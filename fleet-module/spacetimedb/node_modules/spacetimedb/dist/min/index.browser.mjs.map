{"version":3,"sources":["../../src/lib/time_duration.ts","../../src/lib/timestamp.ts","../../src/lib/uuid.ts","../../src/lib/binary_reader.ts","../../src/lib/binary_writer.ts","../../src/lib/util.ts","../../src/lib/identity.ts","../../src/lib/algebraic_type_variants.ts","../../src/lib/algebraic_type.ts","../../src/lib/connection_id.ts","../../src/lib/errors.ts","../../src/lib/algebraic_value.ts","../../src/lib/schedule_at.ts","../../src/lib/option.ts","../../src/lib/result.ts","../../src/lib/query.ts","../../src/lib/type_util.ts","../../src/lib/type_builders.ts","../../src/sdk/client_api/types.ts","../../src/sdk/event_emitter.ts","../../src/sdk/logger.ts","../../src/sdk/table_cache.ts","../../src/sdk/client_cache.ts","../../src/sdk/version.ts","../../src/sdk/decompress.ts","../../src/sdk/ws.ts","../../src/sdk/websocket_decompress_adapter.ts","../../src/sdk/db_connection_builder.ts","../../src/sdk/internal.ts","../../src/sdk/subscription_builder_impl.ts","../../src/sdk/db_connection_impl.ts","../../src/lib/schema.ts","../../src/sdk/schema.ts","../../src/lib/autogen/types.ts","../../src/lib/table.ts","../../src/sdk/reducers.ts","../../src/sdk/procedures.ts"],"names":["body","table","schema","t","name","variants","isUnit","ssStringify","fromByteArray","AlgebraicType","SumType","ProductType","reducers","procedures"],"mappings":";AAcO,IAAM,YAAA,GAAN,MAAM,aAAA,CAAa;AAAA,EACxB,wBAAA;AAAA,EAEA,OAAe,iBAAA,GAA4B,KAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAM3C,OAAO,gBAAA,GAA8C;AACnD,IAAA,OAAO,cAAc,OAAA,CAAQ;AAAA,MAC3B,QAAA,EAAU;AAAA,QACR;AAAA,UACE,IAAA,EAAM,0BAAA;AAAA,UACN,eAAe,aAAA,CAAc;AAAA;AAC/B;AACF,KACD,CAAA;AAAA,EACH;AAAA,EAEA,OAAO,eACL,aAAA,EAC4C;AAC5C,IAAA,IAAI,aAAA,CAAc,QAAQ,SAAA,EAAW;AACnC,MAAA,OAAO,KAAA;AAAA,IACT;AACA,IAAA,MAAM,QAAA,GAAW,cAAc,KAAA,CAAM,QAAA;AACrC,IAAA,IAAI,QAAA,CAAS,WAAW,CAAA,EAAG;AACzB,MAAA,OAAO,KAAA;AAAA,IACT;AACA,IAAA,MAAM,aAAA,GAAgB,SAAS,CAAC,CAAA;AAChC,IAAA,OACE,aAAA,CAAc,IAAA,KAAS,0BAAA,IACvB,aAAA,CAAc,cAAc,GAAA,KAAQ,KAAA;AAAA,EAExC;AAAA,EAEA,IAAI,MAAA,GAAiB;AACnB,IAAA,OAAO,IAAA,CAAK,wBAAA;AAAA,EACd;AAAA,EAEA,IAAI,MAAA,GAAiB;AACnB,IAAA,OAAO,MAAA,CAAO,IAAA,CAAK,MAAA,GAAS,aAAA,CAAa,iBAAiB,CAAA;AAAA,EAC5D;AAAA,EAEA,YAAY,MAAA,EAAgB;AAC1B,IAAA,IAAA,CAAK,wBAAA,GAA2B,MAAA;AAAA,EAClC;AAAA,EAEA,OAAO,WAAW,MAAA,EAA8B;AAC9C,IAAA,OAAO,IAAI,aAAA,CAAa,MAAA,CAAO,MAAM,CAAA,GAAI,cAAa,iBAAiB,CAAA;AAAA,EACzE;AAAA;AAAA,EAGA,QAAA,GAAmB;AACjB,IAAA,MAAM,SAAS,IAAA,CAAK,MAAA;AACpB,IAAA,MAAM,IAAA,GAAO,MAAA,GAAS,CAAA,GAAI,GAAA,GAAM,GAAA;AAChC,IAAA,MAAM,GAAA,GAAM,MAAA,GAAS,CAAA,GAAI,CAAC,MAAA,GAAS,MAAA;AACnC,IAAA,MAAM,OAAO,GAAA,GAAM,QAAA;AACnB,IAAA,MAAM,mBAAmB,GAAA,GAAM,QAAA;AAC/B,IAAA,OAAO,CAAA,EAAG,IAAI,CAAA,EAAG,IAAI,CAAA,CAAA,EAAI,MAAA,CAAO,gBAAgB,CAAA,CAAE,QAAA,CAAS,CAAA,EAAG,GAAG,CAAC,CAAA,CAAA;AAAA,EACpE;AACF;;;AC1DO,IAAM,SAAA,GAAN,MAAM,UAAA,CAAU;AAAA,EACrB,qCAAA;AAAA,EAEA,OAAe,iBAAA,GAA4B,KAAA;AAAA,EAE3C,IAAI,oBAAA,GAA+B;AACjC,IAAA,OAAO,IAAA,CAAK,qCAAA;AAAA,EACd;AAAA,EAEA,YAAY,MAAA,EAAgB;AAC1B,IAAA,IAAA,CAAK,qCAAA,GAAwC,MAAA;AAAA,EAC/C;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,OAAO,gBAAA,GAA2C;AAChD,IAAA,OAAO,cAAc,OAAA,CAAQ;AAAA,MAC3B,QAAA,EAAU;AAAA,QACR;AAAA,UACE,IAAA,EAAM,uCAAA;AAAA,UACN,eAAe,aAAA,CAAc;AAAA;AAC/B;AACF,KACD,CAAA;AAAA,EACH;AAAA,EAEA,OAAO,YACL,aAAA,EACyC;AACzC,IAAA,IAAI,aAAA,CAAc,QAAQ,SAAA,EAAW;AACnC,MAAA,OAAO,KAAA;AAAA,IACT;AACA,IAAA,MAAM,QAAA,GAAW,cAAc,KAAA,CAAM,QAAA;AACrC,IAAA,IAAI,QAAA,CAAS,WAAW,CAAA,EAAG;AACzB,MAAA,OAAO,KAAA;AAAA,IACT;AACA,IAAA,MAAM,aAAA,GAAgB,SAAS,CAAC,CAAA;AAChC,IAAA,OACE,aAAA,CAAc,IAAA,KAAS,uCAAA,IACvB,aAAA,CAAc,cAAc,GAAA,KAAQ,KAAA;AAAA,EAExC;AAAA;AAAA;AAAA;AAAA,EAKA,OAAO,UAAA,GAAwB,IAAI,UAAA,CAAU,EAAE,CAAA;AAAA;AAAA;AAAA;AAAA,EAK/C,OAAO,GAAA,GAAiB;AACtB,IAAA,OAAO,UAAA,CAAU,QAAA,iBAAS,IAAI,IAAA,EAAM,CAAA;AAAA,EACtC;AAAA;AAAA,EAGA,QAAA,GAAmB;AACjB,IAAA,OAAO,KAAK,oBAAA,GAAuB,KAAA;AAAA,EACrC;AAAA;AAAA;AAAA;AAAA,EAKA,OAAO,SAAS,IAAA,EAAuB;AACrC,IAAA,MAAM,MAAA,GAAS,KAAK,OAAA,EAAQ;AAC5B,IAAA,MAAM,MAAA,GAAS,MAAA,CAAO,MAAM,CAAA,GAAI,UAAA,CAAU,iBAAA;AAC1C,IAAA,OAAO,IAAI,WAAU,MAAM,CAAA;AAAA,EAC7B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,MAAA,GAAe;AACb,IAAA,MAAM,SAAS,IAAA,CAAK,qCAAA;AACpB,IAAA,MAAM,MAAA,GAAS,SAAS,UAAA,CAAU,iBAAA;AAClC,IAAA,IACE,MAAA,GAAS,OAAO,MAAA,CAAO,gBAAgB,KACvC,MAAA,GAAS,MAAA,CAAO,MAAA,CAAO,gBAAgB,CAAA,EACvC;AACA,MAAA,MAAM,IAAI,UAAA;AAAA,QACR;AAAA,OACF;AAAA,IACF;AACA,IAAA,OAAO,IAAI,IAAA,CAAK,MAAA,CAAO,MAAM,CAAC,CAAA;AAAA,EAChC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,WAAA,GAAsB;AACpB,IAAA,MAAM,SAAS,IAAA,CAAK,qCAAA;AACpB,IAAA,MAAM,MAAA,GAAS,SAAS,UAAA,CAAU,iBAAA;AAElC,IAAA,IACE,MAAA,GAAS,OAAO,MAAA,CAAO,gBAAgB,KACvC,MAAA,GAAS,MAAA,CAAO,MAAA,CAAO,gBAAgB,CAAA,EACvC;AACA,MAAA,MAAM,IAAI,UAAA;AAAA,QACR;AAAA,OACF;AAAA,IACF;AAEA,IAAA,MAAM,IAAA,GAAO,IAAI,IAAA,CAAK,MAAA,CAAO,MAAM,CAAC,CAAA;AACpC,IAAA,MAAM,OAAA,GAAU,KAAK,WAAA,EAAY;AAGjC,IAAA,MAAM,kBAAkB,IAAA,CAAK,GAAA,CAAI,MAAA,CAAO,MAAA,GAAS,QAAQ,CAAC,CAAA;AAC1D,IAAA,MAAM,iBAAiB,MAAA,CAAO,eAAe,CAAA,CAAE,QAAA,CAAS,GAAG,GAAG,CAAA;AAG9D,IAAA,OAAO,OAAA,CAAQ,OAAA,CAAQ,WAAA,EAAa,CAAA,CAAA,EAAI,cAAc,CAAA,CAAA,CAAG,CAAA;AAAA,EAC3D;AAAA,EAEA,MAAM,KAAA,EAAgC;AACpC,IAAA,OAAO,IAAI,YAAA;AAAA,MACT,IAAA,CAAK,wCACH,KAAA,CAAM;AAAA,KACV;AAAA,EACF;AACF;;;AClHO,IAAM,IAAA,GAAN,MAAM,KAAA,CAAK;AAAA,EAChB,QAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAaA,OAAgB,GAAA,GAAM,IAAI,KAAA,CAAK,EAAE,CAAA;AAAA,EACjC,OAAgB,eAAA,GAAkB,mCAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYlC,OAAgB,GAAA,GAAM,IAAI,KAAA,CAAK,MAAK,eAAe,CAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQnD,YAAY,CAAA,EAAW;AAErB,IAAA,IAAI,CAAA,GAAI,EAAA,IAAM,CAAA,GAAI,KAAA,CAAK,eAAA,EAAiB;AACtC,MAAA,MAAM,IAAI,MAAM,uDAAuD,CAAA;AAAA,IACzE;AACA,IAAA,IAAA,CAAK,QAAA,GAAW,CAAA;AAAA,EAClB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAsBA,OAAO,kBAAkB,KAAA,EAAyB;AAChD,IAAA,IAAI,MAAM,MAAA,KAAW,EAAA,EAAI,MAAM,IAAI,MAAM,2BAA2B,CAAA;AACpE,IAAA,MAAM,GAAA,GAAM,IAAI,UAAA,CAAW,KAAK,CAAA;AAChC,IAAA,GAAA,CAAI,CAAC,CAAA,GAAK,GAAA,CAAI,CAAC,IAAI,EAAA,GAAQ,EAAA;AAC3B,IAAA,GAAA,CAAI,CAAC,CAAA,GAAK,GAAA,CAAI,CAAC,IAAI,EAAA,GAAQ,GAAA;AAC3B,IAAA,OAAO,IAAI,KAAA,CAAK,KAAA,CAAK,aAAA,CAAc,GAAG,CAAC,CAAA;AAAA,EACzC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EA6CA,OAAO,aAAA,CACL,OAAA,EACA,GAAA,EACA,WAAA,EACM;AACN,IAAA,IAAI,WAAA,CAAY,WAAW,CAAA,EAAG;AAC5B,MAAA,MAAM,IAAI,MAAM,oDAAoD,CAAA;AAAA,IACtE;AAEA,IAAA,IAAI,OAAA,CAAQ,QAAQ,CAAA,EAAG;AACrB,MAAA,MAAM,IAAI,MAAM,qDAAqD,CAAA;AAAA,IACvE;AAEA,IAAA,IAAI,GAAA,CAAI,wCAAwC,CAAA,EAAG;AACjD,MAAA,MAAM,IAAI,MAAM,+CAA+C,CAAA;AAAA,IACjE;AAGA,IAAA,MAAM,aAAa,OAAA,CAAQ,KAAA;AAC3B,IAAA,OAAA,CAAQ,KAAA,GAAS,aAAa,CAAA,GAAK,UAAA;AAGnC,IAAA,MAAM,IAAA,GAAO,GAAA,CAAI,QAAA,EAAS,GAAI,eAAA;AAE9B,IAAA,MAAM,KAAA,GAAQ,IAAI,UAAA,CAAW,EAAE,CAAA;AAG/B,IAAA,KAAA,CAAM,CAAC,CAAA,GAAI,MAAA,CAAQ,IAAA,IAAQ,MAAO,KAAK,CAAA;AACvC,IAAA,KAAA,CAAM,CAAC,CAAA,GAAI,MAAA,CAAQ,IAAA,IAAQ,MAAO,KAAK,CAAA;AACvC,IAAA,KAAA,CAAM,CAAC,CAAA,GAAI,MAAA,CAAQ,IAAA,IAAQ,MAAO,KAAK,CAAA;AACvC,IAAA,KAAA,CAAM,CAAC,CAAA,GAAI,MAAA,CAAQ,IAAA,IAAQ,MAAO,KAAK,CAAA;AACvC,IAAA,KAAA,CAAM,CAAC,CAAA,GAAI,MAAA,CAAQ,IAAA,IAAQ,KAAM,KAAK,CAAA;AACtC,IAAA,KAAA,CAAM,CAAC,CAAA,GAAI,MAAA,CAAO,IAAA,GAAO,KAAK,CAAA;AAG9B,IAAA,KAAA,CAAM,CAAC,CAAA,GAAK,UAAA,KAAe,EAAA,GAAM,GAAA;AACjC,IAAA,KAAA,CAAM,CAAC,CAAA,GAAK,UAAA,KAAe,EAAA,GAAM,GAAA;AACjC,IAAA,KAAA,CAAM,EAAE,CAAA,GAAK,UAAA,KAAe,CAAA,GAAK,GAAA;AACjC,IAAA,KAAA,CAAM,EAAE,CAAA,GAAA,CAAM,UAAA,GAAa,GAAA,KAAS,CAAA,GAAK,GAAA;AAGzC,IAAA,KAAA,CAAM,EAAE,CAAA,IAAK,WAAA,CAAY,CAAC,CAAA,GAAI,GAAA;AAC9B,IAAA,KAAA,CAAM,EAAE,CAAA,GAAI,WAAA,CAAY,CAAC,CAAA;AACzB,IAAA,KAAA,CAAM,EAAE,CAAA,GAAI,WAAA,CAAY,CAAC,CAAA;AACzB,IAAA,KAAA,CAAM,EAAE,CAAA,GAAI,WAAA,CAAY,CAAC,CAAA;AAGzB,IAAA,KAAA,CAAM,CAAC,CAAA,GAAK,KAAA,CAAM,CAAC,IAAI,EAAA,GAAQ,GAAA;AAG/B,IAAA,KAAA,CAAM,CAAC,CAAA,GAAK,KAAA,CAAM,CAAC,IAAI,EAAA,GAAQ,GAAA;AAE/B,IAAA,OAAO,IAAI,KAAA,CAAK,KAAA,CAAK,aAAA,CAAc,KAAK,CAAC,CAAA;AAAA,EAC3C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAiBA,OAAO,MAAM,CAAA,EAAiB;AAC5B,IAAA,MAAM,GAAA,GAAM,CAAA,CAAE,OAAA,CAAQ,IAAA,EAAM,EAAE,CAAA;AAC9B,IAAA,IAAI,IAAI,MAAA,KAAW,EAAA,EAAI,MAAM,IAAI,MAAM,kBAAkB,CAAA;AAEzD,IAAA,IAAI,CAAA,GAAI,EAAA;AACR,IAAA,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,EAAA,EAAI,KAAK,CAAA,EAAG;AAC9B,MAAA,CAAA,GAAK,CAAA,IAAK,EAAA,GAAM,MAAA,CAAO,QAAA,CAAS,GAAA,CAAI,KAAA,CAAM,CAAA,EAAG,CAAA,GAAI,CAAC,CAAA,EAAG,EAAE,CAAC,CAAA;AAAA,IAC1D;AACA,IAAA,OAAO,IAAI,MAAK,CAAC,CAAA;AAAA,EACnB;AAAA;AAAA,EAGA,QAAA,GAAmB;AACjB,IAAA,MAAM,KAAA,GAAQ,KAAA,CAAK,aAAA,CAAc,IAAA,CAAK,QAAQ,CAAA;AAC9C,IAAA,MAAM,MAAM,CAAC,GAAG,KAAK,CAAA,CAAE,IAAI,CAAA,CAAA,KAAK,CAAA,CAAE,QAAA,CAAS,EAAE,EAAE,QAAA,CAAS,CAAA,EAAG,GAAG,CAAC,CAAA,CAAE,KAAK,EAAE,CAAA;AAGxE,IAAA,OACE,GAAA,CAAI,KAAA,CAAM,CAAA,EAAG,CAAC,CAAA,GACd,GAAA,GACA,GAAA,CAAI,KAAA,CAAM,CAAA,EAAG,EAAE,CAAA,GACf,GAAA,GACA,GAAA,CAAI,MAAM,EAAA,EAAI,EAAE,CAAA,GAChB,GAAA,GACA,GAAA,CAAI,KAAA,CAAM,EAAA,EAAI,EAAE,CAAA,GAChB,GAAA,GACA,GAAA,CAAI,KAAA,CAAM,EAAE,CAAA;AAAA,EAEhB;AAAA;AAAA,EAGA,QAAA,GAAmB;AACjB,IAAA,OAAO,IAAA,CAAK,QAAA;AAAA,EACd;AAAA;AAAA,EAGA,OAAA,GAAsB;AACpB,IAAA,OAAO,KAAA,CAAK,aAAA,CAAc,IAAA,CAAK,QAAQ,CAAA;AAAA,EACzC;AAAA,EAEA,OAAe,cAAc,KAAA,EAA2B;AACtD,IAAA,IAAI,MAAA,GAAS,EAAA;AACb,IAAA,KAAA,MAAW,KAAK,KAAA,EAAO,MAAA,GAAU,MAAA,IAAU,EAAA,GAAM,OAAO,CAAC,CAAA;AACzD,IAAA,OAAO,MAAA;AAAA,EACT;AAAA,EAEA,OAAe,cAAc,KAAA,EAA2B;AACtD,IAAA,MAAM,KAAA,GAAQ,IAAI,UAAA,CAAW,EAAE,CAAA;AAC/B,IAAA,KAAA,IAAS,CAAA,GAAI,EAAA,EAAI,CAAA,IAAK,CAAA,EAAG,CAAA,EAAA,EAAK;AAC5B,MAAA,KAAA,CAAM,CAAC,CAAA,GAAI,MAAA,CAAO,KAAA,GAAQ,KAAK,CAAA;AAC/B,MAAA,KAAA,KAAU,EAAA;AAAA,IACZ;AACA,IAAA,OAAO,KAAA;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,UAAA,GAA0B;AACxB,IAAA,MAAM,UAAW,IAAA,CAAK,OAAA,EAAQ,CAAE,CAAC,KAAK,CAAA,GAAK,EAAA;AAE3C,IAAA,QAAQ,OAAA;AAAS,MACf,KAAK,CAAA;AACH,QAAA,OAAO,IAAA;AAAA,MACT,KAAK,CAAA;AACH,QAAA,OAAO,IAAA;AAAA,MACT;AACE,QAAA,IAAI,IAAA,IAAQ,MAAK,GAAA,EAAK;AACpB,UAAA,OAAO,KAAA;AAAA,QACT;AACA,QAAA,IAAI,IAAA,IAAQ,MAAK,GAAA,EAAK;AACpB,UAAA,OAAO,KAAA;AAAA,QACT;AACA,QAAA,MAAM,IAAI,KAAA,CAAM,CAAA,0BAAA,EAA6B,OAAO,CAAA,CAAE,CAAA;AAAA;AAC1D,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,UAAA,GAAqB;AACnB,IAAA,MAAM,KAAA,GAAQ,KAAK,OAAA,EAAQ;AAE3B,IAAA,MAAM,IAAA,GAAO,MAAM,CAAC,CAAA;AACpB,IAAA,MAAM,IAAA,GAAO,MAAM,CAAC,CAAA;AACpB,IAAA,MAAM,IAAA,GAAO,MAAM,EAAE,CAAA;AACrB,IAAA,MAAM,GAAA,GAAM,KAAA,CAAM,EAAE,CAAA,KAAM,CAAA;AAG1B,IAAA,OAAQ,QAAQ,EAAA,GAAO,IAAA,IAAQ,EAAA,GAAO,IAAA,IAAQ,IAAK,GAAA,GAAM,CAAA;AAAA,EAC3D;AAAA,EAEA,UAAU,KAAA,EAAqB;AAC7B,IAAA,IAAI,IAAA,CAAK,QAAA,GAAW,KAAA,CAAM,QAAA,EAAU,OAAO,EAAA;AAC3C,IAAA,IAAI,IAAA,CAAK,QAAA,GAAW,KAAA,CAAM,QAAA,EAAU,OAAO,CAAA;AAE3C,IAAA,OAAO,CAAA;AAAA,EACT;AAAA,EAEA,OAAO,gBAAA,GAAsC;AAC3C,IAAA,OAAO,cAAc,OAAA,CAAQ;AAAA,MAC3B,QAAA,EAAU;AAAA,QACR;AAAA,UACE,IAAA,EAAM,UAAA;AAAA,UACN,eAAe,aAAA,CAAc;AAAA;AAC/B;AACF,KACD,CAAA;AAAA,EACH;AACF;;;AChVA,IAAqB,eAArB,MAAkC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAShC,IAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,MAAA,GAAiB,CAAA;AAAA,EAEjB,YAAY,KAAA,EAA8B;AACxC,IAAA,IAAA,CAAK,IAAA,GACH,KAAA,YAAiB,QAAA,GACb,KAAA,GACA,IAAI,QAAA,CAAS,KAAA,CAAM,MAAA,EAAQ,KAAA,CAAM,UAAA,EAAY,KAAA,CAAM,UAAU,CAAA;AACnE,IAAA,IAAA,CAAK,MAAA,GAAS,CAAA;AAAA,EAChB;AAAA,EAEA,MAAM,IAAA,EAAgB;AACpB,IAAA,IAAA,CAAK,IAAA,GAAO,IAAA;AACZ,IAAA,IAAA,CAAK,MAAA,GAAS,CAAA;AAAA,EAChB;AAAA,EAEA,IAAI,SAAA,GAAoB;AACtB,IAAA,OAAO,IAAA,CAAK,IAAA,CAAK,UAAA,GAAa,IAAA,CAAK,MAAA;AAAA,EACrC;AAAA;AAAA,EAGA,QAAQ,CAAA,EAAiB;AACvB,IAAA,IAAI,IAAA,CAAK,MAAA,GAAS,CAAA,GAAI,IAAA,CAAK,KAAK,UAAA,EAAY;AAC1C,MAAA,MAAM,IAAI,UAAA;AAAA,QACR,iBAAiB,CAAC,CAAA,4BAAA,EAA+B,KAAK,MAAM,CAAA,WAAA,EAAc,KAAK,SAAS,CAAA,eAAA;AAAA,OAC1F;AAAA,IACF;AAAA,EACF;AAAA,EAEA,cAAA,GAA6B;AAC3B,IAAA,MAAM,MAAA,GAAS,KAAK,OAAA,EAAQ;AAC5B,IAAA,IAAA,CAAK,QAAQ,MAAM,CAAA;AACnB,IAAA,OAAO,IAAA,CAAK,UAAU,MAAM,CAAA;AAAA,EAC9B;AAAA,EAEA,QAAA,GAAoB;AAClB,IAAA,MAAM,KAAA,GAAQ,IAAA,CAAK,IAAA,CAAK,QAAA,CAAS,KAAK,MAAM,CAAA;AAC5C,IAAA,IAAA,CAAK,MAAA,IAAU,CAAA;AACf,IAAA,OAAO,KAAA,KAAU,CAAA;AAAA,EACnB;AAAA,EAEA,QAAA,GAAmB;AACjB,IAAA,MAAM,KAAA,GAAQ,IAAA,CAAK,IAAA,CAAK,QAAA,CAAS,KAAK,MAAM,CAAA;AAC5C,IAAA,IAAA,CAAK,MAAA,IAAU,CAAA;AACf,IAAA,OAAO,KAAA;AAAA,EACT;AAAA,EAEA,UAAU,MAAA,EAA4B;AAIpC,IAAA,MAAM,QAAQ,IAAI,UAAA;AAAA,MAChB,KAAK,IAAA,CAAK,MAAA;AAAA,MACV,IAAA,CAAK,IAAA,CAAK,UAAA,GAAa,IAAA,CAAK,MAAA;AAAA,MAC5B;AAAA,KACF;AACA,IAAA,IAAA,CAAK,MAAA,IAAU,MAAA;AACf,IAAA,OAAO,KAAA;AAAA,EACT;AAAA,EAEA,MAAA,GAAiB;AACf,IAAA,MAAM,KAAA,GAAQ,IAAA,CAAK,IAAA,CAAK,OAAA,CAAQ,KAAK,MAAM,CAAA;AAC3C,IAAA,IAAA,CAAK,MAAA,IAAU,CAAA;AACf,IAAA,OAAO,KAAA;AAAA,EACT;AAAA,EAEA,MAAA,GAAiB;AACf,IAAA,OAAO,KAAK,QAAA,EAAS;AAAA,EACvB;AAAA,EAEA,OAAA,GAAkB;AAChB,IAAA,MAAM,QAAQ,IAAA,CAAK,IAAA,CAAK,QAAA,CAAS,IAAA,CAAK,QAAQ,IAAI,CAAA;AAClD,IAAA,IAAA,CAAK,MAAA,IAAU,CAAA;AACf,IAAA,OAAO,KAAA;AAAA,EACT;AAAA,EAEA,OAAA,GAAkB;AAChB,IAAA,MAAM,QAAQ,IAAA,CAAK,IAAA,CAAK,SAAA,CAAU,IAAA,CAAK,QAAQ,IAAI,CAAA;AACnD,IAAA,IAAA,CAAK,MAAA,IAAU,CAAA;AACf,IAAA,OAAO,KAAA;AAAA,EACT;AAAA,EAEA,OAAA,GAAkB;AAChB,IAAA,MAAM,QAAQ,IAAA,CAAK,IAAA,CAAK,QAAA,CAAS,IAAA,CAAK,QAAQ,IAAI,CAAA;AAClD,IAAA,IAAA,CAAK,MAAA,IAAU,CAAA;AACf,IAAA,OAAO,KAAA;AAAA,EACT;AAAA,EAEA,OAAA,GAAkB;AAChB,IAAA,MAAM,QAAQ,IAAA,CAAK,IAAA,CAAK,SAAA,CAAU,IAAA,CAAK,QAAQ,IAAI,CAAA;AACnD,IAAA,IAAA,CAAK,MAAA,IAAU,CAAA;AACf,IAAA,OAAO,KAAA;AAAA,EACT;AAAA,EAEA,OAAA,GAAkB;AAChB,IAAA,MAAM,QAAQ,IAAA,CAAK,IAAA,CAAK,WAAA,CAAY,IAAA,CAAK,QAAQ,IAAI,CAAA;AACrD,IAAA,IAAA,CAAK,MAAA,IAAU,CAAA;AACf,IAAA,OAAO,KAAA;AAAA,EACT;AAAA,EAEA,OAAA,GAAkB;AAChB,IAAA,MAAM,QAAQ,IAAA,CAAK,IAAA,CAAK,YAAA,CAAa,IAAA,CAAK,QAAQ,IAAI,CAAA;AACtD,IAAA,IAAA,CAAK,MAAA,IAAU,CAAA;AACf,IAAA,OAAO,KAAA;AAAA,EACT;AAAA,EAEA,QAAA,GAAmB;AACjB,IAAA,MAAM,YAAY,IAAA,CAAK,IAAA,CAAK,YAAA,CAAa,IAAA,CAAK,QAAQ,IAAI,CAAA;AAC1D,IAAA,MAAM,YAAY,IAAA,CAAK,IAAA,CAAK,aAAa,IAAA,CAAK,MAAA,GAAS,GAAG,IAAI,CAAA;AAC9D,IAAA,IAAA,CAAK,MAAA,IAAU,EAAA;AAEf,IAAA,OAAA,CAAQ,SAAA,IAAa,MAAA,CAAO,EAAE,CAAA,IAAK,SAAA;AAAA,EACrC;AAAA,EAEA,QAAA,GAAmB;AACjB,IAAA,MAAM,YAAY,IAAA,CAAK,IAAA,CAAK,YAAA,CAAa,IAAA,CAAK,QAAQ,IAAI,CAAA;AAC1D,IAAA,MAAM,YAAY,IAAA,CAAK,IAAA,CAAK,YAAY,IAAA,CAAK,MAAA,GAAS,GAAG,IAAI,CAAA;AAC7D,IAAA,IAAA,CAAK,MAAA,IAAU,EAAA;AAEf,IAAA,OAAA,CAAQ,SAAA,IAAa,MAAA,CAAO,EAAE,CAAA,IAAK,SAAA;AAAA,EACrC;AAAA,EAEA,QAAA,GAAmB;AACjB,IAAA,MAAM,KAAK,IAAA,CAAK,IAAA,CAAK,YAAA,CAAa,IAAA,CAAK,QAAQ,IAAI,CAAA;AACnD,IAAA,MAAM,KAAK,IAAA,CAAK,IAAA,CAAK,aAAa,IAAA,CAAK,MAAA,GAAS,GAAG,IAAI,CAAA;AACvD,IAAA,MAAM,KAAK,IAAA,CAAK,IAAA,CAAK,aAAa,IAAA,CAAK,MAAA,GAAS,IAAI,IAAI,CAAA;AACxD,IAAA,MAAM,KAAK,IAAA,CAAK,IAAA,CAAK,aAAa,IAAA,CAAK,MAAA,GAAS,IAAI,IAAI,CAAA;AACxD,IAAA,IAAA,CAAK,MAAA,IAAU,EAAA;AAEf,IAAA,OAAA,CACG,EAAA,IAAM,MAAA,CAAO,CAAA,GAAI,EAAE,MACnB,EAAA,IAAM,MAAA,CAAO,CAAA,GAAI,EAAE,CAAA,CAAA,IACnB,EAAA,IAAM,MAAA,CAAO,CAAA,GAAI,EAAE,CAAA,CAAA,GACpB,EAAA;AAAA,EAEJ;AAAA,EAEA,QAAA,GAAmB;AACjB,IAAA,MAAM,KAAK,IAAA,CAAK,IAAA,CAAK,YAAA,CAAa,IAAA,CAAK,QAAQ,IAAI,CAAA;AACnD,IAAA,MAAM,KAAK,IAAA,CAAK,IAAA,CAAK,aAAa,IAAA,CAAK,MAAA,GAAS,GAAG,IAAI,CAAA;AACvD,IAAA,MAAM,KAAK,IAAA,CAAK,IAAA,CAAK,aAAa,IAAA,CAAK,MAAA,GAAS,IAAI,IAAI,CAAA;AACxD,IAAA,MAAM,KAAK,IAAA,CAAK,IAAA,CAAK,YAAY,IAAA,CAAK,MAAA,GAAS,IAAI,IAAI,CAAA;AACvD,IAAA,IAAA,CAAK,MAAA,IAAU,EAAA;AAEf,IAAA,OAAA,CACG,EAAA,IAAM,MAAA,CAAO,CAAA,GAAI,EAAE,MACnB,EAAA,IAAM,MAAA,CAAO,CAAA,GAAI,EAAE,CAAA,CAAA,IACnB,EAAA,IAAM,MAAA,CAAO,CAAA,GAAI,EAAE,CAAA,CAAA,GACpB,EAAA;AAAA,EAEJ;AAAA,EAEA,OAAA,GAAkB;AAChB,IAAA,MAAM,QAAQ,IAAA,CAAK,IAAA,CAAK,UAAA,CAAW,IAAA,CAAK,QAAQ,IAAI,CAAA;AACpD,IAAA,IAAA,CAAK,MAAA,IAAU,CAAA;AACf,IAAA,OAAO,KAAA;AAAA,EACT;AAAA,EAEA,OAAA,GAAkB;AAChB,IAAA,MAAM,QAAQ,IAAA,CAAK,IAAA,CAAK,UAAA,CAAW,IAAA,CAAK,QAAQ,IAAI,CAAA;AACpD,IAAA,IAAA,CAAK,MAAA,IAAU,CAAA;AACf,IAAA,OAAO,KAAA;AAAA,EACT;AAAA,EAEA,UAAA,GAAqB;AACnB,IAAA,MAAM,UAAA,GAAa,KAAK,cAAA,EAAe;AACvC,IAAA,OAAO,IAAI,WAAA,CAAY,OAAO,CAAA,CAAE,OAAO,UAAU,CAAA;AAAA,EACnD;AACF;ACtLA,IAAM,4BAAA,GACJ,WAAA,CAAY,SAAA,CAAU,QAAA,IACtB,SAA6B,aAAA,EAAe;AAC1C,EAAA,IAAI,kBAAkB,MAAA,EAAW;AAC/B,IAAA,OAAO,KAAK,KAAA,EAAM;AAAA,EACpB,CAAA,MAAA,IAAW,aAAA,IAAiB,IAAA,CAAK,UAAA,EAAY;AAC3C,IAAA,OAAO,IAAA,CAAK,KAAA,CAAM,CAAA,EAAG,aAAa,CAAA;AAAA,EACpC,CAAA,MAAO;AACL,IAAA,MAAM,IAAA,GAAO,IAAI,UAAA,CAAW,aAAa,CAAA;AACzC,IAAA,IAAA,CAAK,GAAA,CAAI,IAAI,UAAA,CAAW,IAAI,CAAC,CAAA;AAC7B,IAAA,OAAO,IAAA,CAAK,MAAA;AAAA,EACd;AACF,CAAA;AAEK,IAAM,kBAAN,MAAsB;AAAA,EAC3B,MAAA;AAAA,EACA,IAAA;AAAA,EAEA,YAAY,IAAA,EAA4B;AACtC,IAAA,IAAA,CAAK,SAAS,OAAO,IAAA,KAAS,WAAW,IAAI,WAAA,CAAY,IAAI,CAAA,GAAI,IAAA;AACjE,IAAA,IAAA,CAAK,IAAA,GAAO,IAAI,QAAA,CAAS,IAAA,CAAK,MAAM,CAAA;AAAA,EACtC;AAAA,EAEA,IAAI,QAAA,GAAmB;AACrB,IAAA,OAAO,KAAK,MAAA,CAAO,UAAA;AAAA,EACrB;AAAA,EAEA,KAAK,OAAA,EAAiB;AACpB,IAAA,IAAI,OAAA,IAAW,IAAA,CAAK,MAAA,CAAO,UAAA,EAAY;AACvC,IAAA,IAAA,CAAK,MAAA,GAAS,4BAAA,CAA6B,IAAA,CAAK,IAAA,CAAK,QAAQ,OAAO,CAAA;AACpE,IAAA,IAAA,CAAK,IAAA,GAAO,IAAI,QAAA,CAAS,IAAA,CAAK,MAAM,CAAA;AAAA,EACtC;AACF,CAAA;AAEA,IAAqB,eAArB,MAAkC;AAAA,EAChC,MAAA;AAAA,EACA,MAAA,GAAiB,CAAA;AAAA,EAEjB,YAAY,IAAA,EAAgC;AAC1C,IAAA,IAAA,CAAK,SAAS,OAAO,IAAA,KAAS,WAAW,IAAI,eAAA,CAAgB,IAAI,CAAA,GAAI,IAAA;AAAA,EACvE;AAAA,EAEA,MAAM,MAAA,EAAyB;AAC7B,IAAA,IAAA,CAAK,MAAA,GAAS,MAAA;AACd,IAAA,IAAA,CAAK,MAAA,GAAS,CAAA;AAAA,EAChB;AAAA,EAEA,aAAa,kBAAA,EAAkC;AAC7C,IAAA,MAAM,WAAA,GAAc,IAAA,CAAK,MAAA,GAAS,kBAAA,GAAqB,CAAA;AACvD,IAAA,IAAI,WAAA,IAAe,IAAA,CAAK,MAAA,CAAO,QAAA,EAAU;AACzC,IAAA,IAAI,WAAA,GAAc,IAAA,CAAK,MAAA,CAAO,QAAA,GAAW,CAAA;AACzC,IAAA,IAAI,WAAA,GAAc,aAAa,WAAA,GAAc,WAAA;AAC7C,IAAA,IAAA,CAAK,MAAA,CAAO,KAAK,WAAW,CAAA;AAAA,EAC9B;AAAA,EAEA,QAAA,GAAmB;AACjB,IAAA,OAAO,aAAA,CAAc,IAAA,CAAK,SAAA,EAAW,CAAA;AAAA,EACvC;AAAA,EAEA,SAAA,GAAwB;AACtB,IAAA,OAAO,IAAI,UAAA,CAAW,IAAA,CAAK,OAAO,MAAA,EAAQ,CAAA,EAAG,KAAK,MAAM,CAAA;AAAA,EAC1D;AAAA,EAEA,IAAI,IAAA,GAAO;AACT,IAAA,OAAO,KAAK,MAAA,CAAO,IAAA;AAAA,EACrB;AAAA,EAEA,gBAAgB,KAAA,EAAyB;AACvC,IAAA,MAAM,SAAS,KAAA,CAAM,MAAA;AAErB,IAAA,IAAA,CAAK,YAAA,CAAa,IAAI,MAAM,CAAA;AAE5B,IAAA,IAAA,CAAK,SAAS,MAAM,CAAA;AACpB,IAAA,IAAI,UAAA,CAAW,KAAK,MAAA,CAAO,MAAA,EAAQ,KAAK,MAAM,CAAA,CAAE,IAAI,KAAK,CAAA;AACzD,IAAA,IAAA,CAAK,MAAA,IAAU,MAAA;AAAA,EACjB;AAAA,EAEA,UAAU,KAAA,EAAsB;AAC9B,IAAA,IAAA,CAAK,aAAa,CAAC,CAAA;AACnB,IAAA,IAAA,CAAK,KAAK,QAAA,CAAS,IAAA,CAAK,MAAA,EAAQ,KAAA,GAAQ,IAAI,CAAC,CAAA;AAC7C,IAAA,IAAA,CAAK,MAAA,IAAU,CAAA;AAAA,EACjB;AAAA,EAEA,UAAU,KAAA,EAAqB;AAC7B,IAAA,IAAA,CAAK,aAAa,CAAC,CAAA;AACnB,IAAA,IAAA,CAAK,IAAA,CAAK,QAAA,CAAS,IAAA,CAAK,MAAA,EAAQ,KAAK,CAAA;AACrC,IAAA,IAAA,CAAK,MAAA,IAAU,CAAA;AAAA,EACjB;AAAA,EAEA,QAAQ,KAAA,EAAqB;AAC3B,IAAA,IAAA,CAAK,aAAa,CAAC,CAAA;AACnB,IAAA,IAAA,CAAK,IAAA,CAAK,OAAA,CAAQ,IAAA,CAAK,MAAA,EAAQ,KAAK,CAAA;AACpC,IAAA,IAAA,CAAK,MAAA,IAAU,CAAA;AAAA,EACjB;AAAA,EAEA,QAAQ,KAAA,EAAqB;AAC3B,IAAA,IAAA,CAAK,aAAa,CAAC,CAAA;AACnB,IAAA,IAAA,CAAK,IAAA,CAAK,QAAA,CAAS,IAAA,CAAK,MAAA,EAAQ,KAAK,CAAA;AACrC,IAAA,IAAA,CAAK,MAAA,IAAU,CAAA;AAAA,EACjB;AAAA,EAEA,SAAS,KAAA,EAAqB;AAC5B,IAAA,IAAA,CAAK,aAAa,CAAC,CAAA;AACnB,IAAA,IAAA,CAAK,IAAA,CAAK,QAAA,CAAS,IAAA,CAAK,MAAA,EAAQ,OAAO,IAAI,CAAA;AAC3C,IAAA,IAAA,CAAK,MAAA,IAAU,CAAA;AAAA,EACjB;AAAA,EAEA,SAAS,KAAA,EAAqB;AAC5B,IAAA,IAAA,CAAK,aAAa,CAAC,CAAA;AACnB,IAAA,IAAA,CAAK,IAAA,CAAK,SAAA,CAAU,IAAA,CAAK,MAAA,EAAQ,OAAO,IAAI,CAAA;AAC5C,IAAA,IAAA,CAAK,MAAA,IAAU,CAAA;AAAA,EACjB;AAAA,EAEA,SAAS,KAAA,EAAqB;AAC5B,IAAA,IAAA,CAAK,aAAa,CAAC,CAAA;AACnB,IAAA,IAAA,CAAK,IAAA,CAAK,QAAA,CAAS,IAAA,CAAK,MAAA,EAAQ,OAAO,IAAI,CAAA;AAC3C,IAAA,IAAA,CAAK,MAAA,IAAU,CAAA;AAAA,EACjB;AAAA,EAEA,SAAS,KAAA,EAAqB;AAC5B,IAAA,IAAA,CAAK,aAAa,CAAC,CAAA;AACnB,IAAA,IAAA,CAAK,IAAA,CAAK,SAAA,CAAU,IAAA,CAAK,MAAA,EAAQ,OAAO,IAAI,CAAA;AAC5C,IAAA,IAAA,CAAK,MAAA,IAAU,CAAA;AAAA,EACjB;AAAA,EAEA,SAAS,KAAA,EAAqB;AAC5B,IAAA,IAAA,CAAK,aAAa,CAAC,CAAA;AACnB,IAAA,IAAA,CAAK,IAAA,CAAK,WAAA,CAAY,IAAA,CAAK,MAAA,EAAQ,OAAO,IAAI,CAAA;AAC9C,IAAA,IAAA,CAAK,MAAA,IAAU,CAAA;AAAA,EACjB;AAAA,EAEA,SAAS,KAAA,EAAqB;AAC5B,IAAA,IAAA,CAAK,aAAa,CAAC,CAAA;AACnB,IAAA,IAAA,CAAK,IAAA,CAAK,YAAA,CAAa,IAAA,CAAK,MAAA,EAAQ,OAAO,IAAI,CAAA;AAC/C,IAAA,IAAA,CAAK,MAAA,IAAU,CAAA;AAAA,EACjB;AAAA,EAEA,UAAU,KAAA,EAAqB;AAC7B,IAAA,IAAA,CAAK,aAAa,EAAE,CAAA;AACpB,IAAA,MAAM,SAAA,GAAY,KAAA,GAAQ,MAAA,CAAO,oBAAoB,CAAA;AACrD,IAAA,MAAM,SAAA,GAAY,KAAA,IAAS,MAAA,CAAO,EAAE,CAAA;AACpC,IAAA,IAAA,CAAK,IAAA,CAAK,YAAA,CAAa,IAAA,CAAK,MAAA,EAAQ,WAAW,IAAI,CAAA;AACnD,IAAA,IAAA,CAAK,KAAK,YAAA,CAAa,IAAA,CAAK,MAAA,GAAS,CAAA,EAAG,WAAW,IAAI,CAAA;AACvD,IAAA,IAAA,CAAK,MAAA,IAAU,EAAA;AAAA,EACjB;AAAA,EAEA,UAAU,KAAA,EAAqB;AAC7B,IAAA,IAAA,CAAK,aAAa,EAAE,CAAA;AACpB,IAAA,MAAM,SAAA,GAAY,KAAA,GAAQ,MAAA,CAAO,oBAAoB,CAAA;AACrD,IAAA,MAAM,SAAA,GAAY,KAAA,IAAS,MAAA,CAAO,EAAE,CAAA;AACpC,IAAA,IAAA,CAAK,IAAA,CAAK,WAAA,CAAY,IAAA,CAAK,MAAA,EAAQ,WAAW,IAAI,CAAA;AAClD,IAAA,IAAA,CAAK,KAAK,WAAA,CAAY,IAAA,CAAK,MAAA,GAAS,CAAA,EAAG,WAAW,IAAI,CAAA;AACtD,IAAA,IAAA,CAAK,MAAA,IAAU,EAAA;AAAA,EACjB;AAAA,EAEA,UAAU,KAAA,EAAqB;AAC7B,IAAA,IAAA,CAAK,aAAa,EAAE,CAAA;AACpB,IAAA,MAAM,WAAA,GAAc,OAAO,oBAAoB,CAAA;AAC/C,IAAA,MAAM,KAAK,KAAA,GAAQ,WAAA;AACnB,IAAA,MAAM,EAAA,GAAM,KAAA,IAAS,MAAA,CAAO,EAAA,GAAK,CAAC,CAAA,GAAK,WAAA;AACvC,IAAA,MAAM,EAAA,GAAM,KAAA,IAAS,MAAA,CAAO,EAAA,GAAK,CAAC,CAAA,GAAK,WAAA;AACvC,IAAA,MAAM,EAAA,GAAK,KAAA,IAAS,MAAA,CAAO,EAAA,GAAK,CAAC,CAAA;AACjC,IAAA,IAAA,CAAK,KAAK,YAAA,CAAa,IAAA,CAAK,SAAS,CAAA,GAAI,CAAA,EAAG,IAAI,IAAI,CAAA;AACpD,IAAA,IAAA,CAAK,KAAK,YAAA,CAAa,IAAA,CAAK,SAAS,CAAA,GAAI,CAAA,EAAG,IAAI,IAAI,CAAA;AACpD,IAAA,IAAA,CAAK,KAAK,YAAA,CAAa,IAAA,CAAK,SAAS,CAAA,GAAI,CAAA,EAAG,IAAI,IAAI,CAAA;AACpD,IAAA,IAAA,CAAK,KAAK,YAAA,CAAa,IAAA,CAAK,SAAS,CAAA,GAAI,CAAA,EAAG,IAAI,IAAI,CAAA;AACpD,IAAA,IAAA,CAAK,MAAA,IAAU,EAAA;AAAA,EACjB;AAAA,EAEA,UAAU,KAAA,EAAqB;AAC7B,IAAA,IAAA,CAAK,aAAa,EAAE,CAAA;AACpB,IAAA,MAAM,WAAA,GAAc,OAAO,oBAAoB,CAAA;AAC/C,IAAA,MAAM,KAAK,KAAA,GAAQ,WAAA;AACnB,IAAA,MAAM,EAAA,GAAM,KAAA,IAAS,MAAA,CAAO,EAAA,GAAK,CAAC,CAAA,GAAK,WAAA;AACvC,IAAA,MAAM,EAAA,GAAM,KAAA,IAAS,MAAA,CAAO,EAAA,GAAK,CAAC,CAAA,GAAK,WAAA;AACvC,IAAA,MAAM,EAAA,GAAK,KAAA,IAAS,MAAA,CAAO,EAAA,GAAK,CAAC,CAAA;AACjC,IAAA,IAAA,CAAK,KAAK,YAAA,CAAa,IAAA,CAAK,SAAS,CAAA,GAAI,CAAA,EAAG,IAAI,IAAI,CAAA;AACpD,IAAA,IAAA,CAAK,KAAK,YAAA,CAAa,IAAA,CAAK,SAAS,CAAA,GAAI,CAAA,EAAG,IAAI,IAAI,CAAA;AACpD,IAAA,IAAA,CAAK,KAAK,YAAA,CAAa,IAAA,CAAK,SAAS,CAAA,GAAI,CAAA,EAAG,IAAI,IAAI,CAAA;AACpD,IAAA,IAAA,CAAK,KAAK,WAAA,CAAY,IAAA,CAAK,SAAS,CAAA,GAAI,CAAA,EAAG,IAAI,IAAI,CAAA;AACnD,IAAA,IAAA,CAAK,MAAA,IAAU,EAAA;AAAA,EACjB;AAAA,EAEA,SAAS,KAAA,EAAqB;AAC5B,IAAA,IAAA,CAAK,aAAa,CAAC,CAAA;AACnB,IAAA,IAAA,CAAK,IAAA,CAAK,UAAA,CAAW,IAAA,CAAK,MAAA,EAAQ,OAAO,IAAI,CAAA;AAC7C,IAAA,IAAA,CAAK,MAAA,IAAU,CAAA;AAAA,EACjB;AAAA,EAEA,SAAS,KAAA,EAAqB;AAC5B,IAAA,IAAA,CAAK,aAAa,CAAC,CAAA;AACnB,IAAA,IAAA,CAAK,IAAA,CAAK,UAAA,CAAW,IAAA,CAAK,MAAA,EAAQ,OAAO,IAAI,CAAA;AAC7C,IAAA,IAAA,CAAK,MAAA,IAAU,CAAA;AAAA,EACjB;AAAA,EAEA,YAAY,KAAA,EAAqB;AAC/B,IAAA,MAAM,OAAA,GAAU,IAAI,WAAA,EAAY;AAChC,IAAA,MAAM,aAAA,GAAgB,OAAA,CAAQ,MAAA,CAAO,KAAK,CAAA;AAC1C,IAAA,IAAA,CAAK,gBAAgB,aAAa,CAAA;AAAA,EACpC;AACF;;;ACjMO,SAAS,aAAa,CAAA,EAAmB;AAC9C,EAAA,MAAM,GAAA,GAAM,CAAA,CAAE,OAAA,CAAQ,eAAA,EAAiB,CAAA,EAAA,KAAM;AAC3C,IAAA,OAAO,EAAA,CAAG,aAAY,CAAE,OAAA,CAAQ,KAAK,EAAE,CAAA,CAAE,OAAA,CAAQ,GAAA,EAAK,EAAE,CAAA;AAAA,EAC1D,CAAC,CAAA;AAED,EAAA,OAAO,GAAA,CAAI,OAAO,CAAC,CAAA,CAAE,aAAY,GAAI,GAAA,CAAI,MAAM,CAAC,CAAA;AAClD;AAEO,SAAS,SAAA,CAAU,MAAW,IAAA,EAAoB;AAEvD,EAAA,IAAI,IAAA,KAAS,MAAM,OAAO,IAAA;AAG1B,EAAA,IACE,OAAO,SAAS,QAAA,IAChB,IAAA,KAAS,QACT,OAAO,IAAA,KAAS,QAAA,IAChB,IAAA,KAAS,IAAA,EACT;AACA,IAAA,OAAO,KAAA;AAAA,EACT;AAGA,EAAA,MAAM,KAAA,GAAQ,MAAA,CAAO,IAAA,CAAK,IAAI,CAAA;AAC9B,EAAA,MAAM,KAAA,GAAQ,MAAA,CAAO,IAAA,CAAK,IAAI,CAAA;AAG9B,EAAA,IAAI,KAAA,CAAM,MAAA,KAAW,KAAA,CAAM,MAAA,EAAQ,OAAO,KAAA;AAG1C,EAAA,KAAA,MAAW,OAAO,KAAA,EAAO;AACvB,IAAA,IAAI,CAAC,KAAA,CAAM,QAAA,CAAS,GAAG,CAAA,IAAK,CAAC,SAAA,CAAU,IAAA,CAAK,GAAG,CAAA,EAAG,IAAA,CAAK,GAAG,CAAC,CAAA,EAAG;AAC5D,MAAA,OAAO,KAAA;AAAA,IACT;AAAA,EACF;AAEA,EAAA,OAAO,IAAA;AACT;AAEO,SAAS,sBAAsB,KAAA,EAA2B;AAC/D,EAAA,OAAO,MAAM,SAAA,CAAU,GAAA,CACpB,KAAK,KAAA,CAAM,OAAA,IAAW,CAAA,CAAA,KAAA,CAAM,IAAA,GAAO,CAAA,CAAE,QAAA,CAAS,EAAE,CAAA,EAAG,KAAA,CAAM,EAAE,CAAC,CAAA,CAC5D,KAAK,EAAE,CAAA;AACZ;AAEO,SAAS,iBAAiB,KAAA,EAA2B;AAC1D,EAAA,IAAI,KAAA,CAAM,UAAU,EAAA,EAAI;AACtB,IAAA,MAAM,IAAI,KAAA,CAAM,CAAA,iCAAA,EAAoC,KAAK,CAAA,CAAE,CAAA;AAAA,EAC7D;AACA,EAAA,OAAO,IAAI,YAAA,CAAa,KAAK,CAAA,CAAE,QAAA,EAAS;AAC1C;AAEO,SAAS,iBAAiB,KAAA,EAA2B;AAC1D,EAAA,IAAI,KAAA,CAAM,UAAU,EAAA,EAAI;AACtB,IAAA,MAAM,IAAI,KAAA,CAAM,CAAA,kCAAA,EAAqC,KAAK,CAAA,CAAA,CAAG,CAAA;AAAA,EAC/D;AACA,EAAA,OAAO,IAAI,YAAA,CAAa,KAAK,CAAA,CAAE,QAAA,EAAS;AAC1C;AAEO,SAAS,sBAAsB,GAAA,EAAyB;AAC7D,EAAA,IAAI,GAAA,CAAI,UAAA,CAAW,IAAI,CAAA,EAAG;AACxB,IAAA,GAAA,GAAM,GAAA,CAAI,MAAM,CAAC,CAAA;AAAA,EACnB;AACA,EAAA,MAAM,OAAA,GAAU,GAAA,CAAI,KAAA,CAAM,SAAS,KAAK,EAAC;AACzC,EAAA,MAAM,OAAO,UAAA,CAAW,IAAA;AAAA,IACtB,QAAQ,GAAA,CAAI,CAAC,SAAiB,QAAA,CAAS,IAAA,EAAM,EAAE,CAAC;AAAA,GAClD;AACA,EAAA,OAAO,KAAK,OAAA,EAAQ;AACtB;AAEO,SAAS,gBAAgB,GAAA,EAAqB;AACnD,EAAA,OAAO,gBAAA,CAAiB,qBAAA,CAAsB,GAAG,CAAC,CAAA;AACpD;AAEO,SAAS,gBAAgB,GAAA,EAAqB;AACnD,EAAA,OAAO,gBAAA,CAAiB,qBAAA,CAAsB,GAAG,CAAC,CAAA;AACpD;AAEO,SAAS,iBAAiB,IAAA,EAA0B;AACzD,EAAA,MAAM,MAAA,GAAS,IAAI,YAAA,CAAa,EAAE,CAAA;AAClC,EAAA,MAAA,CAAO,UAAU,IAAI,CAAA;AACrB,EAAA,OAAO,OAAO,SAAA,EAAU;AAC1B;AAEO,SAAS,gBAAgB,IAAA,EAAsB;AACpD,EAAA,OAAO,qBAAA,CAAsB,gBAAA,CAAiB,IAAI,CAAC,CAAA;AACrD;AAEO,SAAS,iBAAiB,IAAA,EAA0B;AACzD,EAAA,MAAM,MAAA,GAAS,IAAI,YAAA,CAAa,EAAE,CAAA;AAClC,EAAA,MAAA,CAAO,UAAU,IAAI,CAAA;AACrB,EAAA,OAAO,OAAO,SAAA,EAAU;AAC1B;AAEO,SAAS,gBAAgB,IAAA,EAAsB;AACpD,EAAA,OAAO,qBAAA,CAAsB,gBAAA,CAAiB,IAAI,CAAC,CAAA;AACrD;AAOO,SAAS,YAA8B,GAAA,EAAsB;AAClE,EAAA,OAAO,GAAA,CACJ,OAAA,CAAQ,QAAA,EAAU,GAAG,CAAA,CACrB,OAAA,CAAQ,iBAAA,EAAmB,CAAC,CAAA,EAAG,CAAA,KAAM,CAAA,CAAE,WAAA,EAAa,CAAA;AACzD;AAMO,SAAS,YAA8B,GAAA,EAAsB;AAClE,EAAA,OAAO,GAAA,CACJ,QAAQ,UAAA,EAAY,KAAK,EACzB,OAAA,CAAQ,SAAA,EAAW,GAAG,CAAA,CACtB,WAAA,EAAY;AACjB;AAOO,SAAS,aAAA,CAAc,WAAsB,EAAA,EAA2B;AAC7E,EAAA,MAAM,kBAAA,GAAqB,CAAA;AAC3B,EAAA,OAAO,GAAG,GAAA,KAAQ,KAAA,OAAY,SAAA,CAAU,KAAA,CAAM,GAAG,KAAK,CAAA;AACtD,EAAA,IAAI,EAAA,CAAG,QAAQ,SAAA,EAAW;AACxB,IAAA,IAAI,GAAA,GAAM,CAAA;AACV,IAAA,KAAA,MAAW,EAAE,aAAA,EAAe,IAAA,EAAK,IAAK,EAAA,CAAG,MAAM,QAAA,EAAU;AACvD,MAAA,GAAA,IAAO,aAAA,CAAc,WAAW,IAAI,CAAA;AAAA,IACtC;AACA,IAAA,OAAO,GAAA;AAAA,EACT,CAAA,MAAA,IAAW,EAAA,CAAG,GAAA,KAAQ,KAAA,EAAO;AAC3B,IAAA,IAAI,GAAA,GAAM,QAAA;AACV,IAAA,KAAA,MAAW,EAAE,aAAA,EAAe,IAAA,EAAK,IAAK,EAAA,CAAG,MAAM,QAAA,EAAU;AACvD,MAAA,MAAM,KAAA,GAAQ,aAAA,CAAc,SAAA,EAAW,IAAI,CAAA;AAC3C,MAAA,IAAI,KAAA,GAAQ,KAAK,GAAA,GAAM,KAAA;AAAA,IACzB;AACA,IAAA,IAAI,GAAA,KAAQ,UAAU,GAAA,GAAM,CAAA;AAC5B,IAAA,OAAO,CAAA,GAAI,GAAA;AAAA,EACb,CAAA,MAAA,IAAW,EAAA,CAAG,GAAA,IAAO,OAAA,EAAS;AAC5B,IAAA,OAAO,CAAA,GAAI,kBAAA,GAAqB,aAAA,CAAc,SAAA,EAAW,GAAG,KAAK,CAAA;AAAA,EACnE;AACA,EAAA,OAAO;AAAA,IACL,QAAQ,CAAA,GAAI,kBAAA;AAAA,IACZ,GAAA,EAAK,CAAA;AAAA,IACL,IAAA,EAAM,CAAA;AAAA,IACN,EAAA,EAAI,CAAA;AAAA,IACJ,EAAA,EAAI,CAAA;AAAA,IACJ,GAAA,EAAK,CAAA;AAAA,IACL,GAAA,EAAK,CAAA;AAAA,IACL,GAAA,EAAK,CAAA;AAAA,IACL,GAAA,EAAK,CAAA;AAAA,IACL,GAAA,EAAK,CAAA;AAAA,IACL,GAAA,EAAK,CAAA;AAAA,IACL,GAAA,EAAK,CAAA;AAAA,IACL,GAAA,EAAK,CAAA;AAAA,IACL,IAAA,EAAM,EAAA;AAAA,IACN,IAAA,EAAM,EAAA;AAAA,IACN,IAAA,EAAM,EAAA;AAAA,IACN,IAAA,EAAM;AAAA,GACR,CAAE,GAAG,GAAG,CAAA;AACV;AAUO,SAAS,aACd,MAAA,EACsB;AACtB,EAAA,OAAO,MAAA,CAAO,WAAA;AAAA,IACZ,MAAA,CAAO,QAAQ,MAAM,CAAA,CAAE,IAAI,CAAC,CAAC,CAAA,EAAG,CAAC,CAAA,KAAM;AAAA,MACrC,CAAA;AAAA,MACA,aAAA,IAAiB,CAAA,GAAI,CAAA,CAAE,WAAA,GAAc;AAAA,KACtC;AAAA,GACH;AACF;AAEO,IAAM,SAIX,MAAA,CAAO;;;ACzLF,IAAM,QAAA,GAAN,MAAM,SAAA,CAAS;AAAA,EACpB,YAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,YAAY,IAAA,EAAuB;AAGjC,IAAA,IAAA,CAAK,eAAe,OAAO,IAAA,KAAS,QAAA,GAAW,eAAA,CAAgB,IAAI,CAAA,GAAI,IAAA;AAAA,EACzE;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,OAAO,gBAAA,GAA0C;AAC/C,IAAA,OAAO,cAAc,OAAA,CAAQ;AAAA,MAC3B,QAAA,EAAU,CAAC,EAAE,IAAA,EAAM,gBAAgB,aAAA,EAAe,aAAA,CAAc,MAAM;AAAA,KACvE,CAAA;AAAA,EACH;AAAA;AAAA;AAAA;AAAA,EAKA,QAAQ,KAAA,EAA0B;AAChC,IAAA,OAAO,IAAA,CAAK,WAAA,EAAY,KAAM,KAAA,CAAM,WAAA,EAAY;AAAA,EAClD;AAAA;AAAA;AAAA;AAAA,EAKA,OAAO,KAAA,EAA0B;AAC/B,IAAA,OAAO,IAAA,CAAK,QAAQ,KAAK,CAAA;AAAA,EAC3B;AAAA;AAAA;AAAA;AAAA,EAKA,WAAA,GAAsB;AACpB,IAAA,OAAO,eAAA,CAAgB,KAAK,YAAY,CAAA;AAAA,EAC1C;AAAA;AAAA;AAAA;AAAA,EAKA,YAAA,GAA2B;AACzB,IAAA,OAAO,gBAAA,CAAiB,KAAK,YAAY,CAAA;AAAA,EAC3C;AAAA;AAAA;AAAA;AAAA,EAKA,OAAO,WAAW,GAAA,EAAuB;AACvC,IAAA,OAAO,IAAI,UAAS,GAAG,CAAA;AAAA,EACzB;AAAA;AAAA;AAAA;AAAA,EAKA,OAAO,IAAA,GAAiB;AACtB,IAAA,OAAO,IAAI,UAAS,EAAE,CAAA;AAAA,EACxB;AAAA,EAEA,QAAA,GAAmB;AACjB,IAAA,OAAO,KAAK,WAAA,EAAY;AAAA,EAC1B;AACF;;;AClFA,IAAA,+BAAA,GAAA;;;ACsFA,IAAM,WAAA,uBAAkB,GAAA,EAA4C;AACpE,IAAM,aAAA,uBAAoB,GAAA,EAA8C;AAGjE,IAAM,aAAA,GAAgB;AAAA,EAC3B,KAAK,CAAC,KAAA,MAA8C,EAAE,GAAA,EAAK,OAAO,KAAA,EAAM,CAAA;AAAA,EACxE,GAAA,EAAK,CAAwB,KAAA,MAAwC;AAAA,IACnE,GAAA,EAAK,KAAA;AAAA,IACL;AAAA,GACF,CAAA;AAAA,EACA,OAAA,EAAS,CACP,KAAA,MACkC;AAAA,IAClC,GAAA,EAAK,SAAA;AAAA,IACL;AAAA,GACF,CAAA;AAAA,EACA,KAAA,EAAO,CACL,KAAA,MACgC;AAAA,IAChC,GAAA,EAAK,OAAA;AAAA,IACL;AAAA,GACF,CAAA;AAAA,EACA,MAAA,EAAQ,EAAE,GAAA,EAAK,QAAA,EAAS;AAAA,EACxB,IAAA,EAAM,EAAE,GAAA,EAAK,MAAA,EAAO;AAAA,EACpB,EAAA,EAAI,EAAE,GAAA,EAAK,IAAA,EAAK;AAAA,EAChB,EAAA,EAAI,EAAE,GAAA,EAAK,IAAA,EAAK;AAAA,EAChB,GAAA,EAAK,EAAE,GAAA,EAAK,KAAA,EAAM;AAAA,EAClB,GAAA,EAAK,EAAE,GAAA,EAAK,KAAA,EAAM;AAAA,EAClB,GAAA,EAAK,EAAE,GAAA,EAAK,KAAA,EAAM;AAAA,EAClB,GAAA,EAAK,EAAE,GAAA,EAAK,KAAA,EAAM;AAAA,EAClB,GAAA,EAAK,EAAE,GAAA,EAAK,KAAA,EAAM;AAAA,EAClB,GAAA,EAAK,EAAE,GAAA,EAAK,KAAA,EAAM;AAAA,EAClB,IAAA,EAAM,EAAE,GAAA,EAAK,MAAA,EAAO;AAAA,EACpB,IAAA,EAAM,EAAE,GAAA,EAAK,MAAA,EAAO;AAAA,EACpB,IAAA,EAAM,EAAE,GAAA,EAAK,MAAA,EAAO;AAAA,EACpB,IAAA,EAAM,EAAE,GAAA,EAAK,MAAA,EAAO;AAAA,EACpB,GAAA,EAAK,EAAE,GAAA,EAAK,KAAA,EAAM;AAAA,EAClB,GAAA,EAAK,EAAE,GAAA,EAAK,KAAA,EAAM;AAAA,EAClB,cAAA,CACE,IACA,SAAA,EACiB;AACjB,IAAA,IAAI,EAAA,CAAG,QAAQ,KAAA,EAAO;AACpB,MAAA,IAAI,CAAC,SAAA;AACH,QAAA,MAAM,IAAI,MAAM,2CAA2C,CAAA;AAC7D,MAAA,OAAO,GAAG,GAAA,KAAQ,KAAA,OAAY,SAAA,CAAU,KAAA,CAAM,GAAG,KAAK,CAAA;AAAA,IACxD;AACA,IAAA,QAAQ,GAAG,GAAA;AAAK,MACd,KAAK,SAAA;AACH,QAAA,OAAO,WAAA,CAAY,cAAA,CAAe,EAAA,CAAG,KAAA,EAAO,SAAS,CAAA;AAAA,MACvD,KAAK,KAAA;AACH,QAAA,OAAO,OAAA,CAAQ,cAAA,CAAe,EAAA,CAAG,KAAA,EAAO,SAAS,CAAA;AAAA,MACnD,KAAK,OAAA;AACH,QAAA,IAAI,EAAA,CAAG,KAAA,CAAM,GAAA,KAAQ,IAAA,EAAM;AACzB,UAAA,OAAO,mBAAA;AAAA,QACT,CAAA,MAAO;AACL,UAAA,MAAM,SAAA,GAAY,aAAA,CAAc,cAAA,CAAe,EAAA,CAAG,OAAO,SAAS,CAAA;AAClE,UAAA,OAAO,CAAC,QAAQ,KAAA,KAAU;AACxB,YAAA,MAAA,CAAO,QAAA,CAAS,MAAM,MAAM,CAAA;AAC5B,YAAA,KAAA,MAAW,QAAQ,KAAA,EAAO;AACxB,cAAA,SAAA,CAAU,QAAQ,IAAI,CAAA;AAAA,YACxB;AAAA,UACF,CAAA;AAAA,QACF;AAAA,MACF;AACE,QAAA,OAAO,oBAAA,CAAqB,GAAG,GAAG,CAAA;AAAA;AACtC,EACF,CAAA;AAAA;AAAA,EAEA,cAAA,CACE,MAAA,EACA,EAAA,EACA,KAAA,EACA,SAAA,EACA;AACA,IAAA,aAAA,CAAc,cAAA,CAAe,EAAA,EAAI,SAAS,CAAA,CAAE,QAAQ,KAAK,CAAA;AAAA,EAC3D,CAAA;AAAA,EACA,gBAAA,CACE,IACA,SAAA,EACmB;AACnB,IAAA,IAAI,EAAA,CAAG,QAAQ,KAAA,EAAO;AACpB,MAAA,IAAI,CAAC,SAAA;AACH,QAAA,MAAM,IAAI,MAAM,6CAA6C,CAAA;AAC/D,MAAA,OAAO,GAAG,GAAA,KAAQ,KAAA,OAAY,SAAA,CAAU,KAAA,CAAM,GAAG,KAAK,CAAA;AAAA,IACxD;AACA,IAAA,QAAQ,GAAG,GAAA;AAAK,MACd,KAAK,SAAA;AACH,QAAA,OAAO,WAAA,CAAY,gBAAA,CAAiB,EAAA,CAAG,KAAA,EAAO,SAAS,CAAA;AAAA,MACzD,KAAK,KAAA;AACH,QAAA,OAAO,OAAA,CAAQ,gBAAA,CAAiB,EAAA,CAAG,KAAA,EAAO,SAAS,CAAA;AAAA,MACrD,KAAK,OAAA;AACH,QAAA,IAAI,EAAA,CAAG,KAAA,CAAM,GAAA,KAAQ,IAAA,EAAM;AACzB,UAAA,OAAO,qBAAA;AAAA,QACT,CAAA,MAAO;AACL,UAAA,MAAM,cAAc,aAAA,CAAc,gBAAA;AAAA,YAChC,EAAA,CAAG,KAAA;AAAA,YACH;AAAA,WACF;AACA,UAAA,OAAO,CAAA,MAAA,KAAU;AACf,YAAA,MAAM,MAAA,GAAS,OAAO,OAAA,EAAQ;AAC9B,YAAA,MAAM,MAAA,GAAgB,MAAM,MAAM,CAAA;AAClC,YAAA,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,MAAA,EAAQ,CAAA,EAAA,EAAK;AAC/B,cAAA,MAAA,CAAO,CAAC,CAAA,GAAI,WAAA,CAAY,MAAM,CAAA;AAAA,YAChC;AACA,YAAA,OAAO,MAAA;AAAA,UACT,CAAA;AAAA,QACF;AAAA,MACF;AACE,QAAA,OAAO,sBAAA,CAAuB,GAAG,GAAG,CAAA;AAAA;AACxC,EACF,CAAA;AAAA;AAAA,EAEA,gBAAA,CACE,MAAA,EACA,EAAA,EACA,SAAA,EACK;AACL,IAAA,OAAO,aAAA,CAAc,gBAAA,CAAiB,EAAA,EAAI,SAAS,EAAE,MAAM,CAAA;AAAA,EAC7D,CAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,UAAA,EAAY,SACV,EAAA,EACA,KAAA,EACqB;AACrB,IAAA,QAAQ,GAAG,GAAA;AAAK,MACd,KAAK,IAAA;AAAA,MACL,KAAK,KAAA;AAAA,MACL,KAAK,KAAA;AAAA,MACL,KAAK,KAAA;AAAA,MACL,KAAK,MAAA;AAAA,MACL,KAAK,MAAA;AAAA,MACL,KAAK,IAAA;AAAA,MACL,KAAK,KAAA;AAAA,MACL,KAAK,KAAA;AAAA,MACL,KAAK,KAAA;AAAA,MACL,KAAK,MAAA;AAAA,MACL,KAAK,MAAA;AAAA,MACL,KAAK,KAAA;AAAA,MACL,KAAK,KAAA;AAAA,MACL,KAAK,QAAA;AAAA,MACL,KAAK,MAAA;AACH,QAAA,OAAO,KAAA;AAAA,MACT,KAAK,SAAA;AACH,QAAA,OAAO,WAAA,CAAY,UAAA,CAAW,EAAA,CAAG,KAAA,EAAO,KAAK,CAAA;AAAA,MAC/C,SAAS;AAEP,QAAA,MAAM,MAAA,GAAS,IAAI,YAAA,CAAa,EAAE,CAAA;AAClC,QAAA,aAAA,CAAc,cAAA,CAAe,MAAA,EAAQ,EAAA,EAAI,KAAK,CAAA;AAC9C,QAAA,OAAO,OAAO,QAAA,EAAS;AAAA,MACzB;AAAA;AACF,EACF;AACF;AAEA,SAAS,SACP,CAAA,EACuE;AACvE,EAAA,OAAO,QAAA,CAAS,SAAA,CAAU,IAAA,CAAK,IAAA,CAAK,CAAC,CAAA;AACvC;AAOA,IAAM,oBAAA,GAA4D;AAAA,EAChE,IAAA,EAAM,QAAA,CAAS,YAAA,CAAa,SAAA,CAAU,SAAS,CAAA;AAAA,EAC/C,EAAA,EAAI,QAAA,CAAS,YAAA,CAAa,SAAA,CAAU,OAAO,CAAA;AAAA,EAC3C,EAAA,EAAI,QAAA,CAAS,YAAA,CAAa,SAAA,CAAU,OAAO,CAAA;AAAA,EAC3C,GAAA,EAAK,QAAA,CAAS,YAAA,CAAa,SAAA,CAAU,QAAQ,CAAA;AAAA,EAC7C,GAAA,EAAK,QAAA,CAAS,YAAA,CAAa,SAAA,CAAU,QAAQ,CAAA;AAAA,EAC7C,GAAA,EAAK,QAAA,CAAS,YAAA,CAAa,SAAA,CAAU,QAAQ,CAAA;AAAA,EAC7C,GAAA,EAAK,QAAA,CAAS,YAAA,CAAa,SAAA,CAAU,QAAQ,CAAA;AAAA,EAC7C,GAAA,EAAK,QAAA,CAAS,YAAA,CAAa,SAAA,CAAU,QAAQ,CAAA;AAAA,EAC7C,GAAA,EAAK,QAAA,CAAS,YAAA,CAAa,SAAA,CAAU,QAAQ,CAAA;AAAA,EAC7C,IAAA,EAAM,QAAA,CAAS,YAAA,CAAa,SAAA,CAAU,SAAS,CAAA;AAAA,EAC/C,IAAA,EAAM,QAAA,CAAS,YAAA,CAAa,SAAA,CAAU,SAAS,CAAA;AAAA,EAC/C,IAAA,EAAM,QAAA,CAAS,YAAA,CAAa,SAAA,CAAU,SAAS,CAAA;AAAA,EAC/C,IAAA,EAAM,QAAA,CAAS,YAAA,CAAa,SAAA,CAAU,SAAS,CAAA;AAAA,EAC/C,GAAA,EAAK,QAAA,CAAS,YAAA,CAAa,SAAA,CAAU,QAAQ,CAAA;AAAA,EAC7C,GAAA,EAAK,QAAA,CAAS,YAAA,CAAa,SAAA,CAAU,QAAQ,CAAA;AAAA,EAC7C,MAAA,EAAQ,QAAA,CAAS,YAAA,CAAa,SAAA,CAAU,WAAW;AACrD,CAAA;AACA,MAAA,CAAO,OAAO,oBAAoB,CAAA;AAElC,IAAM,mBAAA,GAAsB,QAAA,CAAS,YAAA,CAAa,SAAA,CAAU,eAAe,CAAA;AAE3E,IAAM,sBAAA,GAAgE;AAAA,EACpE,IAAA,EAAM,QAAA,CAAS,YAAA,CAAa,SAAA,CAAU,QAAQ,CAAA;AAAA,EAC9C,EAAA,EAAI,QAAA,CAAS,YAAA,CAAa,SAAA,CAAU,MAAM,CAAA;AAAA,EAC1C,EAAA,EAAI,QAAA,CAAS,YAAA,CAAa,SAAA,CAAU,MAAM,CAAA;AAAA,EAC1C,GAAA,EAAK,QAAA,CAAS,YAAA,CAAa,SAAA,CAAU,OAAO,CAAA;AAAA,EAC5C,GAAA,EAAK,QAAA,CAAS,YAAA,CAAa,SAAA,CAAU,OAAO,CAAA;AAAA,EAC5C,GAAA,EAAK,QAAA,CAAS,YAAA,CAAa,SAAA,CAAU,OAAO,CAAA;AAAA,EAC5C,GAAA,EAAK,QAAA,CAAS,YAAA,CAAa,SAAA,CAAU,OAAO,CAAA;AAAA,EAC5C,GAAA,EAAK,QAAA,CAAS,YAAA,CAAa,SAAA,CAAU,OAAO,CAAA;AAAA,EAC5C,GAAA,EAAK,QAAA,CAAS,YAAA,CAAa,SAAA,CAAU,OAAO,CAAA;AAAA,EAC5C,IAAA,EAAM,QAAA,CAAS,YAAA,CAAa,SAAA,CAAU,QAAQ,CAAA;AAAA,EAC9C,IAAA,EAAM,QAAA,CAAS,YAAA,CAAa,SAAA,CAAU,QAAQ,CAAA;AAAA,EAC9C,IAAA,EAAM,QAAA,CAAS,YAAA,CAAa,SAAA,CAAU,QAAQ,CAAA;AAAA,EAC9C,IAAA,EAAM,QAAA,CAAS,YAAA,CAAa,SAAA,CAAU,QAAQ,CAAA;AAAA,EAC9C,GAAA,EAAK,QAAA,CAAS,YAAA,CAAa,SAAA,CAAU,OAAO,CAAA;AAAA,EAC5C,GAAA,EAAK,QAAA,CAAS,YAAA,CAAa,SAAA,CAAU,OAAO,CAAA;AAAA,EAC5C,MAAA,EAAQ,QAAA,CAAS,YAAA,CAAa,SAAA,CAAU,UAAU;AACpD,CAAA;AACA,MAAA,CAAO,OAAO,sBAAsB,CAAA;AAEpC,IAAM,qBAAA,GAAwB,QAAA,CAAS,YAAA,CAAa,SAAA,CAAU,cAAc,CAAA;AAI5E,IAAM,cAAA,GAAsD;AAAA,EAC1D,IAAA,EAAM,CAAA;AAAA,EACN,EAAA,EAAI,CAAA;AAAA,EACJ,EAAA,EAAI,CAAA;AAAA,EACJ,GAAA,EAAK,CAAA;AAAA,EACL,GAAA,EAAK,CAAA;AAAA,EACL,GAAA,EAAK,CAAA;AAAA,EACL,GAAA,EAAK,CAAA;AAAA,EACL,GAAA,EAAK,CAAA;AAAA,EACL,GAAA,EAAK,CAAA;AAAA,EACL,IAAA,EAAM,EAAA;AAAA,EACN,IAAA,EAAM,EAAA;AAAA,EACN,IAAA,EAAM,EAAA;AAAA,EACN,IAAA,EAAM,EAAA;AAAA,EACN,GAAA,EAAK,CAAA;AAAA,EACL,GAAA,EAAK;AACP,CAAA;AAEA,IAAM,sBAAsB,IAAI,GAAA,CAAI,MAAA,CAAO,IAAA,CAAK,cAAc,CAAC,CAAA;AAM/D,IAAM,kBAAA,GAAqB,CAAC,EAAA,KAC1B,EAAA,CAAG,QAAA,CAAS,KAAA;AAAA,EAAM,CAAC,EAAE,aAAA,OACnB,mBAAA,CAAoB,GAAA,CAAI,cAAc,GAAG;AAC3C,CAAA;AAEF,IAAM,WAAA,GAAc,CAAC,EAAA,KACnB,EAAA,CAAG,QAAA,CAAS,MAAA;AAAA,EACV,CAAC,KAAK,EAAE,aAAA,OAAoB,GAAA,GAAM,cAAA,CAAe,cAAc,GAAG,CAAA;AAAA,EAClE;AACF,CAAA;AAOF,IAAM,eAAA,GAAgD;AAAA,EACpD,IAAA,EAAM,OAAA;AAAA,EACN,EAAA,EAAI,MAAA;AAAA,EACJ,EAAA,EAAI,OAAA;AAAA,EACJ,GAAA,EAAK,OAAA;AAAA,EACL,GAAA,EAAK,QAAA;AAAA,EACL,GAAA,EAAK,OAAA;AAAA,EACL,GAAA,EAAK,QAAA;AAAA,EACL,GAAA,EAAK,UAAA;AAAA,EACL,GAAA,EAAK,WAAA;AAAA,EACL,GAAA,EAAK,SAAA;AAAA,EACL,GAAA,EAAK;AACP,CAAA;AAUA,IAAM,2BAAA,GAEF;AAAA,EACF,0BAA0B,CAAA,MAAA,KAAU,IAAI,YAAA,CAAa,MAAA,CAAO,SAAS,CAAA;AAAA,EACrE,uCAAuC,CAAA,MAAA,KACrC,IAAI,SAAA,CAAU,MAAA,CAAO,SAAS,CAAA;AAAA,EAChC,cAAc,CAAA,MAAA,KAAU,IAAI,QAAA,CAAS,MAAA,CAAO,UAAU,CAAA;AAAA,EACtD,mBAAmB,CAAA,MAAA,KAAU,IAAI,YAAA,CAAa,MAAA,CAAO,UAAU,CAAA;AAAA,EAC/D,UAAU,CAAA,MAAA,KAAU,IAAI,IAAA,CAAK,MAAA,CAAO,UAAU;AAChD,CAAA;AACA,MAAA,CAAO,OAAO,2BAA2B,CAAA;AAEzC,IAAM,gBAAA,GAAqC,OAAO,EAAC,CAAA;AAEnD,IAAM,qBAAA,GAAwB,CAAC,OAAA,KAAgC;AAC7D,EAAA,IAAI,IAAA;AACJ,EAAA,QAAQ,OAAA,CAAQ,cAAc,GAAA;AAAK,IACjC,KAAK,QAAA;AACH,MAAA,IAAA,GAAO,IAAA;AACP,MAAA;AAAA,IACF,KAAK,MAAA;AACH,MAAA,IAAA,GAAO,OAAA;AACP,MAAA;AAAA,IACF,KAAK,IAAA;AAAA,IACL,KAAK,IAAA;AAAA,IACL,KAAK,KAAA;AAAA,IACL,KAAK,KAAA;AAAA,IACL,KAAK,KAAA;AAAA,IACL,KAAK,KAAA;AACH,MAAA,IAAA,GAAO,GAAA;AACP,MAAA;AAAA,IACF,KAAK,KAAA;AAAA,IACL,KAAK,KAAA;AAAA,IACL,KAAK,MAAA;AAAA,IACL,KAAK,MAAA;AAAA,IACL,KAAK,MAAA;AAAA,IACL,KAAK,MAAA;AACH,MAAA,IAAA,GAAO,IAAA;AACP,MAAA;AAAA,IACF,KAAK,KAAA;AAAA,IACL,KAAK,KAAA;AACH,MAAA,IAAA,GAAO,KAAA;AACP,MAAA;AAAA,IACF;AACE,MAAA,IAAA,GAAO,WAAA;AAAA;AAEX,EAAA,OAAO,CAAA,EAAG,OAAA,CAAQ,IAAK,CAAA,EAAA,EAAK,IAAI,CAAA,CAAA;AAClC,CAAA;AA6BO,IAAM,WAAA,GAAc;AAAA,EACzB,cAAA,CACE,IACA,SAAA,EACiB;AACjB,IAAA,IAAI,UAAA,GAAa,WAAA,CAAY,GAAA,CAAI,EAAE,CAAA;AACnC,IAAA,IAAI,UAAA,IAAc,MAAM,OAAO,UAAA;AAE/B,IAAA,IAAI,kBAAA,CAAmB,EAAE,CAAA,EAAG;AAC1B,MAAA,MAAM,IAAA,GAAO,YAAY,EAAE,CAAA;AAC3B,MAAA,MAAMA,KAAAA,GAAO,CAAA;AAAA,oBAAA,EAEG,IAAI,CAAA;AAAA;AAAA,EAExB,GAAG,QAAA,CACF,GAAA;AAAA,QAAI,CAAC,EAAE,IAAA,EAAM,aAAA,EAAe,EAAE,GAAA,EAAI,EAAE,KACnC,GAAA,IAAO,eAAA,GACH,CAAA,QAAA,EACE,gBAAgB,GAAmB,CAAC,yBAAyB,IAAK,CAAA,EAAA,EAAK,eAAe,GAAG,CAAA,GAAI,CAAA,GAAI,MAAA,GAAS,EAAE,CAAA;AAAA,iBAAA,EACnG,eAAe,GAAG,CAAC,MAC9B,CAAA,YAAA,EAAe,GAAG,UAAU,IAAI,CAAA,EAAA;AAAA,OACtC,CACC,IAAA,CAAK,IAAI,CAAC,CAAA,CAAA;AACP,MAAA,UAAA,GAAa,QAAA,CAAS,QAAA,EAAU,OAAA,EAASA,KAAI,CAAA;AAC7C,MAAA,WAAA,CAAY,GAAA,CAAI,IAAI,UAAU,CAAA;AAC9B,MAAA,OAAO,UAAA;AAAA,IACT;AASA,IAAA,MAAM,cAA+C,EAAC;AACtD,IAAA,MAAM,IAAA,GACJ,iBAAA,GACA,EAAA,CAAG,QAAA,CACA,GAAA;AAAA,MACC,aAAW,CAAA,KAAA,EAAQ,OAAA,CAAQ,IAAK,CAAA,eAAA,EAAkB,QAAQ,IAAK,CAAA,EAAA;AAAA,KACjE,CACC,KAAK,IAAI,CAAA;AACd,IAAA,UAAA,GAAa,QAAA,CAAS,QAAA,EAAU,OAAA,EAAS,IAAI,CAAA,CAAE,IAAA;AAAA,MAC7C;AAAA,KACF;AAIA,IAAA,WAAA,CAAY,GAAA,CAAI,IAAI,UAAU,CAAA;AAC9B,IAAA,KAAA,MAAW,EAAE,IAAA,EAAM,aAAA,EAAc,IAAK,GAAG,QAAA,EAAU;AACjD,MAAA,WAAA,CAAY,IAAK,IAAI,aAAA,CAAc,cAAA;AAAA,QACjC,aAAA;AAAA,QACA;AAAA,OACF;AAAA,IACF;AACA,IAAA,MAAA,CAAO,OAAO,WAAW,CAAA;AACzB,IAAA,OAAO,UAAA;AAAA,EACT,CAAA;AAAA;AAAA,EAEA,cAAA,CACE,MAAA,EACA,EAAA,EACA,KAAA,EACA,SAAA,EACM;AACN,IAAA,WAAA,CAAY,cAAA,CAAe,EAAA,EAAI,SAAS,CAAA,CAAE,QAAQ,KAAK,CAAA;AAAA,EACzD,CAAA;AAAA,EACA,gBAAA,CACE,IACA,SAAA,EACmB;AACnB,IAAA,QAAQ,EAAA,CAAG,SAAS,MAAA;AAAQ,MAC1B,KAAK,CAAA;AACH,QAAA,OAAO,gBAAA;AAAA,MACT,KAAK,CAAA,EAAG;AACN,QAAA,MAAM,SAAA,GAAY,EAAA,CAAG,QAAA,CAAS,CAAC,CAAA,CAAE,IAAA;AACjC,QAAA,IAAI,MAAA,CAAO,6BAA6B,SAAS,CAAA;AAC/C,UAAA,OAAO,4BACL,SACF,CAAA;AAAA,MACJ;AAAA;AAGF,IAAA,IAAI,YAAA,GAAe,aAAA,CAAc,GAAA,CAAI,EAAE,CAAA;AACvC,IAAA,IAAI,YAAA,IAAgB,MAAM,OAAO,YAAA;AAEjC,IAAA,IAAI,kBAAA,CAAmB,EAAE,CAAA,EAAG;AAC1B,MAAA,MAAM,IAAA,GAAO,CAAA;AAAA,iBAAA,EAEA,GAAG,QAAA,CAAS,GAAA,CAAI,qBAAqB,CAAA,CAAE,IAAA,CAAK,IAAI,CAAC,CAAA;AAAA;AAAA,EAElE,GAAG,QAAA,CACF,GAAA;AAAA,QAAI,CAAC,EAAE,IAAA,EAAM,aAAA,EAAe,EAAE,GAAA,EAAI,EAAE,KACnC,GAAA,IAAO,eAAA,GACH,CAAA,OAAA,EACC,IAAI,CAAA,WAAA,EAAc,eAAA,CAAgB,GAAmB,CAAC,CAAA,gBAAA,EAAmB,eAAe,GAAG,CAAA,GAAI,CAAA,GAAI,MAAA,GAAS,EAAE,CAAA;AAAA,iBAAA,EACpG,eAAe,GAAG,CAAC,MAC9B,CAAA,OAAA,EAAU,IAAI,iBAAiB,GAAG,CAAA,GAAA;AAAA,OACxC,CACC,IAAA,CAAK,IAAI,CAAC;AAAA,cAAA,CAAA;AAEP,MAAA,YAAA,GAAe,QAAA,CAAS,UAAU,IAAI,CAAA;AACtC,MAAA,aAAA,CAAc,GAAA,CAAI,IAAI,YAAY,CAAA;AAClC,MAAA,OAAO,YAAA;AAAA,IACT;AASA,IAAA,MAAM,gBAAmD,EAAC;AAC1D,IAAA,YAAA,GAAe,QAAA;AAAA,MACb,QAAA;AAAA,MACA,CAAA;AAAA,iBAAA,EAEa,GAAG,QAAA,CAAS,GAAA,CAAI,qBAAqB,CAAA,CAAE,IAAA,CAAK,IAAI,CAAC,CAAA;AAAA,EAClE,EAAA,CAAG,QAAA,CAAS,GAAA,CAAI,CAAC,EAAE,IAAA,EAAK,KAAM,CAAA,OAAA,EAAU,IAAK,WAAW,IAAK,CAAA,SAAA,CAAW,CAAA,CAAE,IAAA,CAAK,IAAI,CAAC;AAAA,cAAA;AAAA,KAElF,CAAE,KAAK,aAAa,CAAA;AAIpB,IAAA,aAAA,CAAc,GAAA,CAAI,IAAI,YAAY,CAAA;AAClC,IAAA,KAAA,MAAW,EAAE,IAAA,EAAM,aAAA,EAAc,IAAK,GAAG,QAAA,EAAU;AACjD,MAAA,aAAA,CAAc,IAAK,IAAI,aAAA,CAAc,gBAAA;AAAA,QACnC,aAAA;AAAA,QACA;AAAA,OACF;AAAA,IACF;AACA,IAAA,MAAA,CAAO,OAAO,aAAa,CAAA;AAC3B,IAAA,OAAO,YAAA;AAAA,EACT,CAAA;AAAA;AAAA,EAEA,gBAAA,CACE,MAAA,EACA,EAAA,EACA,SAAA,EACK;AACL,IAAA,OAAO,WAAA,CAAY,gBAAA,CAAiB,EAAA,EAAI,SAAS,EAAE,MAAM,CAAA;AAAA,EAC3D,CAAA;AAAA,EACA,UAAA,CAAW,IAAqB,KAAA,EAAiC;AAC/D,IAAA,IAAI,EAAA,CAAG,QAAA,CAAS,MAAA,KAAW,CAAA,EAAG;AAC5B,MAAA,MAAM,SAAA,GAAY,EAAA,CAAG,QAAA,CAAS,CAAC,CAAA,CAAE,IAAA;AACjC,MAAA,IAAI,MAAA,CAAO,2BAAA,EAA6B,SAAS,CAAA,EAAG;AAClD,QAAA,OAAO,MAAM,SAAS,CAAA;AAAA,MACxB;AAAA,IACF;AAEA,IAAA,MAAM,MAAA,GAAS,IAAI,YAAA,CAAa,EAAE,CAAA;AAClC,IAAA,aAAA,CAAc,eAAe,MAAA,EAAQ,aAAA,CAAc,OAAA,CAAQ,EAAE,GAAG,KAAK,CAAA;AACrE,IAAA,OAAO,OAAO,QAAA,EAAS;AAAA,EACzB;AACF;AA4BO,IAAM,OAAA,GAAU;AAAA,EACrB,cAAA,CAAe,IAAiB,SAAA,EAA4C;AAC1E,IAAA,IACE,EAAA,CAAG,QAAA,CAAS,MAAA,IAAU,CAAA,IACtB,GAAG,QAAA,CAAS,CAAC,CAAA,CAAE,IAAA,KAAS,UACxB,EAAA,CAAG,QAAA,CAAS,CAAC,CAAA,CAAE,SAAS,MAAA,EACxB;AACA,MAAA,MAAM,YAAY,aAAA,CAAc,cAAA;AAAA,QAC9B,EAAA,CAAG,QAAA,CAAS,CAAC,CAAA,CAAE,aAAA;AAAA,QACf;AAAA,OACF;AACA,MAAA,OAAO,CAAC,QAAQ,KAAA,KAAU;AACxB,QAAA,IAAI,KAAA,KAAU,IAAA,IAAQ,KAAA,KAAU,MAAA,EAAW;AACzC,UAAA,MAAA,CAAO,UAAU,CAAC,CAAA;AAClB,UAAA,SAAA,CAAU,QAAQ,KAAK,CAAA;AAAA,QACzB,CAAA,MAAO;AACL,UAAA,MAAA,CAAO,UAAU,CAAC,CAAA;AAAA,QACpB;AAAA,MACF,CAAA;AAAA,IACF,WACE,EAAA,CAAG,QAAA,CAAS,MAAA,IAAU,CAAA,IACtB,GAAG,QAAA,CAAS,CAAC,CAAA,CAAE,IAAA,KAAS,QACxB,EAAA,CAAG,QAAA,CAAS,CAAC,CAAA,CAAE,SAAS,KAAA,EACxB;AACA,MAAA,MAAM,cAAc,aAAA,CAAc,cAAA;AAAA,QAChC,EAAA,CAAG,QAAA,CAAS,CAAC,CAAA,CAAE,aAAA;AAAA,QACf;AAAA,OACF;AACA,MAAA,MAAM,eAAe,aAAA,CAAc,cAAA;AAAA,QACjC,EAAA,CAAG,QAAA,CAAS,CAAC,CAAA,CAAE,aAAA;AAAA,QACf;AAAA,OACF;AAEA,MAAA,OAAO,CAAC,QAAQ,KAAA,KAAU;AACxB,QAAA,IAAI,QAAQ,KAAA,EAAO;AACjB,UAAA,MAAA,CAAO,QAAQ,CAAC,CAAA;AAChB,UAAA,WAAA,CAAY,MAAA,EAAQ,MAAM,EAAE,CAAA;AAAA,QAC9B,CAAA,MAAA,IAAW,SAAS,KAAA,EAAO;AACzB,UAAA,MAAA,CAAO,QAAQ,CAAC,CAAA;AAChB,UAAA,YAAA,CAAa,MAAA,EAAQ,MAAM,GAAG,CAAA;AAAA,QAChC,CAAA,MAAO;AACL,UAAA,MAAM,IAAI,SAAA;AAAA,YACR;AAAA,WACF;AAAA,QACF;AAAA,MACF,CAAA;AAAA,IACF,CAAA,MAAO;AACL,MAAA,IAAI,UAAA,GAAa,WAAA,CAAY,GAAA,CAAI,EAAE,CAAA;AACnC,MAAA,IAAI,UAAA,IAAc,MAAM,OAAO,UAAA;AAE/B,MAAA,MAAM,cAA+C,EAAC;AAEtD,MAAA,MAAM,IAAA,GAAO,CAAA;AAAA,EAEjB,GAAG,QAAA,CACF,GAAA;AAAA,QACC,CAAC,EAAE,IAAA,EAAK,EAAG,MAAM,CAAA,OAAA,EACZ,IAAA,CAAK,SAAA,CAAU,IAAK,CAAC,CAAA;AAAA,qBAAA,EACP,CAAC,CAAA;AAAA,gBAAA,EACN,IAAK,CAAA,sBAAA;AAAA,OACrB,CACC,IAAA,CAAK,IAAI,CAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,CAAA;AAQP,MAAA,UAAA,GAAa,QAAA,CAAS,QAAA,EAAU,OAAA,EAAS,IAAI,CAAA,CAAE,IAAA;AAAA,QAC7C;AAAA,OACF;AAKA,MAAA,WAAA,CAAY,GAAA,CAAI,IAAI,UAAU,CAAA;AAE9B,MAAA,KAAA,MAAW,EAAE,IAAA,EAAM,aAAA,EAAc,IAAK,GAAG,QAAA,EAAU;AACjD,QAAA,WAAA,CAAY,IAAK,IAAI,aAAA,CAAc,cAAA;AAAA,UACjC,aAAA;AAAA,UACA;AAAA,SACF;AAAA,MACF;AACA,MAAA,MAAA,CAAO,OAAO,WAAW,CAAA;AACzB,MAAA,OAAO,UAAA;AAAA,IACT;AAAA,EACF,CAAA;AAAA;AAAA,EAEA,cAAA,CACE,MAAA,EACA,EAAA,EACA,KAAA,EACA,SAAA,EACM;AACN,IAAA,OAAA,CAAQ,cAAA,CAAe,EAAA,EAAI,SAAS,CAAA,CAAE,QAAQ,KAAK,CAAA;AAAA,EACrD,CAAA;AAAA,EACA,gBAAA,CACE,IACA,SAAA,EACmB;AASnB,IAAA,IACE,EAAA,CAAG,QAAA,CAAS,MAAA,IAAU,CAAA,IACtB,GAAG,QAAA,CAAS,CAAC,CAAA,CAAE,IAAA,KAAS,UACxB,EAAA,CAAG,QAAA,CAAS,CAAC,CAAA,CAAE,SAAS,MAAA,EACxB;AACA,MAAA,MAAM,cAAc,aAAA,CAAc,gBAAA;AAAA,QAChC,EAAA,CAAG,QAAA,CAAS,CAAC,CAAA,CAAE,aAAA;AAAA,QACf;AAAA,OACF;AACA,MAAA,OAAO,CAAA,MAAA,KAAU;AACf,QAAA,MAAM,GAAA,GAAM,OAAO,MAAA,EAAO;AAC1B,QAAA,IAAI,QAAQ,CAAA,EAAG;AACb,UAAA,OAAO,YAAY,MAAM,CAAA;AAAA,QAC3B,CAAA,MAAA,IAAW,QAAQ,CAAA,EAAG;AACpB,UAAA,OAAO,MAAA;AAAA,QACT,CAAA,MAAO;AACL,UAAA,MAAM,mDAAmD,GAAG,CAAA,IAAA,CAAA;AAAA,QAC9D;AAAA,MACF,CAAA;AAAA,IACF,WACE,EAAA,CAAG,QAAA,CAAS,MAAA,IAAU,CAAA,IACtB,GAAG,QAAA,CAAS,CAAC,CAAA,CAAE,IAAA,KAAS,QACxB,EAAA,CAAG,QAAA,CAAS,CAAC,CAAA,CAAE,SAAS,KAAA,EACxB;AACA,MAAA,MAAM,gBAAgB,aAAA,CAAc,gBAAA;AAAA,QAClC,EAAA,CAAG,QAAA,CAAS,CAAC,CAAA,CAAE,aAAA;AAAA,QACf;AAAA,OACF;AACA,MAAA,MAAM,iBAAiB,aAAA,CAAc,gBAAA;AAAA,QACnC,EAAA,CAAG,QAAA,CAAS,CAAC,CAAA,CAAE,aAAA;AAAA,QACf;AAAA,OACF;AACA,MAAA,OAAO,CAAA,MAAA,KAAU;AACf,QAAA,MAAM,GAAA,GAAM,OAAO,QAAA,EAAS;AAC5B,QAAA,IAAI,QAAQ,CAAA,EAAG;AACb,UAAA,OAAO,EAAE,EAAA,EAAI,aAAA,CAAc,MAAM,CAAA,EAAE;AAAA,QACrC,CAAA,MAAA,IAAW,QAAQ,CAAA,EAAG;AACpB,UAAA,OAAO,EAAE,GAAA,EAAK,cAAA,CAAe,MAAM,CAAA,EAAE;AAAA,QACvC,CAAA,MAAO;AACL,UAAA,MAAM,kDAAkD,GAAG,CAAA,IAAA,CAAA;AAAA,QAC7D;AAAA,MACF,CAAA;AAAA,IACF,CAAA,MAAO;AACL,MAAA,IAAI,YAAA,GAAe,aAAA,CAAc,GAAA,CAAI,EAAE,CAAA;AACvC,MAAA,IAAI,YAAA,IAAgB,MAAM,OAAO,YAAA;AACjC,MAAA,MAAM,gBAAmD,EAAC;AAC1D,MAAA,YAAA,GAAe,QAAA;AAAA,QACb,QAAA;AAAA,QACA,CAAA;AAAA,EAA+B,GAAG,QAAA,CAC/B,GAAA;AAAA,UACC,CAAC,EAAE,IAAA,EAAK,EAAG,CAAA,KACT,CAAA,KAAA,EAAQ,CAAC,CAAA,gBAAA,EAAmB,IAAA,CAAK,SAAA,CAAU,IAAK,CAAC,iBAAiB,IAAK,CAAA,WAAA;AAAA,SAC3E,CACC,IAAA,CAAK,IAAI,CAAC,CAAA,EAAA;AAAA,OACf,CAAE,KAAK,aAAa,CAAA;AAIpB,MAAA,aAAA,CAAc,GAAA,CAAI,IAAI,YAAY,CAAA;AAClC,MAAA,KAAA,MAAW,EAAE,IAAA,EAAM,aAAA,EAAc,IAAK,GAAG,QAAA,EAAU;AACjD,QAAA,aAAA,CAAc,IAAK,IAAI,aAAA,CAAc,gBAAA;AAAA,UACnC,aAAA;AAAA,UACA;AAAA,SACF;AAAA,MACF;AACA,MAAA,MAAA,CAAO,OAAO,aAAa,CAAA;AAC3B,MAAA,OAAO,YAAA;AAAA,IACT;AAAA,EACF,CAAA;AAAA;AAAA,EAEA,gBAAA,CACE,MAAA,EACA,EAAA,EACA,SAAA,EACK;AACL,IAAA,OAAO,OAAA,CAAQ,gBAAA,CAAiB,EAAA,EAAI,SAAS,EAAE,MAAM,CAAA;AAAA,EACvD;AACF;;;AC/xBO,IAAM,YAAA,GAAN,MAAM,aAAA,CAAa;AAAA,EACxB,iBAAA;AAAA;AAAA;AAAA;AAAA,EAKA,YAAY,IAAA,EAAc;AACxB,IAAA,IAAA,CAAK,iBAAA,GAAoB,IAAA;AAAA,EAC3B;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,OAAO,gBAAA,GAA8C;AACnD,IAAA,OAAO,cAAc,OAAA,CAAQ;AAAA,MAC3B,QAAA,EAAU;AAAA,QACR,EAAE,IAAA,EAAM,mBAAA,EAAqB,aAAA,EAAe,cAAc,IAAA;AAAK;AACjE,KACD,CAAA;AAAA,EACH;AAAA,EAEA,MAAA,GAAkB;AAChB,IAAA,OAAO,IAAA,CAAK,iBAAA,KAAsB,MAAA,CAAO,CAAC,CAAA;AAAA,EAC5C;AAAA,EAEA,OAAO,WAAW,IAAA,EAAyC;AACzD,IAAA,IAAI,IAAA,CAAK,QAAO,EAAG;AACjB,MAAA,OAAO,IAAA;AAAA,IACT,CAAA,MAAO;AACL,MAAA,OAAO,IAAA;AAAA,IACT;AAAA,EACF;AAAA,EAEA,OAAO,MAAA,GAAuB;AAC5B,IAAA,SAAS,QAAA,GAAmB;AAC1B,MAAA,OAAO,IAAA,CAAK,KAAA,CAAM,IAAA,CAAK,MAAA,KAAW,GAAI,CAAA;AAAA,IACxC;AACA,IAAA,IAAI,MAAA,GAAS,OAAO,CAAC,CAAA;AACrB,IAAA,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,EAAA,EAAI,CAAA,EAAA,EAAK;AAC3B,MAAA,MAAA,GAAU,UAAU,MAAA,CAAO,CAAC,CAAA,GAAK,MAAA,CAAO,UAAU,CAAA;AAAA,IACpD;AACA,IAAA,OAAO,IAAI,cAAa,MAAM,CAAA;AAAA,EAChC;AAAA;AAAA;AAAA;AAAA,EAKA,QAAQ,KAAA,EAA8B;AACpC,IAAA,OAAO,IAAA,CAAK,qBAAqB,KAAA,CAAM,iBAAA;AAAA,EACzC;AAAA;AAAA;AAAA;AAAA,EAKA,OAAO,KAAA,EAA8B;AACnC,IAAA,OAAO,IAAA,CAAK,QAAQ,KAAK,CAAA;AAAA,EAC3B;AAAA;AAAA;AAAA;AAAA,EAKA,WAAA,GAAsB;AACpB,IAAA,OAAO,eAAA,CAAgB,KAAK,iBAAiB,CAAA;AAAA,EAC/C;AAAA;AAAA;AAAA;AAAA,EAKA,YAAA,GAA2B;AACzB,IAAA,OAAO,gBAAA,CAAiB,KAAK,iBAAiB,CAAA;AAAA,EAChD;AAAA;AAAA;AAAA;AAAA,EAKA,OAAO,WAAW,GAAA,EAA2B;AAC3C,IAAA,OAAO,IAAI,aAAA,CAAa,eAAA,CAAgB,GAAG,CAAC,CAAA;AAAA,EAC9C;AAAA,EAEA,OAAO,iBAAiB,GAAA,EAAkC;AACxD,IAAA,MAAM,IAAA,GAAO,aAAA,CAAa,UAAA,CAAW,GAAG,CAAA;AACxC,IAAA,IAAI,IAAA,CAAK,QAAO,EAAG;AACjB,MAAA,OAAO,IAAA;AAAA,IACT,CAAA,MAAO;AACL,MAAA,OAAO,IAAA;AAAA,IACT;AAAA,EACF;AACF;;;AC/FO,IAAM,WAAA,GAAN,cAA0B,KAAA,CAAM;AAAA,EACrC,YAAY,OAAA,EAAiB;AAC3B,IAAA,KAAA,CAAM,OAAO,CAAA;AAAA,EACf;AAAA,EACA,IAAI,IAAA,GAAe;AACjB,IAAA,OAAO,aAAA;AAAA,EACT;AACF;AAKO,IAAM,aAAA,GAAN,cAA4B,KAAA,CAAM;AAAA,EACvC,YAAY,OAAA,EAAiB;AAC3B,IAAA,KAAA,CAAM,OAAO,CAAA;AAAA,EACf;AAAA,EACA,IAAI,IAAA,GAAe;AACjB,IAAA,OAAO,eAAA;AAAA,EACT;AACF;;;ACnBO,SAAS,UAAA,CAAc,IAAsB,GAAA,EAAoB;AACtE,EAAA,MAAM,MAAA,GAAS,IAAI,YAAA,CAAa,GAAG,CAAA;AACnC,EAAA,OAAO,EAAA,CAAG,YAAY,MAAM,CAAA;AAC9B;;;ACOO,IAAM,UAAA,GAWT;AAAA,EACF,SAAS,KAAA,EAA+B;AACtC,IAAA,OAAO,SAAS,KAAK,CAAA;AAAA,EACvB,CAAA;AAAA,EACA,KAAK,KAAA,EAA+B;AAClC,IAAA,OAAO,KAAK,KAAK,CAAA;AAAA,EACnB,CAAA;AAAA,EACA,gBAAA,GAA4C;AAC1C,IAAA,OAAO,cAAc,GAAA,CAAI;AAAA,MACvB,QAAA,EAAU;AAAA,QACR;AAAA,UACE,IAAA,EAAM,UAAA;AAAA,UACN,aAAA,EAAe,aAAa,gBAAA;AAAiB,SAC/C;AAAA,QACA,EAAE,IAAA,EAAM,MAAA,EAAQ,aAAA,EAAe,SAAA,CAAU,kBAAiB;AAAE;AAC9D,KACD,CAAA;AAAA,EACH,CAAA;AAAA,EACA,aACE,aAAA,EAC0C;AAC1C,IAAA,IAAI,aAAA,CAAc,QAAQ,KAAA,EAAO;AAC/B,MAAA,OAAO,KAAA;AAAA,IACT;AACA,IAAA,MAAM,QAAA,GAAW,cAAc,KAAA,CAAM,QAAA;AACrC,IAAA,IAAI,QAAA,CAAS,WAAW,CAAA,EAAG;AACzB,MAAA,OAAO,KAAA;AAAA,IACT;AACA,IAAA,MAAM,kBAAkB,QAAA,CAAS,IAAA,CAAK,CAAA,CAAA,KAAK,CAAA,CAAE,SAAS,UAAU,CAAA;AAChE,IAAA,MAAM,cAAc,QAAA,CAAS,IAAA,CAAK,CAAA,CAAA,KAAK,CAAA,CAAE,SAAS,MAAM,CAAA;AACxD,IAAA,IAAI,CAAC,eAAA,IAAmB,CAAC,WAAA,EAAa;AACpC,MAAA,OAAO,KAAA;AAAA,IACT;AACA,IAAA,OACE,YAAA,CAAa,eAAe,eAAA,CAAgB,aAAa,KACzD,SAAA,CAAU,WAAA,CAAY,YAAY,aAAa,CAAA;AAAA,EAEnD;AACF;AAMO,IAAM,QAAA,GAAW,CAAC,MAAA,MAA8B;AAAA,EACrD,GAAA,EAAK,UAAA;AAAA,EACL,KAAA,EAAO,IAAI,YAAA,CAAa,MAAM;AAChC,CAAA;AAKO,IAAM,IAAA,GAAO,CAAC,oBAAA,MAAwC;AAAA,EAC3D,GAAA,EAAK,MAAA;AAAA,EACL,KAAA,EAAO,IAAI,SAAA,CAAU,oBAAoB;AAC3C,CAAA;AAEA,IAAO,mBAAA,GAAQ,UAAA;;;ACrER,IAAM,MAAA,GAIT;AAAA,EACF,iBACE,SAAA,EACwB;AACxB,IAAA,OAAO,cAAc,GAAA,CAAI;AAAA,MACvB,QAAA,EAAU;AAAA,QACR,EAAE,IAAA,EAAM,MAAA,EAAQ,aAAA,EAAe,SAAA,EAAU;AAAA,QACzC;AAAA,UACE,IAAA,EAAM,MAAA;AAAA,UACN,eAAe,aAAA,CAAc,OAAA,CAAQ,EAAE,QAAA,EAAU,IAAI;AAAA;AACvD;AACF,KACD,CAAA;AAAA,EACH;AACF;;;AClBO,IAAM,MAAA,GAQT;AAAA,EACF,gBAAA,CAGE,QAAW,OAAA,EAAuC;AAClD,IAAA,OAAO,cAAc,GAAA,CAAI;AAAA,MACvB,QAAA,EAAU;AAAA,QACR,EAAE,IAAA,EAAM,IAAA,EAAM,aAAA,EAAe,MAAA,EAAO;AAAA,QACpC,EAAE,IAAA,EAAM,KAAA,EAAO,aAAA,EAAe,OAAA;AAAQ;AACxC,KACD,CAAA;AAAA,EACH;AACF;;;ACLA,IAAM,UAAA,GAAa,OAAO,YAAY,CAAA;AAmB/B,IAAM,eAAA,GAAkB,CAAC,GAAA,KAC9B,CAAC,CAAC,GAAA,IAAO,OAAO,GAAA,KAAQ,QAAA,IAAY,UAAA,IAAe;AAE9C,IAAM,YAAA,GAAe,CAAC,GAAA,KAC3B,CAAC,CAAC,GAAA,IAAO,OAAO,GAAA,KAAQ,QAAA,IAAY,UAAA,IAAe;AAE9C,SAAS,MAAM,CAAA,EAAuB;AAC3C,EAAA,OAAQ,EAAqC,KAAA,EAAM;AACrD;AA4CA,IAAM,YAAA,GAAN,MAAM,aAAA,CAEN;AAAA,EAGE,WAAA,CACW,WAAA,EACA,WAAA,EACA,aAAA,EACT;AAHS,IAAA,IAAA,CAAA,WAAA,GAAA,WAAA;AACA,IAAA,IAAA,CAAA,WAAA,GAAA,WAAA;AACA,IAAA,IAAA,CAAA,aAAA,GAAA,aAAA;AAET,IAAA,IAAI,WAAA,CAAY,KAAA,CAAM,UAAA,KAAe,WAAA,CAAY,MAAM,UAAA,EAAY;AAEjE,MAAA,MAAM,IAAI,MAAM,mCAAmC,CAAA;AAAA,IACrD;AAAA,EACF;AAAA,EAXA,CAAU,UAAU,IAAI,IAAA;AAAA,EACf,IAAA,GAAO,UAAA;AAAA,EAYhB,KAAA,GAAyB;AACvB,IAAA,OAAO,IAAA;AAAA,EACT;AAAA,EAEA,MACE,SAAA,EACwB;AACxB,IAAA,MAAM,eAAA,GAAkB,IAAA,CAAK,WAAA,CAAY,KAAA,CAAM,SAAS,CAAA;AACxD,IAAA,OAAO,IAAI,aAAA;AAAA,MACT,eAAA;AAAA,MACA,IAAA,CAAK,WAAA;AAAA,MACL,IAAA,CAAK;AAAA,KACP;AAAA,EACF;AAAA,EAEA,KAAA,GAAgB;AACd,IAAA,MAAM,OAAO,IAAA,CAAK,WAAA;AAClB,IAAA,MAAM,QAAQ,IAAA,CAAK,WAAA;AACnB,IAAA,MAAM,SAAA,GAAY,eAAA,CAAgB,IAAA,CAAK,KAAA,CAAM,UAAU,CAAA;AACvD,IAAA,MAAM,UAAA,GAAa,eAAA,CAAgB,KAAA,CAAM,KAAA,CAAM,UAAU,CAAA;AACzD,IAAA,IAAI,GAAA,GAAM,CAAA,OAAA,EAAU,UAAU,CAAA,QAAA,EAAW,SAAS,CAAA,MAAA,EAAS,UAAU,CAAA,IAAA,EAAO,gBAAA,CAAiB,IAAA,CAAK,aAAa,CAAC,CAAA,CAAA;AAEhH,IAAA,MAAM,UAAoB,EAAC;AAC3B,IAAA,IAAI,KAAK,WAAA,EAAa;AACpB,MAAA,OAAA,CAAQ,IAAA,CAAK,gBAAA,CAAiB,IAAA,CAAK,WAAW,CAAC,CAAA;AAAA,IACjD;AACA,IAAA,IAAI,MAAM,WAAA,EAAa;AACrB,MAAA,OAAA,CAAQ,IAAA,CAAK,gBAAA,CAAiB,KAAA,CAAM,WAAW,CAAC,CAAA;AAAA,IAClD;AAEA,IAAA,IAAI,OAAA,CAAQ,SAAS,CAAA,EAAG;AACtB,MAAA,MAAM,QAAA,GACJ,OAAA,CAAQ,MAAA,KAAW,CAAA,GACf,OAAA,CAAQ,CAAC,CAAA,GACT,OAAA,CAAQ,GAAA,CAAI,YAAY,CAAA,CAAE,IAAA,CAAK,OAAO,CAAA;AAC5C,MAAA,GAAA,IAAO,UAAU,QAAQ,CAAA,CAAA;AAAA,IAC3B;AAEA,IAAA,OAAO,GAAA;AAAA,EACT;AACF,CAAA;AAEA,IAAM,WAAA,GAAN,MAAM,YAAA,CAEN;AAAA,EAEE,WAAA,CACWC,QACA,WAAA,EACT;AAFS,IAAA,IAAA,CAAA,KAAA,GAAAA,MAAAA;AACA,IAAA,IAAA,CAAA,WAAA,GAAA,WAAA;AAAA,EACR;AAAA,EAJH,CAAU,UAAU,IAAI,IAAA;AAAA,EAMxB,MACE,SAAA,EACuB;AACvB,IAAA,MAAM,YAAA,GAAe,SAAA,CAAU,IAAA,CAAK,KAAA,CAAM,IAAI,CAAA;AAC9C,IAAA,MAAM,YAAY,IAAA,CAAK,WAAA,GACnB,KAAK,WAAA,CAAY,GAAA,CAAI,YAAY,CAAA,GACjC,YAAA;AACJ,IAAA,OAAO,IAAI,YAAA,CAAsB,IAAA,CAAK,KAAA,EAAO,SAAS,CAAA;AAAA,EACxD;AAAA,EAEA,aAAA,CACE,OACA,EAAA,EAI6B;AAC7B,IAAA,MAAM,WAAA,GAAc,IAAI,YAAA,CAAY,KAAK,CAAA;AACzC,IAAA,MAAM,aAAA,GAAgB,EAAA;AAAA,MACpB,KAAK,KAAA,CAAM,WAAA;AAAA,MACX,KAAA,CAAM;AAAA,KACR;AACA,IAAA,OAAO,IAAI,YAAA,CAAyB,WAAA,EAAa,IAAA,EAAM,aAAa,CAAA;AAAA,EACtE;AAAA,EAEA,YAAA,CACE,OACA,EAAA,EAI2B;AAC3B,IAAA,MAAM,WAAA,GAAc,IAAI,YAAA,CAAY,KAAK,CAAA;AACzC,IAAA,MAAM,aAAA,GAAgB,EAAA;AAAA,MACpB,KAAK,KAAA,CAAM,WAAA;AAAA,MACX,KAAA,CAAM;AAAA,KACR;AACA,IAAA,OAAO,IAAI,YAAA,CAAuB,IAAA,EAAM,WAAA,EAAa,aAAa,CAAA;AAAA,EACpE;AAAA,EAEA,KAAA,GAAgB;AACd,IAAA,OAAO,wBAAA,CAAyB,IAAA,CAAK,KAAA,EAAO,IAAA,CAAK,WAAW,CAAA;AAAA,EAC9D;AAAA,EAEA,KAAA,GAAyB;AACvB,IAAA,OAAO,IAAA;AAAA,EACT;AACF,CAAA;AA0BA,IAAM,eAAN,MAEA;AAAA,EACE,CAAU,UAAU,IAAI,IAAA;AAAA,EACf,IAAA,GAAO,OAAA;AAAA,EAChB,UAAA;AAAA,EACA,YAAA;AAAA,EACA,IAAA;AAAA,EACA,WAAA;AAAA,EACA,QAAA;AAAA;AAAA,EAEA,IAAI,OAAA,GAAU;AACZ,IAAA,OAAO,KAAK,QAAA,CAAS,OAAA;AAAA,EACvB;AAAA,EACA,IAAI,OAAA,GAAU;AACZ,IAAA,OAAO,KAAK,QAAA,CAAS,OAAA;AAAA,EACvB;AAAA,EACA,IAAI,OAAA,GAAU;AACZ,IAAA,OAAO,KAAK,QAAA,CAAS,OAAA;AAAA,EACvB;AAAA,EACA,IAAI,WAAA,GAAc;AAChB,IAAA,OAAQ,KAAK,QAAA,CAAiB,WAAA;AAAA,EAChC;AAAA,EACA,YAAY,QAAA,EAAoB;AAC9B,IAAA,IAAA,CAAK,aAAa,QAAA,CAAS,UAAA;AAC3B,IAAA,IAAA,CAAK,eAAe,QAAA,CAAS,YAAA;AAC7B,IAAA,IAAA,CAAK,IAAA,GAAO,cAAc,QAAQ,CAAA;AAKlC,IAAA,IAAA,CAAK,cAAc,IAAA,CAAK,IAAA;AACxB,IAAA,IAAA,CAAK,QAAA,GAAW,QAAA;AAChB,IAAA,MAAA,CAAO,OAAO,IAAI,CAAA;AAAA,EACpB;AAAA,EAEA,MAAA,GAAgC;AAC9B,IAAA,OAAO,IAAI,YAAsB,IAAI,CAAA;AAAA,EACvC;AAAA,EAEA,aAAA,CACE,OACA,EAAA,EAI6B;AAC7B,IAAA,OAAO,IAAA,CAAK,MAAA,EAAO,CAAE,aAAA,CAAc,OAAO,EAAE,CAAA;AAAA,EAC9C;AAAA,EAEA,YAAA,CACE,OACA,EAAA,EAI2B;AAC3B,IAAA,OAAO,IAAA,CAAK,MAAA,EAAO,CAAE,YAAA,CAAa,OAAO,EAAE,CAAA;AAAA,EAC7C;AAAA,EAEA,KAAA,GAAyB;AACvB,IAAA,OAAO,IAAA,CAAK,MAAA,EAAO,CAAE,KAAA,EAAM;AAAA,EAC7B;AAAA,EAEA,KAAA,GAAgB;AACd,IAAA,OAAO,IAAA,CAAK,MAAA,EAAO,CAAE,KAAA,EAAM;AAAA,EAC7B;AAAA,EAEA,MACE,SAAA,EACuB;AACvB,IAAA,OAAO,IAAA,CAAK,MAAA,EAAO,CAAE,KAAA,CAAM,SAAS,CAAA;AAAA,EACtC;AACF,CAAA;AAEO,SAAS,sBACd,QAAA,EACoB;AACpB,EAAA,OAAO,IAAI,aAAuB,QAAQ,CAAA;AAC5C;AAEO,SAAS,iBACdC,OAAAA,EACyB;AACzB,EAAA,MAAM,EAAA,mBAAK,MAAA,CAAO,MAAA,CAAO,IAAI,CAAA;AAC7B,EAAA,KAAA,MAAWD,MAAAA,IAAS,MAAA,CAAO,MAAA,CAAOC,OAAAA,CAAO,MAAM,CAAA,EAAG;AAChD,IAAA,MAAM,GAAA,GAAM,qBAAA;AAAA,MACVD;AAAA,KACF;AACA,IAAC,EAAA,CAAqCA,MAAAA,CAAM,YAAY,CAAA,GAAI,GAAA;AAAA,EAC9D;AACA,EAAA,OAAO,MAAA,CAAO,OAAO,EAAE,CAAA;AACzB;AAEA,SAAS,cACP,QAAA,EACmB;AACnB,EAAA,MAAM,MAAiD,EAAC;AACxD,EAAA,KAAA,MAAW,UAAA,IAAc,MAAA,CAAO,IAAA,CAAK,QAAA,CAAS,OAAO,CAAA,EAElD;AACD,IAAA,MAAM,aAAA,GAAgB,QAAA,CAAS,OAAA,CAAQ,UAAU,CAAA;AACjD,IAAA,MAAM,SAAS,IAAI,gBAAA;AAAA,MACjB,QAAA,CAAS,UAAA;AAAA,MACT,UAAA;AAAA,MACA,cAAc,WAAA,CAAY;AAAA,KAI5B;AACA,IAAA,GAAA,CAAI,UAAU,CAAA,GAAI,MAAA,CAAO,MAAA,CAAO,MAAM,CAAA;AAAA,EACxC;AACA,EAAA,OAAO,MAAA,CAAO,OAAO,GAAG,CAAA;AAC1B;AAEA,SAAS,wBAAA,CACPA,MAAAA,EACA,KAAA,EACA,YAAA,GAAkC,EAAC,EAC3B;AACR,EAAA,MAAM,WAAA,GAAc,eAAA,CAAgBA,MAAAA,CAAM,UAAU,CAAA;AACpD,EAAA,MAAM,GAAA,GAAM,iBAAiB,WAAW,CAAA,CAAA;AACxC,EAAA,MAAM,UAAoB,EAAC;AAC3B,EAAA,IAAI,KAAA,EAAO,OAAA,CAAQ,IAAA,CAAK,gBAAA,CAAiB,KAAK,CAAC,CAAA;AAC/C,EAAA,OAAA,CAAQ,IAAA,CAAK,GAAG,YAAY,CAAA;AAC5B,EAAA,IAAI,OAAA,CAAQ,MAAA,KAAW,CAAA,EAAG,OAAO,GAAA;AACjC,EAAA,MAAM,QAAA,GACJ,OAAA,CAAQ,MAAA,KAAW,CAAA,GAAI,OAAA,CAAQ,CAAC,CAAA,GAAI,OAAA,CAAQ,GAAA,CAAI,YAAY,CAAA,CAAE,IAAA,CAAK,OAAO,CAAA;AAC5E,EAAA,OAAO,CAAA,EAAG,GAAG,CAAA,OAAA,EAAU,QAAQ,CAAA,CAAA;AACjC;AAgEO,IAAM,mBAAN,MAGL;AAAA,EACS,IAAA,GAAO,QAAA;AAAA,EACP,MAAA;AAAA,EACA,KAAA;AAAA;AAAA,EAEA,WAAA;AAAA,EACA,aAAA;AAAA,EAET,WAAA,CACEA,MAAAA,EACA,MAAA,EACA,aAAA,EACA;AACA,IAAA,IAAA,CAAK,KAAA,GAAQA,MAAAA;AACb,IAAA,IAAA,CAAK,MAAA,GAAS,MAAA;AACd,IAAA,IAAA,CAAK,aAAA,GAAgB,aAAA;AAAA,EACvB;AAAA,EASA,GAAG,CAAA,EAAa;AACd,IAAA,OAAO,IAAI,WAAA,CAAY;AAAA,MACrB,IAAA,EAAM,IAAA;AAAA,MACN,IAAA,EAAM,IAAA;AAAA,MACN,KAAA,EAAO,eAAe,CAAC;AAAA,KACxB,CAAA;AAAA,EACH;AAAA,EASA,GAAG,CAAA,EAAa;AACd,IAAA,OAAO,IAAI,WAAA,CAAY;AAAA,MACrB,IAAA,EAAM,IAAA;AAAA,MACN,IAAA,EAAM,IAAA;AAAA,MACN,KAAA,EAAO,eAAe,CAAC;AAAA,KACxB,CAAA;AAAA,EACH;AAAA,EASA,GAAG,CAAA,EAAa;AACd,IAAA,OAAO,IAAI,WAAA,CAAY;AAAA,MACrB,IAAA,EAAM,IAAA;AAAA,MACN,IAAA,EAAM,IAAA;AAAA,MACN,KAAA,EAAO,eAAe,CAAC;AAAA,KACxB,CAAA;AAAA,EACH;AAAA,EASA,IAAI,CAAA,EAAa;AACf,IAAA,OAAO,IAAI,WAAA,CAAY;AAAA,MACrB,IAAA,EAAM,KAAA;AAAA,MACN,IAAA,EAAM,IAAA;AAAA,MACN,KAAA,EAAO,eAAe,CAAC;AAAA,KACxB,CAAA;AAAA,EACH;AAAA,EASA,GAAG,CAAA,EAAa;AACd,IAAA,OAAO,IAAI,WAAA,CAAY;AAAA,MACrB,IAAA,EAAM,IAAA;AAAA,MACN,IAAA,EAAM,IAAA;AAAA,MACN,KAAA,EAAO,eAAe,CAAC;AAAA,KACxB,CAAA;AAAA,EACH;AAAA,EASA,IAAI,CAAA,EAAa;AACf,IAAA,OAAO,IAAI,WAAA,CAAY;AAAA,MACrB,IAAA,EAAM,KAAA;AAAA,MACN,IAAA,EAAM,IAAA;AAAA,MACN,KAAA,EAAO,eAAe,CAAC;AAAA,KACxB,CAAA;AAAA,EACH;AACF;AA2FO,SAAS,QACd,KAAA,EACyB;AACzB,EAAA,OAAO,EAAE,IAAA,EAAM,SAAA,EAAW,KAAA,EAAM;AAClC;AAGA,SAAS,eAAe,GAAA,EAA2C;AACjE,EAAA,IAAK,IAAyB,IAAA,KAAS,SAAA;AACrC,IAAA,OAAO,GAAA;AACT,EAAA,IACE,OAAO,QAAQ,QAAA,IACf,GAAA,IAAO,QACP,MAAA,IAAW,GAAA,IACV,GAAA,CAAY,IAAA,KAAS,QAAA,EACtB;AACA,IAAA,OAAO,GAAA;AAAA,EACT;AACA,EAAA,OAAO,QAAQ,GAAmB,CAAA;AACpC;AAkCO,IAAM,WAAA,GAAN,MAAM,YAAA,CAAyC;AAAA,EACpD,YAAqB,IAAA,EAA8B;AAA9B,IAAA,IAAA,CAAA,IAAA,GAAA,IAAA;AAAA,EAA+B;AAAA,EAEpD,IAAI,KAAA,EAA+C;AACjD,IAAA,OAAO,IAAI,YAAA,CAAY,EAAE,IAAA,EAAM,KAAA,EAAO,OAAA,EAAS,CAAC,IAAA,CAAK,IAAA,EAAM,KAAA,CAAM,IAAI,CAAA,EAAG,CAAA;AAAA,EAC1E;AAAA,EAEA,GAAG,KAAA,EAA+C;AAChD,IAAA,OAAO,IAAI,YAAA,CAAY,EAAE,IAAA,EAAM,IAAA,EAAM,OAAA,EAAS,CAAC,IAAA,CAAK,IAAA,EAAM,KAAA,CAAM,IAAI,CAAA,EAAG,CAAA;AAAA,EACzE;AAAA,EAEA,GAAA,GAA0B;AACxB,IAAA,OAAO,IAAI,aAAY,EAAE,IAAA,EAAM,OAAO,MAAA,EAAQ,IAAA,CAAK,MAAM,CAAA;AAAA,EAC3D;AACF;AAEO,SAAS,IACd,MAAA,EACgB;AAChB,EAAA,OAAO,IAAI,YAAY,EAAE,IAAA,EAAM,OAAO,MAAA,EAAQ,MAAA,CAAO,MAAM,CAAA;AAC7D;AAEO,SAAS,OACX,OAAA,EACa;AAChB,EAAA,OAAO,IAAI,WAAA,CAAY;AAAA,IACrB,IAAA,EAAM,KAAA;AAAA,IACN,OAAA,EAAS,OAAA,CAAQ,GAAA,CAAI,CAAA,CAAA,KAAK,EAAE,IAAI;AAAA,GAKjC,CAAA;AACH;AAEO,SAAS,MACX,OAAA,EACa;AAChB,EAAA,OAAO,IAAI,WAAA,CAAY;AAAA,IACrB,IAAA,EAAM,IAAA;AAAA,IACN,OAAA,EAAS,OAAA,CAAQ,GAAA,CAAI,CAAA,CAAA,KAAK,EAAE,IAAI;AAAA,GAKjC,CAAA;AACH;AAEA,SAAS,gBAAA,CACP,MACA,UAAA,EACQ;AACR,EAAA,MAAM,IAAA,GAAO,IAAA,YAAgB,WAAA,GAAc,IAAA,CAAK,IAAA,GAAO,IAAA;AACvD,EAAA,QAAQ,KAAK,IAAA;AAAM,IACjB,KAAK,IAAA;AACH,MAAA,OAAO,CAAA,EAAG,cAAA,CAAe,IAAA,CAAK,IAAgB,CAAC,CAAA,GAAA,EAAM,cAAA,CAAe,IAAA,CAAK,KAAiB,CAAC,CAAA,CAAA;AAAA,IAC7F,KAAK,IAAA;AACH,MAAA,OAAO,CAAA,EAAG,cAAA,CAAe,IAAA,CAAK,IAAgB,CAAC,CAAA,IAAA,EAAO,cAAA,CAAe,IAAA,CAAK,KAAiB,CAAC,CAAA,CAAA;AAAA,IAC9F,KAAK,IAAA;AACH,MAAA,OAAO,CAAA,EAAG,cAAA,CAAe,IAAA,CAAK,IAAgB,CAAC,CAAA,GAAA,EAAM,cAAA,CAAe,IAAA,CAAK,KAAiB,CAAC,CAAA,CAAA;AAAA,IAC7F,KAAK,KAAA;AACH,MAAA,OAAO,CAAA,EAAG,cAAA,CAAe,IAAA,CAAK,IAAgB,CAAC,CAAA,IAAA,EAAO,cAAA,CAAe,IAAA,CAAK,KAAiB,CAAC,CAAA,CAAA;AAAA,IAC9F,KAAK,IAAA;AACH,MAAA,OAAO,CAAA,EAAG,cAAA,CAAe,IAAA,CAAK,IAAgB,CAAC,CAAA,GAAA,EAAM,cAAA,CAAe,IAAA,CAAK,KAAiB,CAAC,CAAA,CAAA;AAAA,IAC7F,KAAK,KAAA;AACH,MAAA,OAAO,CAAA,EAAG,cAAA,CAAe,IAAA,CAAK,IAAgB,CAAC,CAAA,IAAA,EAAO,cAAA,CAAe,IAAA,CAAK,KAAiB,CAAC,CAAA,CAAA;AAAA,IAC9F,KAAK,KAAA;AACH,MAAA,OAAO,IAAA,CAAK,OAAA,CACT,GAAA,CAAI,CAAA,CAAA,KAAK,gBAAA,CAAiB,CAAa,CAAC,CAAA,CACxC,GAAA,CAAI,YAAY,CAAA,CAChB,KAAK,OAAO,CAAA;AAAA,IACjB,KAAK,IAAA;AACH,MAAA,OAAO,IAAA,CAAK,OAAA,CACT,GAAA,CAAI,CAAA,CAAA,KAAK,gBAAA,CAAiB,CAAa,CAAC,CAAA,CACxC,GAAA,CAAI,YAAY,CAAA,CAChB,KAAK,MAAM,CAAA;AAAA,IAChB,KAAK,KAAA;AACH,MAAA,OAAO,OAAO,YAAA,CAAa,gBAAA,CAAiB,KAAK,MAAkB,CAAC,CAAC,CAAA,CAAA;AAAA;AAE3E;AAEA,SAAS,aAAa,GAAA,EAAqB;AACzC,EAAA,OAAO,IAAI,GAAG,CAAA,CAAA,CAAA;AAChB;AAEA,SAAS,cAAA,CACP,MACA,UAAA,EACQ;AACR,EAAA,IAAI,aAAA,CAAc,IAAI,CAAA,EAAG;AACvB,IAAA,OAAO,iBAAA,CAAkB,KAAK,KAAK,CAAA;AAAA,EACrC;AACA,EAAA,MAAMA,MAAAA,GAAsB,IAAA,CAAK,KAAA;AACjC,EAAA,OAAO,CAAA,EAAG,gBAAgBA,MAAK,CAAC,IAAI,eAAA,CAAgB,IAAA,CAAK,MAAM,CAAC,CAAA,CAAA;AAClE;AAEA,SAAS,kBAAkB,KAAA,EAAwB;AACjD,EAAA,IAAI,KAAA,KAAU,IAAA,IAAQ,KAAA,KAAU,MAAA,EAAW;AACzC,IAAA,OAAO,MAAA;AAAA,EACT;AACA,EAAA,IAAI,KAAA,YAAiB,QAAA,IAAY,KAAA,YAAiB,YAAA,EAAc;AAE9D,IAAA,OAAO,CAAA,EAAA,EAAK,KAAA,CAAM,WAAA,EAAa,CAAA,CAAA;AAAA,EACjC;AACA,EAAA,IAAI,iBAAiB,SAAA,EAAW;AAC9B,IAAA,OAAO,CAAA,CAAA,EAAI,KAAA,CAAM,WAAA,EAAa,CAAA,CAAA,CAAA;AAAA,EAChC;AACA,EAAA,QAAQ,OAAO,KAAA;AAAO,IACpB,KAAK,QAAA;AAAA,IACL,KAAK,QAAA;AACH,MAAA,OAAO,OAAO,KAAK,CAAA;AAAA,IACrB,KAAK,SAAA;AACH,MAAA,OAAO,QAAQ,MAAA,GAAS,OAAA;AAAA,IAC1B,KAAK,QAAA;AACH,MAAA,OAAO,CAAA,CAAA,EAAI,KAAA,CAAM,OAAA,CAAQ,IAAA,EAAM,IAAI,CAAC,CAAA,CAAA,CAAA;AAAA,IACtC;AAEE,MAAA,OAAO,CAAA,CAAA,EAAI,KAAK,SAAA,CAAU,KAAK,EAAE,OAAA,CAAQ,IAAA,EAAM,IAAI,CAAC,CAAA,CAAA,CAAA;AAAA;AAE1D;AAEA,SAAS,gBAAgB,IAAA,EAAsB;AAC7C,EAAA,OAAO,CAAA,CAAA,EAAI,IAAA,CAAK,OAAA,CAAQ,IAAA,EAAM,IAAI,CAAC,CAAA,CAAA,CAAA;AACrC;AAEA,SAAS,cACP,IAAA,EAC2C;AAC3C,EAAA,OAAQ,KAA4B,IAAA,KAAS,SAAA;AAC/C;AAKO,SAAS,mBAAA,CACd,MACA,GAAA,EACS;AACT,EAAA,OAAO,YAAA,CAAa,IAAA,CAAK,IAAA,EAAM,GAAG,CAAA;AACpC;AAEA,SAAS,YAAA,CACP,MACA,GAAA,EACS;AACT,EAAA,QAAQ,KAAK,IAAA;AAAM,IACjB,KAAK,IAAA;AACH,MAAA,OAAO,YAAA,CAAa,KAAK,IAAA,EAAM,GAAG,MAAM,YAAA,CAAa,IAAA,CAAK,OAAO,GAAG,CAAA;AAAA,IACtE,KAAK,IAAA;AACH,MAAA,OAAO,YAAA,CAAa,KAAK,IAAA,EAAM,GAAG,MAAM,YAAA,CAAa,IAAA,CAAK,OAAO,GAAG,CAAA;AAAA,IACtE,KAAK,IAAA;AACH,MAAA,OAAO,YAAA,CAAa,KAAK,IAAA,EAAM,GAAG,IAAI,YAAA,CAAa,IAAA,CAAK,OAAO,GAAG,CAAA;AAAA,IACpE,KAAK,KAAA;AACH,MAAA,OAAO,YAAA,CAAa,KAAK,IAAA,EAAM,GAAG,KAAK,YAAA,CAAa,IAAA,CAAK,OAAO,GAAG,CAAA;AAAA,IACrE,KAAK,IAAA;AACH,MAAA,OAAO,YAAA,CAAa,KAAK,IAAA,EAAM,GAAG,IAAI,YAAA,CAAa,IAAA,CAAK,OAAO,GAAG,CAAA;AAAA,IACpE,KAAK,KAAA;AACH,MAAA,OAAO,YAAA,CAAa,KAAK,IAAA,EAAM,GAAG,KAAK,YAAA,CAAa,IAAA,CAAK,OAAO,GAAG,CAAA;AAAA,IACrE,KAAK,KAAA;AACH,MAAA,OAAO,KAAK,OAAA,CAAQ,KAAA,CAAM,OAAK,YAAA,CAAa,CAAA,EAAG,GAAG,CAAC,CAAA;AAAA,IACrD,KAAK,IAAA;AACH,MAAA,OAAO,KAAK,OAAA,CAAQ,IAAA,CAAK,OAAK,YAAA,CAAa,CAAA,EAAG,GAAG,CAAC,CAAA;AAAA,IACpD,KAAK,KAAA;AACH,MAAA,OAAO,CAAC,YAAA,CAAa,IAAA,CAAK,MAAA,EAAQ,GAAG,CAAA;AAAA;AAE3C;AAEA,SAAS,YAAA,CACP,MACA,GAAA,EACK;AACL,EAAA,IAAI,aAAA,CAAc,IAAI,CAAA,EAAG;AACvB,IAAA,OAAO,iBAAA,CAAkB,KAAK,KAAK,CAAA;AAAA,EACrC;AACA,EAAA,OAAO,iBAAA,CAAkB,GAAA,CAAI,IAAA,CAAK,MAAM,CAAC,CAAA;AAC3C;AAUA,SAAS,sBAAsB,KAAA,EAA8C;AAC3E,EAAA,OACE,CAAC,CAAC,KAAA,IACF,OAAO,UAAU,QAAA,IACjB,OAAQ,MAAoC,WAAA,KAAgB,UAAA;AAEhE;AAKA,SAAS,gBAAgB,KAAA,EAAwC;AAC/D,EAAA,IAAI,CAAC,KAAA,IAAS,OAAO,KAAA,KAAU,UAAU,OAAO,KAAA;AAEhD,EAAA,IAAI,KAAA,YAAiB,WAAW,OAAO,IAAA;AAEvC,EAAA,MAAM,MAAA,GAAU,MACd,uCACF,CAAA;AACA,EAAA,OAAO,OAAO,MAAA,KAAW,QAAA;AAC3B;AAGO,SAAS,kBAAkB,KAAA,EAAiB;AAEjD,EAAA,IAAI,qBAAA,CAAsB,KAAK,CAAA,EAAG;AAChC,IAAA,OAAO,MAAM,WAAA,EAAY;AAAA,EAC3B;AACA,EAAA,IAAI,eAAA,CAAgB,KAAK,CAAA,EAAG;AAC1B,IAAA,OAAO,KAAA,CAAM,qCAAA;AAAA,EACf;AACA,EAAA,OAAO,KAAA;AACT;AAKO,SAAS,kBAAkB,KAAA,EAAoB;AACpD,EAAA,IAAI,KAAA,CAAM,KAAA,EAAO,OAAO,KAAA,CAAM,KAAA,CAAM,IAAA;AACpC,EAAA,IAAI,KAAA,CAAM,IAAA,EAAM,OAAO,KAAA,CAAM,IAAA;AAC7B,EAAA,IAAI,KAAA,CAAM,WAAA,EAAa,OAAO,KAAA,CAAM,YAAY,KAAA,CAAM,IAAA;AACtD,EAAA,MAAM,IAAI,MAAM,sCAAsC,CAAA;AACxD;AAKO,SAAS,qBAAqB,KAAA,EAAoB;AACvD,EAAA,IAAI,KAAA,CAAM,KAAA,EAAO,OAAO,KAAA,CAAM,KAAA,CAAM,YAAA;AACpC,EAAA,IAAI,KAAA,CAAM,YAAA,EAAc,OAAO,KAAA,CAAM,YAAA;AACrC,EAAA,IAAI,KAAA,CAAM,WAAA,EAAa,OAAO,KAAA,CAAM,YAAY,KAAA,CAAM,YAAA;AACtD,EAAA,MAAM,IAAI,MAAM,yCAAyC,CAAA;AAC3D;AAKO,SAAS,oBAAoB,KAAA,EAA0C;AAC5E,EAAA,IAAI,KAAA,CAAM,WAAA,EAAa,OAAO,KAAA,CAAM,WAAA;AACpC,EAAA,OAAO,MAAA;AACT;;;ACp4BO,SAAS,GAAA,CACd,GACAE,EAAAA,EACmB;AACnB,EAAA,OAAO,EAAE,GAAG,CAAA,EAAG,GAAGA,EAAAA,EAAE;AACtB;;;ACiHO,IAAM,cAAN,MAEP;AAAA;AAAA;AAAA;AAAA;AAAA,EAKW,IAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,aAAA;AAAA,EAET,YAAY,aAAA,EAA8B;AACxC,IAAA,IAAA,CAAK,aAAA,GAAgB,aAAA;AAAA,EACvB;AAAA,EAEA,QAAA,GAAuC;AACrC,IAAA,OAAO,IAAI,cAAc,IAAI,CAAA;AAAA,EAC/B;AAAA,EAEA,SAAA,CAAU,QAAsB,KAAA,EAAmB;AACjD,IAAA,MAAM,SAAA,GAAa,IAAA,CAAK,SAAA,GAAY,aAAA,CAAc,cAAA;AAAA,MAChD,IAAA,CAAK;AAAA,KACP;AACA,IAAA,SAAA,CAAU,QAAQ,KAAK,CAAA;AAAA,EACzB;AAAA,EAEA,YAAY,MAAA,EAA4B;AACtC,IAAA,MAAM,WAAA,GAAe,IAAA,CAAK,WAAA,GAAc,aAAA,CAAc,gBAAA;AAAA,MACpD,IAAA,CAAK;AAAA,KACP;AACA,IAAA,OAAO,YAAY,MAAM,CAAA;AAAA,EAC3B;AACF;AAqMO,IAAM,SAAA,GAAN,cACG,WAAA,CAQV;AAAA,EACE,WAAA,GAAc;AACZ,IAAA,KAAA,CAAM,cAAc,EAAE,CAAA;AAAA,EACxB;AAAA,EAKA,KAAA,CACE,YAAwB,OAAA,EAC6C;AACrE,IAAA,OAAO,IAAI,eAAA;AAAA,MACT,IAAA;AAAA,MACA,GAAA,CAAI,eAAA,EAAiB,EAAE,SAAA,EAAW,WAAW;AAAA,KAC/C;AAAA,EACF;AAAA,EACA,MAAA,GAAuE;AACrE,IAAA,OAAO,IAAI,gBAAgB,IAAA,EAAM,GAAA,CAAI,iBAAiB,EAAE,QAAA,EAAU,IAAA,EAAM,CAAC,CAAA;AAAA,EAC3E;AAAA,EACA,UAAA,GAEE;AACA,IAAA,OAAO,IAAI,eAAA;AAAA,MACT,IAAA;AAAA,MACA,GAAA,CAAI,eAAA,EAAiB,EAAE,YAAA,EAAc,MAAM;AAAA,KAC7C;AAAA,EACF;AAAA,EACA,OAAA,GAEE;AACA,IAAA,OAAO,IAAI,eAAA;AAAA,MACT,IAAA;AAAA,MACA,GAAA,CAAI,eAAA,EAAiB,EAAE,eAAA,EAAiB,MAAM;AAAA,KAChD;AAAA,EACF;AAAA,EACA,QACE,KAAA,EACoE;AACpE,IAAA,OAAO,IAAI,eAAA;AAAA,MACT,IAAA;AAAA,MACA,GAAA,CAAI,eAAA,EAAiB,EAAE,YAAA,EAAc,OAAO;AAAA,KAC9C;AAAA,EACF;AAAA,EACA,KACE,IAAA,EAC0D;AAC1D,IAAA,OAAO,IAAI,gBAAgB,IAAA,EAAM,GAAA,CAAI,iBAAiB,EAAE,IAAA,EAAM,CAAC,CAAA;AAAA,EACjE;AACF;AAEO,IAAM,UAAA,GAAN,cACG,WAAA,CAQV;AAAA,EACE,WAAA,GAAc;AACZ,IAAA,KAAA,CAAM,cAAc,GAAG,CAAA;AAAA,EACzB;AAAA,EAKA,KAAA,CACE,YAAwB,OAAA,EAC8C;AACtE,IAAA,OAAO,IAAI,gBAAA;AAAA,MACT,IAAA;AAAA,MACA,GAAA,CAAI,eAAA,EAAiB,EAAE,SAAA,EAAW,WAAW;AAAA,KAC/C;AAAA,EACF;AAAA,EACA,MAAA,GAAwE;AACtE,IAAA,OAAO,IAAI,iBAAiB,IAAA,EAAM,GAAA,CAAI,iBAAiB,EAAE,QAAA,EAAU,IAAA,EAAM,CAAC,CAAA;AAAA,EAC5E;AAAA,EACA,UAAA,GAEE;AACA,IAAA,OAAO,IAAI,gBAAA;AAAA,MACT,IAAA;AAAA,MACA,GAAA,CAAI,eAAA,EAAiB,EAAE,YAAA,EAAc,MAAM;AAAA,KAC7C;AAAA,EACF;AAAA,EACA,OAAA,GAEE;AACA,IAAA,OAAO,IAAI,gBAAA;AAAA,MACT,IAAA;AAAA,MACA,GAAA,CAAI,eAAA,EAAiB,EAAE,eAAA,EAAiB,MAAM;AAAA,KAChD;AAAA,EACF;AAAA,EACA,QACE,KAAA,EACqE;AACrE,IAAA,OAAO,IAAI,gBAAA;AAAA,MACT,IAAA;AAAA,MACA,GAAA,CAAI,eAAA,EAAiB,EAAE,YAAA,EAAc,OAAO;AAAA,KAC9C;AAAA,EACF;AAAA,EACA,KACE,IAAA,EAC2D;AAC3D,IAAA,OAAO,IAAI,iBAAiB,IAAA,EAAM,GAAA,CAAI,iBAAiB,EAAE,IAAA,EAAM,CAAC,CAAA;AAAA,EAClE;AACF;AAEO,IAAM,UAAA,GAAN,cACG,WAAA,CAQV;AAAA,EACE,WAAA,GAAc;AACZ,IAAA,KAAA,CAAM,cAAc,GAAG,CAAA;AAAA,EACzB;AAAA,EAKA,KAAA,CACE,YAAwB,OAAA,EAC8C;AACtE,IAAA,OAAO,IAAI,gBAAA;AAAA,MACT,IAAA;AAAA,MACA,GAAA,CAAI,eAAA,EAAiB,EAAE,SAAA,EAAW,WAAW;AAAA,KAC/C;AAAA,EACF;AAAA,EACA,MAAA,GAAwE;AACtE,IAAA,OAAO,IAAI,iBAAiB,IAAA,EAAM,GAAA,CAAI,iBAAiB,EAAE,QAAA,EAAU,IAAA,EAAM,CAAC,CAAA;AAAA,EAC5E;AAAA,EACA,UAAA,GAEE;AACA,IAAA,OAAO,IAAI,gBAAA;AAAA,MACT,IAAA;AAAA,MACA,GAAA,CAAI,eAAA,EAAiB,EAAE,YAAA,EAAc,MAAM;AAAA,KAC7C;AAAA,EACF;AAAA,EACA,OAAA,GAEE;AACA,IAAA,OAAO,IAAI,gBAAA;AAAA,MACT,IAAA;AAAA,MACA,GAAA,CAAI,eAAA,EAAiB,EAAE,eAAA,EAAiB,MAAM;AAAA,KAChD;AAAA,EACF;AAAA,EACA,QACE,KAAA,EACqE;AACrE,IAAA,OAAO,IAAI,gBAAA;AAAA,MACT,IAAA;AAAA,MACA,GAAA,CAAI,eAAA,EAAiB,EAAE,YAAA,EAAc,OAAO;AAAA,KAC9C;AAAA,EACF;AAAA,EACA,KACE,IAAA,EAC2D;AAC3D,IAAA,OAAO,IAAI,iBAAiB,IAAA,EAAM,GAAA,CAAI,iBAAiB,EAAE,IAAA,EAAM,CAAC,CAAA;AAAA,EAClE;AACF;AAEO,IAAM,UAAA,GAAN,cACG,WAAA,CAQV;AAAA,EACE,WAAA,GAAc;AACZ,IAAA,KAAA,CAAM,cAAc,GAAG,CAAA;AAAA,EACzB;AAAA,EAKA,KAAA,CACE,YAAwB,OAAA,EAC8C;AACtE,IAAA,OAAO,IAAI,gBAAA;AAAA,MACT,IAAA;AAAA,MACA,GAAA,CAAI,eAAA,EAAiB,EAAE,SAAA,EAAW,WAAW;AAAA,KAC/C;AAAA,EACF;AAAA,EACA,MAAA,GAAwE;AACtE,IAAA,OAAO,IAAI,iBAAiB,IAAA,EAAM,GAAA,CAAI,iBAAiB,EAAE,QAAA,EAAU,IAAA,EAAM,CAAC,CAAA;AAAA,EAC5E;AAAA,EACA,UAAA,GAEE;AACA,IAAA,OAAO,IAAI,gBAAA;AAAA,MACT,IAAA;AAAA,MACA,GAAA,CAAI,eAAA,EAAiB,EAAE,YAAA,EAAc,MAAM;AAAA,KAC7C;AAAA,EACF;AAAA,EACA,OAAA,GAEE;AACA,IAAA,OAAO,IAAI,gBAAA;AAAA,MACT,IAAA;AAAA,MACA,GAAA,CAAI,eAAA,EAAiB,EAAE,eAAA,EAAiB,MAAM;AAAA,KAChD;AAAA,EACF;AAAA,EACA,QACE,KAAA,EACqE;AACrE,IAAA,OAAO,IAAI,gBAAA;AAAA,MACT,IAAA;AAAA,MACA,GAAA,CAAI,eAAA,EAAiB,EAAE,YAAA,EAAc,OAAO;AAAA,KAC9C;AAAA,EACF;AAAA,EACA,KACE,IAAA,EAC2D;AAC3D,IAAA,OAAO,IAAI,iBAAiB,IAAA,EAAM,GAAA,CAAI,iBAAiB,EAAE,IAAA,EAAM,CAAC,CAAA;AAAA,EAClE;AACF;AAEO,IAAM,WAAA,GAAN,cACG,WAAA,CAQV;AAAA,EACE,WAAA,GAAc;AACZ,IAAA,KAAA,CAAM,cAAc,IAAI,CAAA;AAAA,EAC1B;AAAA,EAKA,KAAA,CACE,YAAwB,OAAA,EAC+C;AACvE,IAAA,OAAO,IAAI,iBAAA;AAAA,MACT,IAAA;AAAA,MACA,GAAA,CAAI,eAAA,EAAiB,EAAE,SAAA,EAAW,WAAW;AAAA,KAC/C;AAAA,EACF;AAAA,EACA,MAAA,GAAyE;AACvE,IAAA,OAAO,IAAI,iBAAA;AAAA,MACT,IAAA;AAAA,MACA,GAAA,CAAI,eAAA,EAAiB,EAAE,QAAA,EAAU,MAAM;AAAA,KACzC;AAAA,EACF;AAAA,EACA,UAAA,GAEE;AACA,IAAA,OAAO,IAAI,iBAAA;AAAA,MACT,IAAA;AAAA,MACA,GAAA,CAAI,eAAA,EAAiB,EAAE,YAAA,EAAc,MAAM;AAAA,KAC7C;AAAA,EACF;AAAA,EACA,OAAA,GAEE;AACA,IAAA,OAAO,IAAI,iBAAA;AAAA,MACT,IAAA;AAAA,MACA,GAAA,CAAI,eAAA,EAAiB,EAAE,eAAA,EAAiB,MAAM;AAAA,KAChD;AAAA,EACF;AAAA,EACA,QACE,KAAA,EACsE;AACtE,IAAA,OAAO,IAAI,iBAAA;AAAA,MACT,IAAA;AAAA,MACA,GAAA,CAAI,eAAA,EAAiB,EAAE,YAAA,EAAc,OAAO;AAAA,KAC9C;AAAA,EACF;AAAA,EACA,KACE,IAAA,EAC4D;AAC5D,IAAA,OAAO,IAAI,kBAAkB,IAAA,EAAM,GAAA,CAAI,iBAAiB,EAAE,IAAA,EAAM,CAAC,CAAA;AAAA,EACnE;AACF;AAEO,IAAM,WAAA,GAAN,cACG,WAAA,CAQV;AAAA,EACE,WAAA,GAAc;AACZ,IAAA,KAAA,CAAM,cAAc,IAAI,CAAA;AAAA,EAC1B;AAAA,EAKA,KAAA,CACE,YAAwB,OAAA,EAC+C;AACvE,IAAA,OAAO,IAAI,iBAAA;AAAA,MACT,IAAA;AAAA,MACA,GAAA,CAAI,eAAA,EAAiB,EAAE,SAAA,EAAW,WAAW;AAAA,KAC/C;AAAA,EACF;AAAA,EACA,MAAA,GAAyE;AACvE,IAAA,OAAO,IAAI,iBAAA;AAAA,MACT,IAAA;AAAA,MACA,GAAA,CAAI,eAAA,EAAiB,EAAE,QAAA,EAAU,MAAM;AAAA,KACzC;AAAA,EACF;AAAA,EACA,UAAA,GAEE;AACA,IAAA,OAAO,IAAI,iBAAA;AAAA,MACT,IAAA;AAAA,MACA,GAAA,CAAI,eAAA,EAAiB,EAAE,YAAA,EAAc,MAAM;AAAA,KAC7C;AAAA,EACF;AAAA,EACA,OAAA,GAEE;AACA,IAAA,OAAO,IAAI,iBAAA;AAAA,MACT,IAAA;AAAA,MACA,GAAA,CAAI,eAAA,EAAiB,EAAE,eAAA,EAAiB,MAAM;AAAA,KAChD;AAAA,EACF;AAAA,EACA,QACE,KAAA,EACsE;AACtE,IAAA,OAAO,IAAI,iBAAA;AAAA,MACT,IAAA;AAAA,MACA,GAAA,CAAI,eAAA,EAAiB,EAAE,YAAA,EAAc,OAAO;AAAA,KAC9C;AAAA,EACF;AAAA,EACA,KACE,IAAA,EAC4D;AAC5D,IAAA,OAAO,IAAI,kBAAkB,IAAA,EAAM,GAAA,CAAI,iBAAiB,EAAE,IAAA,EAAM,CAAC,CAAA;AAAA,EACnE;AACF;AAEO,IAAM,SAAA,GAAN,cACG,WAAA,CAQV;AAAA,EACE,WAAA,GAAc;AACZ,IAAA,KAAA,CAAM,cAAc,EAAE,CAAA;AAAA,EACxB;AAAA,EAKA,KAAA,CACE,YAAwB,OAAA,EAC6C;AACrE,IAAA,OAAO,IAAI,eAAA;AAAA,MACT,IAAA;AAAA,MACA,GAAA,CAAI,eAAA,EAAiB,EAAE,SAAA,EAAW,WAAW;AAAA,KAC/C;AAAA,EACF;AAAA,EACA,MAAA,GAAuE;AACrE,IAAA,OAAO,IAAI,gBAAgB,IAAA,EAAM,GAAA,CAAI,iBAAiB,EAAE,QAAA,EAAU,IAAA,EAAM,CAAC,CAAA;AAAA,EAC3E;AAAA,EACA,UAAA,GAEE;AACA,IAAA,OAAO,IAAI,eAAA;AAAA,MACT,IAAA;AAAA,MACA,GAAA,CAAI,eAAA,EAAiB,EAAE,YAAA,EAAc,MAAM;AAAA,KAC7C;AAAA,EACF;AAAA,EACA,OAAA,GAEE;AACA,IAAA,OAAO,IAAI,eAAA;AAAA,MACT,IAAA;AAAA,MACA,GAAA,CAAI,eAAA,EAAiB,EAAE,eAAA,EAAiB,MAAM;AAAA,KAChD;AAAA,EACF;AAAA,EACA,QACE,KAAA,EACoE;AACpE,IAAA,OAAO,IAAI,eAAA;AAAA,MACT,IAAA;AAAA,MACA,GAAA,CAAI,eAAA,EAAiB,EAAE,YAAA,EAAc,OAAO;AAAA,KAC9C;AAAA,EACF;AAAA,EACA,KACE,IAAA,EAC0D;AAC1D,IAAA,OAAO,IAAI,gBAAgB,IAAA,EAAM,GAAA,CAAI,iBAAiB,EAAE,IAAA,EAAM,CAAC,CAAA;AAAA,EACjE;AACF;AAEO,IAAM,UAAA,GAAN,cACG,WAAA,CAQV;AAAA,EACE,WAAA,GAAc;AACZ,IAAA,KAAA,CAAM,cAAc,GAAG,CAAA;AAAA,EACzB;AAAA,EAKA,KAAA,CACE,YAAwB,OAAA,EAC8C;AACtE,IAAA,OAAO,IAAI,gBAAA;AAAA,MACT,IAAA;AAAA,MACA,GAAA,CAAI,eAAA,EAAiB,EAAE,SAAA,EAAW,WAAW;AAAA,KAC/C;AAAA,EACF;AAAA,EACA,MAAA,GAAwE;AACtE,IAAA,OAAO,IAAI,iBAAiB,IAAA,EAAM,GAAA,CAAI,iBAAiB,EAAE,QAAA,EAAU,IAAA,EAAM,CAAC,CAAA;AAAA,EAC5E;AAAA,EACA,UAAA,GAEE;AACA,IAAA,OAAO,IAAI,gBAAA;AAAA,MACT,IAAA;AAAA,MACA,GAAA,CAAI,eAAA,EAAiB,EAAE,YAAA,EAAc,MAAM;AAAA,KAC7C;AAAA,EACF;AAAA,EACA,OAAA,GAEE;AACA,IAAA,OAAO,IAAI,gBAAA;AAAA,MACT,IAAA;AAAA,MACA,GAAA,CAAI,eAAA,EAAiB,EAAE,eAAA,EAAiB,MAAM;AAAA,KAChD;AAAA,EACF;AAAA,EACA,QACE,KAAA,EACqE;AACrE,IAAA,OAAO,IAAI,gBAAA;AAAA,MACT,IAAA;AAAA,MACA,GAAA,CAAI,eAAA,EAAiB,EAAE,YAAA,EAAc,OAAO;AAAA,KAC9C;AAAA,EACF;AAAA,EACA,KACE,IAAA,EAC2D;AAC3D,IAAA,OAAO,IAAI,iBAAiB,IAAA,EAAM,GAAA,CAAI,iBAAiB,EAAE,IAAA,EAAM,CAAC,CAAA;AAAA,EAClE;AACF;AAEO,IAAM,UAAA,GAAN,cACG,WAAA,CASV;AAAA,EACE,WAAA,GAAc;AACZ,IAAA,KAAA,CAAM,cAAc,GAAG,CAAA;AAAA,EACzB;AAAA,EAKA,KAAA,CACE,YAAwB,OAAA,EAC8C;AACtE,IAAA,OAAO,IAAI,gBAAA;AAAA,MACT,IAAA;AAAA,MACA,GAAA,CAAI,eAAA,EAAiB,EAAE,SAAA,EAAW,WAAW;AAAA,KAC/C;AAAA,EACF;AAAA,EACA,MAAA,GAAwE;AACtE,IAAA,OAAO,IAAI,iBAAiB,IAAA,EAAM,GAAA,CAAI,iBAAiB,EAAE,QAAA,EAAU,IAAA,EAAM,CAAC,CAAA;AAAA,EAC5E;AAAA,EACA,UAAA,GAEE;AACA,IAAA,OAAO,IAAI,gBAAA;AAAA,MACT,IAAA;AAAA,MACA,GAAA,CAAI,eAAA,EAAiB,EAAE,YAAA,EAAc,MAAM;AAAA,KAC7C;AAAA,EACF;AAAA,EACA,OAAA,GAEE;AACA,IAAA,OAAO,IAAI,gBAAA;AAAA,MACT,IAAA;AAAA,MACA,GAAA,CAAI,eAAA,EAAiB,EAAE,eAAA,EAAiB,MAAM;AAAA,KAChD;AAAA,EACF;AAAA,EACA,QACE,KAAA,EACqE;AACrE,IAAA,OAAO,IAAI,gBAAA;AAAA,MACT,IAAA;AAAA,MACA,GAAA,CAAI,eAAA,EAAiB,EAAE,YAAA,EAAc,OAAO;AAAA,KAC9C;AAAA,EACF;AAAA,EACA,KACE,IAAA,EAC2D;AAC3D,IAAA,OAAO,IAAI,iBAAiB,IAAA,EAAM,GAAA,CAAI,iBAAiB,EAAE,IAAA,EAAM,CAAC,CAAA;AAAA,EAClE;AACF;AAEO,IAAM,UAAA,GAAN,cACG,WAAA,CAQV;AAAA,EACE,WAAA,GAAc;AACZ,IAAA,KAAA,CAAM,cAAc,GAAG,CAAA;AAAA,EACzB;AAAA,EAKA,KAAA,CACE,YAAwB,OAAA,EAC8C;AACtE,IAAA,OAAO,IAAI,gBAAA;AAAA,MACT,IAAA;AAAA,MACA,GAAA,CAAI,eAAA,EAAiB,EAAE,SAAA,EAAW,WAAW;AAAA,KAC/C;AAAA,EACF;AAAA,EACA,MAAA,GAAwE;AACtE,IAAA,OAAO,IAAI,iBAAiB,IAAA,EAAM,GAAA,CAAI,iBAAiB,EAAE,QAAA,EAAU,IAAA,EAAM,CAAC,CAAA;AAAA,EAC5E;AAAA,EACA,UAAA,GAEE;AACA,IAAA,OAAO,IAAI,gBAAA;AAAA,MACT,IAAA;AAAA,MACA,GAAA,CAAI,eAAA,EAAiB,EAAE,YAAA,EAAc,MAAM;AAAA,KAC7C;AAAA,EACF;AAAA,EACA,OAAA,GAEE;AACA,IAAA,OAAO,IAAI,gBAAA;AAAA,MACT,IAAA;AAAA,MACA,GAAA,CAAI,eAAA,EAAiB,EAAE,eAAA,EAAiB,MAAM;AAAA,KAChD;AAAA,EACF;AAAA,EACA,QACE,KAAA,EACqE;AACrE,IAAA,OAAO,IAAI,gBAAA;AAAA,MACT,IAAA;AAAA,MACA,GAAA,CAAI,eAAA,EAAiB,EAAE,YAAA,EAAc,OAAO;AAAA,KAC9C;AAAA,EACF;AAAA,EACA,KACE,IAAA,EAC2D;AAC3D,IAAA,OAAO,IAAI,iBAAiB,IAAA,EAAM,GAAA,CAAI,iBAAiB,EAAE,IAAA,EAAM,CAAC,CAAA;AAAA,EAClE;AACF;AAEO,IAAM,WAAA,GAAN,cACG,WAAA,CAQV;AAAA,EACE,WAAA,GAAc;AACZ,IAAA,KAAA,CAAM,cAAc,IAAI,CAAA;AAAA,EAC1B;AAAA,EAKA,KAAA,CACE,YAAwB,OAAA,EAC+C;AACvE,IAAA,OAAO,IAAI,iBAAA;AAAA,MACT,IAAA;AAAA,MACA,GAAA,CAAI,eAAA,EAAiB,EAAE,SAAA,EAAW,WAAW;AAAA,KAC/C;AAAA,EACF;AAAA,EACA,MAAA,GAAyE;AACvE,IAAA,OAAO,IAAI,iBAAA;AAAA,MACT,IAAA;AAAA,MACA,GAAA,CAAI,eAAA,EAAiB,EAAE,QAAA,EAAU,MAAM;AAAA,KACzC;AAAA,EACF;AAAA,EACA,UAAA,GAEE;AACA,IAAA,OAAO,IAAI,iBAAA;AAAA,MACT,IAAA;AAAA,MACA,GAAA,CAAI,eAAA,EAAiB,EAAE,YAAA,EAAc,MAAM;AAAA,KAC7C;AAAA,EACF;AAAA,EACA,OAAA,GAEE;AACA,IAAA,OAAO,IAAI,iBAAA;AAAA,MACT,IAAA;AAAA,MACA,GAAA,CAAI,eAAA,EAAiB,EAAE,eAAA,EAAiB,MAAM;AAAA,KAChD;AAAA,EACF;AAAA,EACA,QACE,KAAA,EACsE;AACtE,IAAA,OAAO,IAAI,iBAAA;AAAA,MACT,IAAA;AAAA,MACA,GAAA,CAAI,eAAA,EAAiB,EAAE,YAAA,EAAc,OAAO;AAAA,KAC9C;AAAA,EACF;AAAA,EACA,KACE,IAAA,EAC4D;AAC5D,IAAA,OAAO,IAAI,kBAAkB,IAAA,EAAM,GAAA,CAAI,iBAAiB,EAAE,IAAA,EAAM,CAAC,CAAA;AAAA,EACnE;AACF;AAEO,IAAM,WAAA,GAAN,cACG,WAAA,CAQV;AAAA,EACE,WAAA,GAAc;AACZ,IAAA,KAAA,CAAM,cAAc,IAAI,CAAA;AAAA,EAC1B;AAAA,EAKA,KAAA,CACE,YAAwB,OAAA,EAC+C;AACvE,IAAA,OAAO,IAAI,iBAAA;AAAA,MACT,IAAA;AAAA,MACA,GAAA,CAAI,eAAA,EAAiB,EAAE,SAAA,EAAW,WAAW;AAAA,KAC/C;AAAA,EACF;AAAA,EACA,MAAA,GAAyE;AACvE,IAAA,OAAO,IAAI,iBAAA;AAAA,MACT,IAAA;AAAA,MACA,GAAA,CAAI,eAAA,EAAiB,EAAE,QAAA,EAAU,MAAM;AAAA,KACzC;AAAA,EACF;AAAA,EACA,UAAA,GAEE;AACA,IAAA,OAAO,IAAI,iBAAA;AAAA,MACT,IAAA;AAAA,MACA,GAAA,CAAI,eAAA,EAAiB,EAAE,YAAA,EAAc,MAAM;AAAA,KAC7C;AAAA,EACF;AAAA,EACA,OAAA,GAEE;AACA,IAAA,OAAO,IAAI,iBAAA;AAAA,MACT,IAAA;AAAA,MACA,GAAA,CAAI,eAAA,EAAiB,EAAE,eAAA,EAAiB,MAAM;AAAA,KAChD;AAAA,EACF;AAAA,EACA,QACE,KAAA,EACsE;AACtE,IAAA,OAAO,IAAI,iBAAA;AAAA,MACT,IAAA;AAAA,MACA,GAAA,CAAI,eAAA,EAAiB,EAAE,YAAA,EAAc,OAAO;AAAA,KAC9C;AAAA,EACF;AAAA,EACA,KACE,IAAA,EAC4D;AAC5D,IAAA,OAAO,IAAI,kBAAkB,IAAA,EAAM,GAAA,CAAI,iBAAiB,EAAE,IAAA,EAAM,CAAC,CAAA;AAAA,EACnE;AACF;AAEO,IAAM,UAAA,GAAN,cACG,WAAA,CAIV;AAAA,EACE,WAAA,GAAc;AACZ,IAAA,KAAA,CAAM,cAAc,GAAG,CAAA;AAAA,EACzB;AAAA,EACA,QACE,KAAA,EACqE;AACrE,IAAA,OAAO,IAAI,gBAAA;AAAA,MACT,IAAA;AAAA,MACA,GAAA,CAAI,eAAA,EAAiB,EAAE,YAAA,EAAc,OAAO;AAAA,KAC9C;AAAA,EACF;AAAA,EACA,KACE,IAAA,EAC2D;AAC3D,IAAA,OAAO,IAAI,iBAAiB,IAAA,EAAM,GAAA,CAAI,iBAAiB,EAAE,IAAA,EAAM,CAAC,CAAA;AAAA,EAClE;AACF;AAEO,IAAM,UAAA,GAAN,cACG,WAAA,CAIV;AAAA,EACE,WAAA,GAAc;AACZ,IAAA,KAAA,CAAM,cAAc,GAAG,CAAA;AAAA,EACzB;AAAA,EACA,QACE,KAAA,EACqE;AACrE,IAAA,OAAO,IAAI,gBAAA;AAAA,MACT,IAAA;AAAA,MACA,GAAA,CAAI,eAAA,EAAiB,EAAE,YAAA,EAAc,OAAO;AAAA,KAC9C;AAAA,EACF;AAAA,EACA,KACE,IAAA,EAC2D;AAC3D,IAAA,OAAO,IAAI,iBAAiB,IAAA,EAAM,GAAA,CAAI,iBAAiB,EAAE,IAAA,EAAM,CAAC,CAAA;AAAA,EAClE;AACF;AAEO,IAAM,WAAA,GAAN,cACG,WAAA,CAOV;AAAA,EACE,WAAA,GAAc;AACZ,IAAA,KAAA,CAAM,cAAc,IAAI,CAAA;AAAA,EAC1B;AAAA,EAKA,KAAA,CACE,YAAwB,OAAA,EAC+C;AACvE,IAAA,OAAO,IAAI,iBAAA;AAAA,MACT,IAAA;AAAA,MACA,GAAA,CAAI,eAAA,EAAiB,EAAE,SAAA,EAAW,WAAW;AAAA,KAC/C;AAAA,EACF;AAAA,EACA,MAAA,GAAyE;AACvE,IAAA,OAAO,IAAI,iBAAA;AAAA,MACT,IAAA;AAAA,MACA,GAAA,CAAI,eAAA,EAAiB,EAAE,QAAA,EAAU,MAAM;AAAA,KACzC;AAAA,EACF;AAAA,EACA,UAAA,GAEE;AACA,IAAA,OAAO,IAAI,iBAAA;AAAA,MACT,IAAA;AAAA,MACA,GAAA,CAAI,eAAA,EAAiB,EAAE,YAAA,EAAc,MAAM;AAAA,KAC7C;AAAA,EACF;AAAA,EACA,QACE,KAAA,EACuE;AACvE,IAAA,OAAO,IAAI,iBAAA;AAAA,MACT,IAAA;AAAA,MACA,GAAA,CAAI,eAAA,EAAiB,EAAE,YAAA,EAAc,OAAO;AAAA,KAC9C;AAAA,EACF;AAAA,EACA,KACE,IAAA,EAC4D;AAC5D,IAAA,OAAO,IAAI,kBAAkB,IAAA,EAAM,GAAA,CAAI,iBAAiB,EAAE,IAAA,EAAM,CAAC,CAAA;AAAA,EACnE;AACF;AAEO,IAAM,aAAA,GAAN,cACG,WAAA,CAOV;AAAA,EACE,WAAA,GAAc;AACZ,IAAA,KAAA,CAAM,cAAc,MAAM,CAAA;AAAA,EAC5B;AAAA,EAKA,KAAA,CACE,YAAwB,OAAA,EACiD;AACzE,IAAA,OAAO,IAAI,mBAAA;AAAA,MACT,IAAA;AAAA,MACA,GAAA,CAAI,eAAA,EAAiB,EAAE,SAAA,EAAW,WAAW;AAAA,KAC/C;AAAA,EACF;AAAA,EACA,MAAA,GAA2E;AACzE,IAAA,OAAO,IAAI,mBAAA;AAAA,MACT,IAAA;AAAA,MACA,GAAA,CAAI,eAAA,EAAiB,EAAE,QAAA,EAAU,MAAM;AAAA,KACzC;AAAA,EACF;AAAA,EACA,UAAA,GAEE;AACA,IAAA,OAAO,IAAI,mBAAA;AAAA,MACT,IAAA;AAAA,MACA,GAAA,CAAI,eAAA,EAAiB,EAAE,YAAA,EAAc,MAAM;AAAA,KAC7C;AAAA,EACF;AAAA,EACA,QACE,KAAA,EACwE;AACxE,IAAA,OAAO,IAAI,mBAAA;AAAA,MACT,IAAA;AAAA,MACA,GAAA,CAAI,eAAA,EAAiB,EAAE,YAAA,EAAc,OAAO;AAAA,KAC9C;AAAA,EACF;AAAA,EACA,KACE,IAAA,EAC8D;AAC9D,IAAA,OAAO,IAAI,oBAAoB,IAAA,EAAM,GAAA,CAAI,iBAAiB,EAAE,IAAA,EAAM,CAAC,CAAA;AAAA,EACrE;AACF;AAEO,IAAM,YAAA,GAAN,cACG,WAAA,CAOV;AAAA,EACE,OAAA;AAAA,EAEA,YAAY,OAAA,EAAkB;AAC5B,IAAA,KAAA,CAAM,aAAA,CAAc,KAAA,CAAM,OAAA,CAAQ,aAAa,CAAC,CAAA;AAChD,IAAA,IAAA,CAAK,OAAA,GAAU,OAAA;AAAA,EACjB;AAAA,EACA,QACE,KAAA,EAIA;AACA,IAAA,OAAO,IAAI,kBAAA;AAAA,MACT,IAAA;AAAA,MACA,GAAA,CAAI,eAAA,EAAiB,EAAE,YAAA,EAAc,OAAO;AAAA,KAC9C;AAAA,EACF;AAAA,EACA,KACE,IAAA,EACsE;AACtE,IAAA,OAAO,IAAI,mBAAmB,IAAA,EAAM,GAAA,CAAI,iBAAiB,EAAE,IAAA,EAAM,CAAC,CAAA;AAAA,EACpE;AACF;AAEO,IAAM,gBAAA,GAAN,cACG,WAAA,CAKV;AAAA,EACE,WAAA,GAAc;AACZ,IAAA,KAAA,CAAM,aAAA,CAAc,KAAA,CAAM,aAAA,CAAc,EAAE,CAAC,CAAA;AAAA,EAC7C;AAAA,EACA,QACE,KAAA,EACwE;AACxE,IAAA,OAAO,IAAI,sBAAA;AAAA,MACT,GAAA,CAAI,eAAA,EAAiB,EAAE,YAAA,EAAc,OAAO;AAAA,KAC9C;AAAA,EACF;AAAA,EACA,KACE,IAAA,EACiE;AACjE,IAAA,OAAO,IAAI,sBAAA,CAAuB,GAAA,CAAI,iBAAiB,EAAE,IAAA,EAAM,CAAC,CAAA;AAAA,EAClE;AACF;AAEO,IAAM,aAAA,GAAN,cACG,WAAA,CAaV;AAAA,EACE,KAAA;AAAA,EAEA,YAAY,KAAA,EAAc;AACxB,IAAA,KAAA,CAAM,MAAA,CAAO,gBAAA,CAAiB,KAAA,CAAM,aAAa,CAAC,CAAA;AAClD,IAAA,IAAA,CAAK,KAAA,GAAQ,KAAA;AAAA,EACf;AAAA,EACA,QACE,KAAA,EAQA;AACA,IAAA,OAAO,IAAI,mBAAA;AAAA,MACT,IAAA;AAAA,MACA,GAAA,CAAI,eAAA,EAAiB,EAAE,YAAA,EAAc,OAAO;AAAA,KAC9C;AAAA,EACF;AAAA,EACA,KACE,IAAA,EACqE;AACrE,IAAA,OAAO,IAAI,oBAAoB,IAAA,EAAM,GAAA,CAAI,iBAAiB,EAAE,IAAA,EAAM,CAAC,CAAA;AAAA,EACrE;AACF;AAOO,IAAM,cAAA,GAAN,cACG,WAAA,CAIV;AAAA,EACW,QAAA;AAAA,EACA,QAAA;AAAA,EACT,WAAA,CAAY,UAAoB,IAAA,EAAe;AAC7C,IAAA,SAAS,6BAAsD,GAAA,EAAU;AACvE,MAAA,OAAO,MAAA,CAAO,IAAA,CAAK,GAAG,CAAA,CAAE,IAAI,CAAA,GAAA,MAAQ;AAAA,QAClC,IAAA,EAAM,GAAA;AAAA;AAAA;AAAA;AAAA,QAIN,IAAI,aAAA,GAAgB;AAClB,UAAA,OAAO,GAAA,CAAI,GAAG,CAAA,CAAE,aAAA;AAAA,QAClB;AAAA,OACF,CAAE,CAAA;AAAA,IACJ;AACA,IAAA,KAAA;AAAA,MACE,cAAc,OAAA,CAAQ;AAAA,QACpB,QAAA,EAAU,6BAA6B,QAAQ;AAAA,OAChD;AAAA,KACH;AACA,IAAA,IAAA,CAAK,QAAA,GAAW,IAAA;AAChB,IAAA,IAAA,CAAK,QAAA,GAAW,QAAA;AAAA,EAClB;AAAA,EACA,QACE,KAAA,EAIA;AACA,IAAA,OAAO,IAAI,oBAAA;AAAA,MACT,IAAA;AAAA,MACA,GAAA,CAAI,eAAA,EAAiB,EAAE,YAAA,EAAc,OAAO;AAAA,KAC9C;AAAA,EACF;AAAA,EACA,KACE,IAAA,EACyE;AACzE,IAAA,OAAO,IAAI,qBAAqB,IAAA,EAAM,GAAA,CAAI,iBAAiB,EAAE,IAAA,EAAM,CAAC,CAAA;AAAA,EACtE;AACF;AAEO,IAAM,aAAA,GAAN,cAIG,WAAA,CAeV;AAAA,EACE,EAAA;AAAA,EACA,GAAA;AAAA,EAEA,WAAA,CAAY,IAAQ,GAAA,EAAU;AAC5B,IAAA,KAAA,CAAM,OAAO,gBAAA,CAAiB,EAAA,CAAG,aAAA,EAAe,GAAA,CAAI,aAAa,CAAC,CAAA;AAClE,IAAA,IAAA,CAAK,EAAA,GAAK,EAAA;AACV,IAAA,IAAA,CAAK,GAAA,GAAM,GAAA;AAAA,EACb;AAAA,EACA,QACE,KAAA,EASA;AACA,IAAA,OAAO,IAAI,oBAQT,IAAA,EAAM,GAAA,CAAI,iBAAiB,EAAE,YAAA,EAAc,KAAA,EAAO,CAAC,CAAA;AAAA,EACvD;AACF;AAEA,IAAM,WAAA,GAAN,cAA0B,WAAA,CAGxB;AAAA,EACA,WAAA,GAAc;AACZ,IAAA,KAAA,CAAM,EAAE,KAAK,SAAA,EAAW,KAAA,EAAO,EAAE,QAAA,EAAU,EAAC,EAAE,EAAG,CAAA;AAAA,EACnD;AACF,CAAA;AAEO,IAAM,UAAA,GAAN,cAA6C,WAAA,CAMlD;AAAA,EACS,GAAA;AAAA,EACT,QAAA;AAAA,EACA,WAAA,CAAY,KAAU,IAAA,EAAe;AACnC,IAAA,MAAM,YAAY,MAAA,CAAO,WAAA;AAAA,MACvB,MAAA,CAAO,QAAQ,GAAG,CAAA,CAAE,IAAI,CAAC,CAAC,OAAA,EAAS,OAAO,CAAA,KAAM;AAAA,QAC9C,OAAA;AAAA,QACA,mBAAmB,aAAA,GACf,OAAA,GACA,IAAI,aAAA,CAAc,OAAA,EAAS,EAAE;AAAA,OAClC;AAAA,KACH;AAEA,IAAA,MAAM,WAAW,MAAA,CAAO,IAAA,CAAK,SAAS,CAAA,CAAE,GAAA,CAAI,CAAAC,KAAAA,MAAS;AAAA,MACnD,IAAA,EAAAA,KAAAA;AAAA,MACA,IAAI,aAAA,GAAgB;AAClB,QAAA,OAAO,SAAA,CAAUA,KAAI,CAAA,CAAE,WAAA,CAAY,aAAA;AAAA,MACrC;AAAA,KACF,CAAE,CAAA;AAEF,IAAA,KAAA,CAAM,aAAA,CAAc,OAAA,CAAQ,EAAE,QAAA,EAAU,CAAC,CAAA;AACzC,IAAA,IAAA,CAAK,GAAA,GAAM,SAAA;AACX,IAAA,IAAA,CAAK,QAAA,GAAW,IAAA;AAAA,EAClB;AACF;AAyBA,IAAM,cAAA,GAAN,cACU,WAAA,CAIV;AAAA,EACW,QAAA;AAAA,EACA,QAAA;AAAA,EAET,WAAA,CAAY,UAAoB,IAAA,EAAe;AAC7C,IAAA,SAAS,6BACPC,SAAAA,EACA;AACA,MAAA,OAAQ,MAAA,CAAO,IAAA,CAAKA,SAAQ,CAAA,CAA4B,IAAI,CAAA,GAAA,MAAQ;AAAA,QAClE,IAAA,EAAM,GAAA;AAAA;AAAA;AAAA;AAAA,QAIN,IAAI,aAAA,GAAgB;AAClB,UAAA,OAAOA,SAAAA,CAAS,GAAG,CAAA,CAAE,aAAA;AAAA,QACvB;AAAA,OACF,CAAE,CAAA;AAAA,IACJ;AACA,IAAA,KAAA;AAAA,MACE,cAAc,GAAA,CAAI;AAAA,QAChB,QAAA,EAAU,6BAA6B,QAAQ;AAAA,OAChD;AAAA,KACH;AAEA,IAAA,IAAA,CAAK,QAAA,GAAW,QAAA;AAChB,IAAA,IAAA,CAAK,QAAA,GAAW,IAAA;AAEhB,IAAA,KAAA,MAAW,GAAA,IAAO,MAAA,CAAO,IAAA,CAAK,QAAQ,CAAA,EAAqC;AACzE,MAAA,MAAM,IAAA,GAAO,MAAA,CAAO,wBAAA,CAAyB,QAAA,EAAU,GAAG,CAAA;AAE1D,MAAA,MAAM,UAAA,GACJ,CAAC,CAAC,IAAA,KACD,OAAO,KAAK,GAAA,KAAQ,UAAA,IAAc,OAAO,IAAA,CAAK,GAAA,KAAQ,UAAA,CAAA;AAEzD,MAAA,IAAIC,OAAAA,GAAS,KAAA;AAEb,MAAA,IAAI,CAAC,UAAA,EAAY;AAGf,QAAA,MAAM,OAAA,GAAU,SAAS,GAAG,CAAA;AAC5B,QAAAA,UAAS,OAAA,YAAmB,WAAA;AAAA,MAC9B;AAEA,MAAA,IAAIA,OAAAA,EAAQ;AAEV,QAAA,MAAM,QAAA,GAAW,IAAA,CAAK,MAAA,CAAO,GAAU,CAAA;AAIvC,QAAA,MAAA,CAAO,cAAA,CAAe,MAAM,GAAA,EAAK;AAAA,UAC/B,KAAA,EAAO,QAAA;AAAA,UACP,QAAA,EAAU,KAAA;AAAA,UACV,UAAA,EAAY,IAAA;AAAA,UACZ,YAAA,EAAc;AAAA,SACf,CAAA;AAAA,MACH,CAAA,MAAO;AACL,QAAA,MAAM,MAAM,CAAC,KAAA,KACX,IAAA,CAAK,MAAA,CAAO,KAAY,KAAK,CAAA,CAAA;AAK/B,QAAA,MAAA,CAAO,cAAA,CAAe,MAAM,GAAA,EAAK;AAAA,UAC/B,KAAA,EAAO,EAAA;AAAA,UACP,QAAA,EAAU,KAAA;AAAA,UACV,UAAA,EAAY,IAAA;AAAA,UACZ,YAAA,EAAc;AAAA,SACf,CAAA;AAAA,MACH;AAAA,IACF;AAAA,EACF;AAAA,EAcQ,MAAA,CAAO,KAAa,KAAA,EAAiB;AAC3C,IAAA,OAAO,UAAU,MAAA,GAAY,EAAE,KAAI,GAAI,EAAE,KAAK,KAAA,EAAM;AAAA,EACtD;AAAA,EAEA,QACE,KAAA,EAIA;AACA,IAAA,OAAO,IAAI,gBAAA;AAAA,MACT,IAAA;AAAA,MACA,GAAA,CAAI,eAAA,EAAiB,EAAE,YAAA,EAAc,OAAO;AAAA,KAC9C;AAAA,EACF;AAAA,EACA,KACE,IAAA,EACqE;AACrE,IAAA,OAAO,IAAI,iBAAiB,IAAA,EAAM,GAAA,CAAI,iBAAiB,EAAE,IAAA,EAAM,CAAC,CAAA;AAAA,EAClE;AACF,CAAA;AAEO,IAAM,UAAA,GAMT;AAEJ,IAAM,oBAAA,GAAN,cACU,cAAA,CAgBV;AAAA,EAWE,KAAA,CACE,YAAwB,OAAA,EAIxB;AACA,IAAA,OAAO,IAAI,sBAAA;AAAA,MACT,IAAA;AAAA,MACA,GAAA,CAAI,eAAA,EAAiB,EAAE,SAAA,EAAW,WAAW;AAAA,KAC/C;AAAA,EACF;AAAA,EACA,UAAA,GAGE;AACA,IAAA,OAAO,IAAI,sBAAA;AAAA,MACT,IAAA;AAAA,MACA,GAAA,CAAI,eAAA,EAAiB,EAAE,YAAA,EAAc,MAAM;AAAA,KAC7C;AAAA,EACF;AACF,CAAA;AAEO,IAAM,gBAAA,GAKT;AAKG,IAAM,iBAAA,GAAN,cACG,WAAA,CAIV;AAAA,EACE,WAAA,GAAc;AACZ,IAAA,KAAA,CAAM,mBAAA,CAAW,kBAAkB,CAAA;AAAA,EACrC;AAAA,EACA,QACE,KAAA,EAGA;AACA,IAAA,OAAO,IAAI,uBAAA;AAAA,MACT,IAAA;AAAA,MACA,GAAA,CAAI,eAAA,EAAiB,EAAE,YAAA,EAAc,OAAO;AAAA,KAC9C;AAAA,EACF;AAAA,EACA,KACE,IAAA,EACkE;AAClE,IAAA,OAAO,IAAI,wBAAwB,IAAA,EAAM,GAAA,CAAI,iBAAiB,EAAE,IAAA,EAAM,CAAC,CAAA;AAAA,EACzE;AACF;AAEO,IAAM,eAAA,GAAN,cACG,WAAA,CAOV;AAAA,EACE,WAAA,GAAc;AACZ,IAAA,KAAA,CAAM,QAAA,CAAS,kBAAkB,CAAA;AAAA,EACnC;AAAA,EAOA,KAAA,CACE,YAAwB,OAAA,EACmD;AAC3E,IAAA,OAAO,IAAI,qBAAA;AAAA,MACT,IAAA;AAAA,MACA,GAAA,CAAI,eAAA,EAAiB,EAAE,SAAA,EAAW,WAAW;AAAA,KAC/C;AAAA,EACF;AAAA,EACA,MAAA,GAA6E;AAC3E,IAAA,OAAO,IAAI,qBAAA;AAAA,MACT,IAAA;AAAA,MACA,GAAA,CAAI,eAAA,EAAiB,EAAE,QAAA,EAAU,MAAM;AAAA,KACzC;AAAA,EACF;AAAA,EACA,UAAA,GAEE;AACA,IAAA,OAAO,IAAI,qBAAA;AAAA,MACT,IAAA;AAAA,MACA,GAAA,CAAI,eAAA,EAAiB,EAAE,YAAA,EAAc,MAAM;AAAA,KAC7C;AAAA,EACF;AAAA,EACA,OAAA,GAEE;AACA,IAAA,OAAO,IAAI,qBAAA;AAAA,MACT,IAAA;AAAA,MACA,GAAA,CAAI,eAAA,EAAiB,EAAE,eAAA,EAAiB,MAAM;AAAA,KAChD;AAAA,EACF;AAAA,EACA,QACE,KAAA,EAGA;AACA,IAAA,OAAO,IAAI,qBAAA;AAAA,MACT,IAAA;AAAA,MACA,GAAA,CAAI,eAAA,EAAiB,EAAE,YAAA,EAAc,OAAO;AAAA,KAC9C;AAAA,EACF;AAAA,EACA,KACE,IAAA,EACgE;AAChE,IAAA,OAAO,IAAI,sBAAsB,IAAA,EAAM,GAAA,CAAI,iBAAiB,EAAE,IAAA,EAAM,CAAC,CAAA;AAAA,EACvE;AACF;AAEO,IAAM,mBAAA,GAAN,cACG,WAAA,CAOV;AAAA,EACE,WAAA,GAAc;AACZ,IAAA,KAAA,CAAM,YAAA,CAAa,kBAAkB,CAAA;AAAA,EACvC;AAAA,EAOA,KAAA,CACE,YAAwB,OAAA,EAGxB;AACA,IAAA,OAAO,IAAI,yBAAA;AAAA,MACT,IAAA;AAAA,MACA,GAAA,CAAI,eAAA,EAAiB,EAAE,SAAA,EAAW,WAAW;AAAA,KAC/C;AAAA,EACF;AAAA,EACA,MAAA,GAEE;AACA,IAAA,OAAO,IAAI,yBAAA;AAAA,MACT,IAAA;AAAA,MACA,GAAA,CAAI,eAAA,EAAiB,EAAE,QAAA,EAAU,MAAM;AAAA,KACzC;AAAA,EACF;AAAA,EACA,UAAA,GAEE;AACA,IAAA,OAAO,IAAI,yBAAA;AAAA,MACT,IAAA;AAAA,MACA,GAAA,CAAI,eAAA,EAAiB,EAAE,YAAA,EAAc,MAAM;AAAA,KAC7C;AAAA,EACF;AAAA,EACA,OAAA,GAEE;AACA,IAAA,OAAO,IAAI,yBAAA;AAAA,MACT,IAAA;AAAA,MACA,GAAA,CAAI,eAAA,EAAiB,EAAE,eAAA,EAAiB,MAAM;AAAA,KAChD;AAAA,EACF;AAAA,EACA,QACE,KAAA,EAGA;AACA,IAAA,OAAO,IAAI,yBAAA;AAAA,MACT,IAAA;AAAA,MACA,GAAA,CAAI,eAAA,EAAiB,EAAE,YAAA,EAAc,OAAO;AAAA,KAC9C;AAAA,EACF;AAAA,EACA,KACE,IAAA,EACoE;AACpE,IAAA,OAAO,IAAI,0BAA0B,IAAA,EAAM,GAAA,CAAI,iBAAiB,EAAE,IAAA,EAAM,CAAC,CAAA;AAAA,EAC3E;AACF;AAEO,IAAM,gBAAA,GAAN,cACG,WAAA,CAOV;AAAA,EACE,WAAA,GAAc;AACZ,IAAA,KAAA,CAAM,SAAA,CAAU,kBAAkB,CAAA;AAAA,EACpC;AAAA,EAOA,KAAA,CACE,YAAwB,OAAA,EAGxB;AACA,IAAA,OAAO,IAAI,sBAAA;AAAA,MACT,IAAA;AAAA,MACA,GAAA,CAAI,eAAA,EAAiB,EAAE,SAAA,EAAW,WAAW;AAAA,KAC/C;AAAA,EACF;AAAA,EACA,MAAA,GAEE;AACA,IAAA,OAAO,IAAI,sBAAA;AAAA,MACT,IAAA;AAAA,MACA,GAAA,CAAI,eAAA,EAAiB,EAAE,QAAA,EAAU,MAAM;AAAA,KACzC;AAAA,EACF;AAAA,EACA,UAAA,GAEE;AACA,IAAA,OAAO,IAAI,sBAAA;AAAA,MACT,IAAA;AAAA,MACA,GAAA,CAAI,eAAA,EAAiB,EAAE,YAAA,EAAc,MAAM;AAAA,KAC7C;AAAA,EACF;AAAA,EACA,OAAA,GAEE;AACA,IAAA,OAAO,IAAI,sBAAA;AAAA,MACT,IAAA;AAAA,MACA,GAAA,CAAI,eAAA,EAAiB,EAAE,eAAA,EAAiB,MAAM;AAAA,KAChD;AAAA,EACF;AAAA,EACA,QACE,KAAA,EAGA;AACA,IAAA,OAAO,IAAI,sBAAA;AAAA,MACT,IAAA;AAAA,MACA,GAAA,CAAI,eAAA,EAAiB,EAAE,YAAA,EAAc,OAAO;AAAA,KAC9C;AAAA,EACF;AAAA,EACA,KACE,IAAA,EACiE;AACjE,IAAA,OAAO,IAAI,uBAAuB,IAAA,EAAM,GAAA,CAAI,iBAAiB,EAAE,IAAA,EAAM,CAAC,CAAA;AAAA,EACxE;AACF;AAEO,IAAM,mBAAA,GAAN,cACG,WAAA,CAOV;AAAA,EACE,WAAA,GAAc;AACZ,IAAA,KAAA,CAAM,YAAA,CAAa,kBAAkB,CAAA;AAAA,EACvC;AAAA,EAOA,KAAA,CACE,YAAwB,OAAA,EAGxB;AACA,IAAA,OAAO,IAAI,yBAAA;AAAA,MACT,IAAA;AAAA,MACA,GAAA,CAAI,eAAA,EAAiB,EAAE,SAAA,EAAW,WAAW;AAAA,KAC/C;AAAA,EACF;AAAA,EACA,MAAA,GAEE;AACA,IAAA,OAAO,IAAI,yBAAA;AAAA,MACT,IAAA;AAAA,MACA,GAAA,CAAI,eAAA,EAAiB,EAAE,QAAA,EAAU,MAAM;AAAA,KACzC;AAAA,EACF;AAAA,EACA,UAAA,GAEE;AACA,IAAA,OAAO,IAAI,yBAAA;AAAA,MACT,IAAA;AAAA,MACA,GAAA,CAAI,eAAA,EAAiB,EAAE,YAAA,EAAc,MAAM;AAAA,KAC7C;AAAA,EACF;AAAA,EACA,OAAA,GAEE;AACA,IAAA,OAAO,IAAI,yBAAA;AAAA,MACT,IAAA;AAAA,MACA,GAAA,CAAI,eAAA,EAAiB,EAAE,eAAA,EAAiB,MAAM;AAAA,KAChD;AAAA,EACF;AAAA,EACA,QACE,KAAA,EAGA;AACA,IAAA,OAAO,IAAI,yBAAA;AAAA,MACT,IAAA;AAAA,MACA,GAAA,CAAI,eAAA,EAAiB,EAAE,YAAA,EAAc,OAAO;AAAA,KAC9C;AAAA,EACF;AAAA,EACA,KACE,IAAA,EACoE;AACpE,IAAA,OAAO,IAAI,0BAA0B,IAAA,EAAM,GAAA,CAAI,iBAAiB,EAAE,IAAA,EAAM,CAAC,CAAA;AAAA,EAC3E;AACF;AAEO,IAAM,WAAA,GAAN,cACG,WAAA,CAOV;AAAA,EACE,WAAA,GAAc;AACZ,IAAA,KAAA,CAAM,IAAA,CAAK,kBAAkB,CAAA;AAAA,EAC/B;AAAA,EAKA,KAAA,CACE,YAAwB,OAAA,EAC+C;AACvE,IAAA,OAAO,IAAI,iBAAA;AAAA,MACT,IAAA;AAAA,MACA,GAAA,CAAI,eAAA,EAAiB,EAAE,SAAA,EAAW,WAAW;AAAA,KAC/C;AAAA,EACF;AAAA,EACA,MAAA,GAAyE;AACvE,IAAA,OAAO,IAAI,iBAAA;AAAA,MACT,IAAA;AAAA,MACA,GAAA,CAAI,eAAA,EAAiB,EAAE,QAAA,EAAU,MAAM;AAAA,KACzC;AAAA,EACF;AAAA,EACA,UAAA,GAEE;AACA,IAAA,OAAO,IAAI,iBAAA;AAAA,MACT,IAAA;AAAA,MACA,GAAA,CAAI,eAAA,EAAiB,EAAE,YAAA,EAAc,MAAM;AAAA,KAC7C;AAAA,EACF;AAAA,EACA,OAAA,GAEE;AACA,IAAA,OAAO,IAAI,iBAAA;AAAA,MACT,IAAA;AAAA,MACA,GAAA,CAAI,eAAA,EAAiB,EAAE,eAAA,EAAiB,MAAM;AAAA,KAChD;AAAA,EACF;AAAA,EACA,QACE,KAAA,EACoE;AACpE,IAAA,OAAO,IAAI,iBAAA;AAAA,MACT,IAAA;AAAA,MACA,GAAA,CAAI,eAAA,EAAiB,EAAE,YAAA,EAAc,OAAO;AAAA,KAC9C;AAAA,EACF;AAAA,EACA,KACE,IAAA,EAC4D;AAC5D,IAAA,OAAO,IAAI,kBAAkB,IAAA,EAAM,GAAA,CAAI,iBAAiB,EAAE,IAAA,EAAM,CAAC,CAAA;AAAA,EACnE;AACF;AA4BA,IAAM,kBAAyC,EAAC;AAczC,IAAM,gBAAN,MAIL;AAAA,EACA,WAAA;AAAA,EACA,cAAA;AAAA,EAEA,WAAA,CAAY,aAA+C,QAAA,EAAa;AACtE,IAAA,IAAA,CAAK,WAAA,GAAc,WAAA;AACnB,IAAA,IAAA,CAAK,cAAA,GAAiB,QAAA;AAAA,EACxB;AAAA,EAEA,SAAA,CAAU,QAAsB,KAAA,EAAmB;AACjD,IAAA,IAAA,CAAK,WAAA,CAAY,SAAA,CAAU,MAAA,EAAQ,KAAK,CAAA;AAAA,EAC1C;AAAA,EAEA,YAAY,MAAA,EAA4B;AACtC,IAAA,OAAO,IAAA,CAAK,WAAA,CAAY,WAAA,CAAY,MAAM,CAAA;AAAA,EAC5C;AACF;AAEO,IAAM,eAAA,GAAN,MAAM,gBAAA,SACH,aAAA,CAQV;AAAA,EAKE,KAAA,CACE,YAAwB,OAAA,EAC+B;AACvD,IAAA,OAAO,IAAI,gBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,IAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,SAAA,EAAW,WAAW;AAAA,KACnD;AAAA,EACF;AAAA,EACA,MAAA,GAAyD;AACvD,IAAA,OAAO,IAAI,gBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,IAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,QAAA,EAAU,MAAM;AAAA,KAC7C;AAAA,EACF;AAAA,EACA,UAAA,GAAiE;AAC/D,IAAA,OAAO,IAAI,gBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,IAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,YAAA,EAAc,MAAM;AAAA,KACjD;AAAA,EACF;AAAA,EACA,OAAA,GAAiE;AAC/D,IAAA,OAAO,IAAI,gBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,IAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,eAAA,EAAiB,MAAe;AAAA,KAC7D;AAAA,EACF;AAAA,EACA,QAAQ,KAAA,EAAqE;AAC3E,IAAA,OAAO,IAAI,gBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,GAAA,CAAI,KAAK,cAAA,EAAgB;AAAA,QACvB,YAAA,EAAc;AAAA,OACf;AAAA,KACH;AAAA,EACF;AAAA,EACA,KACE,IAAA,EAC4C;AAC5C,IAAA,OAAO,IAAI,gBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,GAAA,CAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,MAAM;AAAA,KACnC;AAAA,EACF;AACF;AAEO,IAAM,gBAAA,GAAN,MAAM,iBAAA,SAGH,aAAA,CAQV;AAAA,EAKE,KAAA,CACE,YAAwB,OAAA,EACgC;AACxD,IAAA,OAAO,IAAI,iBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,IAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,SAAA,EAAW,WAAW;AAAA,KACnD;AAAA,EACF;AAAA,EACA,MAAA,GAA0D;AACxD,IAAA,OAAO,IAAI,iBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,IAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,QAAA,EAAU,MAAM;AAAA,KAC7C;AAAA,EACF;AAAA,EACA,UAAA,GAAkE;AAChE,IAAA,OAAO,IAAI,iBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,IAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,YAAA,EAAc,MAAM;AAAA,KACjD;AAAA,EACF;AAAA,EACA,OAAA,GAAkE;AAChE,IAAA,OAAO,IAAI,iBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,IAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,eAAA,EAAiB,MAAM;AAAA,KACpD;AAAA,EACF;AAAA,EACA,QACE,KAAA,EACuD;AACvD,IAAA,OAAO,IAAI,iBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,GAAA,CAAI,KAAK,cAAA,EAAgB;AAAA,QACvB,YAAA,EAAc;AAAA,OACf;AAAA,KACH;AAAA,EACF;AAAA,EACA,KACE,IAAA,EAC6C;AAC7C,IAAA,OAAO,IAAI,iBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,GAAA,CAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,MAAM;AAAA,KACnC;AAAA,EACF;AACF;AAEO,IAAM,gBAAA,GAAN,MAAM,iBAAA,SAGH,aAAA,CAQV;AAAA,EAKE,KAAA,CACE,YAAwB,OAAA,EACgC;AACxD,IAAA,OAAO,IAAI,iBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,IAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,SAAA,EAAW,WAAW;AAAA,KACnD;AAAA,EACF;AAAA,EACA,MAAA,GAA0D;AACxD,IAAA,OAAO,IAAI,iBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,IAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,QAAA,EAAU,MAAM;AAAA,KAC7C;AAAA,EACF;AAAA,EACA,UAAA,GAAkE;AAChE,IAAA,OAAO,IAAI,iBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,IAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,YAAA,EAAc,MAAM;AAAA,KACjD;AAAA,EACF;AAAA,EACA,OAAA,GAAkE;AAChE,IAAA,OAAO,IAAI,iBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,IAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,eAAA,EAAiB,MAAM;AAAA,KACpD;AAAA,EACF;AAAA,EACA,QACE,KAAA,EACuD;AACvD,IAAA,OAAO,IAAI,iBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,GAAA,CAAI,KAAK,cAAA,EAAgB;AAAA,QACvB,YAAA,EAAc;AAAA,OACf;AAAA,KACH;AAAA,EACF;AAAA,EACA,KACE,IAAA,EAC6C;AAC7C,IAAA,OAAO,IAAI,iBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,GAAA,CAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,MAAM;AAAA,KACnC;AAAA,EACF;AACF;AAEO,IAAM,gBAAA,GAAN,MAAM,iBAAA,SAGH,aAAA,CAQV;AAAA,EAKE,KAAA,CACE,YAAwB,OAAA,EACgC;AACxD,IAAA,OAAO,IAAI,iBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,IAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,SAAA,EAAW,WAAW;AAAA,KACnD;AAAA,EACF;AAAA,EACA,MAAA,GAA0D;AACxD,IAAA,OAAO,IAAI,iBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,IAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,QAAA,EAAU,MAAM;AAAA,KAC7C;AAAA,EACF;AAAA,EACA,UAAA,GAAkE;AAChE,IAAA,OAAO,IAAI,iBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,IAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,YAAA,EAAc,MAAM;AAAA,KACjD;AAAA,EACF;AAAA,EACA,OAAA,GAAkE;AAChE,IAAA,OAAO,IAAI,iBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,IAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,eAAA,EAAiB,MAAM;AAAA,KACpD;AAAA,EACF;AAAA,EACA,QACE,KAAA,EACuD;AACvD,IAAA,OAAO,IAAI,iBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,GAAA,CAAI,KAAK,cAAA,EAAgB;AAAA,QACvB,YAAA,EAAc;AAAA,OACf;AAAA,KACH;AAAA,EACF;AAAA,EACA,KACE,IAAA,EAC6C;AAC7C,IAAA,OAAO,IAAI,iBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,GAAA,CAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,MAAM;AAAA,KACnC;AAAA,EACF;AACF;AAEO,IAAM,iBAAA,GAAN,MAAM,kBAAA,SAGH,aAAA,CAQV;AAAA,EAKE,KAAA,CACE,YAAwB,OAAA,EACiC;AACzD,IAAA,OAAO,IAAI,kBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,IAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,SAAA,EAAW,WAAW;AAAA,KACnD;AAAA,EACF;AAAA,EACA,MAAA,GAA2D;AACzD,IAAA,OAAO,IAAI,kBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,IAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,QAAA,EAAU,MAAM;AAAA,KAC7C;AAAA,EACF;AAAA,EACA,UAAA,GAAmE;AACjE,IAAA,OAAO,IAAI,kBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,IAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,YAAA,EAAc,MAAM;AAAA,KACjD;AAAA,EACF;AAAA,EACA,OAAA,GAAmE;AACjE,IAAA,OAAO,IAAI,kBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,IAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,eAAA,EAAiB,MAAM;AAAA,KACpD;AAAA,EACF;AAAA,EACA,QACE,KAAA,EACwD;AACxD,IAAA,OAAO,IAAI,kBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,GAAA,CAAI,KAAK,cAAA,EAAgB;AAAA,QACvB,YAAA,EAAc;AAAA,OACf;AAAA,KACH;AAAA,EACF;AAAA,EACA,KACE,IAAA,EAC8C;AAC9C,IAAA,OAAO,IAAI,kBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,GAAA,CAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,MAAM;AAAA,KACnC;AAAA,EACF;AACF;AAEO,IAAM,iBAAA,GAAN,MAAM,kBAAA,SAGH,aAAA,CAQV;AAAA,EAKE,KAAA,CACE,YAAwB,OAAA,EACiC;AACzD,IAAA,OAAO,IAAI,kBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,IAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,SAAA,EAAW,WAAW;AAAA,KACnD;AAAA,EACF;AAAA,EACA,MAAA,GAA2D;AACzD,IAAA,OAAO,IAAI,kBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,IAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,QAAA,EAAU,MAAM;AAAA,KAC7C;AAAA,EACF;AAAA,EACA,UAAA,GAAmE;AACjE,IAAA,OAAO,IAAI,kBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,IAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,YAAA,EAAc,MAAM;AAAA,KACjD;AAAA,EACF;AAAA,EACA,OAAA,GAAmE;AACjE,IAAA,OAAO,IAAI,kBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,IAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,eAAA,EAAiB,MAAM;AAAA,KACpD;AAAA,EACF;AAAA,EACA,QACE,KAAA,EACwD;AACxD,IAAA,OAAO,IAAI,kBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,GAAA,CAAI,KAAK,cAAA,EAAgB;AAAA,QACvB,YAAA,EAAc;AAAA,OACf;AAAA,KACH;AAAA,EACF;AAAA,EACA,KACE,IAAA,EAC8C;AAC9C,IAAA,OAAO,IAAI,kBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,GAAA,CAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,MAAM;AAAA,KACnC;AAAA,EACF;AACF;AAEO,IAAM,eAAA,GAAN,MAAM,gBAAA,SACH,aAAA,CAQV;AAAA,EAKE,KAAA,CACE,YAAwB,OAAA,EAC+B;AACvD,IAAA,OAAO,IAAI,gBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,IAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,SAAA,EAAW,WAAW;AAAA,KACnD;AAAA,EACF;AAAA,EACA,MAAA,GAAyD;AACvD,IAAA,OAAO,IAAI,gBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,IAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,QAAA,EAAU,MAAM;AAAA,KAC7C;AAAA,EACF;AAAA,EACA,UAAA,GAAiE;AAC/D,IAAA,OAAO,IAAI,gBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,IAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,YAAA,EAAc,MAAM;AAAA,KACjD;AAAA,EACF;AAAA,EACA,OAAA,GAAiE;AAC/D,IAAA,OAAO,IAAI,gBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,IAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,eAAA,EAAiB,MAAM;AAAA,KACpD;AAAA,EACF;AAAA,EACA,QAAQ,KAAA,EAAqE;AAC3E,IAAA,OAAO,IAAI,gBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,GAAA,CAAI,KAAK,cAAA,EAAgB;AAAA,QACvB,YAAA,EAAc;AAAA,OACf;AAAA,KACH;AAAA,EACF;AAAA,EACA,KACE,IAAA,EAC4C;AAC5C,IAAA,OAAO,IAAI,gBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,GAAA,CAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,MAAM;AAAA,KACnC;AAAA,EACF;AACF;AAEO,IAAM,gBAAA,GAAN,MAAM,iBAAA,SAGH,aAAA,CAQV;AAAA,EAKE,KAAA,CACE,YAAwB,OAAA,EACgC;AACxD,IAAA,OAAO,IAAI,iBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,IAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,SAAA,EAAW,WAAW;AAAA,KACnD;AAAA,EACF;AAAA,EACA,MAAA,GAA0D;AACxD,IAAA,OAAO,IAAI,iBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,IAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,QAAA,EAAU,MAAM;AAAA,KAC7C;AAAA,EACF;AAAA,EACA,UAAA,GAAkE;AAChE,IAAA,OAAO,IAAI,iBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,IAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,YAAA,EAAc,MAAM;AAAA,KACjD;AAAA,EACF;AAAA,EACA,OAAA,GAAkE;AAChE,IAAA,OAAO,IAAI,iBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,IAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,eAAA,EAAiB,MAAM;AAAA,KACpD;AAAA,EACF;AAAA,EACA,QACE,KAAA,EACuD;AACvD,IAAA,OAAO,IAAI,iBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,GAAA,CAAI,KAAK,cAAA,EAAgB;AAAA,QACvB,YAAA,EAAc;AAAA,OACf;AAAA,KACH;AAAA,EACF;AAAA,EACA,KACE,IAAA,EAC6C;AAC7C,IAAA,OAAO,IAAI,iBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,GAAA,CAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,MAAM;AAAA,KACnC;AAAA,EACF;AACF;AAEO,IAAM,gBAAA,GAAN,MAAM,iBAAA,SAGH,aAAA,CAQV;AAAA,EAKE,KAAA,CACE,YAAwB,OAAA,EACgC;AACxD,IAAA,OAAO,IAAI,iBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,IAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,SAAA,EAAW,WAAW;AAAA,KACnD;AAAA,EACF;AAAA,EACA,MAAA,GAA0D;AACxD,IAAA,OAAO,IAAI,iBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,IAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,QAAA,EAAU,MAAM;AAAA,KAC7C;AAAA,EACF;AAAA,EACA,UAAA,GAAkE;AAChE,IAAA,OAAO,IAAI,iBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,IAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,YAAA,EAAc,MAAM;AAAA,KACjD;AAAA,EACF;AAAA,EACA,OAAA,GAAkE;AAChE,IAAA,OAAO,IAAI,iBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,IAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,eAAA,EAAiB,MAAM;AAAA,KACpD;AAAA,EACF;AAAA,EACA,QACE,KAAA,EACuD;AACvD,IAAA,OAAO,IAAI,iBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,GAAA,CAAI,KAAK,cAAA,EAAgB;AAAA,QACvB,YAAA,EAAc;AAAA,OACf;AAAA,KACH;AAAA,EACF;AAAA,EACA,KACE,IAAA,EAC6C;AAC7C,IAAA,OAAO,IAAI,iBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,GAAA,CAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,MAAM;AAAA,KACnC;AAAA,EACF;AACF;AAEO,IAAM,gBAAA,GAAN,MAAM,iBAAA,SAGH,aAAA,CAQV;AAAA,EAKE,KAAA,CACE,YAAwB,OAAA,EACgC;AACxD,IAAA,OAAO,IAAI,iBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,IAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,SAAA,EAAW,WAAW;AAAA,KACnD;AAAA,EACF;AAAA,EACA,MAAA,GAA0D;AACxD,IAAA,OAAO,IAAI,iBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,IAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,QAAA,EAAU,MAAM;AAAA,KAC7C;AAAA,EACF;AAAA,EACA,UAAA,GAAkE;AAChE,IAAA,OAAO,IAAI,iBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,IAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,YAAA,EAAc,MAAM;AAAA,KACjD;AAAA,EACF;AAAA,EACA,OAAA,GAAkE;AAChE,IAAA,OAAO,IAAI,iBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,IAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,eAAA,EAAiB,MAAM;AAAA,KACpD;AAAA,EACF;AAAA,EACA,QACE,KAAA,EACuD;AACvD,IAAA,OAAO,IAAI,iBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,GAAA,CAAI,KAAK,cAAA,EAAgB;AAAA,QACvB,YAAA,EAAc;AAAA,OACf;AAAA,KACH;AAAA,EACF;AAAA,EACA,KACE,IAAA,EAC6C;AAC7C,IAAA,OAAO,IAAI,iBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,GAAA,CAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,MAAM;AAAA,KACnC;AAAA,EACF;AACF;AAEO,IAAM,iBAAA,GAAN,MAAM,kBAAA,SAGH,aAAA,CAQV;AAAA,EAKE,KAAA,CACE,YAAwB,OAAA,EACiC;AACzD,IAAA,OAAO,IAAI,kBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,IAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,SAAA,EAAW,WAAW;AAAA,KACnD;AAAA,EACF;AAAA,EACA,MAAA,GAA2D;AACzD,IAAA,OAAO,IAAI,kBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,IAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,QAAA,EAAU,MAAM;AAAA,KAC7C;AAAA,EACF;AAAA,EACA,UAAA,GAAmE;AACjE,IAAA,OAAO,IAAI,kBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,IAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,YAAA,EAAc,MAAM;AAAA,KACjD;AAAA,EACF;AAAA,EACA,OAAA,GAAmE;AACjE,IAAA,OAAO,IAAI,kBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,IAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,eAAA,EAAiB,MAAM;AAAA,KACpD;AAAA,EACF;AAAA,EACA,QACE,KAAA,EACwD;AACxD,IAAA,OAAO,IAAI,kBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,GAAA,CAAI,KAAK,cAAA,EAAgB;AAAA,QACvB,YAAA,EAAc;AAAA,OACf;AAAA,KACH;AAAA,EACF;AAAA,EACA,KACE,IAAA,EAC8C;AAC9C,IAAA,OAAO,IAAI,kBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,GAAA,CAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,MAAM;AAAA,KACnC;AAAA,EACF;AACF;AAEO,IAAM,iBAAA,GAAN,MAAM,kBAAA,SAGH,aAAA,CAQV;AAAA,EAKE,KAAA,CACE,YAAwB,OAAA,EACiC;AACzD,IAAA,OAAO,IAAI,kBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,IAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,SAAA,EAAW,WAAW;AAAA,KACnD;AAAA,EACF;AAAA,EACA,MAAA,GAA2D;AACzD,IAAA,OAAO,IAAI,kBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,IAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,QAAA,EAAU,MAAM;AAAA,KAC7C;AAAA,EACF;AAAA,EACA,UAAA,GAAmE;AACjE,IAAA,OAAO,IAAI,kBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,IAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,YAAA,EAAc,MAAM;AAAA,KACjD;AAAA,EACF;AAAA,EACA,OAAA,GAAmE;AACjE,IAAA,OAAO,IAAI,kBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,IAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,eAAA,EAAiB,MAAM;AAAA,KACpD;AAAA,EACF;AAAA,EACA,QACE,KAAA,EACwD;AACxD,IAAA,OAAO,IAAI,kBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,GAAA,CAAI,KAAK,cAAA,EAAgB;AAAA,QACvB,YAAA,EAAc;AAAA,OACf;AAAA,KACH;AAAA,EACF;AAAA,EACA,KACE,IAAA,EAC8C;AAC9C,IAAA,OAAO,IAAI,kBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,GAAA,CAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,MAAM;AAAA,KACnC;AAAA,EACF;AACF;AAEO,IAAM,gBAAA,GAAN,MAAM,iBAAA,SAGH,aAAA,CAIV;AAAA,EACE,QACE,KAAA,EACuD;AACvD,IAAA,OAAO,IAAI,iBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,GAAA,CAAI,KAAK,cAAA,EAAgB;AAAA,QACvB,YAAA,EAAc;AAAA,OACf;AAAA,KACH;AAAA,EACF;AAAA,EACA,KACE,IAAA,EAC6C;AAC7C,IAAA,OAAO,IAAI,iBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,GAAA,CAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,MAAM;AAAA,KACnC;AAAA,EACF;AACF;AAEO,IAAM,gBAAA,GAAN,MAAM,iBAAA,SAGH,aAAA,CAIV;AAAA,EACE,QACE,KAAA,EACuD;AACvD,IAAA,OAAO,IAAI,iBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,GAAA,CAAI,KAAK,cAAA,EAAgB;AAAA,QACvB,YAAA,EAAc;AAAA,OACf;AAAA,KACH;AAAA,EACF;AAAA,EACA,KACE,IAAA,EAC6C;AAC7C,IAAA,OAAO,IAAI,iBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,GAAA,CAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,MAAM;AAAA,KACnC;AAAA,EACF;AACF;AAEO,IAAM,iBAAA,GAAN,MAAM,kBAAA,SAGH,aAAA,CAOV;AAAA,EAKE,KAAA,CACE,YAAwB,OAAA,EACiC;AACzD,IAAA,OAAO,IAAI,kBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,IAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,SAAA,EAAW,WAAW;AAAA,KACnD;AAAA,EACF;AAAA,EACA,MAAA,GAA2D;AACzD,IAAA,OAAO,IAAI,kBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,IAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,QAAA,EAAU,MAAM;AAAA,KAC7C;AAAA,EACF;AAAA,EACA,UAAA,GAAmE;AACjE,IAAA,OAAO,IAAI,kBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,IAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,YAAA,EAAc,MAAM;AAAA,KACjD;AAAA,EACF;AAAA,EACA,QACE,KAAA,EACyD;AACzD,IAAA,OAAO,IAAI,kBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,GAAA,CAAI,KAAK,cAAA,EAAgB;AAAA,QACvB,YAAA,EAAc;AAAA,OACf;AAAA,KACH;AAAA,EACF;AAAA,EACA,KACE,IAAA,EAC8C;AAC9C,IAAA,OAAO,IAAI,kBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,GAAA,CAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,MAAM;AAAA,KACnC;AAAA,EACF;AACF;AAEO,IAAM,mBAAA,GAAN,MAAM,oBAAA,SAGH,aAAA,CAOV;AAAA,EAKE,KAAA,CACE,YAAwB,OAAA,EACmC;AAC3D,IAAA,OAAO,IAAI,oBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,IAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,SAAA,EAAW,WAAW;AAAA,KACnD;AAAA,EACF;AAAA,EACA,MAAA,GAA6D;AAC3D,IAAA,OAAO,IAAI,oBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,IAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,QAAA,EAAU,MAAM;AAAA,KAC7C;AAAA,EACF;AAAA,EACA,UAAA,GAAqE;AACnE,IAAA,OAAO,IAAI,oBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,IAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,YAAA,EAAc,MAAM;AAAA,KACjD;AAAA,EACF;AAAA,EACA,QACE,KAAA,EAC0D;AAC1D,IAAA,OAAO,IAAI,oBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,GAAA,CAAI,KAAK,cAAA,EAAgB;AAAA,QACvB,YAAA,EAAc;AAAA,OACf;AAAA,KACH;AAAA,EACF;AAAA,EACA,KACE,IAAA,EACgD;AAChD,IAAA,OAAO,IAAI,oBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,GAAA,CAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,MAAM;AAAA,KACnC;AAAA,EACF;AACF;AAEO,IAAM,kBAAA,GAAN,MAAM,mBAAA,SAMH,aAAA,CAcV;AAAA,EACE,QACE,KAAA,EAIA;AACA,IAAA,OAAO,IAAI,mBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,GAAA,CAAI,KAAK,cAAA,EAAgB;AAAA,QACvB,YAAA,EAAc;AAAA,OACf;AAAA,KACH;AAAA,EACF;AAAA,EACA,KACE,IAAA,EACwD;AACxD,IAAA,OAAO,IAAI,mBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,GAAA,CAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,MAAM;AAAA,KACnC;AAAA,EACF;AACF;AAOO,IAAM,sBAAA,GAAN,MAAM,uBAAA,SAGH,aAAA,CAIV;AAAA,EACE,YAAY,QAAA,EAAa;AACvB,IAAA,KAAA,CAAM,IAAI,YAAY,aAAA,CAAc,KAAA,CAAM,cAAc,EAAE,CAAC,GAAG,QAAQ,CAAA;AAAA,EACxE;AAAA,EACA,QACE,KAAA,EACiE;AACjE,IAAA,OAAO,IAAI,uBAAA;AAAA,MACT,IAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,YAAA,EAAc,OAAO;AAAA,KAClD;AAAA,EACF;AAAA,EACA,KACE,IAAA,EACmD;AACnD,IAAA,OAAO,IAAI,wBAAuB,GAAA,CAAI,IAAA,CAAK,gBAAgB,EAAE,IAAA,EAAM,CAAC,CAAA;AAAA,EACtE;AACF;AAEO,IAAM,mBAAA,GAAN,MAAM,oBAAA,SAMH,aAAA,CAcV;AAAA,EACE,QACE,KAAA,EAIA;AACA,IAAA,OAAO,IAAI,oBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,GAAA,CAAI,KAAK,cAAA,EAAgB;AAAA,QACvB,YAAA,EAAc;AAAA,OACf;AAAA,KACH;AAAA,EACF;AAAA,EACA,KACE,IAAA,EACuD;AACvD,IAAA,OAAO,IAAI,oBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,GAAA,CAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,MAAM;AAAA,KACnC;AAAA,EACF;AACF;AAEO,IAAM,mBAAA,GAAN,MAAM,oBAAA,SAOH,aAAA,CAgBV;AAAA,EACE,WAAA,CAAY,aAAoC,QAAA,EAAa;AAC3D,IAAA,KAAA,CAAM,aAAa,QAAQ,CAAA;AAAA,EAC7B;AAAA,EAEA,QACE,KAAA,EASA;AACA,IAAA,OAAO,IAAI,oBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,GAAA,CAAI,KAAK,cAAA,EAAgB;AAAA,QACvB,YAAA,EAAc;AAAA,OACf;AAAA,KACH;AAAA,EACF;AACF;AAEO,IAAM,oBAAA,GAAN,MAAM,qBAAA,SAIH,aAAA,CAQV;AAAA,EACE,QACE,KAAA,EAIA;AACA,IAAA,OAAO,IAAI,qBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,IAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,YAAA,EAAc,OAAO;AAAA,KAClD;AAAA,EACF;AAAA,EACA,KACE,IAAA,EACyE;AACzE,IAAA,OAAO,IAAI,qBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,GAAA,CAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,MAAM;AAAA,KACnC;AAAA,EACF;AACF;AAEO,IAAM,gBAAA,GAAN,MAAM,iBAAA,SAIH,aAAA,CAIV;AAAA,EACE,QACE,KAAA,EAIA;AACA,IAAA,OAAO,IAAI,iBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,IAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,YAAA,EAAc,OAAO;AAAA,KAClD;AAAA,EACF;AAAA,EACA,KACE,IAAA,EACqE;AACrE,IAAA,OAAO,IAAI,iBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,GAAA,CAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,MAAM;AAAA,KACnC;AAAA,EACF;AACF;AAEO,IAAM,sBAAA,GAAN,MAAM,uBAAA,SAIH,gBAAA,CAIV;AAAA,EAWE,KAAA,CACE,YAAwB,OAAA,EAIxB;AACA,IAAA,OAAO,IAAI,uBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,IAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,SAAA,EAAW,WAAW;AAAA,KACnD;AAAA,EACF;AAAA,EACA,UAAA,GAGE;AACA,IAAA,OAAO,IAAI,uBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,IAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,YAAA,EAAc,MAAM;AAAA,KACjD;AAAA,EACF;AACF;AAEO,IAAM,uBAAA,GAAN,MAAM,wBAAA,SAGH,aAAA,CAIV;AAAA,EACE,QACE,KAAA,EACkE;AAClE,IAAA,OAAO,IAAI,wBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,IAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,YAAA,EAAc,OAAO;AAAA,KAClD;AAAA,EACF;AAAA,EACA,KACE,IAAA,EACoD;AACpD,IAAA,OAAO,IAAI,wBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,GAAA,CAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,MAAM;AAAA,KACnC;AAAA,EACF;AACF;AAEO,IAAM,qBAAA,GAAN,MAAM,sBAAA,SAGH,aAAA,CAOV;AAAA,EAKE,KAAA,CACE,YAAwB,OAAA,EACqC;AAC7D,IAAA,OAAO,IAAI,sBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,IAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,SAAA,EAAW,WAAW;AAAA,KACnD;AAAA,EACF;AAAA,EACA,MAAA,GAA+D;AAC7D,IAAA,OAAO,IAAI,sBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,IAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,QAAA,EAAU,MAAM;AAAA,KAC7C;AAAA,EACF;AAAA,EACA,UAAA,GAAuE;AACrE,IAAA,OAAO,IAAI,sBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,IAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,YAAA,EAAc,MAAM;AAAA,KACjD;AAAA,EACF;AAAA,EACA,QACE,KAAA,EAC8D;AAC9D,IAAA,OAAO,IAAI,sBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,IAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,YAAA,EAAc,OAAO;AAAA,KAClD;AAAA,EACF;AAAA,EACA,KACE,IAAA,EACkD;AAClD,IAAA,OAAO,IAAI,sBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,GAAA,CAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,MAAM;AAAA,KACnC;AAAA,EACF;AACF;AAEO,IAAM,yBAAA,GAAN,MAAM,0BAAA,SAGH,aAAA,CAOV;AAAA,EAKE,KAAA,CACE,YAAwB,OAAA,EACyC;AACjE,IAAA,OAAO,IAAI,0BAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,IAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,SAAA,EAAW,WAAW;AAAA,KACnD;AAAA,EACF;AAAA,EACA,MAAA,GAAmE;AACjE,IAAA,OAAO,IAAI,0BAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,IAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,QAAA,EAAU,MAAM;AAAA,KAC7C;AAAA,EACF;AAAA,EACA,UAAA,GAA2E;AACzE,IAAA,OAAO,IAAI,0BAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,IAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,YAAA,EAAc,MAAM;AAAA,KACjD;AAAA,EACF;AAAA,EACA,QACE,KAAA,EACsE;AACtE,IAAA,OAAO,IAAI,0BAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,IAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,YAAA,EAAc,OAAO;AAAA,KAClD;AAAA,EACF;AAAA,EACA,KACE,IAAA,EACsD;AACtD,IAAA,OAAO,IAAI,0BAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,GAAA,CAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,MAAM;AAAA,KACnC;AAAA,EACF;AACF;AAEO,IAAM,sBAAA,GAAN,MAAM,uBAAA,SAGH,aAAA,CAOV;AAAA,EAKE,KAAA,CACE,YAAwB,OAAA,EACsC;AAC9D,IAAA,OAAO,IAAI,uBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,IAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,SAAA,EAAW,WAAW;AAAA,KACnD;AAAA,EACF;AAAA,EACA,MAAA,GAAgE;AAC9D,IAAA,OAAO,IAAI,uBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,IAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,QAAA,EAAU,MAAM;AAAA,KAC7C;AAAA,EACF;AAAA,EACA,UAAA,GAAwE;AACtE,IAAA,OAAO,IAAI,uBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,IAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,YAAA,EAAc,MAAM;AAAA,KACjD;AAAA,EACF;AAAA,EACA,QACE,KAAA,EACgE;AAChE,IAAA,OAAO,IAAI,uBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,IAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,YAAA,EAAc,OAAO;AAAA,KAClD;AAAA,EACF;AAAA,EACA,KACE,IAAA,EACmD;AACnD,IAAA,OAAO,IAAI,uBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,GAAA,CAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,MAAM;AAAA,KACnC;AAAA,EACF;AACF;AAEO,IAAM,yBAAA,GAAN,MAAM,0BAAA,SAGH,aAAA,CAOV;AAAA,EAKE,KAAA,CACE,YAAwB,OAAA,EACyC;AACjE,IAAA,OAAO,IAAI,0BAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,IAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,SAAA,EAAW,WAAW;AAAA,KACnD;AAAA,EACF;AAAA,EACA,MAAA,GAAmE;AACjE,IAAA,OAAO,IAAI,0BAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,IAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,QAAA,EAAU,MAAM;AAAA,KAC7C;AAAA,EACF;AAAA,EACA,UAAA,GAA2E;AACzE,IAAA,OAAO,IAAI,0BAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,IAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,YAAA,EAAc,MAAM;AAAA,KACjD;AAAA,EACF;AAAA,EACA,QACE,KAAA,EACsE;AACtE,IAAA,OAAO,IAAI,0BAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,IAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,YAAA,EAAc,OAAO;AAAA,KAClD;AAAA,EACF;AAAA,EACA,KACE,IAAA,EACsD;AACtD,IAAA,OAAO,IAAI,0BAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,GAAA,CAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,MAAM;AAAA,KACnC;AAAA,EACF;AACF;AAEO,IAAM,iBAAA,GAAN,MAAM,kBAAA,SACH,aAAA,CAOV;AAAA,EAKE,KAAA,CACE,YAAwB,OAAA,EACiC;AACzD,IAAA,OAAO,IAAI,kBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,IAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,SAAA,EAAW,WAAW;AAAA,KACnD;AAAA,EACF;AAAA,EACA,MAAA,GAA2D;AACzD,IAAA,OAAO,IAAI,kBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,IAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,QAAA,EAAU,MAAM;AAAA,KAC7C;AAAA,EACF;AAAA,EACA,UAAA,GAAmE;AACjE,IAAA,OAAO,IAAI,kBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,IAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,YAAA,EAAc,MAAM;AAAA,KACjD;AAAA,EACF;AAAA,EACA,QAAQ,KAAA,EAAmE;AACzE,IAAA,OAAO,IAAI,kBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,IAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,YAAA,EAAc,OAAO;AAAA,KAClD;AAAA,EACF;AAAA,EACA,KACE,IAAA,EAC8C;AAC9C,IAAA,OAAO,IAAI,kBAAA;AAAA,MACT,IAAA,CAAK,WAAA;AAAA,MACL,GAAA,CAAI,IAAA,CAAK,cAAA,EAAgB,EAAE,MAAM;AAAA,KACnC;AAAA,EACF;AACF;AAEO,IAAM,UAAA,GAAN,cAA8C,WAAA,CAGnD;AAAA,EACS,GAAA;AAAA;AAAA,EAEQ,eAAA;AAAA,EACjB,YAAY,GAAA,EAAa;AACvB,IAAA,KAAA,CAAM,aAAA,CAAc,GAAA,CAAI,GAAG,CAAC,CAAA;AAC5B,IAAA,IAAA,CAAK,GAAA,GAAM,GAAA;AAAA,EACb;AACF;AAuCA,IAAM,QAAA,IAAY,CAAC,SAAA,EAAgB,QAAA,KAAmB;AACpD,EAAA,IAAI,GAAA,GAAW,SAAA;AACf,EAAA,IAAI,IAAA,GAA2B,MAAA;AAE/B,EAAA,IAAI,OAAO,cAAc,QAAA,EAAU;AACjC,IAAA,IAAI,CAAC,QAAA,EAAU;AACb,MAAA,MAAM,IAAI,SAAA;AAAA,QACR;AAAA,OACF;AAAA,IACF;AACA,IAAA,GAAA,GAAM,QAAA;AACN,IAAA,IAAA,GAAO,SAAA;AAAA,EACT;AAGA,EAAA,IAAI,KAAA,CAAM,OAAA,CAAQ,GAAG,CAAA,EAAG;AACtB,IAAA,MAAM,oBAAiD,EAAC;AACxD,IAAA,KAAA,MAAW,WAAW,GAAA,EAAK;AACzB,MAAA,iBAAA,CAAkB,OAAO,CAAA,GAAI,IAAI,WAAA,EAAY;AAAA,IAC/C;AACA,IAAA,OAAO,IAAI,oBAAA,CAAqB,iBAAA,EAAmB,IAAI,CAAA;AAAA,EACzD;AAGA,EAAA,OAAO,IAAI,UAAA,CAAW,GAAA,EAAK,IAAI,CAAA;AACjC,CAAA,CAAA;AAmBO,IAAM,CAAA,GAAI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMf,IAAA,EAAM,MAAmB,IAAI,WAAA,EAAY;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOzC,MAAA,EAAQ,MAAqB,IAAI,aAAA,EAAc;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAO/C,MAAA,EAAQ,MAAkB,IAAI,UAAA,EAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOzC,EAAA,EAAI,MAAiB,IAAI,SAAA,EAAU;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOnC,EAAA,EAAI,MAAiB,IAAI,SAAA,EAAU;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOnC,GAAA,EAAK,MAAkB,IAAI,UAAA,EAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOtC,GAAA,EAAK,MAAkB,IAAI,UAAA,EAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOtC,GAAA,EAAK,MAAkB,IAAI,UAAA,EAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOtC,GAAA,EAAK,MAAkB,IAAI,UAAA,EAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOtC,GAAA,EAAK,MAAkB,IAAI,UAAA,EAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOtC,GAAA,EAAK,MAAkB,IAAI,UAAA,EAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOtC,IAAA,EAAM,MAAmB,IAAI,WAAA,EAAY;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOzC,IAAA,EAAM,MAAmB,IAAI,WAAA,EAAY;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOzC,IAAA,EAAM,MAAmB,IAAI,WAAA,EAAY;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOzC,IAAA,EAAM,MAAmB,IAAI,WAAA,EAAY;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOzC,GAAA,EAAK,MAAkB,IAAI,UAAA,EAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOtC,GAAA,EAAK,MAAkB,IAAI,UAAA,EAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAatC,MAAA,GAAS,CAAC,SAAA,EAAgB,QAAA,KAAmB;AAC3C,IAAA,IAAI,OAAO,cAAc,QAAA,EAAU;AACjC,MAAA,IAAI,CAAC,QAAA,EAAU;AACb,QAAA,MAAM,IAAI,SAAA;AAAA,UACR;AAAA,SACF;AAAA,MACF;AACA,MAAA,OAAO,IAAI,cAAA,CAAe,QAAA,EAAU,SAAS,CAAA;AAAA,IAC/C;AACA,IAAA,OAAO,IAAI,cAAA,CAAe,SAAA,EAAW,MAAS,CAAA;AAAA,EAChD,CAAA,CAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAsBA,GAAA,GAAM,CACJ,SAAA,EACA,QAAA,KACoB;AACpB,IAAA,MAAM,CAAC,GAAA,EAAK,IAAI,CAAA,GACd,OAAO,SAAA,KAAc,QAAA,GACjB,CAAC,QAAA,EAAW,SAAS,CAAA,GACrB,CAAC,WAAW,MAAS,CAAA;AAC3B,IAAA,OAAO,IAAI,UAAA,CAAW,GAAA,EAAK,IAAI,CAAA;AAAA,EACjC,CAAA,CAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,MACE,CAAA,EACuB;AACvB,IAAA,OAAO,IAAI,aAAa,CAAC,CAAA;AAAA,EAC3B,CAAA;AAAA,EAEA,IAAA,EAAM,QAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAON,IAAA,GAAoB;AAClB,IAAA,OAAO,IAAI,WAAA,EAAY;AAAA,EACzB,CAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,KACE,KAAA,EACmB;AAEnB,IAAA,IAAI,MAAA,GAAmB,IAAA;AACvB,IAAA,MAAM,GAAA,GAAM,MAAU,MAAA,KAAW,KAAA,EAAM;AAEvC,IAAA,MAAM,KAAA,GAAQ,IAAI,KAAA,CAAM,EAAC,EAAmB;AAAA,MAC1C,GAAA,CAAI,EAAA,EAAI,IAAA,EAAM,IAAA,EAAM;AAClB,QAAA,MAAM,SAAS,GAAA,EAAI;AACnB,QAAA,MAAM,GAAA,GAAM,OAAA,CAAQ,GAAA,CAAI,MAAA,EAAQ,MAAM,IAAI,CAAA;AAC1C,QAAA,OAAO,OAAO,GAAA,KAAQ,UAAA,GAAa,GAAA,CAAI,IAAA,CAAK,MAAM,CAAA,GAAI,GAAA;AAAA,MACxD,CAAA;AAAA,MACA,GAAA,CAAI,EAAA,EAAI,IAAA,EAAM,KAAA,EAAO,IAAA,EAAM;AACzB,QAAA,OAAO,QAAQ,GAAA,CAAI,GAAA,EAAI,EAAU,IAAA,EAAM,OAAO,IAAI,CAAA;AAAA,MACpD,CAAA;AAAA,MACA,GAAA,CAAI,IAAI,IAAA,EAAM;AACZ,QAAA,OAAO,QAAS,GAAA,EAAI;AAAA,MACtB,CAAA;AAAA,MACA,OAAA,GAAU;AACR,QAAA,OAAO,OAAA,CAAQ,OAAA,CAAQ,GAAA,EAAY,CAAA;AAAA,MACrC,CAAA;AAAA,MACA,wBAAA,CAAyB,IAAI,IAAA,EAAM;AACjC,QAAA,OAAO,MAAA,CAAO,wBAAA,CAAyB,GAAA,EAAI,EAAU,IAAI,CAAA;AAAA,MAC3D,CAAA;AAAA,MACA,cAAA,GAAiB;AAEf,QAAA,OAAO,MAAA,CAAO,cAAA,CAAe,GAAA,EAAY,CAAA;AAAA,MAC3C;AAAA,KACD,CAAA;AAED,IAAA,OAAO,KAAA;AAAA,EACT,CAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,YAAY,MAAyB;AACnC,IAAA,OAAO,IAAI,iBAAA,EAAkB;AAAA,EAC/B,CAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,OACE,KAAA,EACsB;AACtB,IAAA,OAAO,IAAI,cAAc,KAAK,CAAA;AAAA,EAChC,CAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,MAAA,CACE,IACA,GAAA,EACwB;AACxB,IAAA,OAAO,IAAI,aAAA,CAAc,EAAA,EAAI,GAAG,CAAA;AAAA,EAClC,CAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,UAAU,MAAuB;AAC/B,IAAA,OAAO,IAAI,eAAA,EAAgB;AAAA,EAC7B,CAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,cAAc,MAA2B;AACvC,IAAA,OAAO,IAAI,mBAAA,EAAoB;AAAA,EACjC,CAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,WAAW,MAAwB;AACjC,IAAA,OAAO,IAAI,gBAAA,EAAiB;AAAA,EAC9B,CAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,cAAc,MAA2B;AACvC,IAAA,OAAO,IAAI,mBAAA,EAAoB;AAAA,EACjC,CAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,MAAmB;AACvB,IAAA,OAAO,IAAI,WAAA,EAAY;AAAA,EACzB,CAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,WAAW,MAAwB;AACjC,IAAA,OAAO,IAAI,gBAAA,EAAiB;AAAA,EAC9B;AACF;;;ACh6HO,IAAM,YAAA,GAAe,CAAA,CAAI,MAAA,CAAO,cAAA,EAAgB;AAAA,EACrD,IAAI,QAAA,GAAW;AACb,IAAA,OAAO,WAAA;AAAA,EACT,CAAA;AAAA,EACA,QAAA,EAAU,EAAI,SAAA;AAChB,CAAC,CAAA;AAGM,IAAM,aAAA,GAAgB,CAAA,CAAI,MAAA,CAAO,eAAA,EAAiB;AAAA,EACvD,SAAA,EAAW,EAAI,GAAA,EAAI;AAAA,EACnB,KAAA,EAAO,EAAI,EAAA,EAAG;AAAA,EACd,SAAA,EAAW,EAAI,MAAA,EAAO;AAAA,EACtB,IAAA,EAAM,EAAI,SAAA;AACZ,CAAC,CAAA;AAGM,IAAM,WAAA,GAAc,CAAA,CAAI,MAAA,CAAO,aAAA,EAAe;AAAA,EACnD,SAAA,EAAW,EAAI,GAAA,EAAI;AAAA,EACnB,KAAA,EAAO,EAAI,EAAA,EAAG;AAAA,EACd,OAAA,EAAS,EAAI,MAAA,EAAO;AAAA,EACpB,IAAA,EAAM,EAAI,SAAA;AACZ,CAAC,CAAA;AAIM,IAAM,aAAA,GAAgB,CAAA,CAAI,IAAA,CAAK,eAAA,EAAiB;AAAA,EACrD,IAAI,SAAA,GAAY;AACd,IAAA,OAAO,SAAA;AAAA,EACT,CAAA;AAAA,EACA,IAAI,WAAA,GAAc;AAChB,IAAA,OAAO,WAAA;AAAA,EACT,CAAA;AAAA,EACA,IAAI,WAAA,GAAc;AAChB,IAAA,OAAO,WAAA;AAAA,EACT,CAAA;AAAA,EACA,IAAI,WAAA,GAAc;AAChB,IAAA,OAAO,WAAA;AAAA,EACT,CAAA;AAAA,EACA,IAAI,aAAA,GAAgB;AAClB,IAAA,OAAO,aAAA;AAAA,EACT;AACF,CAAC,CAAA;AAGM,IAAM,cAAA,GAAiB,CAAA,CAAI,MAAA,CAAO,gBAAA,EAAkB;AAAA,EACzD,IAAI,MAAA,GAAS;AACX,IAAA,OAAO,YAAA;AAAA,EACT;AACF,CAAC,CAAA;AAGM,IAAM,iBAAA,GAAoB,CAAA,CAAI,MAAA,CAAO,mBAAA,EAAqB;AAAA,EAC/D,QAAA,EAAU,EAAI,QAAA,EAAS;AAAA,EACvB,YAAA,EAAc,EAAI,YAAA,EAAa;AAAA,EAC/B,KAAA,EAAO,EAAI,MAAA;AACb,CAAC,CAAA;AAGM,IAAM,WAAA,GAAc,CAAA,CAAI,MAAA,CAAO,aAAA,EAAe;AAAA,EACnD,SAAA,EAAW,EAAI,GAAA,EAAI;AAAA,EACnB,WAAA,EAAa,EAAI,MAAA;AACnB,CAAC,CAAA;AAGM,IAAM,iBAAA,GAAoB,CAAA,CAAI,MAAA,CAAO,mBAAA,EAAqB;AAAA,EAC/D,SAAA,EAAW,EAAI,GAAA,EAAI;AAAA,EACnB,IAAI,MAAA,GAAS;AACX,IAAA,OAAO,CAAA,CAAI,MAAA,CAAO,SAAA,EAAW,CAAA,CAAI,QAAQ,CAAA;AAAA,EAC3C;AACF,CAAC,CAAA;AAGM,IAAM,mBAAA,GAAsB,CAAA,CAAI,MAAA,CAAO,qBAAA,EAAuB;AAAA,EACnE,IAAI,OAAA,GAAU;AACZ,IAAA,OAAO,YAAA;AAAA,EACT,CAAA;AAAA,EACA,IAAI,OAAA,GAAU;AACZ,IAAA,OAAO,YAAA;AAAA,EACT;AACF,CAAC,CAAA;AAGM,IAAM,eAAA,GAAkB,CAAA,CAAI,MAAA,CAAO,iBAAA,EAAmB;AAAA,EAC3D,IAAI,MAAA,GAAS;AACX,IAAA,OAAO,eAAA;AAAA,EACT,CAAA;AAAA,EACA,SAAA,EAAW,EAAI,SAAA,EAAU;AAAA,EACzB,0BAAA,EAA4B,EAAI,YAAA,EAAa;AAAA,EAC7C,SAAA,EAAW,EAAI,GAAA;AACjB,CAAC,CAAA;AAIM,IAAM,eAAA,GAAkB,CAAA,CAAI,IAAA,CAAK,iBAAA,EAAmB;AAAA,EACzD,QAAA,EAAU,EAAI,SAAA,EAAU;AAAA,EACxB,aAAA,EAAe,EAAI,MAAA;AACrB,CAAC,CAAA;AAGM,IAAM,SAAA,GAAY,CAAA,CAAI,MAAA,CAAO,WAAA,EAAa;AAAA,EAC/C,IAAI,MAAA,GAAS;AACX,IAAA,OAAO,CAAA,CAAI,MAAM,eAAe,CAAA;AAAA,EAClC;AACF,CAAC,CAAA;AAGM,IAAM,UAAA,GAAa,CAAA,CAAI,MAAA,CAAO,YAAA,EAAc;AAAA,EACjD,EAAA,EAAI,EAAI,GAAA;AACV,CAAC,CAAA;AAGM,IAAM,cAAA,GAAiB,CAAA,CAAI,MAAA,CAAO,gBAAA,EAAkB;AAAA,EACzD,IAAI,UAAA,GAAa;AACf,IAAA,OAAO,UAAA;AAAA,EACT,CAAA;AAAA,EACA,IAAI,MAAA,GAAS;AACX,IAAA,OAAO,CAAA,CAAI,MAAM,WAAW,CAAA;AAAA,EAC9B;AACF,CAAC,CAAA;AAGM,IAAM,SAAA,GAAY,CAAA,CAAI,MAAA,CAAO,WAAA,EAAa;AAAA,EAC/C,QAAA,EAAU,EAAI,SAAA,EAAU;AAAA,EACxB,IAAI,iBAAA,GAAoB;AACtB,IAAA,OAAO,iBAAA;AAAA,EACT;AACF,CAAC,CAAA;AAIM,IAAM,cAAA,GAAiB,CAAA,CAAI,IAAA,CAAK,gBAAA,EAAkB;AAAA,EACvD,IAAI,EAAA,GAAK;AACP,IAAA,OAAO,SAAA;AAAA,EACT,CAAA;AAAA,EACA,OAAA,EAAS,EAAI,IAAA,EAAK;AAAA,EAClB,GAAA,EAAK,EAAI,SAAA,EAAU;AAAA,EACnB,aAAA,EAAe,EAAI,MAAA;AACrB,CAAC,CAAA;AAGM,IAAM,aAAA,GAAgB,CAAA,CAAI,MAAA,CAAO,eAAA,EAAiB;AAAA,EACvD,SAAA,EAAW,EAAI,GAAA,EAAI;AAAA,EACnB,SAAA,EAAW,EAAI,SAAA,EAAU;AAAA,EACzB,IAAI,MAAA,GAAS;AACX,IAAA,OAAO,cAAA;AAAA,EACT;AACF,CAAC,CAAA;AAIM,IAAM,WAAA,GAAc,CAAA,CAAI,IAAA,CAAK,aAAA,EAAe;AAAA,EACjD,SAAA,EAAW,EAAI,GAAA,EAAI;AAAA,EACnB,UAAA,EAAY,CAAA,CAAI,KAAA,CAAM,CAAA,CAAI,KAAK;AACjC,CAAC,CAAA;AAIM,IAAM,aAAA,GAAgB,CAAA,CAAI,IAAA,CAAK,eAAA,EAAiB;AAAA,EACrD,IAAI,iBAAA,GAAoB;AACtB,IAAA,OAAO,iBAAA;AAAA,EACT,CAAA;AAAA,EACA,IAAI,gBAAA,GAAmB;AACrB,IAAA,OAAO,gBAAA;AAAA,EACT,CAAA;AAAA,EACA,IAAI,kBAAA,GAAqB;AACvB,IAAA,OAAO,kBAAA;AAAA,EACT,CAAA;AAAA,EACA,IAAI,iBAAA,GAAoB;AACtB,IAAA,OAAO,iBAAA;AAAA,EACT,CAAA;AAAA,EACA,IAAI,iBAAA,GAAoB;AACtB,IAAA,OAAO,iBAAA;AAAA,EACT,CAAA;AAAA,EACA,IAAI,iBAAA,GAAoB;AACtB,IAAA,OAAO,iBAAA;AAAA,EACT,CAAA;AAAA,EACA,IAAI,aAAA,GAAgB;AAClB,IAAA,OAAO,aAAA;AAAA,EACT,CAAA;AAAA,EACA,IAAI,eAAA,GAAkB;AACpB,IAAA,OAAO,eAAA;AAAA,EACT;AACF,CAAC,CAAA;AAGM,IAAM,eAAA,GAAkB,CAAA,CAAI,MAAA,CAAO,iBAAA,EAAmB;AAAA,EAC3D,KAAA,EAAO,EAAI,MAAA,EAAO;AAAA,EAClB,IAAI,IAAA,GAAO;AACT,IAAA,OAAO,YAAA;AAAA,EACT;AACF,CAAC,CAAA;AAGM,IAAM,SAAA,GAAY,CAAA,CAAI,MAAA,CAAO,WAAA,EAAa;AAAA,EAC/C,SAAA,EAAW,EAAI,GAAA,EAAI;AAAA,EACnB,IAAI,UAAA,GAAa;AACf,IAAA,OAAO,UAAA;AAAA,EACT,CAAA;AAAA,EACA,YAAA,EAAc,CAAA,CAAI,KAAA,CAAM,CAAA,CAAI,QAAQ;AACtC,CAAC,CAAA;AAGM,IAAM,gBAAA,GAAmB,CAAA,CAAI,MAAA,CAAO,kBAAA,EAAoB;AAAA,EAC7D,SAAA,EAAW,EAAI,GAAA,EAAI;AAAA,EACnB,IAAI,UAAA,GAAa;AACf,IAAA,OAAO,UAAA;AAAA,EACT,CAAA;AAAA,EACA,IAAI,IAAA,GAAO;AACT,IAAA,OAAO,SAAA;AAAA,EACT;AACF,CAAC,CAAA;AAGM,IAAM,iBAAA,GAAoB,CAAA,CAAI,MAAA,CAAO,mBAAA,EAAqB;AAAA,EAC/D,SAAA,EAAW,CAAA,CAAI,MAAA,CAAO,CAAA,CAAI,KAAK,CAAA;AAAA,EAC/B,IAAI,UAAA,GAAa;AACf,IAAA,OAAO,UAAA;AAAA,EACT,CAAA;AAAA,EACA,KAAA,EAAO,EAAI,MAAA;AACb,CAAC,CAAA;AAGM,IAAM,WAAA,GAAc,CAAA,CAAI,MAAA,CAAO,aAAA,EAAe;AAAA,EACnD,SAAA,EAAW,EAAI,MAAA,EAAO;AAAA,EACtB,IAAI,IAAA,GAAO;AACT,IAAA,OAAO,CAAA,CAAI,MAAM,eAAe,CAAA;AAAA,EAClC;AACF,CAAC,CAAA;AAIM,IAAM,eAAA,GAAkB,CAAA,CAAI,IAAA,CAAK,iBAAA,EAAmB;AAAA,EACzD,IAAI,eAAA,GAAkB;AACpB,IAAA,OAAO,mBAAA;AAAA,EACT,CAAA;AAAA,EACA,IAAI,UAAA,GAAa;AACf,IAAA,OAAO,cAAA;AAAA,EACT;AACF,CAAC,CAAA;AAGM,IAAM,iBAAA,GAAoB,CAAA,CAAI,MAAA,CAAO,mBAAA,EAAqB;AAAA,EAC/D,IAAI,SAAA,GAAY;AACd,IAAA,OAAO,CAAA,CAAI,MAAM,cAAc,CAAA;AAAA,EACjC;AACF,CAAC,CAAA;AAGM,IAAM,WAAA,GAAc,CAAA,CAAI,MAAA,CAAO,aAAA,EAAe;AAAA,EACnD,SAAA,EAAW,EAAI,GAAA,EAAI;AAAA,EACnB,IAAI,UAAA,GAAa;AACf,IAAA,OAAO,UAAA;AAAA,EACT,CAAA;AAAA,EACA,IAAI,KAAA,GAAQ;AACV,IAAA,OAAO,gBAAA;AAAA,EACT;AACF,CAAC,CAAA;AAGM,IAAM,kBAAA,GAAqB,CAAA,CAAI,MAAA,CAAO,oBAAA,EAAsB;AAAA,EACjE,SAAA,EAAW,EAAI,GAAA,EAAI;AAAA,EACnB,IAAI,UAAA,GAAa;AACf,IAAA,OAAO,UAAA;AAAA,EACT,CAAA;AAAA,EACA,IAAI,IAAA,GAAO;AACT,IAAA,OAAO,CAAA,CAAI,OAAO,SAAS,CAAA;AAAA,EAC7B;AACF,CAAC,CAAA;AAIM,IAAM,gBAAA,GAAmB,CAAA,CAAI,IAAA,CAAK,kBAAA,EAAoB;AAAA,EAC3D,OAAA,EAAS,EAAI,IAAA,EAAK;AAAA,EAClB,eAAA,EAAiB,EAAI,IAAA;AACvB,CAAC,CAAA;;;AC7RM,IAAM,eAAN,MAA8D;AAAA,EACnE,OAAA,uBAAuC,GAAA,EAAI;AAAA,EAE3C,EAAA,CAAG,OAAY,QAAA,EAA0B;AACvC,IAAA,IAAI,SAAA,GAAY,IAAA,CAAK,OAAA,CAAQ,GAAA,CAAI,KAAK,CAAA;AACtC,IAAA,IAAI,CAAC,SAAA,EAAW;AACd,MAAA,SAAA,uBAAgB,GAAA,EAAI;AACpB,MAAA,IAAA,CAAK,OAAA,CAAQ,GAAA,CAAI,KAAA,EAAO,SAAS,CAAA;AAAA,IACnC;AACA,IAAA,SAAA,CAAU,IAAI,QAAQ,CAAA;AAAA,EACxB;AAAA,EAEA,GAAA,CAAI,OAAY,QAAA,EAA0B;AACxC,IAAA,MAAM,SAAA,GAAY,IAAA,CAAK,OAAA,CAAQ,GAAA,CAAI,KAAK,CAAA;AACxC,IAAA,IAAI,CAAC,SAAA,EAAW;AACd,MAAA;AAAA,IACF;AACA,IAAA,SAAA,CAAU,OAAO,QAAQ,CAAA;AAAA,EAC3B;AAAA,EAEA,IAAA,CAAK,UAAe,IAAA,EAAmB;AACrC,IAAA,MAAM,SAAA,GAAY,IAAA,CAAK,OAAA,CAAQ,GAAA,CAAI,KAAK,CAAA;AACxC,IAAA,IAAI,CAAC,SAAA,EAAW;AACd,MAAA;AAAA,IACF;AAEA,IAAA,KAAA,MAAW,YAAY,SAAA,EAAW;AAChC,MAAA,QAAA,CAAS,GAAG,IAAI,CAAA;AAAA,IAClB;AAAA,EACF;AACF,CAAA;AC3BA,IAAM,sBAAA,GAAyB;AAAA,EAC7B,SAAA,EAAW,WAAA;AAAA,EACX,IAAA,EAAM,cAAA;AAAA,EACN,IAAA,EAAM,cAAA;AAAA,EACN,KAAA,EAAO,QAAA;AAAA,EACP,KAAA,EAAO,WAAA;AAAA,EACP,KAAA,EAAO;AACT,CAAA;AAEA,IAAM,QAAA,GAAW;AAAA,EACf,SAAA,EACE,+EAAA;AAAA,EACF,IAAA,EAAM,+EAAA;AAAA,EACN,IAAA,EAAM,+EAAA;AAAA,EACN,KAAA,EACE,+EAAA;AAAA,EACF,KAAA,EACE,+EAAA;AAAA,EACF,KAAA,EACE;AACJ,CAAA;AAEA,IAAM,YAAA,GAAe;AAAA,EACnB,SAAA,EAAW,iBAAA;AAAA,EACX,IAAA,EAAM,iBAAA;AAAA,EACN,IAAA,EAAM,iBAAA;AAAA,EACN,KAAA,EAAO,iBAAA;AAAA,EACP,KAAA,EAAO,iBAAA;AAAA,EACP,KAAA,EAAO;AACT,CAAA;AAEA,IAAM,YAAA,GAAyC;AAAA,EAC7C,KAAA,EAAO,CAAA;AAAA,EACP,IAAA,EAAM,CAAA;AAAA,EACN,IAAA,EAAM,CAAA;AAAA,EACN,KAAA,EAAO,CAAA;AAAA,EACP,KAAA,EAAO;AACT,CAAA;AAEA,IAAI,cAAA,GAA2B,MAAA;AAExB,IAAM,iBAAA,GAAoB,CAAC,KAAA,KAA0B;AAC1D,EAAA,cAAA,GAAiB,KAAA;AACnB;AAEO,IAAM,oBAAoB,MAAgB;AAEjD,IAAM,YAAY,CAAC,KAAA,KACjB,aAAa,KAAK,CAAA,IAAK,aAAa,cAAc,CAAA;AAIpD,IAAM,cAAc,CAAI,CAAA,KACtB,OAAO,CAAA,KAAM,UAAA,GAAc,GAAc,GAAI,CAAA;AAE/C,IAAM,QAAQ,CAAC,KAAA,KACb,MAAM,IAAA,CAAK,KAAK,EACb,GAAA,CAAI,CAAA,CAAA,KAAK,EAAE,QAAA,CAAS,EAAE,EAAE,QAAA,CAAS,CAAA,EAAG,GAAG,CAAC,CAAA,CACxC,KAAK,EAAE,CAAA;AACZ,IAAM,0BAAA,GAA6B,EAAA;AACnC,IAAM,mBAAA,GAAsB,EAAA;AAE5B,IAAM,cAAA,uBAAqB,GAAA,CAAI;AAAA,EAC7B,OAAA;AAAA,EACA,WAAA;AAAA,EACA,eAAA;AAAA,EACA,aAAA;AAAA,EACA;AACF,CAAC,CAAA;AAEM,IAAM,YAAY,CAAC,KAAA,KACxBC,YAAY,KAAA,EAAO,CAAC,KAAK,OAAA,KAAY;AACnC,EAAA,IAAI,cAAA,CAAe,GAAA,CAAI,GAAG,CAAA,EAAG;AAC3B,IAAA,OAAO,YAAA;AAAA,EACT;AACA,EAAA,IACE,OAAA,IACA,OAAO,OAAA,KAAY,QAAA,IACnB,kBAAkB,OAAA,IAClB,OAAQ,OAAA,CAAsC,YAAA,KAAiB,QAAA,EAC/D;AACA,IAAA,OAAO,eAAA;AAAA,MACJ,OAAA,CAAqC;AAAA,KACxC;AAAA,EACF;AACA,EAAA,IACE,OAAA,IACA,OAAO,OAAA,KAAY,QAAA,IACnB,uBAAuB,OAAA,IACvB,OAAQ,OAAA,CAA2C,iBAAA,KACjD,QAAA,EACF;AACA,IAAA,OAAO,eAAA;AAAA,MACJ,OAAA,CAA0C;AAAA,KAC7C;AAAA,EACF;AACA,EAAA,IAAI,mBAAmB,UAAA,EAAY;AACjC,IAAA,IAAI,OAAA,CAAQ,SAAS,EAAA,EAAI;AACvB,MAAA,OAAO,CAAA,EAAA,EAAK,KAAA,CAAM,OAAO,CAAC,CAAA,CAAA;AAAA,IAC5B;AACA,IAAA,MAAM,IAAA,GAAO,OAAA,CAAQ,QAAA,CAAS,CAAA,EAAG,EAAE,CAAA;AACnC,IAAA,OAAO,kBAAkB,OAAA,CAAQ,MAAM,CAAA,SAAA,EAAY,KAAA,CAAM,IAAI,CAAC,CAAA,CAAA,CAAA;AAAA,EAChE;AACA,EAAA,IACE,MAAM,OAAA,CAAQ,OAAO,CAAA,IACrB,OAAA,CAAQ,UAAU,0BAAA,EAClB;AACA,IAAA,MAAM,OAAOA,WAAA,CAAY,OAAA,CAAQ,KAAA,CAAM,CAAA,EAAG,mBAAmB,CAAC,CAAA;AAC9D,IAAA,OAAO,CAAA,UAAA,EAAa,OAAA,CAAQ,MAAM,CAAA,OAAA,EAAU,QAAQ,IAAI,CAAA,CAAA,CAAA;AAAA,EAC1D;AACA,EAAA,OAAO,OAAA;AACT,CAAC;AAEI,IAAM,UAAA,GAAa,CACxB,KAAA,EACA,OAAA,EAAA,GACG,IAAA,KACM;AACT,EAAA,IAAI,CAAC,SAAA,CAAU,KAAK,CAAA,EAAG;AACrB,IAAA;AAAA,EACF;AACA,EAAA,MAAM,eAAA,GAAkB,YAAY,OAAO,CAAA;AAC3C,EAAA,MAAM,YAAA,GAAe,IAAA,CAAK,GAAA,CAAI,WAAW,CAAA;AACzC,EAAA,OAAA,CAAQ,GAAA;AAAA,IACN,CAAA,EAAA,EAAK,uBAAuB,KAAK,CAAC,IAAI,KAAA,CAAM,WAAA,EAAa,CAAA,GAAA,EAAM,eAAe,CAAA,CAAA;AAAA,IAC9E,SAAS,KAAK,CAAA;AAAA,IACd,aAAa,KAAK,CAAA;AAAA,IAClB,GAAG;AAAA,GACL;AACF;;;AC5FA,IAAM,aAAA,GAAgB,CAAC,CAAA,EAAQ,CAAA,KAAmB;AAChD,EAAA,IAAI,CAAA,KAAM,GAAG,OAAO,CAAA;AAEpB,EAAA,OAAO,CAAA,GAAI,IAAI,EAAA,GAAK,CAAA;AACtB,CAAA;AAmBO,IAAM,iBAAN,MAIP;AAAA,EACU,IAAA;AAAA,EAIA,QAAA;AAAA,EACA,OAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQR,YAAY,QAAA,EAAyD;AACnE,IAAA,IAAA,CAAK,QAAA,GAAW,QAAA;AAChB,IAAA,IAAA,CAAK,IAAA,uBAAW,GAAA,EAAI;AACpB,IAAA,IAAA,CAAK,OAAA,GAAU,IAAI,YAAA,EAAa;AAEhC,IAAA,MAAM,UAAA,GAAa,IAAA,CAAK,QAAA,CAAS,OAAA,IAAW,EAAC;AAC7C,IAAA,KAAA,MAAW,OAAO,UAAA,EAAY;AAE5B,MAAA,MAAM,MAAA,GAAS,GAAA;AAGf,MAAA,MAAM,KAAA,GAAQ,IAAA,CAAK,kBAAA,CAAmB,IAAA,CAAK,UAAU,MAAM,CAAA;AAC3D,MAAC,IAAA,CAAa,MAAA,CAAO,IAAI,CAAA,GAAI,KAAA;AAAA,IAC/B;AAAA,EACF;AAAA;AAAA,EAGA,kBAAA,CAKE,UACA,GAAA,EACiE;AAKjE,IAAA,IAAI,GAAA,CAAI,cAAc,OAAA,EAAS;AAC7B,MAAA,MAAM,IAAI,MAAM,oDAAoD,CAAA;AAAA,IACtE;AAEA,IAAA,MAAM,UAAU,GAAA,CAAI,OAAA;AAGpB,IAAA,MAAM,MAAA,GAAS,CAAC,GAAA,KAAiC,OAAA,CAAQ,IAAI,CAAA,CAAA,KAAK,GAAA,CAAI,CAAC,CAAC,CAAA;AASxE,IAAA,MAAM,UAAA,GAAa,CAAC,GAAA,EAAU,QAAA,KAA2B;AACvD,MAAA,MAAM,GAAA,GAAM,OAAO,GAAG,CAAA;AAItB,MAAA,MAAM,MAAM,KAAA,CAAM,OAAA,CAAQ,QAAQ,CAAA,GAAI,QAAA,GAAW,CAAC,QAAQ,CAAA;AAE1D,MAAA,MAAM,YAAY,IAAA,CAAK,GAAA,CAAI,CAAA,EAAG,GAAA,CAAI,SAAS,CAAC,CAAA;AAE5C,MAAA,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,SAAA,EAAW,CAAA,EAAA,EAAK;AAClC,QAAA,IAAI,CAAC,UAAU,GAAA,CAAI,CAAC,GAAG,GAAA,CAAI,CAAC,CAAC,CAAA,EAAG,OAAO,KAAA;AAAA,MACzC;AAEA,MAAA,MAAM,YAAA,GAAe,GAAA,CAAI,GAAA,CAAI,MAAA,GAAS,CAAC,CAAA;AACvC,MAAA,MAAM,KAAA,GAAQ,IAAI,SAAS,CAAA;AAG3B,MAAA,IACE,gBACA,OAAO,YAAA,KAAiB,YACxB,MAAA,IAAU,YAAA,IACV,QAAQ,YAAA,EACR;AAEA,QAAA,MAAM,OAAO,YAAA,CAAa,IAAA;AAC1B,QAAA,MAAM,KAAK,YAAA,CAAa,EAAA;AAGxB,QAAA,IAAI,IAAA,CAAK,QAAQ,WAAA,EAAa;AAC5B,UAAA,MAAM,CAAA,GAAI,aAAA,CAAc,KAAA,EAAO,IAAA,CAAK,KAAK,CAAA;AACzC,UAAA,IAAI,CAAA,GAAI,GAAG,OAAO,KAAA;AAClB,UAAA,IAAI,CAAA,KAAM,CAAA,IAAK,IAAA,CAAK,GAAA,KAAQ,YAAY,OAAO,KAAA;AAAA,QACjD;AAGA,QAAA,IAAI,EAAA,CAAG,QAAQ,WAAA,EAAa;AAC1B,UAAA,MAAM,CAAA,GAAI,aAAA,CAAc,KAAA,EAAO,EAAA,CAAG,KAAK,CAAA;AACvC,UAAA,IAAI,CAAA,GAAI,GAAG,OAAO,KAAA;AAClB,UAAA,IAAI,CAAA,KAAM,CAAA,IAAK,EAAA,CAAG,GAAA,KAAQ,YAAY,OAAO,KAAA;AAAA,QAC/C;AAIA,QAAA,OAAO,IAAA;AAAA,MACT,CAAA,MAAO;AAEL,QAAA,IAAI,CAAC,SAAA,CAAU,KAAA,EAAO,YAAY,GAAG,OAAO,KAAA;AAE5C,QAAA,OAAO,IAAA;AAAA,MACT;AAAA,IACF,CAAA;AAGA,IAAA,MAAM,QAAA,GAAW,QAAA,CAAS,WAAA,CAAY,IAAA,CAAK,CAAA,UAAA,KAAc;AACvD,MAAA,IAAI,UAAA,CAAW,eAAe,QAAA,EAAU;AACtC,QAAA,OAAO,KAAA;AAAA,MACT;AACA,MAAA,OAAO,SAAA,CAAU,UAAA,CAAW,OAAA,EAAS,GAAA,CAAI,OAAO,CAAA;AAAA,IAClD,CAAC,CAAA;AAGD,IAAA,MAAM,IAAA,GAAO,IAAA;AACb,IAAA,IAAI,QAAA,EAAU;AACZ,MAAA,MAAM,IAAA,GAAyC;AAAA,QAC7C,IAAA,EAAM,CAAC,MAAA,KAA4B;AAEjC,UAAA,MAAM,WAAW,KAAA,CAAM,OAAA,CAAQ,MAAM,CAAA,GAAI,MAAA,GAAS,CAAC,MAAM,CAAA;AACzD,UAAA,KAAA,MAAW,GAAA,IAAO,IAAA,CAAK,IAAA,EAAK,EAAG;AAC7B,YAAA,IAAI,UAAU,MAAA,CAAO,GAAG,CAAA,EAAG,QAAQ,GAAG,OAAO,GAAA;AAAA,UAC/C;AACA,UAAA,OAAO,IAAA;AAAA,QACT;AAAA,OACF;AACA,MAAA,OAAO,IAAA;AAAA,IACT,CAAA,MAAO;AACL,MAAA,MAAM,IAAA,GAAyC;AAAA,QAC7C,CAAC,OAAO,KAAA,EAA4C;AAClD,UAAA,KAAA,MAAW,GAAA,IAAO,IAAA,CAAK,IAAA,EAAK,EAAG;AAC7B,YAAA,IAAI,UAAA,CAAW,GAAA,EAAK,KAAK,CAAA,EAAG,MAAM,GAAA;AAAA,UACpC;AAAA,QACF;AAAA,OACF;AACA,MAAA,OAAO,IAAA;AAAA,IACT;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,KAAA,GAAgB;AACd,IAAA,OAAO,MAAA,CAAO,IAAA,CAAK,IAAA,CAAK,IAAI,CAAA;AAAA,EAC9B;AAAA;AAAA;AAAA;AAAA,EAKA,IAAA,GAGE;AACA,IAAA,UAAU,UACR,IAAA,EAOA;AACA,MAAA,KAAA,MAAW,CAAC,GAAG,CAAA,IAAK,IAAA,CAAK,QAAO,EAAG;AACjC,QAAA,MAAM,GAAA;AAAA,MAGR;AAAA,IACF;AACA,IAAA,OAAO,SAAA,CAAU,KAAK,IAAI,CAAA;AAAA,EAC5B;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,CAAC,MAAA,CAAO,QAAQ,CAAA,GAGd;AACA,IAAA,OAAO,KAAK,IAAA,EAAK;AAAA,EACnB;AAAA,EAEA,eAAA,GAAkB,CAChB,UAAA,EAGA,GAAA,KACsB;AACtB,IAAA,MAAM,mBAAsC,EAAC;AAG7C,IAAA,IAAI,IAAA,CAAK,SAAS,OAAA,EAAS;AACzB,MAAA,KAAA,MAAW,MAAM,UAAA,EAAY;AAC3B,QAAA,IAAI,EAAA,CAAG,SAAS,QAAA,EAAU;AACxB,UAAA,gBAAA,CAAiB,IAAA,CAAK;AAAA,YACpB,IAAA,EAAM,QAAA;AAAA,YACN,KAAA,EAAO,KAAK,QAAA,CAAS,UAAA;AAAA,YACrB,IAAI,MAAM;AACR,cAAA,IAAA,CAAK,OAAA,CAAQ,IAAA,CAAK,QAAA,EAAU,GAAA,EAAK,GAAG,GAAG,CAAA;AAAA,YACzC;AAAA,WACD,CAAA;AAAA,QACH;AAAA,MACF;AACA,MAAA,OAAO,gBAAA;AAAA,IACT;AAGA,IAAA,MAAM,gBAAgB,MAAA,CAAO,MAAA,CAAO,IAAA,CAAK,QAAA,CAAS,OAAO,CAAA,CAAE,IAAA;AAAA,MACzD,CAAA,GAAA,KAAO,GAAA,CAAI,cAAA,CAAe,YAAA,KAAiB;AAAA,KAC7C;AACA,IAAA,IAAI,aAAA,EAAe;AACjB,MAAA,MAAM,SAAA,uBAAgB,GAAA,EAMpB;AACF,MAAA,MAAM,SAAA,uBAAgB,GAAA,EAMpB;AACF,MAAA,KAAA,MAAW,MAAM,UAAA,EAAY;AAC3B,QAAA,IAAI,EAAA,CAAG,SAAS,QAAA,EAAU;AACxB,UAAA,MAAM,CAAC,CAAA,EAAG,SAAS,CAAA,GAAI,SAAA,CAAU,GAAA,CAAI,EAAA,CAAG,KAAK,CAAA,IAAK,CAAC,EAAA,EAAI,CAAC,CAAA;AACxD,UAAA,SAAA,CAAU,IAAI,EAAA,CAAG,KAAA,EAAO,CAAC,EAAA,EAAI,SAAA,GAAY,CAAC,CAAC,CAAA;AAAA,QAC7C,CAAA,MAAO;AACL,UAAA,MAAM,CAAC,CAAA,EAAG,SAAS,CAAA,GAAI,SAAA,CAAU,GAAA,CAAI,EAAA,CAAG,KAAK,CAAA,IAAK,CAAC,EAAA,EAAI,CAAC,CAAA;AACxD,UAAA,SAAA,CAAU,IAAI,EAAA,CAAG,KAAA,EAAO,CAAC,EAAA,EAAI,SAAA,GAAY,CAAC,CAAC,CAAA;AAAA,QAC7C;AAAA,MACF;AACA,MAAA,KAAA,MAAW,CAAC,UAAA,EAAY,CAAC,UAAU,QAAQ,CAAC,KAAK,SAAA,EAAW;AAC1D,QAAA,MAAM,WAAA,GAAc,SAAA,CAAU,GAAA,CAAI,UAAU,CAAA;AAC5C,QAAA,IAAI,WAAA,EAAa;AACf,UAAA,MAAM,CAAC,CAAA,EAAG,WAAW,CAAA,GAAI,WAAA;AAIzB,UAAA,MAAM,gBAAgB,QAAA,GAAW,WAAA;AACjC,UAAA,MAAM,UAAU,IAAA,CAAK,MAAA;AAAA,YACnB,GAAA;AAAA,YACA,UAAA;AAAA,YACA,QAAA,CAAS,GAAA;AAAA,YACT;AAAA,WACF;AACA,UAAA,IAAI,OAAA,EAAS;AACX,YAAA,gBAAA,CAAiB,KAAK,OAAO,CAAA;AAAA,UAC/B;AACA,UAAA,SAAA,CAAU,OAAO,UAAU,CAAA;AAAA,QAC7B,CAAA,MAAO;AACL,UAAA,MAAM,OAAA,GAAU,IAAA,CAAK,MAAA,CAAO,GAAA,EAAK,UAAU,QAAQ,CAAA;AACnD,UAAA,IAAI,OAAA,EAAS;AACX,YAAA,gBAAA,CAAiB,KAAK,OAAO,CAAA;AAAA,UAC/B;AAAA,QACF;AAAA,MACF;AACA,MAAA,KAAA,MAAW,CAAC,QAAA,EAAU,QAAQ,CAAA,IAAK,SAAA,CAAU,QAAO,EAAG;AACrD,QAAA,MAAM,OAAA,GAAU,IAAA,CAAK,MAAA,CAAO,GAAA,EAAK,UAAU,QAAQ,CAAA;AACnD,QAAA,IAAI,OAAA,EAAS;AACX,UAAA,gBAAA,CAAiB,KAAK,OAAO,CAAA;AAAA,QAC/B;AAAA,MACF;AAAA,IACF,CAAA,MAAO;AACL,MAAA,KAAA,MAAW,MAAM,UAAA,EAAY;AAC3B,QAAA,IAAI,EAAA,CAAG,SAAS,QAAA,EAAU;AACxB,UAAA,MAAM,OAAA,GAAU,IAAA,CAAK,MAAA,CAAO,GAAA,EAAK,EAAE,CAAA;AACnC,UAAA,IAAI,OAAA,EAAS;AACX,YAAA,gBAAA,CAAiB,KAAK,OAAO,CAAA;AAAA,UAC/B;AAAA,QACF,CAAA,MAAO;AACL,UAAA,MAAM,OAAA,GAAU,IAAA,CAAK,MAAA,CAAO,GAAA,EAAK,EAAE,CAAA;AACnC,UAAA,IAAI,OAAA,EAAS;AACX,YAAA,gBAAA,CAAiB,KAAK,OAAO,CAAA;AAAA,UAC/B;AAAA,QACF;AAAA,MACF;AAAA,IACF;AACA,IAAA,OAAO,gBAAA;AAAA,EACT,CAAA;AAAA,EAEA,SAAS,CACP,GAAA,EACA,KAAA,EACA,MAAA,EACA,gBAAwB,CAAA,KACQ;AAChC,IAAA,MAAM,aAAA,GAAgB,IAAA,CAAK,IAAA,CAAK,GAAA,CAAI,KAAK,CAAA;AACzC,IAAA,IAAI,CAAC,aAAA,EAAe;AAElB,MAAA,UAAA;AAAA,QACE,OAAA;AAAA,QACA,CAAA,yDAAA,EAA4D,IAAA,CAAK,QAAA,CAAS,UAAU,YAAY,KAAK,CAAA;AAAA,OACvG;AACA,MAAA,OAAO,MAAA;AAAA,IACT;AACA,IAAA,MAAM,CAAC,MAAA,EAAQ,aAAa,CAAA,GAAI,aAAA;AAChC,IAAA,MAAM,QAAA,GAAW,IAAA,CAAK,GAAA,CAAI,CAAA,EAAG,gBAAgB,aAAa,CAAA;AAC1D,IAAA,IAAI,aAAA,GAAgB,iBAAiB,CAAA,EAAG;AACtC,MAAA,UAAA;AAAA,QACE,OAAA;AAAA,QACA,CAAA,sCAAA,EAAyC,KAAK,QAAA,CAAS,UAAU,QAAQ,KAAK,CAAA,EAAA,EAAK,aAAa,CAAA,GAAA,EAAM,aAAa,CAAA,CAAA;AAAA,OACrH;AACA,MAAA,OAAO,MAAA;AAAA,IACT;AACA,IAAA,IAAA,CAAK,KAAK,GAAA,CAAI,KAAA,EAAO,CAAC,MAAA,EAAQ,QAAQ,CAAC,CAAA;AAEvC,IAAA,IAAI,kBAAkB,CAAA,EAAG;AACvB,MAAA,UAAA;AAAA,QACE,OAAA;AAAA,QACA,CAAA,2BAAA,EAA8B,IAAA,CAAK,QAAA,CAAS,UAAU,+CAA+C,KAAK,CAAA,CAAA;AAAA,OAC5G;AACA,MAAA,OAAO;AAAA,QACL,IAAA,EAAM,QAAA;AAAA,QACN,KAAA,EAAO,KAAK,QAAA,CAAS,UAAA;AAAA,QACrB,IAAI,MAAM;AACR,UAAA,IAAA,CAAK,OAAA,CAAQ,IAAA,CAAK,QAAA,EAAU,GAAA,EAAK,MAAM,CAAA;AAAA,QACzC;AAAA,OACF;AAAA,IACF;AACA,IAAA,OAAO;AAAA,MACL,IAAA,EAAM,QAAA;AAAA,MACN,KAAA,EAAO,KAAK,QAAA,CAAS,UAAA;AAAA,MACrB,IAAI,MAAM;AACR,QAAA,IAAA,CAAK,OAAA,CAAQ,IAAA,CAAK,QAAA,EAAU,GAAA,EAAK,QAAQ,MAAM,CAAA;AAAA,MACjD;AAAA,KACF;AAAA,EACF,CAAA;AAAA,EAEA,MAAA,GAAS,CACP,GAAA,EACA,SAAA,EAGA,QAAgB,CAAA,KACgB;AAChC,IAAA,MAAM,CAAC,GAAG,aAAa,CAAA,GAAI,KAAK,IAAA,CAAK,GAAA,CAAI,SAAA,CAAU,KAAK,CAAA,IAAK;AAAA,MAC3D,SAAA,CAAU,GAAA;AAAA,MACV;AAAA,KACF;AACA,IAAA,IAAA,CAAK,IAAA,CAAK,IAAI,SAAA,CAAU,KAAA,EAAO,CAAC,SAAA,CAAU,GAAA,EAAK,aAAA,GAAgB,KAAK,CAAC,CAAA;AACrE,IAAA,IAAI,kBAAkB,CAAA,EAAG;AACvB,MAAA,OAAO;AAAA,QACL,IAAA,EAAM,QAAA;AAAA,QACN,KAAA,EAAO,KAAK,QAAA,CAAS,UAAA;AAAA,QACrB,IAAI,MAAM;AACR,UAAA,IAAA,CAAK,OAAA,CAAQ,IAAA,CAAK,QAAA,EAAU,GAAA,EAAK,UAAU,GAAG,CAAA;AAAA,QAChD;AAAA,OACF;AAAA,IACF;AAEA,IAAA,OAAO,MAAA;AAAA,EACT,CAAA;AAAA,EAEA,MAAA,GAAS,CACP,GAAA,EACA,SAAA,EAGA,QAAgB,CAAA,KACgB;AAChC,IAAA,MAAM,CAAC,GAAG,aAAa,CAAA,GAAI,KAAK,IAAA,CAAK,GAAA,CAAI,SAAA,CAAU,KAAK,CAAA,IAAK;AAAA,MAC3D,SAAA,CAAU,GAAA;AAAA,MACV;AAAA,KACF;AAEA,IAAA,IAAI,kBAAkB,CAAA,EAAG;AACvB,MAAA,UAAA,CAAW,QAAQ,kDAAkD,CAAA;AACrE,MAAA,OAAO,MAAA;AAAA,IACT;AAEA,IAAA,IAAI,iBAAiB,KAAA,EAAO;AAE1B,MAAA,IAAA,CAAK,IAAA,CAAK,MAAA,CAAO,SAAA,CAAU,KAAK,CAAA;AAChC,MAAA,OAAO;AAAA,QACL,IAAA,EAAM,QAAA;AAAA,QACN,KAAA,EAAO,KAAK,QAAA,CAAS,UAAA;AAAA,QACrB,IAAI,MAAM;AACR,UAAA,IAAA,CAAK,OAAA,CAAQ,IAAA,CAAK,QAAA,EAAU,GAAA,EAAK,UAAU,GAAG,CAAA;AAAA,QAChD;AAAA,OACF;AAAA,IACF;AACA,IAAA,IAAA,CAAK,IAAA,CAAK,IAAI,SAAA,CAAU,KAAA,EAAO,CAAC,SAAA,CAAU,GAAA,EAAK,aAAA,GAAgB,KAAK,CAAC,CAAA;AACrE,IAAA,OAAO,MAAA;AAAA,EACT,CAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAiBA,QAAA,GAAW,CACT,EAAA,KAIS;AACT,IAAA,IAAA,CAAK,OAAA,CAAQ,EAAA,CAAG,QAAA,EAAU,EAAE,CAAA;AAAA,EAC9B,CAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAiBA,QAAA,GAAW,CACT,EAAA,KAIS;AACT,IAAA,IAAA,CAAK,OAAA,CAAQ,EAAA,CAAG,QAAA,EAAU,EAAE,CAAA;AAAA,EAC9B,CAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAiBA,QAAA,GAAW,CACT,EAAA,KAKS;AACT,IAAA,IAAA,CAAK,OAAA,CAAQ,EAAA,CAAG,QAAA,EAAU,EAAE,CAAA;AAAA,EAC9B,CAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,cAAA,GAAiB,CACf,EAAA,KAIS;AACT,IAAA,IAAA,CAAK,OAAA,CAAQ,GAAA,CAAI,QAAA,EAAU,EAAE,CAAA;AAAA,EAC/B,CAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,cAAA,GAAiB,CACf,EAAA,KAIS;AACT,IAAA,IAAA,CAAK,OAAA,CAAQ,GAAA,CAAI,QAAA,EAAU,EAAE,CAAA;AAAA,EAC/B,CAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,cAAA,GAAiB,CACf,EAAA,KAKS;AACT,IAAA,IAAA,CAAK,OAAA,CAAQ,GAAA,CAAI,QAAA,EAAU,EAAE,CAAA;AAAA,EAC/B,CAAA;AACF,CAAA;;;ACviBA,IAAM,WAAN,MAAyD;AAAA,EACtC,GAAA,uBAGT,GAAA,EAAI;AAAA,EAEZ,IACE,GAAA,EACqD;AAErD,IAAA,OAAO,IAAA,CAAK,GAAA,CAAI,GAAA,CAAI,GAAG,CAAA;AAAA,EAGzB;AAAA,EAEA,GAAA,CACE,KACA,KAAA,EACM;AACN,IAAA,IAAA,CAAK,GAAA,CAAI,GAAA,CAAI,GAAA,EAAK,KAAK,CAAA;AACvB,IAAA,OAAO,IAAA;AAAA,EACT;AAAA,EAEA,IAAI,GAAA,EAAuC;AACzC,IAAA,OAAO,IAAA,CAAK,GAAA,CAAI,GAAA,CAAI,GAAG,CAAA;AAAA,EACzB;AAAA,EAEA,OAAO,GAAA,EAAuC;AAC5C,IAAA,OAAO,IAAA,CAAK,GAAA,CAAI,MAAA,CAAO,GAAG,CAAA;AAAA,EAC5B;AAAA;AAAA,EAGA,IAAA,GAAiC;AAC/B,IAAA,OAAO,IAAA,CAAK,IAAI,IAAA,EAAK;AAAA,EACvB;AAAA,EACA,MAAA,GAEE;AACA,IAAA,OAAO,IAAA,CAAK,IAAI,MAAA,EAAO;AAAA,EACzB;AAAA,EACA,OAAA,GAEE;AACA,IAAA,OAAO,IAAA,CAAK,IAAI,OAAA,EAAQ;AAAA,EAC1B;AAAA,EACA,CAAC,MAAA,CAAO,QAAQ,CAAA,GAAI;AAClB,IAAA,OAAO,KAAK,OAAA,EAAQ;AAAA,EACtB;AACF,CAAA;AAOO,IAAM,cAAN,MAA4D;AAAA;AAAA;AAAA;AAAA,EAIxD,MAAA,GAAS,IAAI,QAAA,EAAuB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQ7C,SACE,IAAA,EACyC;AACzC,IAAA,MAAMN,MAAAA,GAAQ,IAAA,CAAK,MAAA,CAAO,GAAA,CAAI,IAAI,CAAA;AAClC,IAAA,IAAI,CAACA,MAAAA,EAAO;AACV,MAAA,OAAA,CAAQ,KAAA;AAAA,QACN;AAAA,OACF;AACA,MAAA,MAAM,IAAI,KAAA,CAAM,CAAA,MAAA,EAAS,MAAA,CAAO,IAAI,CAAC,CAAA,eAAA,CAAiB,CAAA;AAAA,IACxD;AACA,IAAA,OAAOA,MAAAA;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,iBACE,QAAA,EACyC;AACzC,IAAA,MAAM,OAAO,QAAA,CAAS,YAAA;AAEtB,IAAA,MAAMA,MAAAA,GAAQ,IAAA,CAAK,MAAA,CAAO,GAAA,CAAI,IAAI,CAAA;AAClC,IAAA,IAAIA,MAAAA,EAAO;AACT,MAAA,OAAOA,MAAAA;AAAA,IACT;AAEA,IAAA,MAAM,WAAW,IAAI,cAAA;AAAA,MACnB;AAAA,KACF;AACA,IAAA,IAAA,CAAK,MAAA,CAAO,GAAA,CAAI,IAAA,EAAM,QAAQ,CAAA;AAC9B,IAAA,OAAO,QAAA;AAAA,EACT;AACF;;;AC3HA,SAAS,kBAAA,CAAmB,GAAe,CAAA,EAAuB;AAChE,EAAA,MAAM,MAAM,IAAA,CAAK,GAAA,CAAI,CAAA,CAAE,MAAA,EAAQ,EAAE,MAAM,CAAA;AACvC,EAAA,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,GAAA,EAAK,CAAA,EAAA,EAAK;AAC5B,IAAA,MAAM,KAAA,GAAQ,EAAE,CAAC,CAAA;AACjB,IAAA,MAAM,KAAA,GAAQ,EAAE,CAAC,CAAA;AACjB,IAAA,IAAI,UAAU,KAAA,EAAO;AACrB,IAAA,IAAI,OAAO,KAAA,KAAU,QAAA,IAAY,OAAO,UAAU,QAAA,EAAU;AAC1D,MAAA,OAAO,KAAA,GAAQ,KAAA;AAAA,IACjB;AACA,IAAA,IAAI,OAAO,KAAA,KAAU,QAAA,IAAY,OAAO,UAAU,QAAA,EAAU;AAC1D,MAAA,OAAO,KAAA,CAAM,cAAc,KAAK,CAAA;AAAA,IAClC;AAGA,IAAA,OAAO,OAAO,KAAA,KAAU,QAAA,GAAW,CAAA,GAAI,EAAA;AAAA,EACzC;AAEA,EAAA,OAAO,CAAA,CAAE,SAAS,CAAA,CAAE,MAAA;AACtB;AAMO,IAAM,eAAA,GAAN,MAAM,gBAAA,CAAgB;AAAA,EAC3B,KAAA;AAAA,EACA,KAAA;AAAA,EACA,KAAA;AAAA,EACA,UAAA;AAAA,EACA,SAAA;AAAA,EAEA,YACE,KAAA,EACA,KAAA,EACA,OACA,UAAA,GAAgC,IAAA,EAChC,YAA8B,IAAA,EAC9B;AACA,IAAA,IAAA,CAAK,KAAA,GAAQ,KAAA;AACb,IAAA,IAAA,CAAK,KAAA,GAAQ,KAAA;AACb,IAAA,IAAA,CAAK,KAAA,GAAQ,KAAA;AACb,IAAA,IAAA,CAAK,UAAA,GAAa,UAAA;AAClB,IAAA,IAAA,CAAK,SAAA,GAAY,SAAA;AAAA,EACnB;AAAA,EAEA,QAAA,GAAmB;AACjB,IAAA,IAAI,aAAA,GAAgB,GAAG,IAAA,CAAK,KAAK,IAAI,IAAA,CAAK,KAAK,CAAA,CAAA,EAAI,IAAA,CAAK,KAAK,CAAA,CAAA;AAC7D,IAAA,IAAI,KAAK,UAAA,EAAY;AACnB,MAAA,aAAA,IAAiB,CAAA,CAAA,EAAI,IAAA,CAAK,UAAA,CAAW,IAAA,CAAK,GAAG,CAAC,CAAA,CAAA;AAAA,IAChD;AACA,IAAA,IAAI,KAAK,SAAA,EAAW;AAClB,MAAA,aAAA,IAAiB,CAAA,CAAA,EAAI,KAAK,SAAS,CAAA,CAAA;AAAA,IACrC;AACA,IAAA,OAAO,aAAA;AAAA,EACT;AAAA,EAEA,QAAQ,KAAA,EAAgC;AACtC,IAAA,IAAI,IAAA,CAAK,KAAA,KAAU,KAAA,CAAM,KAAA,EAAO;AAC9B,MAAA,OAAO,IAAA,CAAK,QAAQ,KAAA,CAAM,KAAA;AAAA,IAC5B;AACA,IAAA,IAAI,IAAA,CAAK,KAAA,KAAU,KAAA,CAAM,KAAA,EAAO;AAC9B,MAAA,OAAO,IAAA,CAAK,QAAQ,KAAA,CAAM,KAAA;AAAA,IAC5B;AACA,IAAA,IAAI,IAAA,CAAK,KAAA,KAAU,KAAA,CAAM,KAAA,EAAO;AAC9B,MAAA,OAAO,IAAA,CAAK,QAAQ,KAAA,CAAM,KAAA;AAAA,IAC5B;AACA,IAAA,IAAI,IAAA,CAAK,UAAA,IAAc,KAAA,CAAM,UAAA,EAAY;AACvC,MAAA,OAAO,kBAAA,CAAmB,IAAA,CAAK,UAAA,EAAY,KAAA,CAAM,UAAU,CAAA;AAAA,IAC7D;AACA,IAAA,IAAI,KAAK,UAAA,EAAY;AACnB,MAAA,OAAO,EAAA;AAAA,IACT;AACA,IAAA,IAAI,MAAM,UAAA,EAAY;AACpB,MAAA,OAAO,EAAA;AAAA,IACT;AACA,IAAA,OAAO,CAAA;AAAA,EACT;AAAA,EAEA,KAAA,GAAyB;AACvB,IAAA,OAAO,IAAI,gBAAA;AAAA,MACT,IAAA,CAAK,KAAA;AAAA,MACL,IAAA,CAAK,KAAA;AAAA,MACL,IAAA,CAAK,KAAA;AAAA,MACL,KAAK,UAAA,GAAa,CAAC,GAAG,IAAA,CAAK,UAAU,CAAA,GAAI,IAAA;AAAA,MACzC,IAAA,CAAK;AAAA,KACP;AAAA,EACF;AAAA,EAEA,OAAO,mBAAmB,OAAA,EAAkC;AAC1D,IAAA,MAAM,KAAA,GACJ,2HAAA;AACF,IAAA,MAAM,KAAA,GAAQ,OAAA,CAAQ,KAAA,CAAM,KAAK,CAAA;AACjC,IAAA,IAAI,CAAC,KAAA,EAAO;AACV,MAAA,MAAM,IAAI,KAAA,CAAM,CAAA,wBAAA,EAA2B,OAAO,CAAA,CAAE,CAAA;AAAA,IACtD;AAEA,IAAA,MAAM,KAAA,GAAQ,QAAA,CAAS,KAAA,CAAM,CAAC,GAAG,EAAE,CAAA;AACnC,IAAA,MAAM,KAAA,GAAQ,QAAA,CAAS,KAAA,CAAM,CAAC,GAAG,EAAE,CAAA;AACnC,IAAA,MAAM,KAAA,GAAQ,QAAA,CAAS,KAAA,CAAM,CAAC,GAAG,EAAE,CAAA;AACnC,IAAA,MAAM,UAAA,GAAa,MAAM,CAAC,CAAA,GACtB,MAAM,CAAC,CAAA,CAAE,MAAM,GAAG,CAAA,CAAE,IAAI,CAAA,EAAA,KAAO,KAAA,CAAM,OAAO,EAAE,CAAC,IAAI,EAAA,GAAK,MAAA,CAAO,EAAE,CAAE,CAAA,GACnE,IAAA;AACJ,IAAA,MAAM,SAAA,GAAY,KAAA,CAAM,CAAC,CAAA,IAAK,IAAA;AAE9B,IAAA,OAAO,IAAI,gBAAA,CAAgB,KAAA,EAAO,KAAA,EAAO,KAAA,EAAO,YAAY,SAAS,CAAA;AAAA,EACvE;AACF,CAAA;AAGO,IAAM,uBAAwC,IAAI,eAAA;AAAA,EACvD,CAAA;AAAA,EACA,CAAA;AAAA,EACA;AACF,CAAA;AAEO,SAAS,4BAA4B,aAAA,EAA8B;AACxE,EAAA,IAAI,kBAAkB,MAAA,EAAW;AAC/B,IAAA,MAAM,IAAI,KAAA,CAAM,mBAAA,CAAoB,aAAa,CAAC,CAAA;AAAA,EACpD;AACA,EAAA,MAAM,OAAA,GAAU,eAAA,CAAgB,kBAAA,CAAmB,aAAa,CAAA;AAChE,EAAA,IAAI,OAAA,CAAQ,OAAA,CAAQ,oBAAoB,CAAA,GAAI,CAAA,EAAG;AAC7C,IAAA,MAAM,IAAI,KAAA,CAAM,mBAAA,CAAoB,aAAa,CAAC,CAAA;AAAA,EACpD;AACF;AAEA,SAAS,oBAAoB,mBAAA,EAAsC;AACjE,EAAA,OAAO,CAAA,+EAAA,EAAkF,mBAAmB,CAAA,sCAAA,EAAyC,oBAAA,CAAqB,UAAU,CAAA,6GAAA,CAAA;AACtL;;;ACpIA,eAAsB,UAAA,CACpB,MAAA,EAEA,IAAA,EACA,SAAA,GAAoB,MAAM,IAAA,EACL;AAErB,EAAA,IAAI,MAAA,GAAS,CAAA;AACb,EAAA,MAAM,cAAA,GAAiB,IAAI,cAAA,CAAe;AAAA,IACxC,KAAK,UAAA,EAAY;AACf,MAAA,IAAI,MAAA,GAAS,OAAO,MAAA,EAAQ;AAE1B,QAAA,MAAM,QAAQ,MAAA,CAAO,QAAA;AAAA,UACnB,MAAA;AAAA,UACA,IAAA,CAAK,GAAA,CAAI,MAAA,GAAS,SAAA,EAAW,OAAO,MAAM;AAAA,SAC5C;AACA,QAAA,UAAA,CAAW,QAAQ,KAAK,CAAA;AACxB,QAAA,MAAA,IAAU,SAAA;AAAA,MACZ,CAAA,MAAO;AACL,QAAA,UAAA,CAAW,KAAA,EAAM;AAAA,MACnB;AAAA,IACF;AAAA,GACD,CAAA;AAGD,EAAA,MAAM,mBAAA,GAAsB,IAAI,mBAAA,CAAoB,IAAI,CAAA;AAGxD,EAAA,MAAM,kBAAA,GAAqB,cAAA,CAAe,WAAA,CAAY,mBAAmB,CAAA;AAGzE,EAAA,MAAM,MAAA,GAAS,mBAAmB,SAAA,EAAU;AAC5C,EAAA,MAAM,SAAuB,EAAC;AAC9B,EAAA,IAAI,WAAA,GAAc,CAAA;AAClB,EAAA,IAAI,MAAA;AAEJ,EAAA,OAAO,EAAE,MAAA,GAAS,MAAM,MAAA,CAAO,IAAA,IAAQ,IAAA,EAAM;AAC3C,IAAA,MAAA,CAAO,IAAA,CAAK,OAAO,KAAK,CAAA;AACxB,IAAA,WAAA,IAAe,OAAO,KAAA,CAAM,MAAA;AAAA,EAC9B;AAGA,EAAA,MAAM,iBAAA,GAAoB,IAAI,UAAA,CAAW,WAAW,CAAA;AACpD,EAAA,IAAI,WAAA,GAAc,CAAA;AAElB,EAAA,KAAA,MAAW,SAAS,MAAA,EAAQ;AAC1B,IAAA,iBAAA,CAAkB,GAAA,CAAI,OAAO,WAAW,CAAA;AACxC,IAAA,WAAA,IAAe,KAAA,CAAM,MAAA;AAAA,EACvB;AAEA,EAAA,OAAO,iBAAA;AACT;;;ACjDA,eAAsB,SAAA,GAAuC;AAE3D,EAAA,IAAI,OAAQ,UAAA,CAAmB,SAAA,KAAc,WAAA,EAAa;AACxD,IAAA,OAAQ,UAAA,CAAmB,SAAA;AAAA,EAC7B;AAIA,EAAA,MAAM,aAAA,GAAgB,IAAI,QAAA,CAAS,GAAA,EAAK,kBAAkB,CAAA;AAI1D,EAAA,IAAI;AACF,IAAA,MAAM,EAAE,SAAA,EAAW,QAAA,EAAS,GAAI,MAAM,cAAc,QAAQ,CAAA;AAC5D,IAAA,OAAO,QAAA;AAAA,EACT,SAAS,GAAA,EAAK;AACZ,IAAA,UAAA;AAAA,MACE,MAAA;AAAA,MACA;AAAA,KAGF;AACA,IAAA,MAAM,GAAA;AAAA,EACR;AACF;;;ACvBO,IAAM,0BAAA,GAAN,MAAM,2BAAA,CAA2B;AAAA,EACtC,OAAA;AAAA,EACA,MAAA;AAAA,EACA,SAAA;AAAA,EACA,OAAA;AAAA,EAEA,GAAA;AAAA,EAEA,MAAM,iBAAiB,GAAA,EAAmB;AACxC,IAAA,MAAM,MAAA,GAAS,IAAI,UAAA,CAAW,GAAA,CAAI,IAAI,CAAA;AACtC,IAAA,IAAI,YAAA;AAEJ,IAAA,IAAI,MAAA,CAAO,CAAC,CAAA,KAAM,CAAA,EAAG;AACnB,MAAA,YAAA,GAAe,MAAA,CAAO,MAAM,CAAC,CAAA;AAAA,IAC/B,CAAA,MAAA,IAAW,MAAA,CAAO,CAAC,CAAA,KAAM,CAAA,EAAG;AAC1B,MAAA,MAAM,IAAI,KAAA;AAAA,QACR;AAAA,OACF;AAAA,IACF,CAAA,MAAA,IAAW,MAAA,CAAO,CAAC,CAAA,KAAM,CAAA,EAAG;AAC1B,MAAA,YAAA,GAAe,MAAM,UAAA,CAAW,MAAA,CAAO,KAAA,CAAM,CAAC,GAAG,MAAM,CAAA;AAAA,IACzD,CAAA,MAAO;AACL,MAAA,MAAM,IAAI,KAAA;AAAA,QACR;AAAA,OACF;AAAA,IACF;AAEA,IAAA,IAAA,CAAK,SAAA,GAAY,EAAE,IAAA,EAAM,YAAA,EAAc,CAAA;AAAA,EACzC;AAAA,EAEA,cAAc,GAAA,EAAU;AACtB,IAAA,IAAA,CAAK,SAAS,GAAG,CAAA;AAAA,EACnB;AAAA,EAEA,eAAe,GAAA,EAAU;AACvB,IAAA,IAAA,CAAK,UAAU,GAAG,CAAA;AAAA,EACpB;AAAA,EAEA,eAAe,GAAA,EAAU;AACvB,IAAA,IAAA,CAAK,UAAU,GAAG,CAAA;AAAA,EACpB;AAAA,EAEA,KAAK,GAAA,EAAgB;AACnB,IAAA,IAAA,CAAK,GAAA,CAAI,KAAK,GAAG,CAAA;AAAA,EACnB;AAAA,EAEA,KAAA,GAAc;AACZ,IAAA,IAAA,CAAK,IAAI,KAAA,EAAM;AAAA,EACjB;AAAA,EAEA,YAAY,EAAA,EAAe;AACzB,IAAA,IAAA,CAAK,SAAA,GAAY,MAAA;AACjB,IAAA,IAAA,CAAK,MAAA,GAAS,MAAA;AACd,IAAA,IAAA,CAAK,SAAA,GAAY,MAAA;AACjB,IAAA,IAAA,CAAK,OAAA,GAAU,MAAA;AAEf,IAAA,EAAA,CAAG,SAAA,GAAY,IAAA,CAAK,gBAAA,CAAiB,IAAA,CAAK,IAAI,CAAA;AAC9C,IAAA,EAAA,CAAG,OAAA,GAAU,IAAA,CAAK,cAAA,CAAe,IAAA,CAAK,IAAI,CAAA;AAC1C,IAAA,EAAA,CAAG,OAAA,GAAU,IAAA,CAAK,cAAA,CAAe,IAAA,CAAK,IAAI,CAAA;AAC1C,IAAA,EAAA,CAAG,MAAA,GAAS,IAAA,CAAK,aAAA,CAAc,IAAA,CAAK,IAAI,CAAA;AAExC,IAAA,EAAA,CAAG,UAAA,GAAa,aAAA;AAEhB,IAAA,IAAA,CAAK,GAAA,GAAM,EAAA;AAAA,EACb;AAAA,EAEA,aAAa,iBAAA,CAAkB;AAAA,IAC7B,GAAA;AAAA,IACA,aAAA;AAAA,IACA,UAAA;AAAA,IACA,SAAA;AAAA,IACA,WAAA;AAAA,IACA,SAAA;AAAA,IACA;AAAA,GACF,EAQwC;AACtC,IAAA,MAAM,OAAA,GAAU,IAAI,OAAA,EAAQ;AAE5B,IAAA,MAAM,EAAA,GAAK,MAAM,SAAA,EAAU;AAI3B,IAAA,IAAI,kBAAA,GAAyC,MAAA;AAC7C,IAAA,IAAI,SAAA,EAAW;AACb,MAAA,OAAA,CAAQ,GAAA,CAAI,eAAA,EAAiB,CAAA,OAAA,EAAU,SAAS,CAAA,CAAE,CAAA;AAClD,MAAA,MAAM,QAAA,GAAW,IAAI,GAAA,CAAI,6BAAA,EAA+B,GAAG,CAAA;AAC3D,MAAA,QAAA,CAAS,QAAA,GAAW,GAAA,CAAI,QAAA,KAAa,MAAA,GAAS,QAAA,GAAW,OAAA;AAEzD,MAAA,MAAM,QAAA,GAAW,MAAM,KAAA,CAAM,QAAA,EAAU,EAAE,MAAA,EAAQ,MAAA,EAAQ,SAAS,CAAA;AAClE,MAAA,IAAI,SAAS,EAAA,EAAI;AACf,QAAA,MAAM,EAAE,KAAA,EAAM,GAAI,MAAM,SAAS,IAAA,EAAK;AACtC,QAAA,kBAAA,GAAqB,KAAA;AAAA,MACvB,CAAA,MAAO;AACL,QAAA,OAAO,OAAA,CAAQ,MAAA;AAAA,UACb,IAAI,KAAA,CAAM,CAAA,wBAAA,EAA2B,QAAA,CAAS,UAAU,CAAA,CAAE;AAAA,SAC5D;AAAA,MACF;AAAA,IACF;AAEA,IAAA,MAAM,cAAc,IAAI,GAAA,CAAI,CAAA,YAAA,EAAe,aAAa,cAAc,GAAG,CAAA;AACzE,IAAA,IAAI,kBAAA,EAAoB;AACtB,MAAA,WAAA,CAAY,YAAA,CAAa,GAAA,CAAI,OAAA,EAAS,kBAAkB,CAAA;AAAA,IAC1D;AACA,IAAA,WAAA,CAAY,YAAA,CAAa,GAAA;AAAA,MACvB,aAAA;AAAA,MACA,WAAA,KAAgB,SAAS,MAAA,GAAS;AAAA,KACpC;AACA,IAAA,IAAI,SAAA,EAAW;AACb,MAAA,WAAA,CAAY,YAAA,CAAa,GAAA,CAAI,OAAA,EAAS,MAAM,CAAA;AAAA,IAC9C;AACA,IAAA,IAAI,mBAAmB,MAAA,EAAW;AAChC,MAAA,WAAA,CAAY,YAAA,CAAa,GAAA,CAAI,WAAA,EAAa,cAAA,CAAe,UAAU,CAAA;AAAA,IACrE;AAEA,IAAA,MAAM,KAAK,IAAI,EAAA,CAAG,WAAA,CAAY,QAAA,IAAY,UAAU,CAAA;AAEpD,IAAA,OAAO,IAAI,4BAA2B,EAAE,CAAA;AAAA,EAC1C;AACF,CAAA;;;AC5GO,IAAM,sBAAN,MAAsE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAmB3E,WAAA,CACU,cACA,gBAAA,EAGR;AAJQ,IAAA,IAAA,CAAA,YAAA,GAAA,YAAA;AACA,IAAA,IAAA,CAAA,gBAAA,GAAA,gBAAA;AAIR,IAAA,IAAA,CAAK,cAAc,0BAAA,CAA2B,iBAAA;AAAA,EAChD;AAAA,EAzBA,IAAA;AAAA,EACA,cAAA;AAAA,EACA,SAAA;AAAA,EACA,MAAA;AAAA,EACA,QAAA,GAA0C,IAAI,YAAA,EAAa;AAAA,EAC3D,YAAA,GAAgC,MAAA;AAAA,EAChC,UAAA,GAAsB,KAAA;AAAA,EACtB,eAAA;AAAA,EACA,WAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAyBA,QAAQ,GAAA,EAAyB;AAC/B,IAAA,IAAA,CAAK,IAAA,GAAO,IAAI,GAAA,CAAI,GAAG,CAAA;AACvB,IAAA,OAAO,IAAA;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,iBAAiB,aAAA,EAA6B;AAC5C,IAAA,IAAA,CAAK,cAAA,GAAiB,aAAA;AACtB,IAAA,OAAO,IAAA;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,UAAU,KAAA,EAAsB;AAC9B,IAAA,IAAA,CAAK,MAAA,GAAS,KAAA;AACd,IAAA,OAAO,IAAA;AAAA,EACT;AAAA,EAEA,SACE,UAAA,EACM;AACN,IAAA,IAAA,CAAK,WAAA,GAAc,UAAA;AACnB,IAAA,OAAO,IAAA;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,gBAAgB,WAAA,EAAoC;AAClD,IAAA,IAAA,CAAK,YAAA,GAAe,WAAA;AACpB,IAAA,OAAO,IAAA;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,cAAc,SAAA,EAA0B;AACtC,IAAA,IAAA,CAAK,UAAA,GAAa,SAAA;AAClB,IAAA,OAAO,IAAA;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAsBA,mBAAmB,cAAA,EAA+B;AAChD,IAAA,IAAA,CAAK,eAAA,GAAkB,cAAA;AACvB,IAAA,OAAO,IAAA;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EA0BA,UACE,QAAA,EAKM;AACN,IAAA,IAAA,CAAK,QAAA,CAAS,EAAA,CAAG,SAAA,EAAW,QAAQ,CAAA;AACpC,IAAA,OAAO,IAAA;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAaA,eACE,QAAA,EAIM;AACN,IAAA,IAAA,CAAK,QAAA,CAAS,EAAA,CAAG,cAAA,EAAgB,QAAQ,CAAA;AACzC,IAAA,OAAO,IAAA;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EA6BA,aACE,QAAA,EAIM;AACN,IAAA,IAAA,CAAK,QAAA,CAAS,EAAA,CAAG,YAAA,EAAc,QAAQ,CAAA;AACvC,IAAA,OAAO,IAAA;AAAA,EACT;AAAA,EAEA,MAAA,GAAiB;AACf,IAAA,OAAO,IAAA,CAAK,IAAA,EAAM,QAAA,EAAS,IAAK,EAAA;AAAA,EAClC;AAAA,EAEA,aAAA,GAAwB;AACtB,IAAA,OAAO,KAAK,cAAA,IAAkB,EAAA;AAAA,EAChC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAgBA,KAAA,GAAsB;AACpB,IAAA,IAAI,CAAC,KAAK,IAAA,EAAM;AACd,MAAA,MAAM,IAAI,MAAM,2CAA2C,CAAA;AAAA,IAC7D;AAEA,IAAA,IAAI,CAAC,KAAK,cAAA,EAAgB;AACxB,MAAA,MAAM,IAAI,KAAA;AAAA,QACR;AAAA,OACF;AAAA,IACF;AAGA,IAAA,2BAAA,CAA4B,IAAA,CAAK,YAAA,CAAa,WAAA,EAAa,UAAU,CAAA;AAErE,IAAA,OAAO,KAAK,gBAAA,CAAiB;AAAA,MAC3B,KAAK,IAAA,CAAK,IAAA;AAAA,MACV,eAAe,IAAA,CAAK,cAAA;AAAA,MACpB,UAAU,IAAA,CAAK,SAAA;AAAA,MACf,OAAO,IAAA,CAAK,MAAA;AAAA,MACZ,SAAS,IAAA,CAAK,QAAA;AAAA,MACd,aAAa,IAAA,CAAK,YAAA;AAAA,MAClB,WAAW,IAAA,CAAK,UAAA;AAAA,MAChB,gBAAgB,IAAA,CAAK,eAAA;AAAA,MACrB,YAAY,IAAA,CAAK,WAAA;AAAA,MACjB,cAAc,IAAA,CAAK;AAAA,KACpB,CAAA;AAAA,EACH;AACF;;;ACvRO,IAAM,sBAAA,GAAyB,OAAO,wBAAwB,CAAA;;;ACU9D,IAAM,0BAAN,MAAwE;AAAA,EAI7E,YAAoB,EAAA,EAAoC;AAApC,IAAA,IAAA,CAAA,EAAA,GAAA,EAAA;AAAA,EAAqC;AAAA,EAHzD,UAAA,GACE,MAAA;AAAA,EACF,QAAA,GAAgE,MAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAkBhE,UACE,EAAA,EACuC;AACvC,IAAA,IAAA,CAAK,UAAA,GAAa,EAAA;AAClB,IAAA,OAAO,IAAA;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAsBA,QACE,EAAA,EACuC;AACvC,IAAA,IAAA,CAAK,QAAA,GAAW,EAAA;AAChB,IAAA,OAAO,IAAA;AAAA,EACT;AAAA,EA6BA,UACE,SAAA,EAKsC;AACtC,IAAA,IAAI,OAAA;AACJ,IAAA,IAAI,OAAO,cAAc,UAAA,EAAY;AACnC,MAAA,MAAM,SAAA,GAAY,IAAA,CAAK,EAAA,CAAG,YAAA,IAAe;AACzC,MAAA,MAAM,MAAA,GAAS,UAAU,SAAS,CAAA;AAClC,MAAA,OAAA,GAAU,MAAM,OAAA,CAAQ,MAAM,CAAA,GAAI,MAAA,GAAS,CAAC,MAAM,CAAA;AAAA,IACpD,CAAA,MAAO;AACL,MAAA,OAAA,GAAU,MAAM,OAAA,CAAQ,SAAS,CAAA,GAAI,SAAA,GAAY,CAAC,SAAS,CAAA;AAAA,IAC7D;AACA,IAAA,IAAI,OAAA,CAAQ,WAAW,CAAA,EAAG;AACxB,MAAA,MAAM,IAAI,MAAM,4CAA4C,CAAA;AAAA,IAC9D;AACA,IAAA,MAAM,YAAA,GAAe,OAAA,CAAQ,GAAA,CAAI,CAAA,CAAA,KAAK;AACpC,MAAA,IAAI,OAAO,CAAA,KAAM,QAAA,EAAU,OAAO,CAAA;AAClC,MAAA,IAAI,eAAA,CAAgB,CAAC,CAAA,EAAG,OAAO,MAAM,CAAC,CAAA;AACtC,MAAA,MAAM,IAAI,MAAM,oDAAoD,CAAA;AAAA,IACtE,CAAC,CAAA;AACD,IAAA,OAAO,IAAI,sBAAA;AAAA,MACT,IAAA,CAAK,EAAA;AAAA,MACL,YAAA;AAAA,MACA,IAAA,CAAK,UAAA;AAAA,MACL,IAAA,CAAK;AAAA,KACP;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAmBA,oBAAA,GAA6B;AAC3B,IAAA,MAAM,YAAA,GAAe,IAAA,CAAK,EAAA,CAAG,sBAAsB,CAAA,EAAE;AACrD,IAAA,MAAM,OAAA,GAAU,MAAA,CAAO,MAAA,CAAO,YAAA,CAAa,MAAM,CAAA,CAAE,GAAA;AAAA,MACjD,CAAAA,MAAAA,KAAS,CAAA,cAAA,EAAiBA,MAAAA,CAAM,UAAU,CAAA;AAAA,KAC5C;AACA,IAAA,IAAA,CAAK,UAAU,OAAO,CAAA;AAAA,EACxB;AACF;AAIO,IAAM,sBAAN,MAAoE;AAAA,EACzE,aAAA,uBAMQ,GAAA,EAAI;AACd,CAAA;AAEO,IAAM,yBAAN,MAAuE;AAAA,EAQ5E,WAAA,CACU,EAAA,EACR,QAAA,EACA,SAAA,EACA,OAAA,EACA;AAJQ,IAAA,IAAA,CAAA,EAAA,GAAA,EAAA;AAKR,IAAA,IAAA,CAAK,QAAA,CAAS,EAAA;AAAA,MACZ,SAAA;AAAA,MACA,CAAC,GAAA,KAAyD;AACxD,QAAA,IAAA,CAAK,YAAA,GAAe,IAAA;AACpB,QAAA,IAAI,SAAA,EAAW;AACb,UAAA,SAAA,CAAU,GAAG,CAAA;AAAA,QACf;AAAA,MACF;AAAA,KACF;AACA,IAAA,IAAA,CAAK,QAAA,CAAS,EAAA;AAAA,MACZ,OAAA;AAAA,MACA,CAAC,KAA0C,KAAA,KAAiB;AAC1D,QAAA,IAAA,CAAK,YAAA,GAAe,KAAA;AACpB,QAAA,IAAA,CAAK,WAAA,GAAc,IAAA;AACnB,QAAA,IAAI,OAAA,EAAS;AACX,UAAA,OAAA,CAAQ,KAAK,KAAK,CAAA;AAAA,QACpB;AAAA,MACF;AAAA,KACF;AACA,IAAA,IAAA,CAAK,WAAA,GAAc,KAAK,EAAA,CAAG,oBAAA;AAAA,MACzB,IAAA;AAAA,MACA,IAAA,CAAK,QAAA;AAAA,MACL;AAAA,KACF;AAAA,EACF;AAAA,EArCA,WAAA;AAAA,EACA,kBAAA,GAA8B,KAAA;AAAA,EAC9B,WAAA,GAAuB,KAAA;AAAA,EACvB,YAAA,GAAwB,KAAA;AAAA,EACxB,QAAA,GACE,IAAI,YAAA,EAAa;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAuCnB,WAAA,GAAoB;AAClB,IAAA,IAAI,KAAK,kBAAA,EAAoB;AAC3B,MAAA,MAAM,IAAI,MAAM,qCAAqC,CAAA;AAAA,IACvD;AACA,IAAA,IAAA,CAAK,kBAAA,GAAqB,IAAA;AAC1B,IAAA,IAAA,CAAK,EAAA,CAAG,sBAAA,CAAuB,IAAA,CAAK,WAAW,CAAA;AAC/C,IAAA,IAAA,CAAK,QAAA,CAAS,EAAA;AAAA,MACZ,KAAA;AAAA,MACA,CAAC,IAAA,KAA0D;AACzD,QAAA,IAAA,CAAK,WAAA,GAAc,IAAA;AACnB,QAAA,IAAA,CAAK,YAAA,GAAe,KAAA;AAAA,MACtB;AAAA,KACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYA,gBACE,KAAA,EACM;AACN,IAAA,IAAI,KAAK,WAAA,EAAa;AACpB,MAAA,MAAM,IAAI,MAAM,gCAAgC,CAAA;AAAA,IAClD;AACA,IAAA,IAAI,KAAK,kBAAA,EAAoB;AAC3B,MAAA,MAAM,IAAI,MAAM,qCAAqC,CAAA;AAAA,IACvD;AACA,IAAA,IAAA,CAAK,kBAAA,GAAqB,IAAA;AAC1B,IAAA,IAAA,CAAK,EAAA,CAAG,sBAAA,CAAuB,IAAA,CAAK,WAAW,CAAA;AAC/C,IAAA,IAAA,CAAK,QAAA,CAAS,EAAA;AAAA,MACZ,KAAA;AAAA,MACA,CAAC,GAAA,KAAyD;AACxD,QAAA,IAAA,CAAK,WAAA,GAAc,IAAA;AACnB,QAAA,IAAA,CAAK,YAAA,GAAe,KAAA;AACpB,QAAA,KAAA,CAAM,GAAG,CAAA;AAAA,MACX;AAAA,KACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,OAAA,GAAmB;AACjB,IAAA,OAAO,IAAA,CAAK,WAAA;AAAA,EACd;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,QAAA,GAAoB;AAClB,IAAA,OAAO,IAAA,CAAK,YAAA;AAAA,EACd;AACF;AChLO,IAAM,mBAAN,MAEP;AAAA;AAAA;AAAA;AAAA,EAIE,QAAA,GAAW,KAAA;AAAA;AAAA;AAAA;AAAA,EAKX,QAAA,GAAsB,MAAA;AAAA;AAAA;AAAA;AAAA,EAKtB,KAAA,GAAiB,MAAA;AAAA;AAAA,EAGjB,CAAC,sBAAsB,CAAA,GAAkB;AACvC,IAAA,OAAO,IAAA,CAAK,aAAA;AAAA,EACd;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,EAAA;AAAA;AAAA;AAAA;AAAA,EAKA,QAAA;AAAA;AAAA;AAAA;AAAA,EAKA,UAAA;AAAA;AAAA;AAAA;AAAA,EAKA,YAAA,GAA6B,aAAa,MAAA,EAAO;AAAA;AAAA,EAGjD,QAAA,GAAW,CAAA;AAAA,EACX,UAAA,GAAa,CAAA;AAAA,EACb,QAAA,GAAW,CAAA;AAAA,EACX,QAAA;AAAA,EACA,aAAA,GAAgB,QAAQ,OAAA,EAAQ;AAAA,EAChC,iBAAkC,EAAC;AAAA,EACnC,oBAAA,GAAuB,IAAI,mBAAA,EAAkC;AAAA,EAC7D,aAAA;AAAA,EACA,iBAAA,uBAAwB,GAAA,EAGtB;AAAA,EACF,gBAAA,uBAAuB,GAAA,EAA4C;AAAA,EACnE,mBAAA,uBAA0B,GAAA,EAA+B;AAAA,EACzD,iBAAA;AAAA,EACA,uBAAA;AAAA,EAIA,qBAAA;AAAA,EAIA,qBAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMQ,WAAA;AAAA,EACA,EAAA;AAAA,EACA,SAAA;AAAA,EAIR,WAAA,CAAY;AAAA,IACV,GAAA;AAAA,IACA,aAAA;AAAA,IACA,QAAA;AAAA,IACA,KAAA;AAAA,IACA,OAAA;AAAA,IACA,YAAA;AAAA,IACA,UAAA;AAAA,IACA,WAAA;AAAA,IACA,SAAA;AAAA,IACA;AAAA,GACF,EAAqC;AACnC,IAAA,UAAA,CAAW,QAAQ,iCAAiC,CAAA;AAKpD,IAAA,MAAM,GAAA,GAAM,IAAI,GAAA,CAAI,GAAA,CAAI,UAAU,CAAA;AAClC,IAAA,IAAI,CAAC,QAAA,CAAS,IAAA,CAAK,GAAA,CAAI,QAAQ,CAAA,EAAG;AAChC,MAAA,GAAA,CAAI,QAAA,GAAW,GAAA,CAAI,QAAA,KAAa,QAAA,GAAW,MAAA,GAAS,KAAA;AAAA,IACtD;AAEA,IAAA,IAAA,CAAK,QAAA,GAAW,QAAA;AAChB,IAAA,IAAA,CAAK,KAAA,GAAQ,KAAA;AAEb,IAAA,IAAA,CAAK,aAAA,GAAgB,YAAA;AACrB,IAAA,IAAA,CAAK,QAAA,GAAW,OAAA;AAEhB,IAAA,IAAA,CAAK,iBAAA,mBAAoB,MAAA,CAAO,MAAA,CAAO,IAAI,CAAA;AAC3C,IAAA,IAAA,CAAK,qBAAA,mBAAwB,MAAA,CAAO,MAAA,CAAO,IAAI,CAAA;AAC/C,IAAA,KAAA,MAAWA,MAAAA,IAAS,MAAA,CAAO,MAAA,CAAO,YAAA,CAAa,MAAM,CAAA,EAAG;AACtD,MAAA,IAAA,CAAK,iBAAA,CAAkBA,MAAAA,CAAM,UAAU,CAAA,GAAI,WAAA,CAAY,gBAAA;AAAA,QACrDA,MAAAA,CAAM;AAAA,OACR;AACA,MAAA,IAAA,CAAK,qBAAA,CAAsBA,MAAAA,CAAM,UAAU,CAAA,GAAIA,MAAAA;AAAA,IAGjD;AAEA,IAAA,IAAA,CAAK,uBAAA,mBAA0B,MAAA,CAAO,MAAA,CAAO,IAAI,CAAA;AACjD,IAAA,KAAA,MAAW,OAAA,IAAW,aAAa,QAAA,EAAU;AAC3C,MAAA,IAAA,CAAK,uBAAA,CAAwB,OAAA,CAAQ,IAAI,CAAA,GAAI;AAAA,QAC3C,SAAA,EAAW,WAAA,CAAY,cAAA,CAAe,OAAA,CAAQ,UAAU,CAAA;AAAA,QACxD,WAAA,EAAa,WAAA,CAAY,gBAAA,CAAiB,OAAA,CAAQ,UAAU;AAAA,OAC9D;AAAA,IACF;AAEA,IAAA,IAAA,CAAK,qBAAA,mBAAwB,MAAA,CAAO,MAAA,CAAO,IAAI,CAAA;AAC/C,IAAA,KAAA,MAAW,SAAA,IAAa,aAAa,UAAA,EAAY;AAC/C,MAAA,IAAA,CAAK,qBAAA,CAAsB,SAAA,CAAU,IAAI,CAAA,GAAI;AAAA,QAC3C,eAAe,WAAA,CAAY,cAAA;AAAA,UACzB,IAAI,cAAA,CAAe,SAAA,CAAU,MAAM,EAAE,aAAA,CAAc;AAAA,SACrD;AAAA,QACA,mBAAmB,aAAA,CAAc,gBAAA;AAAA,UAC/B,UAAU,UAAA,CAAW;AAAA;AACvB,OACF;AAAA,IACF;AAEA,IAAA,MAAM,YAAA,GAAe,IAAA,CAAK,YAAA,CAAa,WAAA,EAAY;AACnD,IAAA,GAAA,CAAI,YAAA,CAAa,GAAA,CAAI,eAAA,EAAiB,YAAY,CAAA;AAElD,IAAA,IAAA,CAAK,WAAA,GAAc,IAAI,WAAA,EAA0B;AACjD,IAAA,IAAA,CAAK,EAAA,GAAK,KAAK,WAAA,EAAY;AAC3B,IAAA,IAAA,CAAK,QAAA,GAAW,IAAA,CAAK,aAAA,CAAc,YAAY,CAAA;AAC/C,IAAA,IAAA,CAAK,UAAA,GAAa,IAAA,CAAK,eAAA,CAAgB,YAAY,CAAA;AAEnD,IAAA,IAAA,CAAK,YAAY,UAAA,CAAW;AAAA,MAC1B,GAAA;AAAA,MACA,aAAA;AAAA,MACA,UAAA,EAAY,sBAAA;AAAA,MACZ,SAAA,EAAW,KAAA;AAAA,MACX,WAAA;AAAA,MACA,SAAA;AAAA,MACA;AAAA,KACD,CAAA,CACE,IAAA,CAAK,CAAA,CAAA,KAAK;AACT,MAAA,IAAA,CAAK,EAAA,GAAK,CAAA;AAEV,MAAA,IAAA,CAAK,EAAA,CAAG,UAAU,MAAM;AACtB,QAAA,IAAA,CAAK,QAAA,CAAS,IAAA,CAAK,YAAA,EAAc,IAAI,CAAA;AACrC,QAAA,IAAA,CAAK,QAAA,GAAW,KAAA;AAAA,MAClB,CAAA;AACA,MAAA,IAAA,CAAK,EAAA,CAAG,OAAA,GAAU,CAAC,CAAA,KAAkB;AACnC,QAAA,IAAA,CAAK,QAAA,CAAS,IAAA,CAAK,cAAA,EAAgB,IAAA,EAAM,CAAC,CAAA;AAC1C,QAAA,IAAA,CAAK,QAAA,GAAW,KAAA;AAAA,MAClB,CAAA;AACA,MAAA,IAAA,CAAK,EAAA,CAAG,MAAA,GAAS,IAAA,CAAK,aAAA,CAAc,KAAK,IAAI,CAAA;AAC7C,MAAA,IAAA,CAAK,EAAA,CAAG,SAAA,GAAY,IAAA,CAAK,gBAAA,CAAiB,KAAK,IAAI,CAAA;AACnD,MAAA,OAAO,CAAA;AAAA,IACT,CAAC,CAAA,CACA,KAAA,CAAM,CAAA,CAAA,KAAK;AACV,MAAA,UAAA,CAAW,SAAS,oCAAoC,CAAA;AACxD,MAAA,IAAA,CAAK,QAAA,CAAS,IAAA,CAAK,cAAA,EAAgB,IAAA,EAAM,CAAC,CAAA;AAE1C,MAAA,OAAO,MAAA;AAAA,IACT,CAAC,CAAA;AAAA,EACL;AAAA,EAEA,kBAAkB,MAAM;AACtB,IAAA,MAAM,UAAU,IAAA,CAAK,QAAA;AACrB,IAAA,IAAA,CAAK,QAAA,IAAY,CAAA;AACjB,IAAA,OAAO,OAAA;AAAA,EACT,CAAA;AAAA,EAEA,iBAAA,GAAoB,MAAM,IAAA,CAAK,UAAA,EAAA;AAAA,EAE/B,WAAA,GAA0C;AACxC,IAAA,MAAM,IAAA,mBAAO,MAAA,CAAO,MAAA,CAAO,IAAI,CAAA;AAE/B,IAAA,KAAA,MAAW,GAAA,IAAO,MAAA,CAAO,MAAA,CAAO,IAAA,CAAK,qBAAqB,CAAA,EAAG;AAE3D,MAAA,MAAM,MAAM,GAAA,CAAI,YAAA;AAChB,MAAA,MAAA,CAAO,cAAA,CAAe,MAAM,GAAA,EAAK;AAAA,QAC/B,UAAA,EAAY,IAAA;AAAA,QACZ,YAAA,EAAc,KAAA;AAAA,QACd,GAAA,EAAK,MAAM,IAAA,CAAK,WAAA,CAAY,iBAAiB,GAAG;AAAA,OACjD,CAAA;AAAA,IACH;AAEA,IAAA,OAAO,IAAA;AAAA,EACT;AAAA,EAEA,cAAc,GAAA,EAA+C;AAC3D,IAAA,MAAM,MAA+B,EAAC;AAEtC,IAAA,KAAA,MAAW,OAAA,IAAW,IAAI,QAAA,EAAU;AAClC,MAAA,MAAM,cAAc,OAAA,CAAQ,IAAA;AAC5B,MAAA,MAAM,MAAM,OAAA,CAAQ,YAAA;AAEpB,MAAA,MAAM,EAAE,SAAA,EAAW,aAAA,EAAc,GAC/B,IAAA,CAAK,wBAAwB,WAAW,CAAA;AAE1C,MAAC,GAAA,CAAY,GAAG,CAAA,GAAI,CAAC,MAAA,KAAkD;AACrE,QAAA,MAAM,MAAA,GAAS,IAAI,YAAA,CAAa,IAAI,CAAA;AACpC,QAAA,aAAA,CAAc,QAAQ,MAAM,CAAA;AAC5B,QAAA,MAAM,UAAA,GAAa,OAAO,SAAA,EAAU;AACpC,QAAA,OAAO,IAAA,CAAK,WAAA,CAAY,WAAA,EAAa,UAAA,EAAY,MAAM,CAAA;AAAA,MACzD,CAAA;AAAA,IACF;AAEA,IAAA,OAAO,GAAA;AAAA,EACT;AAAA,EAEA,gBAAgB,GAAA,EAAiD;AAC/D,IAAA,MAAM,MAA+B,EAAC;AAEtC,IAAA,KAAA,MAAW,SAAA,IAAa,IAAI,UAAA,EAAY;AACtC,MAAA,MAAM,gBAAgB,SAAA,CAAU,IAAA;AAChC,MAAA,MAAM,MAAM,SAAA,CAAU,YAAA;AAEtB,MAAA,MAAM,EAAE,aAAA,EAAe,iBAAA,EAAkB,GACvC,IAAA,CAAK,sBAAsB,aAAa,CAAA;AAE1C,MAAC,GAAA,CAAY,GAAG,CAAA,GAAI,CAClB,MAAA,KACiB;AACjB,QAAA,MAAM,MAAA,GAAS,IAAI,YAAA,CAAa,IAAI,CAAA;AACpC,QAAA,aAAA,CAAc,QAAQ,MAAM,CAAA;AAC5B,QAAA,MAAM,UAAA,GAAa,OAAO,SAAA,EAAU;AACpC,QAAA,OAAO,KAAK,aAAA,CAAc,aAAA,EAAe,UAAU,CAAA,CAAE,KAAK,CAAA,SAAA,KAAa;AACrE,UAAA,OAAO,iBAAA,CAAkB,IAAI,YAAA,CAAa,SAAS,CAAC,CAAA;AAAA,QACtD,CAAC,CAAA;AAAA,MACH,CAAA;AAAA,IACF;AAEA,IAAA,OAAO,GAAA;AAAA,EACT;AAAA,EAEA,kBACE,KAAA,EAMqC;AAErC,IAAA,OAAO;AAAA,MACL,IAAI,IAAA,CAAK,EAAA;AAAA,MACT,UAAU,IAAA,CAAK,QAAA;AAAA,MACf,UAAU,IAAA,CAAK,QAAA;AAAA,MACf,mBAAA,EAAqB,IAAA,CAAK,mBAAA,CAAoB,IAAA,CAAK,IAAI,CAAA;AAAA,MACvD,UAAA,EAAY,IAAA,CAAK,UAAA,CAAW,IAAA,CAAK,IAAI,CAAA;AAAA,MACrC;AAAA,KACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,sBAAsB,MAA6C;AACjE,IAAA,OAAO,IAAI,wBAAwB,IAAI,CAAA;AAAA,EACzC,CAAA;AAAA,EAEA,YAAA,GAAoB;AAClB,IAAA,OAAO,iBAAiB,EAAE,MAAA,EAAQ,IAAA,CAAK,aAAA,CAAc,QAAe,CAAA;AAAA,EACtE;AAAA,EAEA,oBAAA,CACE,MAAA,EACA,aAAA,EAIA,QAAA,EACQ;AACR,IAAA,MAAM,UAAA,GAAa,KAAK,eAAA,EAAgB;AACxC,IAAA,IAAA,CAAK,oBAAA,CAAqB,aAAA,CAAc,GAAA,CAAI,UAAA,EAAY;AAAA,MACtD,MAAA;AAAA,MACA,OAAA,EAAS;AAAA,KACV,CAAA;AACD,IAAA,MAAM,SAAA,GAAY,KAAK,iBAAA,EAAkB;AACzC,IAAA,IAAA,CAAK,YAAA;AAAA,MACH,cAAc,SAAA,CAAU;AAAA,QACtB,YAAA,EAAc,QAAA;AAAA,QACd,UAAA,EAAY,EAAE,EAAA,EAAI,UAAA,EAAW;AAAA,QAC7B;AAAA,OACD;AAAA,KACH;AACA,IAAA,OAAO,UAAA;AAAA,EACT;AAAA,EAEA,uBAAuB,UAAA,EAA0B;AAC/C,IAAA,MAAM,SAAA,GAAY,KAAK,iBAAA,EAAkB;AACzC,IAAA,IAAA,CAAK,YAAA;AAAA,MACH,cAAc,WAAA,CAAY;AAAA,QACxB,UAAA,EAAY,EAAE,EAAA,EAAI,UAAA,EAAW;AAAA,QAC7B,SAAA;AAAA,QACA,OAAO,gBAAA,CAAiB;AAAA,OACzB;AAAA,KACH;AAAA,EACF;AAAA,EAEA,aAAA,CACE,IAAA,EACA,SAAA,EACA,OAAA,EACa;AACb,IAAA,MAAM,SAAS,OAAA,CAAQ,QAAA;AACvB,IAAA,MAAM,MAAA,GAAS,IAAI,YAAA,CAAa,MAAM,CAAA;AACtC,IAAA,MAAM,OAAoB,EAAC;AAE3B,IAAA,MAAM,cAAA,GAAiB,IAAA,CAAK,iBAAA,CAAkB,SAAS,CAAA;AACvD,IAAA,MAAMA,MAAAA,GAAQ,IAAA,CAAK,qBAAA,CAAsB,SAAS,CAAA;AAElD,IAAA,MAAM,YAAA,GAAe,MAAA,CAAO,OAAA,CAAQA,MAAAA,CAAM,OAAO,CAAA;AACjD,IAAA,MAAM,wBAAwB,YAAA,CAAa,IAAA;AAAA,MACzC,CAAA,GAAA,KAAO,GAAA,CAAI,CAAC,CAAA,CAAE,cAAA,CAAe;AAAA,KAC/B;AACA,IAAA,IAAI,cAAA,GAAiB,CAAA;AACrB,IAAA,OAAO,MAAA,CAAO,YAAY,CAAA,EAAG;AAC3B,MAAA,MAAM,GAAA,GAAM,eAAe,MAAM,CAAA;AACjC,MAAA,IAAI,KAAA,GAAyC,MAAA;AAC7C,MAAA,IAAI,0BAA0B,MAAA,EAAW;AACvC,QAAA,MAAM,iBAAA,GAAoB,sBAAsB,CAAC,CAAA;AACjD,QAAA,MAAM,iBAAA,GACJ,qBAAA,CAAsB,CAAC,CAAA,CAAE,WAAA,CAAY,aAAA;AACvC,QAAA,KAAA,GAAQ,aAAA,CAAc,UAAA;AAAA,UACpB,iBAAA;AAAA,UACA,IAAI,iBAAiB;AAAA,SACvB;AAAA,MACF,CAAA,MAAO;AAEL,QAAA,MAAM,QAAA,GAAW,MAAA,CAAO,QAAA,CAAS,cAAA,EAAgB,OAAO,MAAM,CAAA;AAE9D,QAAA,MAAM,QAAA,GAAWO,cAAc,QAAQ,CAAA;AACvC,QAAA,KAAA,GAAQ,QAAA;AAAA,MACV;AACA,MAAA,cAAA,GAAiB,MAAA,CAAO,MAAA;AAExB,MAAA,IAAA,CAAK,IAAA,CAAK;AAAA,QACR,IAAA;AAAA,QACA,KAAA;AAAA,QACA;AAAA,OACD,CAAA;AAAA,IACH;AACA,IAAA,OAAO,IAAA;AAAA,EACT;AAAA;AAAA,EAGA,mBACE,OAAA,EACqC;AACrC,IAAA,MAAM,MAAA,uBAAa,GAAA,EAAyB;AAC5C,IAAA,KAAA,MAAW,UAAU,OAAA,EAAS;AAC5B,MAAA,MAAM,GAAA,GAAM,MAAA,CAAO,GAAA,CAAI,MAAA,CAAO,SAAS,CAAA;AACvC,MAAA,IAAI,GAAA,EAAK;AACP,QAAA,KAAA,MAAW,EAAA,IAAM,MAAA,CAAO,UAAA,EAAY,GAAA,CAAI,KAAK,EAAE,CAAA;AAAA,MACjD,CAAA,MAAO;AACL,QAAA,MAAA,CAAO,IAAI,MAAA,CAAO,SAAA,EAAW,MAAA,CAAO,UAAA,CAAW,OAAO,CAAA;AAAA,MACxD;AAAA,IACF;AACA,IAAA,OAAO,MAAM,IAAA,CAAK,MAAA,EAAQ,CAAC,CAAC,SAAA,EAAW,UAAU,CAAA,MAAO;AAAA,MACtD,SAAA;AAAA,MACA;AAAA,KACF,CAAE,CAAA;AAAA,EACJ;AAAA,EAEA,wBAAA,CACE,MACA,MAAA,EACqC;AACrC,IAAA,MAAM,UAA+C,EAAC;AACtD,IAAA,KAAA,MAAW,SAAA,IAAa,KAAK,MAAA,EAAQ;AACnC,MAAA,OAAA,CAAQ,IAAA,CAAK;AAAA,QACX,WAAW,SAAA,CAAU,KAAA;AAAA,QACrB,YAAY,IAAA,CAAK,aAAA,CAAc,QAAQ,SAAA,CAAU,KAAA,EAAO,UAAU,IAAI;AAAA,OACvE,CAAA;AAAA,IACH;AACA,IAAA,OAAO,IAAA,CAAK,mBAAmB,OAAO,CAAA;AAAA,EACxC;AAAA,EAEA,4BAAA,CACE,WACA,IAAA,EACa;AACb,IAAA,IAAI,IAAA,CAAK,QAAQ,iBAAA,EAAmB;AAClC,MAAA,MAAM,UAAU,IAAA,CAAK,aAAA;AAAA,QACnB,QAAA;AAAA,QACA,SAAA;AAAA,QACA,KAAK,KAAA,CAAM;AAAA,OACb;AACA,MAAA,MAAM,UAAU,IAAA,CAAK,aAAA;AAAA,QACnB,QAAA;AAAA,QACA,SAAA;AAAA,QACA,KAAK,KAAA,CAAM;AAAA,OACb;AACA,MAAA,OAAO,OAAA,CAAQ,OAAO,OAAO,CAAA;AAAA,IAC/B;AACA,IAAA,IAAI,IAAA,CAAK,QAAQ,YAAA,EAAc;AAG7B,MAAA,OAAO,KAAK,aAAA,CAAc,QAAA,EAAU,SAAA,EAAW,IAAA,CAAK,MAAM,MAAM,CAAA;AAAA,IAClE;AACA,IAAA,OAAO,EAAC;AAAA,EACV;AAAA,EAEA,8BACE,cAAA,EACqC;AACrC,IAAA,MAAM,UAA+C,EAAC;AACtD,IAAA,KAAA,MAAW,WAAA,IAAe,eAAe,MAAA,EAAQ;AAC/C,MAAA,IAAI,aAA0B,EAAC;AAC/B,MAAA,KAAA,MAAW,IAAA,IAAQ,YAAY,IAAA,EAAM;AACnC,QAAA,UAAA,GAAa,UAAA,CAAW,MAAA;AAAA,UACtB,IAAA,CAAK,4BAAA,CAA6B,WAAA,CAAY,SAAA,EAAW,IAAI;AAAA,SAC/D;AAAA,MACF;AACA,MAAA,OAAA,CAAQ,IAAA,CAAK;AAAA,QACX,WAAW,WAAA,CAAY,SAAA;AAAA,QACvB;AAAA,OACD,CAAA;AAAA,IACH;AACA,IAAA,OAAO,IAAA,CAAK,mBAAmB,OAAO,CAAA;AAAA,EACxC;AAAA,EAEA,YAAA,CACE,YACA,OAAA,EACM;AACN,IAAA,UAAA;AAAA,MACE,OAAA;AAAA,MACA,MAAM,CAAA,2BAAA,EAA8B,SAAA,CAAU,OAAO,CAAC,CAAA;AAAA,KACxD;AACA,IAAA,MAAM,MAAA,GAAS,IAAI,YAAA,CAAa,IAAI,CAAA;AACpC,IAAA,aAAA,CAAc,SAAA,CAAU,QAAQ,OAAO,CAAA;AACvC,IAAA,MAAM,OAAA,GAAU,OAAO,SAAA,EAAU;AACjC,IAAA,UAAA,CAAW,KAAK,OAAO,CAAA;AAAA,EACzB;AAAA,EAEA,oBACE,UAAA,EACM;AACN,IAAA,IAAI,CAAC,IAAA,CAAK,QAAA,IAAY,IAAA,CAAK,cAAA,CAAe,WAAW,CAAA,EAAG;AACtD,MAAA;AAAA,IACF;AACA,IAAA,MAAM,OAAA,GAAU,IAAA,CAAK,cAAA,CAAe,MAAA,CAAO,CAAC,CAAA;AAC5C,IAAA,KAAA,MAAW,WAAW,OAAA,EAAS;AAC7B,MAAA,IAAA,CAAK,YAAA,CAAa,YAAY,OAAO,CAAA;AAAA,IACvC;AAAA,EACF;AAAA,EAEA,aAAa,OAAA,EAA8B;AACzC,IAAA,IAAA,CAAK,SAAA,CAAU,KAAK,CAAA,UAAA,KAAc;AAChC,MAAA,IAAI,CAAC,UAAA,IAAc,CAAC,IAAA,CAAK,QAAA,EAAU;AACjC,QAAA,IAAA,CAAK,cAAA,CAAe,KAAK,OAAO,CAAA;AAChC,QAAA;AAAA,MACF;AACA,MAAA,IAAA,CAAK,oBAAoB,UAAU,CAAA;AACnC,MAAA,IAAA,CAAK,YAAA,CAAa,YAAY,OAAO,CAAA;AAAA,IACvC,CAAC,CAAA;AAAA,EACH;AAAA,EAEA,YAAA,GAAuB;AACrB,IAAA,IAAA,CAAK,QAAA,IAAY,CAAA;AACjB,IAAA,OAAO,GAAG,IAAA,CAAK,YAAA,CAAa,aAAa,CAAA,CAAA,EAAI,KAAK,QAAQ,CAAA,CAAA;AAAA,EAC5D;AAAA;AAAA;AAAA;AAAA,EAKA,aAAA,GAAsB;AACpB,IAAA,IAAA,CAAK,QAAA,GAAW,IAAA;AAChB,IAAA,IAAI,KAAK,EAAA,EAAI;AACX,MAAA,IAAA,CAAK,mBAAA,CAAoB,KAAK,EAAE,CAAA;AAAA,IAClC;AAAA,EACF;AAAA,EAEA,kBAAA,CACE,cACA,YAAA,EACmB;AACnB,IAAA,MAAM,mBAAsC,EAAC;AAC7C,IAAA,KAAA,MAAW,eAAe,YAAA,EAAc;AAEtC,MAAA,MAAM,YAAY,WAAA,CAAY,SAAA;AAC9B,MAAA,MAAM,QAAA,GAAW,IAAA,CAAK,qBAAA,CAAsB,SAAS,CAAA;AACrD,MAAA,MAAMP,MAAAA,GAAQ,IAAA,CAAK,WAAA,CAAY,gBAAA,CAAiB,QAAQ,CAAA;AACxD,MAAA,MAAM,eAAeA,MAAAA,CAAM,eAAA;AAAA,QACzB,WAAA,CAAY,UAAA;AAAA,QAGZ;AAAA,OACF;AACA,MAAA,KAAA,MAAW,YAAY,YAAA,EAAc;AACnC,QAAA,gBAAA,CAAiB,KAAK,QAAQ,CAAA;AAAA,MAChC;AAAA,IACF;AACA,IAAA,OAAO,gBAAA;AAAA,EACT;AAAA,EAEA,wBAAA,CACE,cACA,EAAA,EACmB;AACnB,IAAA,MAAM,aAAkD,EAAC;AACzD,IAAA,KAAA,MAAW,cAAA,IAAkB,GAAG,SAAA,EAAW;AACzC,MAAA,MAAM,YAAA,GAAe,IAAA,CAAK,6BAAA,CAA8B,cAAc,CAAA;AACtE,MAAA,KAAA,MAAW,UAAU,YAAA,EAAc;AACjC,QAAA,UAAA,CAAW,KAAK,MAAM,CAAA;AAAA,MACxB;AAAA,IAEF;AACA,IAAA,OAAO,IAAA,CAAK,kBAAA;AAAA,MACV,IAAA,CAAK,mBAAmB,UAAU,CAAA;AAAA,MAClC;AAAA,KACF;AAAA,EACF;AAAA,EAEA,MAAM,gBAAgB,IAAA,EAAiC;AACrD,IAAA,MAAM,gBAAgB,aAAA,CAAc,WAAA,CAAY,IAAI,YAAA,CAAa,IAAI,CAAC,CAAA;AACtE,IAAA,UAAA;AAAA,MACE,OAAA;AAAA,MACA,MAAM,CAAA,2BAAA,EAA8B,SAAA,CAAU,aAAa,CAAC,CAAA;AAAA,KAC9D;AACA,IAAA,QAAQ,cAAc,GAAA;AAAK,MACzB,KAAK,mBAAA,EAAqB;AACxB,QAAA,IAAA,CAAK,QAAA,GAAW,cAAc,KAAA,CAAM,QAAA;AACpC,QAAA,IAAI,CAAC,IAAA,CAAK,KAAA,IAAS,aAAA,CAAc,MAAM,KAAA,EAAO;AAC5C,UAAA,IAAA,CAAK,KAAA,GAAQ,cAAc,KAAA,CAAM,KAAA;AAAA,QACnC;AACA,QAAA,IAAA,CAAK,YAAA,GAAe,cAAc,KAAA,CAAM,YAAA;AACxC,QAAA,IAAA,CAAK,SAAS,IAAA,CAAK,SAAA,EAAW,MAAM,IAAA,CAAK,QAAA,EAAU,KAAK,KAAK,CAAA;AAC7D,QAAA;AAAA,MACF;AAAA,MACA,KAAK,kBAAA,EAAoB;AACvB,QAAA,MAAM,UAAA,GAAa,aAAA,CAAc,KAAA,CAAM,UAAA,CAAW,EAAA;AAClD,QAAA,MAAM,YAAA,GACJ,IAAA,CAAK,oBAAA,CAAqB,aAAA,CAAc,IAAI,UAAU,CAAA;AACxD,QAAA,IAAI,CAAC,YAAA,EAAc;AACjB,UAAA,UAAA;AAAA,YACE,OAAA;AAAA,YACA,oDAAoD,UAAU,CAAA,CAAA;AAAA,WAChE;AACA,UAAA;AAAA,QACF;AACA,QAAA,MAAM,KAAA,GAAsB;AAAA,UAC1B,EAAA,EAAI,KAAK,YAAA,EAAa;AAAA,UACtB,GAAA,EAAK;AAAA,SACP;AACA,QAAA,MAAM,YAAA,GAAe,IAAA,CAAK,iBAAA,CAAkB,KAAK,CAAA;AACjD,QAAA,MAAM,eAAe,IAAA,CAAK,wBAAA;AAAA,UACxB,cAAc,KAAA,CAAM,IAAA;AAAA,UACpB;AAAA,SACF;AACA,QAAA,MAAM,SAAA,GAAY,IAAA,CAAK,kBAAA,CAAmB,YAAA,EAAc,YAAY,CAAA;AACpE,QAAA,MAAM,EAAE,KAAA,EAAO,CAAA,EAAG,GAAG,0BAAyB,GAAI,YAAA;AAClD,QAAA,YAAA,CAAa,OAAA,CAAQ,IAAA,CAAK,SAAA,EAAW,wBAAwB,CAAA;AAC7D,QAAA,UAAA;AAAA,UACE,OAAA;AAAA,UACA,MAAM,CAAA,QAAA,EAAW,SAAA,CAAU,MAAM,CAAA,wBAAA;AAAA,SACnC;AACA,QAAA,KAAA,MAAW,YAAY,SAAA,EAAW;AAChC,UAAA,QAAA,CAAS,EAAA,EAAG;AAAA,QACd;AACA,QAAA;AAAA,MACF;AAAA,MACA,KAAK,oBAAA,EAAsB;AACzB,QAAA,MAAM,UAAA,GAAa,aAAA,CAAc,KAAA,CAAM,UAAA,CAAW,EAAA;AAClD,QAAA,MAAM,YAAA,GACJ,IAAA,CAAK,oBAAA,CAAqB,aAAA,CAAc,IAAI,UAAU,CAAA;AACxD,QAAA,IAAI,CAAC,YAAA,EAAc;AACjB,UAAA,UAAA;AAAA,YACE,OAAA;AAAA,YACA,sDAAsD,UAAU,CAAA,CAAA;AAAA,WAClE;AACA,UAAA;AAAA,QACF;AACA,QAAA,MAAM,KAAA,GAAsB;AAAA,UAC1B,EAAA,EAAI,KAAK,YAAA,EAAa;AAAA,UACtB,GAAA,EAAK;AAAA,SACP;AACA,QAAA,MAAM,YAAA,GAAe,IAAA,CAAK,iBAAA,CAAkB,KAAK,CAAA;AACjD,QAAA,MAAM,YAAA,GAAe,aAAA,CAAc,KAAA,CAAM,IAAA,GACrC,IAAA,CAAK,wBAAA,CAAyB,aAAA,CAAc,KAAA,CAAM,IAAA,EAAM,QAAQ,CAAA,GAChE,EAAC;AACL,QAAA,MAAM,SAAA,GAAY,IAAA,CAAK,kBAAA,CAAmB,YAAA,EAAc,YAAY,CAAA;AACpE,QAAA,MAAM,EAAE,KAAA,EAAO,CAAA,EAAG,GAAG,0BAAyB,GAAI,YAAA;AAClD,QAAA,YAAA,CAAa,OAAA,CAAQ,IAAA,CAAK,KAAA,EAAO,wBAAwB,CAAA;AACzD,QAAA,IAAA,CAAK,oBAAA,CAAqB,aAAA,CAAc,MAAA,CAAO,UAAU,CAAA;AACzD,QAAA,UAAA;AAAA,UACE,OAAA;AAAA,UACA,MAAM,CAAA,QAAA,EAAW,SAAA,CAAU,MAAM,CAAA,wBAAA;AAAA,SACnC;AACA,QAAA,KAAA,MAAW,YAAY,SAAA,EAAW;AAChC,UAAA,QAAA,CAAS,EAAA,EAAG;AAAA,QACd;AACA,QAAA;AAAA,MACF;AAAA,MACA,KAAK,mBAAA,EAAqB;AACxB,QAAA,MAAM,UAAA,GAAa,aAAA,CAAc,KAAA,CAAM,UAAA,CAAW,EAAA;AAClD,QAAA,MAAM,KAAA,GAAQ,KAAA,CAAM,aAAA,CAAc,KAAA,CAAM,KAAK,CAAA;AAC7C,QAAA,MAAM,KAAA,GAAsB;AAAA,UAC1B,EAAA,EAAI,KAAK,YAAA,EAAa;AAAA,UACtB,GAAA,EAAK,OAAA;AAAA,UACL,KAAA,EAAO;AAAA,SACT;AACA,QAAA,MAAM,YAAA,GAAe,IAAA,CAAK,iBAAA,CAAkB,KAAK,CAAA;AACjD,QAAA,MAAM,YAAA,GAAe;AAAA,UACnB,GAAG,YAAA;AAAA,UACH,KAAA,EAAO;AAAA,SACT;AACA,QAAA,MAAM,YAAA,GACJ,IAAA,CAAK,oBAAA,CAAqB,aAAA,CAAc,IAAI,UAAU,CAAA;AACxD,QAAA,IAAI,YAAA,EAAc;AAChB,UAAA,YAAA,CAAa,OAAA,CAAQ,IAAA,CAAK,OAAA,EAAS,YAAA,EAAc,KAAK,CAAA;AACtD,UAAA,IAAA,CAAK,oBAAA,CAAqB,aAAA,CAAc,MAAA,CAAO,UAAU,CAAA;AAAA,QAC3D,CAAA,MAAO;AACL,UAAA,UAAA;AAAA,YACE,OAAA;AAAA,YACA,qDAAqD,UAAU,CAAA,CAAA,CAAA;AAAA,YAC/D;AAAA,WACF;AAAA,QACF;AACA,QAAA;AAAA,MACF;AAAA,MACA,KAAK,mBAAA,EAAqB;AACxB,QAAA,MAAM,KAAA,GAAsB;AAAA,UAC1B,EAAA,EAAI,KAAK,YAAA,EAAa;AAAA,UACtB,GAAA,EAAK;AAAA,SACP;AACA,QAAA,MAAM,YAAA,GAAe,IAAA,CAAK,iBAAA,CAAkB,KAAK,CAAA;AACjD,QAAA,MAAM,YAAY,IAAA,CAAK,wBAAA;AAAA,UACrB,YAAA;AAAA,UACA,aAAA,CAAc;AAAA,SAChB;AACA,QAAA,UAAA;AAAA,UACE,OAAA;AAAA,UACA,MAAM,CAAA,QAAA,EAAW,SAAA,CAAU,MAAM,CAAA,wBAAA;AAAA,SACnC;AACA,QAAA,KAAA,MAAW,YAAY,SAAA,EAAW;AAChC,UAAA,QAAA,CAAS,EAAA,EAAG;AAAA,QACd;AACA,QAAA;AAAA,MACF;AAAA,MACA,KAAK,eAAA,EAAiB;AACpB,QAAA,MAAM,EAAE,SAAA,EAAW,MAAA,EAAO,GAAI,aAAA,CAAc,KAAA;AAE5C,QAAA,IAAI,MAAA,CAAO,QAAQ,IAAA,EAAM;AACvB,UAAA,MAAM,WAAA,GAAc,IAAA,CAAK,gBAAA,CAAiB,GAAA,CAAI,SAAS,CAAA;AACvD,UAAA,MAAM,OAAA,GAAkB,KAAK,YAAA,EAAa;AAC1C,UAAA,MAAM,QAAoB,WAAA,GACtB;AAAA,YACE,EAAA,EAAI,OAAA;AAAA,YACJ,GAAA,EAAK,SAAA;AAAA,YACL,KAAA,EAAO;AAAA,cACL,SAAA,EAAW,cAAc,KAAA,CAAM,SAAA;AAAA,cAC/B,OAAA,EAAS,MAAA;AAAA,cACT,OAAA,EAAS;AAAA,gBACP,MAAM,WAAA,CAAY,IAAA;AAAA,gBAClB,MAAM,WAAA,CAAY;AAAA;AACpB;AACF,WACF,GACA;AAAA,YACE,EAAA,EAAI,OAAA;AAAA,YACJ,GAAA,EAAK;AAAA,WACP;AACJ,UAAA,MAAM,YAAA,GAAe,IAAA,CAAK,iBAAA,CAAkB,KAAY,CAAA;AAExD,UAAA,MAAM,YAAY,IAAA,CAAK,wBAAA;AAAA,YACrB,YAAA;AAAA,YACA,OAAO,KAAA,CAAM;AAAA,WACf;AACA,UAAA,UAAA;AAAA,YACE,OAAA;AAAA,YACA,MAAM,CAAA,QAAA,EAAW,SAAA,CAAU,MAAM,CAAA,wBAAA;AAAA,WACnC;AACA,UAAA,KAAA,MAAW,YAAY,SAAA,EAAW;AAChC,YAAA,QAAA,CAAS,EAAA,EAAG;AAAA,UACd;AAAA,QACF;AACA,QAAA,IAAA,CAAK,gBAAA,CAAiB,OAAO,SAAS,CAAA;AACtC,QAAA,MAAM,EAAA,GAAK,IAAA,CAAK,iBAAA,CAAkB,GAAA,CAAI,SAAS,CAAA;AAC/C,QAAA,IAAA,CAAK,iBAAA,CAAkB,OAAO,SAAS,CAAA;AACvC,QAAA,EAAA,GAAK,MAAM,CAAA;AACX,QAAA;AAAA,MACF;AAAA,MACA,KAAK,iBAAA,EAAmB;AACtB,QAAA,MAAM,EAAE,MAAA,EAAQ,SAAA,EAAU,GAAI,aAAA,CAAc,KAAA;AAC5C,QAAA,MAAM,SACJ,MAAA,CAAO,GAAA,KAAQ,UAAA,GACX,EAAE,KAAK,IAAA,EAAM,KAAA,EAAO,MAAA,CAAO,KAAA,KAC3B,EAAE,GAAA,EAAK,KAAA,EAAO,KAAA,EAAO,OAAO,KAAA,EAAM;AACxC,QAAA,MAAM,EAAA,GAAK,IAAA,CAAK,mBAAA,CAAoB,GAAA,CAAI,SAAS,CAAA;AACjD,QAAA,IAAA,CAAK,mBAAA,CAAoB,OAAO,SAAS,CAAA;AACzC,QAAA,EAAA,GAAK,MAAM,CAAA;AACX,QAAA;AAAA,MACF;AAAA,MACA,KAAK,mBAAA,EAAqB;AACxB,QAAA,UAAA;AAAA,UACE,MAAA;AAAA,UACA;AAAA,SACF;AACA,QAAA;AAAA,MACF;AAAA;AACF,EACF;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,iBAAiB,SAAA,EAAuC;AAKtD,IAAA,IAAA,CAAK,aAAA,GAAgB,IAAA,CAAK,aAAA,CAAc,IAAA,CAAK,MAAM;AACjD,MAAA,OAAO,IAAA,CAAK,eAAA,CAAgB,SAAA,CAAU,IAAI,CAAA;AAAA,IAC5C,CAAC,CAAA;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,WAAA,CACE,WAAA,EACA,UAAA,EACA,WAAA,EACe;AACf,IAAA,MAAM,EAAE,OAAA,EAAS,OAAA,EAAS,MAAA,EAAO,GAAI,QAAQ,aAAA,EAAoB;AACjE,IAAA,MAAM,SAAA,GAAY,KAAK,iBAAA,EAAkB;AACzC,IAAA,MAAM,OAAA,GAAU,cAAc,WAAA,CAAY;AAAA,MACxC,OAAA,EAAS,WAAA;AAAA,MACT,IAAA,EAAM,UAAA;AAAA,MACN,SAAA;AAAA,MACA,KAAA,EAAO;AAAA,KACR,CAAA;AACD,IAAA,IAAA,CAAK,aAAa,OAAO,CAAA;AACzB,IAAA,IAAI,WAAA,EAAa;AACf,MAAA,IAAA,CAAK,gBAAA,CAAiB,IAAI,SAAA,EAAW;AAAA,QACnC,IAAA,EAAM,WAAA;AAAA,QACN,IAAA,EAAM;AAAA,OACP,CAAA;AAAA,IACH;AACA,IAAA,IAAA,CAAK,iBAAA,CAAkB,GAAA,CAAI,SAAA,EAAW,CAAA,MAAA,KAAU;AAC9C,MAAA,IAAI,MAAA,CAAO,GAAA,KAAQ,IAAA,IAAQ,MAAA,CAAO,QAAQ,SAAA,EAAW;AACnD,QAAA,OAAA,EAAQ;AAAA,MACV,CAAA,MAAO;AACL,QAAA,IAAI,MAAA,CAAO,QAAQ,KAAA,EAAO;AAExB,UAAA,MAAM,MAAA,GAAS,IAAI,YAAA,CAAa,MAAA,CAAO,KAAK,CAAA;AAC5C,UAAA,MAAM,WAAA,GAAc,OAAO,UAAA,EAAW;AACtC,UAAA,MAAA,CAAO,IAAI,WAAA,CAAY,WAAW,CAAC,CAAA;AAAA,QACrC,CAAA,MAAA,IAAW,MAAA,CAAO,GAAA,KAAQ,eAAA,EAAiB;AACzC,UAAA,MAAA,CAAO,IAAI,aAAA,CAAc,MAAA,CAAO,KAAK,CAAC,CAAA;AAAA,QACxC,CAAA,MAAO;AAEL,UAAA,MAAA,CAAO,IAAI,KAAA,CAAM,2BAA2B,CAAC,CAAA;AACxC,QACP;AAAA,MACF;AAAA,IACF,CAAC,CAAA;AACD,IAAA,OAAO,OAAA;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,qBAAA,CACE,WAAA,EAEA,WAAA,EACA,MAAA,EACe;AACf,IAAA,MAAM,MAAA,GAAS,IAAI,YAAA,CAAa,IAAI,CAAA;AACpC,IAAA,IAAA,CAAK,uBAAA,CAAwB,WAAW,CAAA,CAAE,SAAA,CAAU,QAAQ,MAAM,CAAA;AAClE,IAAA,MAAM,UAAA,GAAa,OAAO,SAAA,EAAU;AACpC,IAAA,OAAO,IAAA,CAAK,WAAA,CAAY,WAAA,EAAa,UAAA,EAAY,MAAM,CAAA;AAAA,EACzD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,aAAA,CACE,eACA,UAAA,EACqB;AACrB,IAAA,MAAM,EAAE,OAAA,EAAS,OAAA,EAAS,MAAA,EAAO,GAAI,QAAQ,aAAA,EAA0B;AACvE,IAAA,MAAM,SAAA,GAAY,KAAK,iBAAA,EAAkB;AACzC,IAAA,MAAM,OAAA,GAAU,cAAc,aAAA,CAAc;AAAA,MAC1C,SAAA,EAAW,aAAA;AAAA,MACX,IAAA,EAAM,UAAA;AAAA,MACN,SAAA;AAAA;AAAA,MAEA,KAAA,EAAO;AAAA,KACR,CAAA;AACD,IAAA,IAAA,CAAK,aAAa,OAAO,CAAA;AACzB,IAAA,IAAA,CAAK,mBAAA,CAAoB,GAAA,CAAI,SAAA,EAAW,CAAA,MAAA,KAAU;AAChD,MAAA,IAAI,MAAA,CAAO,QAAQ,IAAA,EAAM;AACvB,QAAA,OAAA,CAAQ,OAAO,KAAK,CAAA;AAAA,MACtB,CAAA,MAAO;AACL,QAAA,MAAA,CAAO,OAAO,KAAK,CAAA;AAAA,MACrB;AAAA,IACF,CAAC,CAAA;AACD,IAAA,OAAO,OAAA;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,uBAAA,CACE,aAAA,EAEA,WAAA,EACA,MAAA,EAEA,WAAA,EACc;AACd,IAAA,MAAM,MAAA,GAAS,IAAI,YAAA,CAAa,IAAI,CAAA;AACpC,IAAA,MAAM,EAAE,aAAA,EAAe,iBAAA,EAAkB,GACvC,IAAA,CAAK,sBAAsB,aAAa,CAAA;AAC1C,IAAA,aAAA,CAAc,QAAQ,MAAM,CAAA;AAC5B,IAAA,MAAM,UAAA,GAAa,OAAO,SAAA,EAAU;AACpC,IAAA,OAAO,KAAK,aAAA,CAAc,aAAA,EAAe,UAAU,CAAA,CAAE,KAAK,CAAA,SAAA,KAAa;AACrE,MAAA,OAAO,iBAAA,CAAkB,IAAI,YAAA,CAAa,SAAS,CAAC,CAAA;AAAA,IACtD,CAAC,CAAA;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYA,UAAA,GAAmB;AACjB,IAAA,IAAA,CAAK,SAAA,CAAU,KAAK,CAAA,UAAA,KAAc;AAChC,MAAA,IAAI,UAAA,EAAY;AACd,QAAA,UAAA,CAAW,KAAA,EAAM;AAAA,MACnB;AAAA,IACF,CAAC,CAAA;AAAA,EACH;AAAA,EAEQ,EAAA,CACN,WACA,QAAA,EACM;AACN,IAAA,IAAA,CAAK,QAAA,CAAS,EAAA,CAAG,SAAA,EAAW,QAAQ,CAAA;AAAA,EACtC;AAAA,EAEQ,GAAA,CACN,WACA,QAAA,EACM;AACN,IAAA,IAAA,CAAK,QAAA,CAAS,GAAA,CAAI,SAAA,EAAW,QAAQ,CAAA;AAAA,EACvC;AAAA,EAEQ,UACN,QAAA,EACM;AACN,IAAA,IAAA,CAAK,QAAA,CAAS,EAAA,CAAG,SAAA,EAAW,QAAQ,CAAA;AAAA,EACtC;AAAA,EAEQ,aACN,QAAA,EACM;AACN,IAAA,IAAA,CAAK,QAAA,CAAS,EAAA,CAAG,YAAA,EAAc,QAAQ,CAAA;AAAA,EACzC;AAAA,EAEQ,eACN,QAAA,EACM;AACN,IAAA,IAAA,CAAK,QAAA,CAAS,EAAA,CAAG,cAAA,EAAgB,QAAQ,CAAA;AAAA,EAC3C;AAAA,EAEA,gBACE,QAAA,EACM;AACN,IAAA,IAAA,CAAK,QAAA,CAAS,GAAA,CAAI,SAAA,EAAW,QAAQ,CAAA;AAAA,EACvC;AAAA,EAEA,mBACE,QAAA,EACM;AACN,IAAA,IAAA,CAAK,QAAA,CAAS,GAAA,CAAI,YAAA,EAAc,QAAQ,CAAA;AAAA,EAC1C;AAAA,EAEA,qBACE,QAAA,EACM;AACN,IAAA,IAAA,CAAK,QAAA,CAAS,GAAA,CAAI,cAAA,EAAgB,QAAQ,CAAA;AAAA,EAC5C;AACF;;;AC37BO,SAAS,cAAA,CAEd,KAAoB,MAAA,EAA8B;AAClD,EAAA,OAAO;AAAA,IACL,QAAQ,MAAA,CAAO,WAAA;AAAA,MACb,MAAA,CAAO,QAAQ,MAAM,CAAA,CAAE,IAAI,CAAC,CAAC,OAAA,EAASC,OAAM,CAAA,KAAM;AAAA,QAChD,OAAA;AAAA,QACA,cAAc,OAAA,EAASA,OAAAA,EAAQA,QAAO,QAAA,CAAS,GAAA,EAAK,OAAO,CAAC;AAAA,OAC7D;AAAA;AACH,GACF;AACF;AAEO,SAAS,aAAA,CAId,OAAA,EACAA,OAAAA,EACA,QAAA,EAC2B;AAC3B,EAAA,MAAM,UAAA,GAAa,CAAC,CAAA,KAClBA,OAAAA,CAAO,QAAQ,aAAA,CAAc,KAAA,CAAM,QAAA,CAAS,CAAC,CAAA,CAAE,IAAA;AAGjD,EAAA,OAAO;AAAA,IACL,UAAA,EAAY,OAAA;AAAA,IACZ,YAAA,EAAc,OAAA;AAAA,IACd,OAAA,EAASA,QAAO,OAAA,CAAQ,GAAA;AAAA;AAAA,IACxB,SAASA,OAAAA,CAAO,gBAAA;AAAA,IAChB,WAAA,EAAa,QAAA,CAAS,WAAA,CAAY,GAAA,CAAI,CAAA,CAAA,MAAM;AAAA,MAC1C,MAAM,CAAA,CAAE,UAAA;AAAA,MACR,UAAA,EAAY,QAAA;AAAA,MACZ,SAAS,CAAA,CAAE,IAAA,CAAK,KAAA,CAAM,OAAA,CAAQ,IAAI,UAAU;AAAA,KAC9C,CAAE,CAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAKF,OAAA,EAAS,QAAA,CAAS,OAAA,CAAQ,GAAA,CAAI,CAAC,GAAA,KAAkC;AAC/D,MAAA,MAAM,SAAA,GACJ,GAAA,CAAI,SAAA,CAAU,GAAA,KAAQ,QAAA,GAClB,CAAC,GAAA,CAAI,SAAA,CAAU,KAAK,CAAA,GACpB,GAAA,CAAI,SAAA,CAAU,KAAA;AACpB,MAAA,OAAO;AAAA,QACL,MAAM,GAAA,CAAI,YAAA;AAAA,QACV,MAAA,EAAQ,SAAS,WAAA,CAAY,IAAA;AAAA,UAAK,CAAA,CAAA,KAChC,CAAA,CAAE,IAAA,CAAK,KAAA,CAAM,OAAA,CAAQ,MAAM,CAAA,GAAA,KAAO,SAAA,CAAU,QAAA,CAAS,GAAG,CAAC;AAAA,SAC3D;AAAA,QACA,SAAA,EAAW,GAAA,CAAI,SAAA,CAAU,GAAA,CAAI,WAAA,EAAY;AAAA,QACzC,OAAA,EAAS,SAAA,CAAU,GAAA,CAAI,UAAU;AAAA,OACnC;AAAA,IACF,CAAC,CAAA;AAAA,IACD,QAAA;AAAA,IACA,GAAI,QAAA,CAAS,OAAA,GAAU,EAAE,OAAA,EAAS,IAAA,KAAS;AAAC,GAC9C;AACF;AAaO,IAAM,gBAAN,MAAoB;AAAA,EACzB,cAAA,uBAAwC,GAAA,EAAI;AAAA;AAAA;AAAA;AAAA,EAK5C,UAAA,GAAwB;AAAA,IACtB,SAAA,EAAW,EAAE,KAAA,EAAO,EAAC,EAAE;AAAA,IACvB,QAAQ,EAAC;AAAA,IACT,UAAU,EAAC;AAAA,IACX,OAAO,EAAC;AAAA,IACR,kBAAkB,EAAC;AAAA,IACnB,WAAW,EAAC;AAAA,IACZ,YAAY,EAAC;AAAA,IACb,OAAO,EAAC;AAAA,IACR,mBAAmB,EAAC;AAAA,IACpB,oBAAA,EAAsB,EAAE,GAAA,EAAK,WAAA,EAAY;AAAA,IACzC,aAAA,EAAe;AAAA,MACb,SAAS;AAAC;AACZ,GACF;AAAA,EAEA,IAAI,SAAA,GAAuB;AACzB,IAAA,OAAO,IAAA,CAAK,UAAA;AAAA,EACd;AAAA,EAEA,eAAA,GAAmC;AACjC,IAAA,MAAM,WAAsB,EAAC;AAE7B,IAAA,MAAM,IAAA,GAAO,CAAoB,CAAA,KAAqB;AACpD,MAAA,IAAI,CAAA,EAAG,QAAA,CAAS,IAAA,CAAK,CAAC,CAAA;AAAA,IACxB,CAAA;AAEA,IAAA,MAAM,SAAS,IAAA,CAAK,UAAA;AAEpB,IAAA,IAAA,CAAK,MAAA,CAAO,aAAa,EAAE,GAAA,EAAK,aAAa,KAAA,EAAO,MAAA,CAAO,WAAW,CAAA;AACtE,IAAA,IAAA,CAAK,MAAA,CAAO,SAAS,EAAE,GAAA,EAAK,SAAS,KAAA,EAAO,MAAA,CAAO,OAAO,CAAA;AAC1D,IAAA,IAAA,CAAK,MAAA,CAAO,UAAU,EAAE,GAAA,EAAK,UAAU,KAAA,EAAO,MAAA,CAAO,QAAQ,CAAA;AAC7D,IAAA,IAAA,CAAK,MAAA,CAAO,YAAY,EAAE,GAAA,EAAK,YAAY,KAAA,EAAO,MAAA,CAAO,UAAU,CAAA;AACnE,IAAA,IAAA,CAAK,MAAA,CAAO,cAAc,EAAE,GAAA,EAAK,cAAc,KAAA,EAAO,MAAA,CAAO,YAAY,CAAA;AACzE,IAAA,IAAA,CAAK,MAAA,CAAO,SAAS,EAAE,GAAA,EAAK,SAAS,KAAA,EAAO,MAAA,CAAO,OAAO,CAAA;AAC1D,IAAA,IAAA,CAAK,MAAA,CAAO,aAAa,EAAE,GAAA,EAAK,aAAa,KAAA,EAAO,MAAA,CAAO,WAAW,CAAA;AACtE,IAAA,IAAA;AAAA,MACE,OAAO,iBAAA,IAAqB;AAAA,QAC1B,GAAA,EAAK,mBAAA;AAAA,QACL,OAAO,MAAA,CAAO;AAAA;AAChB,KACF;AACA,IAAA,IAAA;AAAA,MACE,OAAO,gBAAA,IAAoB;AAAA,QACzB,GAAA,EAAK,kBAAA;AAAA,QACL,OAAO,MAAA,CAAO;AAAA;AAChB,KACF;AACA,IAAA,IAAA;AAAA,MACE,OAAO,aAAA,IAAiB;AAAA,QACtB,GAAA,EAAK,eAAA;AAAA,QACL,OAAO,MAAA,CAAO;AAAA;AAChB,KACF;AACA,IAAA,IAAA;AAAA,MACE,OAAO,oBAAA,IAAwB;AAAA,QAC7B,GAAA,EAAK,sBAAA;AAAA,QACL,OAAO,MAAA,CAAO;AAAA;AAChB,KACF;AACA,IAAA,OAAO,EAAE,QAAA,EAAS;AAAA,EACpB;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,wBAAwB,MAAA,EAA8B;AACpD,IAAA,IAAA,CAAK,WAAW,oBAAA,GAAuB,MAAA;AAAA,EACzC;AAAA,EAEA,IAAI,SAAA,GAAY;AACd,IAAA,OAAO,KAAK,UAAA,CAAW,SAAA;AAAA,EACzB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQO,YACL,WAAA,EACI;AACJ,IAAA,IAAI,KAAoB,WAAA,CAAY,aAAA;AACpC,IAAA,OAAO,EAAA,CAAG,QAAQ,KAAA,EAAO;AACvB,MAAA,EAAA,GAAK,IAAA,CAAK,SAAA,CAAU,KAAA,CAAM,EAAA,CAAG,KAAK,CAAA;AAAA,IACpC;AACA,IAAA,OAAO,EAAA;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASO,yBACL,WAAA,EAGI;AACJ,IAAA,IACG,WAAA,YAAuB,kBAAkB,CAAC,MAAA,CAAO,WAAW,CAAA,IAC7D,WAAA,YAAuB,UAAA,IACvB,WAAA,YAAuB,UAAA,EACvB;AACA,MAAA,OAAO,IAAA,CAAK,iCAAiC,WAAW,CAAA;AAAA,IAC1D,CAAA,MAAA,IAAW,uBAAuB,aAAA,EAAe;AAC/C,MAAA,OAAO,IAAI,aAAA;AAAA,QACT,IAAA,CAAK,wBAAA,CAAyB,WAAA,CAAY,KAAK;AAAA,OACjD;AAAA,IACF,CAAA,MAAA,IAAW,uBAAuB,aAAA,EAAe;AAC/C,MAAA,OAAO,IAAI,aAAA;AAAA,QACT,IAAA,CAAK,wBAAA,CAAyB,WAAA,CAAY,EAAE,CAAA;AAAA,QAC5C,IAAA,CAAK,wBAAA,CAAyB,WAAA,CAAY,GAAG;AAAA,OAC/C;AAAA,IACF,CAAA,MAAA,IAAW,uBAAuB,YAAA,EAAc;AAC9C,MAAA,OAAO,IAAI,YAAA;AAAA,QACT,IAAA,CAAK,wBAAA,CAAyB,WAAA,CAAY,OAAO;AAAA,OACnD;AAAA,IACF,CAAA,MAAO;AACL,MAAA,OAAO,WAAA;AAAA,IACT;AAAA,EACF;AAAA,EAEA,iCAKE,WAAA,EAA0E;AAC1E,IAAA,MAAM,KAAK,WAAA,CAAY,aAAA;AAIvB,IAAA,MAAM,OAAO,WAAA,CAAY,QAAA;AACzB,IAAA,IAAI,SAAS,MAAA,EAAW;AACtB,MAAA,MAAM,IAAI,KAAA;AAAA,QACR,CAAA,sBAAA,EAAyB,YAAY,WAAA,CAAY,IAAA,IAAQ,aAAa,CAAA,CAAA,EAAI,IAAA,CAAK,SAAA,CAAU,WAAW,CAAC,CAAA;AAAA,OACvG;AAAA,IACF;AAEA,IAAA,IAAI,CAAA,GAAI,IAAA,CAAK,cAAA,CAAe,GAAA,CAAI,EAAE,CAAA;AAClC,IAAA,IAAI,KAAK,IAAA,EAAM;AAEb,MAAA,OAAO,CAAA;AAAA,IACT;AAGA,IAAA,MAAM,KAAA,GACJ,WAAA,YAAuB,UAAA,IAAc,WAAA,YAAuB,cAAA,GACvD;AAAA,MACC,GAAA,EAAK,SAAA;AAAA,MACL,KAAA,EAAO,EAAE,QAAA,EAAU,EAAC;AAAE,KACxB,GACC;AAAA,MACC,GAAA,EAAK,KAAA;AAAA,MACL,KAAA,EAAO,EAAE,QAAA,EAAU,EAAC;AAAE,KACxB;AAEN,IAAA,CAAA,GAAI,IAAI,UAAA,CAAW,IAAA,CAAK,UAAA,CAAW,SAAA,CAAU,MAAM,MAAM,CAAA;AACzD,IAAA,IAAA,CAAK,UAAA,CAAW,SAAA,CAAU,KAAA,CAAM,IAAA,CAAK,KAAK,CAAA;AAE1C,IAAA,IAAA,CAAK,cAAA,CAAe,GAAA,CAAI,EAAA,EAAI,CAAC,CAAA;AAE7B,IAAA,IAAI,uBAAuB,UAAA,EAAY;AACrC,MAAA,KAAA,MAAW,CAACE,OAAM,IAAI,CAAA,IAAK,OAAO,OAAA,CAAQ,WAAA,CAAY,GAAG,CAAA,EAAG;AAC1D,QAAC,KAAA,CAAM,KAAA,CAAsB,QAAA,CAAS,IAAA,CAAK;AAAA,UACzC,IAAA,EAAAA,KAAAA;AAAA,UACA,aAAA,EAAe,IAAA,CAAK,wBAAA,CAAyB,IAAA,CAAK,WAAW,CAAA,CAC1D;AAAA,SACJ,CAAA;AAAA,MACH;AAAA,IACF,CAAA,MAAA,IAAW,uBAAuB,cAAA,EAAgB;AAChD,MAAA,KAAA,MAAW,CAACA,OAAM,IAAI,CAAA,IAAK,OAAO,OAAA,CAAQ,WAAA,CAAY,QAAQ,CAAA,EAAG;AAC/D,QAAC,KAAA,CAAM,KAAA,CAAsB,QAAA,CAAS,IAAA,CAAK;AAAA,UACzC,IAAA,EAAAA,KAAAA;AAAA,UACA,aAAA,EAAe,IAAA,CAAK,wBAAA,CAAyB,IAAI,CAAA,CAAE;AAAA,SACpD,CAAA;AAAA,MACH;AAAA,IACF,CAAA,MAAA,IAAW,uBAAuB,UAAA,EAAY;AAC5C,MAAA,KAAA,MAAW,CAACA,OAAM,OAAO,CAAA,IAAK,OAAO,OAAA,CAAQ,WAAA,CAAY,QAAQ,CAAA,EAAG;AAClE,QAAC,KAAA,CAAM,KAAA,CAAkB,QAAA,CAAS,IAAA,CAAK;AAAA,UACrC,IAAA,EAAAA,KAAAA;AAAA,UACA,aAAA,EAAe,IAAA,CAAK,wBAAA,CAAyB,OAAO,CAAA,CAAE;AAAA,SACvD,CAAA;AAAA,MACH;AAAA,IACF;AAEA,IAAA,IAAA,CAAK,UAAA,CAAW,MAAM,IAAA,CAAK;AAAA,MACzB,UAAA,EAAY,UAAU,IAAI,CAAA;AAAA,MAC1B,IAAI,CAAA,CAAE,GAAA;AAAA,MACN,cAAA,EAAgB;AAAA,KACjB,CAAA;AAED,IAAA,OAAO,CAAA;AAAA,EACT;AACF,CAAA;AAEA,SAAS,OAAO,WAAA,EAAmD;AACjE,EAAA,OACE,YAAY,QAAA,IAAY,IAAA,IACxB,YAAY,aAAA,CAAc,KAAA,CAAM,SAAS,MAAA,KAAW,CAAA;AAExD;AAEO,SAAS,UAAU,IAAA,EAAoC;AAC5D,EAAA,MAAM,KAAA,GAAQ,IAAA,CAAK,KAAA,CAAM,GAAG,CAAA;AAC5B,EAAA,OAAO,EAAE,UAAA,EAAY,KAAA,CAAM,GAAA,IAAQ,KAAA,EAAM;AAC3C;;;ACzVA,IAAM,SAAN,MAAyC;AAAA,EACvC,YAAqB,UAAA,EAAe;AAAf,IAAA,IAAA,CAAA,UAAA,GAAA,UAAA;AAAA,EAAgB;AACvC,CAAA;AAcO,SAAS,OACd,MAAA,EAC2B;AAC3B,EAAA,MAAM,GAAA,GAAM,IAAI,aAAA,EAAc;AAE9B,EAAA,OAAO,IAAI,MAAA,CAAO,cAAA,CAAe,GAAA,EAAK,MAAM,CAAC,CAAA;AAC/C;AAQO,SAAS,qBACd,GAAA,EACyB;AACzB,EAAA,OAAO,MAAA,CAAO,WAAA;AAAA,IACZ,IAAI,GAAA,CAAI,CAAA,CAAA,KAAK,CAAC,CAAA,CAAE,YAAA,EAAc,CAAC,CAAC;AAAA,GAClC;AACF;;;AC/BO,IAAMK,cAAAA,GAGT,CAAA,CAAI,IAAA,CAAK,eAAA,EAAiB;AAAA,EAC5B,GAAA,EAAK,EAAI,GAAA,EAAI;AAAA,EACb,IAAI,GAAA,GAAM;AACR,IAAA,OAAOC,QAAAA;AAAA,EACT,CAAA;AAAA,EACA,IAAI,OAAA,GAAU;AACZ,IAAA,OAAOC,YAAAA;AAAA,EACT,CAAA;AAAA,EACA,IAAI,KAAA,GAAQ;AACV,IAAA,OAAOF,cAAAA;AAAA,EACT,CAAA;AAAA,EACA,MAAA,EAAQ,EAAI,IAAA,EAAK;AAAA,EACjB,IAAA,EAAM,EAAI,IAAA,EAAK;AAAA,EACf,EAAA,EAAI,EAAI,IAAA,EAAK;AAAA,EACb,EAAA,EAAI,EAAI,IAAA,EAAK;AAAA,EACb,GAAA,EAAK,EAAI,IAAA,EAAK;AAAA,EACd,GAAA,EAAK,EAAI,IAAA,EAAK;AAAA,EACd,GAAA,EAAK,EAAI,IAAA,EAAK;AAAA,EACd,GAAA,EAAK,EAAI,IAAA,EAAK;AAAA,EACd,GAAA,EAAK,EAAI,IAAA,EAAK;AAAA,EACd,GAAA,EAAK,EAAI,IAAA,EAAK;AAAA,EACd,IAAA,EAAM,EAAI,IAAA,EAAK;AAAA,EACf,IAAA,EAAM,EAAI,IAAA,EAAK;AAAA,EACf,IAAA,EAAM,EAAI,IAAA,EAAK;AAAA,EACf,IAAA,EAAM,EAAI,IAAA,EAAK;AAAA,EACf,GAAA,EAAK,EAAI,IAAA,EAAK;AAAA,EACd,GAAA,EAAK,EAAI,IAAA;AACX,CAAC,CAAA;AAIM,IAAM,oBAAA,GAAuB,CAAA,CAAI,IAAA,CAAK,sBAAA,EAAwB;AAAA,EACnE,IAAA,EAAM,EAAI,IAAA,EAAK;AAAA,EACf,SAAA,EAAW,EAAI,IAAA;AACjB,CAAC,CAAA;AAIM,IAAM,iBAAA,GAAoB,CAAA,CAAI,IAAA,CAAK,mBAAA,EAAqB;AAAA,EAC7D,IAAI,KAAA,GAAQ;AACV,IAAA,OAAO,WAAA;AAAA,EACT,CAAA;AAAA,EACA,IAAI,QAAA,GAAW;AACb,IAAA,OAAO,WAAA;AAAA,EACT,CAAA;AAAA,EACA,IAAI,KAAA,GAAQ;AACV,IAAA,OAAO,WAAA;AAAA,EACT;AACF,CAAC,CAAA;AAGM,IAAM,aAAA,GAAgB,CAAA,CAAI,MAAA,CAAO,eAAA,EAAiB;AAAA,EACvD,IAAI,OAAA,GAAU;AACZ,IAAA,OAAO,CAAA,CAAI,MAAM,iBAAiB,CAAA;AAAA,EACpC;AACF,CAAC,CAAA;AAIM,IAAM,kBAAA,GAAqB,CAAA,CAAI,IAAA,CAAK,oBAAA,EAAsB;AAAA,EAC/D,OAAA,EAAS,EAAI,IAAA,EAAK;AAAA,EAClB,cAAA,EAAgB,EAAI,IAAA;AACtB,CAAC,CAAA;AAGM,IAAM,cAAA,GAAiB,CAAA,CAAI,MAAA,CAAO,gBAAA,EAAkB;AAAA,EACzD,IAAA,EAAM,EAAI,MAAA,EAAO;AAAA,EACjB,KAAA,EAAO,EAAI,SAAA;AACb,CAAC,CAAA;AAGM,IAAM,WAAA,GAAc,CAAA,CAAI,MAAA,CAAO,aAAA,EAAe;AAAA,EACnD,IAAI,OAAA,GAAU;AACZ,IAAA,OAAO,CAAA,CAAI,MAAM,cAAc,CAAA;AAAA,EACjC;AACF,CAAC,CAAA;AAIM,IAAM,UAAA,GAAa,CAAA,CAAI,IAAA,CAAK,YAAA,EAAc;AAAA,EAC/C,GAAA,EAAK,EAAI,IAAA,EAAK;AAAA,EACd,IAAA,EAAM,EAAI,IAAA,EAAK;AAAA,EACf,IAAA,EAAM,EAAI,IAAA,EAAK;AAAA,EACf,GAAA,EAAK,EAAI,IAAA,EAAK;AAAA,EACd,MAAA,EAAQ,EAAI,IAAA,EAAK;AAAA,EACjB,OAAA,EAAS,EAAI,IAAA,EAAK;AAAA,EAClB,OAAA,EAAS,EAAI,IAAA,EAAK;AAAA,EAClB,KAAA,EAAO,EAAI,IAAA,EAAK;AAAA,EAChB,KAAA,EAAO,EAAI,IAAA,EAAK;AAAA,EAChB,SAAA,EAAW,EAAI,MAAA;AACjB,CAAC,CAAA;AAG0B,CAAA,CAAI,MAAA,CAAO,aAAA,EAAe;AAAA,EACnD,IAAI,MAAA,GAAS;AACX,IAAA,OAAO,UAAA;AAAA,EACT,CAAA;AAAA,EACA,IAAI,OAAA,GAAU;AACZ,IAAA,OAAO,WAAA;AAAA,EACT,CAAA;AAAA,EACA,OAAA,EAAS,CAAA,CAAI,MAAA,CAAO,CAAA,CAAI,cAAc,CAAA;AAAA,EACtC,GAAA,EAAK,EAAI,MAAA,EAAO;AAAA,EAChB,IAAI,OAAA,GAAU;AACZ,IAAA,OAAO,WAAA;AAAA,EACT;AACF,CAAC;AAG2B,CAAA,CAAI,MAAA,CAAO,cAAA,EAAgB;AAAA,EACrD,IAAI,OAAA,GAAU;AACZ,IAAA,OAAO,WAAA;AAAA,EACT,CAAA;AAAA,EACA,IAAI,OAAA,GAAU;AACZ,IAAA,OAAO,WAAA;AAAA,EACT,CAAA;AAAA,EACA,IAAA,EAAM,EAAI,GAAA;AACZ,CAAC;AAIM,IAAM,WAAA,GAAc,CAAA,CAAI,IAAA,CAAK,aAAA,EAAe;AAAA,EACjD,MAAA,EAAQ,EAAI,IAAA,EAAK;AAAA,EACjB,MAAA,EAAQ,EAAI,IAAA,EAAK;AAAA,EACjB,MAAA,EAAQ,EAAI,IAAA,EAAK;AAAA,EACjB,KAAA,EAAO,EAAI,IAAA,EAAK;AAAA,EAChB,KAAA,EAAO,EAAI,IAAA;AACb,CAAC,CAAA;AAIM,IAAM,SAAA,GAAY,CAAA,CAAI,IAAA,CAAK,WAAA,EAAa;AAAA,EAC7C,KAAA,EAAO,EAAI,IAAA,EAAK;AAAA,EAChB,IAAA,EAAM,EAAI,IAAA;AACZ,CAAC,CAAA;AAIM,IAAM,SAAA,GAAY,CAAA,CAAI,IAAA,CAAK,WAAA,EAAa;AAAA,EAC7C,IAAA,EAAM,EAAI,IAAA,EAAK;AAAA,EACf,SAAA,EAAW,EAAI,IAAA,EAAK;AAAA,EACpB,YAAA,EAAc,EAAI,IAAA;AACpB,CAAC,CAAA;AAIM,IAAM,gBAAA,GAAmB,CAAA,CAAI,IAAA,CAAK,kBAAA,EAAoB;AAAA,EAC3D,IAAI,SAAA,GAAY;AACd,IAAA,OAAO,SAAA;AAAA,EACT;AACF,CAAC,CAAA;AAGM,IAAM,WAAA,GAAc,CAAA,CAAI,MAAA,CAAO,aAAA,EAAe;AAAA,EACnD,UAAA,EAAY,EAAI,MAAA,EAAO;AAAA,EACvB,aAAA,EAAe,EAAI,MAAA;AACrB,CAAC,CAAA;AAGM,IAAME,YAAAA,GAAc,CAAA,CAAI,MAAA,CAAO,aAAA,EAAe;AAAA,EACnD,IAAI,QAAA,GAAW;AACb,IAAA,OAAO,CAAA,CAAI,MAAM,kBAAkB,CAAA;AAAA,EACrC;AACF,CAAC,CAAA;AAGM,IAAM,kBAAA,GAAqB,CAAA,CAAI,MAAA,CAAO,oBAAA,EAAsB;AAAA,EACjE,IAAA,EAAM,CAAA,CAAI,MAAA,CAAO,CAAA,CAAI,QAAQ,CAAA;AAAA,EAC7B,IAAI,aAAA,GAAgB;AAClB,IAAA,OAAOF,cAAAA;AAAA,EACT;AACF,CAAC,CAAA;AAGM,IAAM,cAAA,GAAiB,CAAA,CAAI,MAAA,CAAO,gBAAA,EAAkB;AAAA,EACzD,OAAA,EAAS,EAAI,MAAA,EAAO;AAAA,EACpB,IAAI,OAAA,GAAU;AACZ,IAAA,OAAOA,cAAAA;AAAA,EACT;AACF,CAAC,CAAA;AAGM,IAAM,wBAAA,GAA2B,CAAA,CAAI,MAAA,CAAO,0BAAA,EAA4B;AAAA,EAC7E,KAAA,EAAO,EAAI,GAAA,EAAI;AAAA,EACf,KAAA,EAAO,EAAI,SAAA;AACb,CAAC,CAAA;AAGM,IAAM,uBAAA,GAA0B,CAAA,CAAI,MAAA,CAAO,yBAAA,EAA2B;AAAA,EAC3E,KAAA,EAAO,EAAI,MAAA,EAAO;AAAA,EAClB,KAAA,EAAO,EAAI,GAAA,EAAI;AAAA,EACf,KAAA,EAAO,EAAI,SAAA;AACb,CAAC,CAAA;AAIM,IAAM,mBAAA,GAAsB,CAAA,CAAI,IAAA,CAAK,qBAAA,EAAuB;AAAA,EACjE,IAAI,MAAA,GAAS;AACX,IAAA,OAAO,yBAAA;AAAA,EACT;AACF,CAAC,CAAA;AAGM,IAAM,mBAAA,GAAsB,CAAA,CAAI,MAAA,CAAO,qBAAA,EAAuB;AAAA,EACnE,UAAA,EAAY,CAAA,CAAI,MAAA,CAAO,CAAA,CAAI,QAAQ,CAAA;AAAA,EACnC,IAAI,IAAA,GAAO;AACT,IAAA,OAAO,mBAAA;AAAA,EACT;AACF,CAAC,CAAA;AAGM,IAAM,kBAAA,GAAqB,CAAA,CAAI,MAAA,CAAO,oBAAA,EAAsB;AAAA,EACjE,cAAA,EAAgB,EAAI,MAAA,EAAO;AAAA,EAC3B,WAAA,EAAa,EAAI,EAAA,EAAG;AAAA,EACpB,OAAA,EAAS,CAAA,CAAI,KAAA,CAAM,CAAA,CAAI,KAAK;AAC9B,CAAC,CAAA;AAGM,IAAM,kBAAA,GAAqB,CAAA,CAAI,MAAA,CAAO,oBAAA,EAAsB;AAAA,EACjE,IAAA,EAAM,CAAA,CAAI,MAAA,CAAO,CAAA,CAAI,QAAQ,CAAA;AAAA,EAC7B,IAAI,IAAA,GAAO;AACT,IAAA,OAAO,mBAAA;AAAA,EACT;AACF,CAAC,CAAA;AAIM,IAAM,iBAAA,GAAoB,CAAA,CAAI,IAAA,CAAK,mBAAA,EAAqB;AAAA,EAC7D,KAAA,EAAO,CAAA,CAAI,KAAA,CAAM,CAAA,CAAI,KAAK,CAAA;AAAA,EAC1B,IAAA,EAAM,CAAA,CAAI,KAAA,CAAM,CAAA,CAAI,KAAK,CAAA;AAAA,EACzB,MAAA,EAAQ,EAAI,GAAA;AACd,CAAC,CAAA;AAGM,IAAM,cAAA,GAAiB,CAAA,CAAI,MAAA,CAAO,gBAAA,EAAkB;AAAA,EACzD,UAAA,EAAY,CAAA,CAAI,MAAA,CAAO,CAAA,CAAI,QAAQ,CAAA;AAAA,EACnC,YAAA,EAAc,CAAA,CAAI,MAAA,CAAO,CAAA,CAAI,QAAQ,CAAA;AAAA,EACrC,IAAI,SAAA,GAAY;AACd,IAAA,OAAO,iBAAA;AAAA,EACT;AACF,CAAC,CAAA;AAGM,IAAM,aAAA,GAAgB,CAAA,CAAI,MAAA,CAAO,eAAA,EAAiB;AAAA,EACvD,SAAA,EAAW,EAAI,MAAA,EAAO;AAAA,EACtB,QAAA,EAAU,EAAI,IAAA,EAAK;AAAA,EACnB,IAAI,SAAA,GAAY;AACd,IAAA,OAAO,SAAA;AAAA,EACT,CAAA;AAAA,EACA,OAAA,EAAS,CAAA,CAAI,KAAA,CAAM,CAAA,CAAI,KAAK;AAC9B,CAAC,CAAA;AAGM,IAAM,aAAA,GAAgB,CAAA,CAAI,MAAA,CAAO,eAAA,EAAiB;AAAA,EACvD,IAAA,EAAM,CAAA,CAAI,MAAA,CAAO,CAAA,CAAI,QAAQ,CAAA;AAAA,EAC7B,YAAA,EAAc,CAAA,CAAI,MAAA,CAAO,CAAA,CAAI,QAAQ,CAAA;AAAA,EACrC,IAAI,SAAA,GAAY;AACd,IAAA,OAAO,iBAAA;AAAA,EACT;AACF,CAAC,CAAA;AAGM,IAAM,4BAA4B,CAAA,CAAI,MAAA;AAAA,EAC3C,2BAAA;AAAA,EACA;AAAA,IACE,IAAI,aAAA,GAAgB;AAClB,MAAA,OAAO,SAAA;AAAA,IACT,CAAA;AAAA,IACA,YAAA,EAAc,EAAI,MAAA;AAAO;AAE7B,CAAA;AAMO,IAAM,qBAAA,GAAwB,CAAA,CAAI,IAAA,CAAK,uBAAA,EAAyB;AAAA,EACrE,IAAI,kBAAA,GAAqB;AACvB,IAAA,OAAO,uBAAA;AAAA,EACT,CAAA;AAAA,EACA,IAAI,SAAA,GAAY;AACd,IAAA,OAAO,iBAAA;AAAA,EACT,CAAA;AAAA,EACA,IAAI,IAAA,GAAO;AACT,IAAA,OAAO,YAAA;AAAA,EACT;AACF,CAAC,CAAA;AAI2B,CAAA,CAAI,IAAA,CAAK,cAAA,EAAgB;AAAA,EACnD,IAAI,YAAA,GAAe;AACjB,IAAA,OAAO,cAAA;AAAA,EACT,CAAA;AAAA,EACA,IAAI,EAAA,GAAK;AACP,IAAA,OAAO,cAAA;AAAA,EACT,CAAA;AAAA,EACA,IAAI,GAAA,GAAM;AACR,IAAA,OAAO,eAAA;AAAA,EACT;AACF,CAAC;AAGM,IAAM,eAAA,GAAkB,CAAA,CAAI,MAAA,CAAO,iBAAA,EAAmB;AAAA,EAC3D,IAAI,QAAA,GAAW;AACb,IAAA,OAAO,CAAA,CAAI,MAAM,sBAAsB,CAAA;AAAA,EACzC;AACF,CAAC,CAAA;AAIM,IAAM,sBAAA,GAAyB,CAAA,CAAI,IAAA,CAAK,wBAAA,EAA0B;AAAA,EACvE,IAAI,SAAA,GAAY;AACd,IAAA,OAAO,SAAA;AAAA,EACT,CAAA;AAAA,EACA,IAAI,KAAA,GAAQ;AACV,IAAA,OAAO,CAAA,CAAI,MAAM,aAAa,CAAA;AAAA,EAChC,CAAA;AAAA,EACA,IAAI,MAAA,GAAS;AACX,IAAA,OAAO,CAAA,CAAI,MAAM,cAAc,CAAA;AAAA,EACjC,CAAA;AAAA,EACA,IAAI,QAAA,GAAW;AACb,IAAA,OAAO,CAAA,CAAI,MAAM,gBAAgB,CAAA;AAAA,EACnC,CAAA;AAAA,EACA,IAAI,UAAA,GAAa;AACf,IAAA,OAAO,CAAA,CAAI,MAAM,kBAAkB,CAAA;AAAA,EACrC,CAAA;AAAA,EACA,IAAI,KAAA,GAAQ;AACV,IAAA,OAAO,CAAA,CAAI,MAAM,aAAa,CAAA;AAAA,EAChC,CAAA;AAAA,EACA,IAAI,SAAA,GAAY;AACd,IAAA,OAAO,CAAA,CAAI,MAAM,iBAAiB,CAAA;AAAA,EACpC,CAAA;AAAA,EACA,IAAI,iBAAA,GAAoB;AACtB,IAAA,OAAO,CAAA,CAAI,MAAM,yBAAyB,CAAA;AAAA,EAC5C,CAAA;AAAA,EACA,IAAI,gBAAA,GAAmB;AACrB,IAAA,OAAO,CAAA,CAAI,MAAM,wBAAwB,CAAA;AAAA,EAC3C,CAAA;AAAA,EACA,IAAI,oBAAA,GAAuB;AACzB,IAAA,OAAO,oBAAA;AAAA,EACT,CAAA;AAAA,EACA,IAAI,aAAA,GAAgB;AAClB,IAAA,OAAO,aAAA;AAAA,EACT;AACF,CAAC,CAAA;AAGM,IAAM,cAAA,GAAiB,CAAA,CAAI,MAAA,CAAO,gBAAA,EAAkB;AAAA,EACzD,IAAI,SAAA,GAAY;AACd,IAAA,OAAO,SAAA;AAAA,EACT,CAAA;AAAA,EACA,IAAI,MAAA,GAAS;AACX,IAAA,OAAO,CAAA,CAAI,MAAM,SAAS,CAAA;AAAA,EAC5B,CAAA;AAAA,EACA,IAAI,QAAA,GAAW;AACb,IAAA,OAAO,CAAA,CAAI,MAAM,UAAU,CAAA;AAAA,EAC7B,CAAA;AAAA,EACA,IAAI,WAAA,GAAc;AAChB,IAAA,OAAO,CAAA,CAAI,MAAM,gBAAgB,CAAA;AAAA,EACnC;AACF,CAAC,CAAA;AAGM,IAAM,cAAA,GAAiB,CAAA,CAAI,MAAA,CAAO,gBAAA,EAAkB;AAAA,EACzD,IAAI,SAAA,GAAY;AACd,IAAA,OAAO,SAAA;AAAA,EACT,CAAA;AAAA,EACA,IAAI,MAAA,GAAS;AACX,IAAA,OAAO,CAAA,CAAI,MAAM,aAAa,CAAA;AAAA,EAChC,CAAA;AAAA,EACA,IAAI,QAAA,GAAW;AACb,IAAA,OAAO,CAAA,CAAI,MAAM,eAAe,CAAA;AAAA,EAClC,CAAA;AAAA,EACA,IAAI,KAAA,GAAQ;AACV,IAAA,OAAO,CAAA,CAAI,MAAM,YAAY,CAAA;AAAA,EAC/B,CAAA;AAAA,EACA,IAAI,WAAA,GAAc;AAChB,IAAA,OAAO,CAAA,CAAI,MAAM,qBAAqB,CAAA;AAAA,EACxC,CAAA;AAAA,EACA,IAAI,gBAAA,GAAmB;AACrB,IAAA,OAAO,CAAA,CAAI,MAAM,wBAAwB,CAAA;AAAA,EAC3C;AACF,CAAC,CAAA;AAGM,IAAM,kBAAA,GAAqB,CAAA,CAAI,MAAA,CAAO,oBAAA,EAAsB;AAAA,EACjE,UAAA,EAAY,EAAI,MAAA,EAAO;AAAA,EACvB,IAAI,MAAA,GAAS;AACX,IAAA,OAAOE,YAAAA;AAAA,EACT,CAAA;AAAA,EACA,IAAI,UAAA,GAAa;AACf,IAAA,OAAOF,cAAAA;AAAA,EACT,CAAA;AAAA,EACA,IAAI,UAAA,GAAa;AACf,IAAA,OAAO,kBAAA;AAAA,EACT;AACF,CAAC,CAAA;AAGM,IAAM,iBAAA,GAAoB,CAAA,CAAI,MAAA,CAAO,mBAAA,EAAqB;AAAA,EAC/D,IAAA,EAAM,EAAI,MAAA,EAAO;AAAA,EACjB,IAAI,MAAA,GAAS;AACX,IAAA,OAAOE,YAAAA;AAAA,EACT,CAAA;AAAA,EACA,IAAI,UAAA,GAAa;AACf,IAAA,OAAOF,cAAAA;AAAA,EACT;AACF,CAAC,CAAA;AAGM,IAAM,gBAAA,GAAmB,CAAA,CAAI,MAAA,CAAO,kBAAA,EAAoB;AAAA,EAC7D,UAAA,EAAY,EAAI,MAAA,EAAO;AAAA,EACvB,IAAI,MAAA,GAAS;AACX,IAAA,OAAOE,YAAAA;AAAA,EACT,CAAA;AAAA,EACA,IAAI,UAAA,GAAa;AACf,IAAA,OAAO,kBAAA;AAAA,EACT,CAAA;AAAA,EACA,IAAI,YAAA,GAAe;AACjB,IAAA,OAAOF,cAAAA;AAAA,EACT,CAAA;AAAA,EACA,IAAI,aAAA,GAAgB;AAClB,IAAA,OAAOA,cAAAA;AAAA,EACT;AACF,CAAC,CAAA;AAGM,IAAM,eAAA,GAAkB,CAAA,CAAI,MAAA,CAAO,iBAAA,EAAmB;AAAA,EAC3D,IAAA,EAAM,EAAI,MAAA,EAAO;AAAA,EACjB,IAAI,MAAA,GAAS;AACX,IAAA,OAAOE,YAAAA;AAAA,EACT,CAAA;AAAA,EACA,IAAI,SAAA,GAAY;AACd,IAAA,OAAO,CAAA,CAAI,OAAO,SAAS,CAAA;AAAA,EAC7B;AACF,CAAC,CAAA;AAGM,IAAM,wBAAA,GAA2B,CAAA,CAAI,MAAA,CAAO,0BAAA,EAA4B;AAAA,EAC7E,GAAA,EAAK,EAAI,MAAA;AACX,CAAC,CAAA;AAGM,IAAM,iBAAA,GAAoB,CAAA,CAAI,MAAA,CAAO,mBAAA,EAAqB;AAAA,EAC/D,UAAA,EAAY,CAAA,CAAI,MAAA,CAAO,CAAA,CAAI,QAAQ,CAAA;AAAA,EACnC,SAAA,EAAW,EAAI,MAAA,EAAO;AAAA,EACtB,aAAA,EAAe,EAAI,GAAA,EAAI;AAAA,EACvB,YAAA,EAAc,EAAI,MAAA;AACpB,CAAC,CAAA;AAGM,IAAM,gBAAA,GAAmB,CAAA,CAAI,MAAA,CAAO,kBAAA,EAAoB;AAAA,EAC7D,IAAA,EAAM,CAAA,CAAI,MAAA,CAAO,CAAA,CAAI,QAAQ,CAAA;AAAA,EAC7B,WAAA,EAAa,EAAI,MAAA,EAAO;AAAA,EACxB,iBAAA,EAAmB,EAAI,GAAA;AACzB,CAAC,CAAA;AAGM,IAAM,oBAAA,GAAuB,CAAA,CAAI,MAAA,CAAO,sBAAA,EAAwB;AAAA,EACrE,KAAA,EAAO,CAAA,CAAI,KAAA,CAAM,CAAA,CAAI,QAAQ,CAAA;AAAA,EAC7B,UAAA,EAAY,EAAI,MAAA;AAClB,CAAC,CAAA;AAGM,IAAM,mBAAA,GAAsB,CAAA,CAAI,MAAA,CAAO,qBAAA,EAAuB;AAAA,EACnE,KAAA,EAAO,CAAA,CAAI,KAAA,CAAM,CAAA,CAAI,QAAQ,CAAA;AAAA,EAC7B,IAAA,EAAM,EAAI,MAAA;AACZ,CAAC,CAAA;AAGM,IAAM,iBAAA,GAAoB,CAAA,CAAI,MAAA,CAAO,mBAAA,EAAqB;AAAA,EAC/D,UAAA,EAAY,CAAA,CAAI,MAAA,CAAO,CAAA,CAAI,QAAQ,CAAA;AAAA,EACnC,MAAA,EAAQ,EAAI,GAAA,EAAI;AAAA,EAChB,KAAA,EAAO,CAAA,CAAI,MAAA,CAAO,CAAA,CAAI,MAAM,CAAA;AAAA,EAC5B,QAAA,EAAU,CAAA,CAAI,MAAA,CAAO,CAAA,CAAI,MAAM,CAAA;AAAA,EAC/B,QAAA,EAAU,CAAA,CAAI,MAAA,CAAO,CAAA,CAAI,MAAM,CAAA;AAAA,EAC/B,SAAA,EAAW,EAAI,IAAA;AACjB,CAAC,CAAA;AAGM,IAAM,gBAAA,GAAmB,CAAA,CAAI,MAAA,CAAO,kBAAA,EAAoB;AAAA,EAC7D,YAAA,EAAc,EAAI,MAAA,EAAO;AAAA,EACzB,MAAA,EAAQ,EAAI,GAAA,EAAI;AAAA,EAChB,SAAA,EAAW,EAAI,IAAA,EAAK;AAAA,EACpB,KAAA,EAAO,CAAA,CAAI,MAAA,CAAO,CAAA,CAAI,MAAM,CAAA;AAAA,EAC5B,QAAA,EAAU,CAAA,CAAI,MAAA,CAAO,CAAA,CAAI,MAAM,CAAA;AAAA,EAC/B,QAAA,EAAU,CAAA,CAAI,MAAA,CAAO,CAAA,CAAI,MAAM,CAAA;AAAA,EAC/B,SAAA,EAAW,EAAI,IAAA;AACjB,CAAC,CAAA;AAGM,IAAM,gBAAA,GAAmB,CAAA,CAAI,MAAA,CAAO,kBAAA,EAAoB;AAAA,EAC7D,IAAA,EAAM,CAAA,CAAI,MAAA,CAAO,CAAA,CAAI,QAAQ,CAAA;AAAA,EAC7B,MAAA,EAAQ,EAAI,GAAA,EAAI;AAAA,EAChB,KAAA,EAAO,CAAA,CAAI,MAAA,CAAO,CAAA,CAAI,MAAM,CAAA;AAAA,EAC5B,QAAA,EAAU,CAAA,CAAI,MAAA,CAAO,CAAA,CAAI,MAAM,CAAA;AAAA,EAC/B,QAAA,EAAU,CAAA,CAAI,MAAA,CAAO,CAAA,CAAI,MAAM,CAAA;AAAA,EAC/B,SAAA,EAAW,EAAI,IAAA;AACjB,CAAC,CAAA;AAGM,IAAM,cAAA,GAAiB,CAAA,CAAI,MAAA,CAAO,gBAAA,EAAkB;AAAA,EACzD,UAAA,EAAY,EAAI,MAAA,EAAO;AAAA,EACvB,cAAA,EAAgB,EAAI,GAAA,EAAI;AAAA,EACxB,UAAA,EAAY,CAAA,CAAI,KAAA,CAAM,CAAA,CAAI,KAAK,CAAA;AAAA,EAC/B,IAAI,OAAA,GAAU;AACZ,IAAA,OAAO,CAAA,CAAI,MAAM,cAAc,CAAA;AAAA,EACjC,CAAA;AAAA,EACA,IAAI,WAAA,GAAc;AAChB,IAAA,OAAO,CAAA,CAAI,MAAM,mBAAmB,CAAA;AAAA,EACtC,CAAA;AAAA,EACA,IAAI,SAAA,GAAY;AACd,IAAA,OAAO,CAAA,CAAI,MAAM,iBAAiB,CAAA;AAAA,EACpC,CAAA;AAAA,EACA,IAAI,SAAA,GAAY;AACd,IAAA,OAAO,SAAA;AAAA,EACT,CAAA;AAAA,EACA,IAAI,WAAA,GAAc;AAChB,IAAA,OAAO,WAAA;AAAA,EACT,CAAA;AAAA,EACA,IAAI,aAAA,GAAgB;AAClB,IAAA,OAAO,CAAA,CAAI,MAAM,wBAAwB,CAAA;AAAA,EAC3C,CAAA;AAAA,EACA,OAAA,EAAS,EAAI,IAAA;AACf,CAAC,CAAA;AAGM,IAAM,aAAA,GAAgB,CAAA,CAAI,MAAA,CAAO,eAAA,EAAiB;AAAA,EACvD,SAAA,EAAW,EAAI,MAAA,EAAO;AAAA,EACtB,IAAI,OAAA,GAAU;AACZ,IAAA,OAAO,CAAA,CAAI,MAAM,cAAc,CAAA;AAAA,EACjC,CAAA;AAAA,EACA,IAAI,OAAA,GAAU;AACZ,IAAA,OAAO,CAAA,CAAI,MAAM,aAAa,CAAA;AAAA,EAChC,CAAA;AAAA,EACA,IAAI,WAAA,GAAc;AAChB,IAAA,OAAO,CAAA,CAAI,MAAM,kBAAkB,CAAA;AAAA,EACrC,CAAA;AAAA,EACA,IAAI,SAAA,GAAY;AACd,IAAA,OAAO,CAAA,CAAI,MAAM,gBAAgB,CAAA;AAAA,EACnC,CAAA;AAAA,EACA,SAAA,EAAW,EAAI,MAAA,EAAO;AAAA,EACtB,WAAA,EAAa,EAAI,MAAA,EAAO;AAAA,EACxB,SAAA,EAAW,CAAA,CAAI,MAAA,CAAO,CAAA,CAAI,QAAQ;AACpC,CAAC,CAAA;AAGM,IAAM,aAAA,GAAgB,CAAA,CAAI,MAAA,CAAO,eAAA,EAAiB;AAAA,EACvD,IAAA,EAAM,EAAI,MAAA,EAAO;AAAA,EACjB,cAAA,EAAgB,EAAI,GAAA,EAAI;AAAA,EACxB,UAAA,EAAY,CAAA,CAAI,KAAA,CAAM,CAAA,CAAI,KAAK,CAAA;AAAA,EAC/B,IAAI,OAAA,GAAU;AACZ,IAAA,OAAO,CAAA,CAAI,MAAM,aAAa,CAAA;AAAA,EAChC,CAAA;AAAA,EACA,IAAI,WAAA,GAAc;AAChB,IAAA,OAAO,CAAA,CAAI,MAAM,kBAAkB,CAAA;AAAA,EACrC,CAAA;AAAA,EACA,IAAI,SAAA,GAAY;AACd,IAAA,OAAO,CAAA,CAAI,MAAM,gBAAgB,CAAA;AAAA,EACnC,CAAA;AAAA,EACA,IAAI,QAAA,GAAW;AACb,IAAA,OAAO,CAAA,CAAI,OAAO,gBAAgB,CAAA;AAAA,EACpC,CAAA;AAAA,EACA,IAAI,SAAA,GAAY;AACd,IAAA,OAAO,SAAA;AAAA,EACT,CAAA;AAAA,EACA,IAAI,WAAA,GAAc;AAChB,IAAA,OAAO,WAAA;AAAA,EACT;AACF,CAAC,CAAA;AAGM,IAAM,aAAA,GAAgB,CAAA,CAAI,MAAA,CAAO,eAAA,EAAiB;AAAA,EACvD,IAAI,UAAA,GAAa;AACf,IAAA,OAAO,oBAAA;AAAA,EACT,CAAA;AAAA,EACA,EAAA,EAAI,EAAI,GAAA,EAAI;AAAA,EACZ,cAAA,EAAgB,EAAI,IAAA;AACtB,CAAC,CAAA;AAGM,IAAM,YAAA,GAAe,CAAA,CAAI,MAAA,CAAO,cAAA,EAAgB;AAAA,EACrD,IAAI,IAAA,GAAO;AACT,IAAA,OAAO,mBAAA;AAAA,EACT,CAAA;AAAA,EACA,EAAA,EAAI,EAAI,GAAA,EAAI;AAAA,EACZ,cAAA,EAAgB,EAAI,IAAA;AACtB,CAAC,CAAA;AAGM,IAAM,4BAA4B,CAAA,CAAI,MAAA;AAAA,EAC3C,2BAAA;AAAA,EACA;AAAA,IACE,OAAA,EAAS,CAAA,CAAI,KAAA,CAAM,CAAA,CAAI,KAAK;AAAA;AAEhC,CAAA;AAKO,IAAM,aAAA,GAAgB,CAAA,CAAI,MAAA,CAAO,eAAA,EAAiB;AAAA,EACvD,UAAA,EAAY,EAAI,MAAA,EAAO;AAAA,EACvB,KAAA,EAAO,EAAI,GAAA,EAAI;AAAA,EACf,QAAA,EAAU,EAAI,IAAA,EAAK;AAAA,EACnB,WAAA,EAAa,EAAI,IAAA,EAAK;AAAA,EACtB,IAAI,MAAA,GAAS;AACX,IAAA,OAAOA,YAAAA;AAAA,EACT,CAAA;AAAA,EACA,IAAI,UAAA,GAAa;AACf,IAAA,OAAOF,cAAAA;AAAA,EACT;AACF,CAAC,CAAA;AAGM,IAAM,YAAA,GAAe,CAAA,CAAI,MAAA,CAAO,cAAA,EAAgB;AAAA,EACrD,IAAA,EAAM,EAAI,MAAA,EAAO;AAAA,EACjB,KAAA,EAAO,EAAI,GAAA,EAAI;AAAA,EACf,QAAA,EAAU,EAAI,IAAA,EAAK;AAAA,EACnB,WAAA,EAAa,EAAI,IAAA,EAAK;AAAA,EACtB,IAAI,MAAA,GAAS;AACX,IAAA,OAAOE,YAAAA;AAAA,EACT,CAAA;AAAA,EACA,IAAI,UAAA,GAAa;AACf,IAAA,OAAOF,cAAAA;AAAA,EACT;AACF,CAAC,CAAA;AAGM,IAAM,UAAA,GAAa,CAAA,CAAI,MAAA,CAAO,YAAA,EAAc;AAAA,EACjD,IAAA,EAAM,EAAI,MAAA,EAAO;AAAA,EACjB,IAAI,IAAA,GAAO;AACT,IAAA,OAAO,CAAA,CAAI,MAAM,kBAAkB,CAAA;AAAA,EACrC;AACF,CAAC,CAAA;AAGM,IAAMC,QAAAA,GAAU,CAAA,CAAI,MAAA,CAAO,SAAA,EAAW;AAAA,EAC3C,IAAI,QAAA,GAAW;AACb,IAAA,OAAO,CAAA,CAAI,MAAM,cAAc,CAAA;AAAA,EACjC;AACF,CAAC,CAAA;AAGM,IAAM,cAAA,GAAiB,CAAA,CAAI,MAAA,CAAO,gBAAA,EAAkB;AAAA,EACzD,IAAA,EAAM,CAAA,CAAI,MAAA,CAAO,CAAA,CAAI,QAAQ,CAAA;AAAA,EAC7B,IAAI,aAAA,GAAgB;AAClB,IAAA,OAAOD,cAAAA;AAAA,EACT;AACF,CAAC,CAAA;AAIM,IAAM,WAAA,GAAc,CAAA,CAAI,IAAA,CAAK,aAAA,EAAe;AAAA,EACjD,MAAA,EAAQ,EAAI,IAAA,EAAK;AAAA,EACjB,OAAA,EAAS,EAAI,IAAA;AACf,CAAC,CAAA;AAGM,IAAM,SAAA,GAAY,CAAA,CAAI,MAAA,CAAO,WAAA,EAAa;AAAA,EAC/C,IAAI,MAAA,GAAS;AACX,IAAA,OAAO,aAAA;AAAA,EACT,CAAA;AAAA,EACA,IAAA,EAAM,EAAI,GAAA;AACZ,CAAC,CAAA;AAIM,IAAM,SAAA,GAAY,CAAA,CAAI,IAAA,CAAK,WAAA,EAAa;AAAA,EAC7C,MAAA,EAAQ,EAAI,IAAA,EAAK;AAAA,EACjB,IAAA,EAAM,EAAI,IAAA;AACZ,CAAC,CAAA;AAGM,IAAM,SAAA,GAAY,CAAA,CAAI,MAAA,CAAO,WAAA,EAAa;AAAA,EAC/C,IAAA,EAAM,EAAI,MAAA,EAAO;AAAA,EACjB,EAAA,EAAI,EAAI,GAAA;AACV,CAAC,CAAA;AAGM,IAAM,SAAA,GAAY,CAAA,CAAI,MAAA,CAAO,WAAA,EAAa;AAAA,EAC/C,IAAI,KAAA,GAAQ;AACV,IAAA,OAAO,CAAA,CAAI,MAAMA,cAAa,CAAA;AAAA,EAChC;AACF,CAAC,CAAA;AAI+B,CAAA,CAAI,IAAA,CAAK,kBAAA,EAAoB;AAAA,EAC3D,OAAA,EAAS,EAAI,IAAA,EAAK;AAAA,EAClB,MAAA,EAAQ,EAAI,MAAA;AACd,CAAC;;;ACnaM,SAAS,KAAA,CACd,IAAA,EACA,GAAA,EAAA,GAKG,CAAA,EAO6C;AAChD,EAAA,MAAM;AAAA,IACJ,IAAA;AAAA,IACA,QAAQ,QAAA,GAAW,KAAA;AAAA,IACnB,OAAA,EAAS,cAAc,EAAC;AAAA,IACxB,SAAA;AAAA,IACA,OAAO,OAAA,GAAU;AAAA,GACnB,GAAI,IAAA;AAGJ,EAAA,MAAM,MAAA,uBAAa,GAAA,EAA+B;AAClD,EAAA,MAAM,cAAwB,EAAC;AAE/B,EAAA,IAAI,EAAE,eAAe,UAAA,CAAA,EAAa;AAChC,IAAA,GAAA,GAAM,IAAI,WAAW,GAAG,CAAA;AAAA,EAC1B;AAEA,EAAA,GAAA,CAAI,cAAc,KAAA,CAAM,QAAA,CAAS,OAAA,CAAQ,CAAC,MAAM,CAAA,KAAM;AACpD,IAAA,MAAA,CAAO,GAAA,CAAI,IAAA,CAAK,IAAA,EAAM,CAAC,CAAA;AACvB,IAAA,WAAA,CAAY,IAAA,CAAK,KAAK,IAAI,CAAA;AAAA,EAC5B,CAAC,CAAA;AAGD,EAAA,MAAM,KAAc,EAAC;AACrB,EAAA,MAAM,UAA2D,EAAC;AAClE,EAAA,MAAM,cAAqC,EAAC;AAC5C,EAAA,MAAM,YAAiC,EAAC;AAExC,EAAA,IAAI,aAAA;AACJ,EAAA,MAAM,gBAA4C,EAAC;AAEnD,EAAA,KAAA,MAAW,CAACL,OAAM,OAAO,CAAA,IAAK,OAAO,OAAA,CAAQ,GAAA,CAAI,GAAG,CAAA,EAAG;AACrD,IAAA,MAAM,OAA4B,OAAA,CAAQ,cAAA;AAE1C,IAAA,IAAI,KAAK,YAAA,EAAc;AACrB,MAAA,EAAA,CAAG,IAAA,CAAK,MAAA,CAAO,GAAA,CAAIA,KAAI,CAAE,CAAA;AAAA,IAC3B;AAEA,IAAA,MAAM,QAAA,GAAW,IAAA,CAAK,QAAA,IAAY,IAAA,CAAK,YAAA;AAGvC,IAAA,IAAI,IAAA,CAAK,aAAa,QAAA,EAAU;AAC9B,MAAA,MAAM,IAAA,GAAO,KAAK,SAAA,IAAa,OAAA;AAC/B,MAAA,MAAM,EAAA,GAAK,MAAA,CAAO,GAAA,CAAIA,KAAI,CAAA;AAC1B,MAAA,IAAI,SAAA;AACJ,MAAA,QAAQ,IAAA;AAAM,QACZ,KAAK,OAAA;AACH,UAAA,SAAA,GAAY,iBAAA,CAAkB,KAAA,CAAM,CAAC,EAAE,CAAC,CAAA;AACxC,UAAA;AAAA,QACF,KAAK,MAAA;AACH,UAAA,SAAA,GAAY,iBAAA,CAAkB,IAAA,CAAK,CAAC,EAAE,CAAC,CAAA;AACvC,UAAA;AAAA,QACF,KAAK,QAAA;AACH,UAAA,SAAA,GAAY,iBAAA,CAAkB,OAAO,EAAE,CAAA;AACvC,UAAA;AAAA;AAEJ,MAAA,OAAA,CAAQ,IAAA,CAAK;AAAA,QACX,UAAA,EAAY,MAAA;AAAA;AAAA,QACZ,YAAA,EAAcA,KAAAA;AAAA,QACd;AAAA,OACD,CAAA;AAAA,IACH;AAEA,IAAA,IAAI,QAAA,EAAU;AACZ,MAAA,WAAA,CAAY,IAAA,CAAK;AAAA,QACf,UAAA,EAAY,MAAA;AAAA,QACZ,IAAA,EAAM,EAAE,GAAA,EAAK,QAAA,EAAU,KAAA,EAAO,EAAE,OAAA,EAAS,CAAC,MAAA,CAAO,GAAA,CAAIA,KAAI,CAAE,GAAE;AAAE,OAChE,CAAA;AAAA,IACH;AAEA,IAAA,IAAI,KAAK,eAAA,EAAiB;AACxB,MAAA,SAAA,CAAU,IAAA,CAAK;AAAA,QACb,UAAA,EAAY,MAAA;AAAA,QACZ,KAAA,EAAO,MAAA;AAAA,QACP,QAAA,EAAU,MAAA;AAAA,QACV,QAAA,EAAU,MAAA;AAAA,QACV,MAAA,EAAQ,MAAA,CAAO,GAAA,CAAIA,KAAI,CAAA;AAAA,QACvB,SAAA,EAAW;AAAA,OACZ,CAAA;AAAA,IACH;AAEA,IAAA,IAAI,KAAK,YAAA,EAAc;AACrB,MAAA,MAAM,MAAA,GAAS,IAAI,YAAA,CAAa,EAAE,CAAA;AAClC,MAAA,OAAA,CAAQ,SAAA,CAAU,MAAA,EAAQ,IAAA,CAAK,YAAY,CAAA;AAC3C,MAAA,aAAA,CAAc,IAAA,CAAK;AAAA,QACjB,KAAA,EAAO,MAAA,CAAO,GAAA,CAAIA,KAAI,CAAA;AAAA,QACtB,KAAA,EAAO,OAAO,SAAA;AAAU,OACzB,CAAA;AAAA,IACH;AAGA,IAAA,IAAI,SAAA,EAAW;AACb,MAAA,MAAM,aAAA,GAAgB,QAAQ,WAAA,CAAY,aAAA;AAC1C,MAAA,IAAI,mBAAA,CAAW,YAAA,CAAa,aAAa,CAAA,EAAG;AAC1C,QAAA,aAAA,GAAgB,MAAA,CAAO,IAAIA,KAAI,CAAA;AAAA,MACjC;AAAA,IACF;AAAA,EACF;AAGA,EAAA,KAAA,MAAW,SAAA,IAAa,WAAA,IAAe,EAAC,EAAG;AACzC,IAAA,IAAI,SAAA;AACJ,IAAA,QAAQ,UAAU,SAAA;AAAW,MAC3B,KAAK,OAAA;AACH,QAAA,SAAA,GAAY;AAAA,UACV,GAAA,EAAK,OAAA;AAAA,UACL,KAAA,EAAO,UAAU,OAAA,CAAQ,GAAA,CAAI,OAAK,MAAA,CAAO,GAAA,CAAI,CAAC,CAAE;AAAA,SAClD;AACA,QAAA;AAAA,MACF,KAAK,MAAA;AACH,QAAA,SAAA,GAAY;AAAA,UACV,GAAA,EAAK,MAAA;AAAA,UACL,KAAA,EAAO,UAAU,OAAA,CAAQ,GAAA,CAAI,OAAK,MAAA,CAAO,GAAA,CAAI,CAAC,CAAE;AAAA,SAClD;AACA,QAAA;AAAA,MACF,KAAK,QAAA;AACH,QAAA,SAAA,GAAY,EAAE,KAAK,QAAA,EAAU,KAAA,EAAO,OAAO,GAAA,CAAI,SAAA,CAAU,MAAM,CAAA,EAAG;AAClE,QAAA;AAAA;AASJ,IAAA,OAAA,CAAQ,IAAA,CAAK;AAAA,MACX,UAAA,EAAY,MAAA;AAAA,MACZ,cAAc,SAAA,CAAU,QAAA;AAAA,MACxB,SAAA;AAAA,MACA,eAAe,SAAA,CAAU;AAAA,KAC1B,CAAA;AAAA,EACH;AAGA,EAAA,KAAA,MAAW,cAAA,IAAkB,IAAA,CAAK,WAAA,IAAe,EAAC,EAAG;AACnD,IAAA,IAAI,cAAA,CAAe,eAAe,QAAA,EAAU;AAC1C,MAAA,MAAM,IAAA,GAAoC;AAAA,QACxC,GAAA,EAAK,QAAA;AAAA,QACL,KAAA,EAAO,EAAE,OAAA,EAAS,cAAA,CAAe,OAAA,CAAQ,GAAA,CAAI,CAAA,CAAA,KAAK,MAAA,CAAO,GAAA,CAAI,CAAC,CAAE,CAAA;AAAE,OACpE;AACA,MAAA,WAAA,CAAY,KAAK,EAAE,UAAA,EAAY,cAAA,CAAe,IAAA,EAAM,MAAM,CAAA;AAC1D,MAAA;AAAA,IACF;AAAA,EACF;AAEA,EAAA,MAAM,WAAA,GAAc,IAAI,aAAA,CAAc,KAAA;AAItC,EAAA,MAAM,QAAA,GACJ,aAAa,aAAA,KAAkB,MAAA,GAC3B,EAAE,aAAA,EAAe,OAAA,EAAS,WAAU,GACpC,MAAA;AAEN,EAAA,OAAO;AAAA,IACL,OAAA,EAAS,GAAA;AAAA,IACT,SAAA,EAAW,IAAA;AAAA,IACX,gBAAA,EAAkB,WAAA;AAAA,IAClB,QAAA,EAAU,CAAC,GAAA,EAAK,OAAA,KAAY;AAC1B,MAAA,MAAM,YAAY,IAAA,IAAQ,OAAA;AAC1B,MAAA,IAAI,GAAA,CAAI,aAAa,MAAA,EAAW;AAC9B,QAAA,GAAA,CAAI,QAAA,GAAW,aAAa,SAAS,CAAA;AAAA,MACvC;AAGA,MAAA,KAAA,MAAW,SAAS,OAAA,EAAS;AAC3B,QAAA,MAAM,IAAA,GACJ,KAAA,CAAM,SAAA,CAAU,GAAA,KAAQ,QAAA,GACpB,CAAC,KAAA,CAAM,SAAA,CAAU,KAAK,CAAA,GACtB,KAAA,CAAM,SAAA,CAAU,KAAA;AAEtB,QAAA,MAAM,IAAA,GAAO,KAAK,GAAA,CAAI,CAAA,CAAA,KAAK,YAAY,CAAC,CAAC,CAAA,CAAE,IAAA,CAAK,GAAG,CAAA;AACnD,QAAA,MAAM,UAAA,GACH,KAAA,CAAM,UAAA,GAAa,CAAA,EAAG,OAAO,CAAA,CAAA,EAAI,IAAI,CAAA,KAAA,EAAQ,KAAA,CAAM,SAAA,CAAU,GAAA,CAAI,WAAA,EAAa,CAAA,CAAA;AAEjF,QAAA,MAAM,EAAE,eAAc,GAAI,KAAA;AAC1B,QAAA,IAAI,kBAAkB,MAAA,EAAW;AAC/B,UAAA,GAAA,CAAI,SAAA,CAAU,cAAc,OAAA,CAAQ,IAAA;AAAA,YAClC,iBAAA,CAAkB,KAAA,CAAM,EAAE,UAAA,EAAY,eAAe;AAAA,WACvD;AAAA,QACF;AAAA,MACF;AAEA,MAAA,OAAO;AAAA,QACL,UAAA,EAAY,OAAA;AAAA,QACZ,cAAA,EAAgB,GAAA,CAAI,wBAAA,CAAyB,GAAG,CAAA,CAAE,GAAA;AAAA,QAClD,UAAA,EAAY,EAAA;AAAA,QACZ,OAAA;AAAA,QACA,WAAA;AAAA,QACA,SAAA;AAAA,QACA,SAAA,EAAW,EAAE,GAAA,EAAK,MAAA,EAAO;AAAA,QACzB,WAAA,EAAa,EAAE,GAAA,EAAK,QAAA,GAAW,WAAW,SAAA,EAAU;AAAA,QACpD,aAAA;AAAA,QACA;AAAA,OACF;AAAA,IACF,CAAA;AAAA,IACA,MAAM,EAAC;AAAA,IACP,WAAA;AAAA,IACA;AAAA,GACF;AACF;;;AC/bA,IAAM,WAAN,MAAuD;AAAA,EACrD,YAAA;AAAA,EAEA,YAAY,OAAA,EAA6C;AACvD,IAAA,IAAA,CAAK,YAAA,GAAe,iBAAiB,OAAO,CAAA;AAAA,EAC9C;AACF,CAAA;AAiBO,SAAS,iBAEdQ,SAAAA,EAAkC;AAClC,EAAA,MAAM,MAAA,GAASA,SAAAA,CAAS,GAAA,CAAI,CAAA,CAAA,KAAK;AAC/B,IAAA,MAAM,SAAA,GAAY,EAAE,MAAA,CAAO,GAAA;AAE3B,IAAA,OAAO;AAAA,MACL,MAAM,CAAA,CAAE,WAAA;AAAA;AAAA,MAER,cAAc,CAAA,CAAE,YAAA;AAAA,MAChB,MAAA,EAAQ,SAAA;AAAA,MACR,YAAY,CAAA,CAAE;AAAA,KAChB;AAAA,EACF,CAAC,CAAA;AASD,EAAA,MAAM,MAAA,GAAS,EAAE,QAAA,EAAU,MAAA,EAAO;AAClC,EAAA,OAAO,MAAA;AACT;AA2BO,SAAS,YACX,IAAA,EAC4B;AAC/B,EAAA,MAAM,OAAA,GACJ,IAAA,CAAK,MAAA,KAAW,CAAA,IAAK,KAAA,CAAM,OAAA,CAAQ,IAAA,CAAK,CAAC,CAAC,CAAA,GAAI,IAAA,CAAK,CAAC,CAAA,GAAI,IAAA;AAE1D,EAAA,OAAO,IAAI,SAAS,OAAO,CAAA;AAC7B;AAEO,SAAS,aAAA,CAGd,MAAmB,MAAA,EAAoD;AACvE,EAAA,MAAM,SAAA,GAAyB;AAAA,IAC7B,QAAA,EAAU,MAAA,CAAO,OAAA,CAAQ,MAAM,CAAA,CAAE,IAAI,CAAC,CAAC,CAAA,EAAG,CAAC,CAAA,MAAO;AAAA,MAChD,IAAA,EAAM,CAAA;AAAA,MACN,eACE,aAAA,IAAiB,CAAA,GAAI,CAAA,CAAE,WAAA,CAAY,gBAAgB,CAAA,CAAE;AAAA,KACzD,CAAE;AAAA,GACJ;AACA,EAAA,OAAO;AAAA,IACL,WAAA,EAAa,IAAA;AAAA,IACb,YAAA,EAAc,YAAY,IAAI,CAAA;AAAA,IAC9B,MAAA,EAAQ,IAAI,UAAA,CAAmB,MAAM,CAAA;AAAA,IACrC,mBAAA,EAAqB,SAAA;AAAA,IACrB,UAAA,EAAY;AAAA,MACV,IAAA;AAAA,MACA,MAAA,EAAQ,SAAA;AAAA,MACR,SAAA,EAAW;AAAA;AACb,GACF;AACF;;;AC/GO,SAAS,cACX,IAAA,EACgB;AACnB,EAAA,MAAMC,WAAAA,GACJ,IAAA,CAAK,MAAA,KAAW,CAAA,IAAK,KAAA,CAAM,OAAA,CAAQ,IAAA,CAAK,CAAC,CAAC,CAAA,GAAI,IAAA,CAAK,CAAC,CAAA,GAAI,IAAA;AAE1D,EAAA,OAAO,EAAE,YAAAA,WAAAA,EAAW;AACtB;AAaO,SAAS,eAAA,CAKd,IAAA,EACA,MAAA,EACA,UAAA,EACiD;AACjD,EAAA,OAAO;AAAA,IACL,IAAA;AAAA,IACA,YAAA,EAAc,YAAY,IAAI,CAAA;AAAA,IAC9B,MAAA,EAAQ,aAAa,MAAM,CAAA;AAAA,IAC3B;AAAA,GACF;AACF","file":"index.browser.mjs","sourcesContent":["import { AlgebraicType } from './algebraic_type';\n\nexport type TimeDurationAlgebraicType = {\n  tag: 'Product';\n  value: {\n    elements: [\n      { name: '__time_duration_micros__'; algebraicType: { tag: 'I64' } },\n    ];\n  };\n};\n\n/**\n * A difference between two points in time, represented as a number of microseconds.\n */\nexport class TimeDuration {\n  __time_duration_micros__: bigint;\n\n  private static MICROS_PER_MILLIS: bigint = 1000n;\n\n  /**\n   * Get the algebraic type representation of the {@link TimeDuration} type.\n   * @returns The algebraic type representation of the type.\n   */\n  static getAlgebraicType(): TimeDurationAlgebraicType {\n    return AlgebraicType.Product({\n      elements: [\n        {\n          name: '__time_duration_micros__',\n          algebraicType: AlgebraicType.I64,\n        },\n      ],\n    });\n  }\n\n  static isTimeDuration(\n    algebraicType: AlgebraicType\n  ): algebraicType is TimeDurationAlgebraicType {\n    if (algebraicType.tag !== 'Product') {\n      return false;\n    }\n    const elements = algebraicType.value.elements;\n    if (elements.length !== 1) {\n      return false;\n    }\n    const microsElement = elements[0];\n    return (\n      microsElement.name === '__time_duration_micros__' &&\n      microsElement.algebraicType.tag === 'I64'\n    );\n  }\n\n  get micros(): bigint {\n    return this.__time_duration_micros__;\n  }\n\n  get millis(): number {\n    return Number(this.micros / TimeDuration.MICROS_PER_MILLIS);\n  }\n\n  constructor(micros: bigint) {\n    this.__time_duration_micros__ = micros;\n  }\n\n  static fromMillis(millis: number): TimeDuration {\n    return new TimeDuration(BigInt(millis) * TimeDuration.MICROS_PER_MILLIS);\n  }\n\n  /** This outputs the same string format that we use in the host and in Rust modules */\n  toString(): string {\n    const micros = this.micros;\n    const sign = micros < 0 ? '-' : '+';\n    const pos = micros < 0 ? -micros : micros;\n    const secs = pos / 1_000_000n;\n    const micros_remaining = pos % 1_000_000n;\n    return `${sign}${secs}.${String(micros_remaining).padStart(6, '0')}`;\n  }\n}\n","import { AlgebraicType } from './algebraic_type';\nimport { TimeDuration } from './time_duration';\n\nexport type TimestampAlgebraicType = {\n  tag: 'Product';\n  value: {\n    elements: [\n      {\n        name: '__timestamp_micros_since_unix_epoch__';\n        algebraicType: { tag: 'I64' };\n      },\n    ];\n  };\n};\n\n/**\n * A point in time, represented as a number of microseconds since the Unix epoch.\n */\nexport class Timestamp {\n  __timestamp_micros_since_unix_epoch__: bigint;\n\n  private static MICROS_PER_MILLIS: bigint = 1000n;\n\n  get microsSinceUnixEpoch(): bigint {\n    return this.__timestamp_micros_since_unix_epoch__;\n  }\n\n  constructor(micros: bigint) {\n    this.__timestamp_micros_since_unix_epoch__ = micros;\n  }\n\n  /**\n   * Get the algebraic type representation of the {@link Timestamp} type.\n   * @returns The algebraic type representation of the type.\n   */\n  static getAlgebraicType(): TimestampAlgebraicType {\n    return AlgebraicType.Product({\n      elements: [\n        {\n          name: '__timestamp_micros_since_unix_epoch__',\n          algebraicType: AlgebraicType.I64,\n        },\n      ],\n    });\n  }\n\n  static isTimestamp(\n    algebraicType: AlgebraicType\n  ): algebraicType is TimestampAlgebraicType {\n    if (algebraicType.tag !== 'Product') {\n      return false;\n    }\n    const elements = algebraicType.value.elements;\n    if (elements.length !== 1) {\n      return false;\n    }\n    const microsElement = elements[0];\n    return (\n      microsElement.name === '__timestamp_micros_since_unix_epoch__' &&\n      microsElement.algebraicType.tag === 'I64'\n    );\n  }\n\n  /**\n   * The Unix epoch, the midnight at the beginning of January 1, 1970, UTC.\n   */\n  static UNIX_EPOCH: Timestamp = new Timestamp(0n);\n\n  /**\n   * Get a `Timestamp` representing the execution environment's belief of the current moment in time.\n   */\n  static now(): Timestamp {\n    return Timestamp.fromDate(new Date());\n  }\n\n  /** Convert to milliseconds since Unix epoch. */\n  toMillis(): bigint {\n    return this.microsSinceUnixEpoch / 1000n;\n  }\n\n  /**\n   * Get a `Timestamp` representing the same point in time as `date`.\n   */\n  static fromDate(date: Date): Timestamp {\n    const millis = date.getTime();\n    const micros = BigInt(millis) * Timestamp.MICROS_PER_MILLIS;\n    return new Timestamp(micros);\n  }\n\n  /**\n   * Get a `Date` representing approximately the same point in time as `this`.\n   *\n   * This method truncates to millisecond precision,\n   * and throws `RangeError` if the `Timestamp` is outside the range representable as a `Date`.\n   */\n  toDate(): Date {\n    const micros = this.__timestamp_micros_since_unix_epoch__;\n    const millis = micros / Timestamp.MICROS_PER_MILLIS;\n    if (\n      millis > BigInt(Number.MAX_SAFE_INTEGER) ||\n      millis < BigInt(Number.MIN_SAFE_INTEGER)\n    ) {\n      throw new RangeError(\n        \"Timestamp is outside of the representable range of JS's Date\"\n      );\n    }\n    return new Date(Number(millis));\n  }\n\n  /**\n   * Get an ISO 8601 / RFC 3339 formatted string representation of this timestamp with microsecond precision.\n   *\n   * This method preserves the full microsecond precision of the timestamp,\n   * and throws `RangeError` if the `Timestamp` is outside the range representable in ISO format.\n   *\n   * @returns ISO 8601 formatted string with microsecond precision (e.g., '2025-02-17T10:30:45.123456Z')\n   */\n  toISOString(): string {\n    const micros = this.__timestamp_micros_since_unix_epoch__;\n    const millis = micros / Timestamp.MICROS_PER_MILLIS;\n\n    if (\n      millis > BigInt(Number.MAX_SAFE_INTEGER) ||\n      millis < BigInt(Number.MIN_SAFE_INTEGER)\n    ) {\n      throw new RangeError(\n        'Timestamp is outside of the representable range for ISO string formatting'\n      );\n    }\n\n    const date = new Date(Number(millis));\n    const isoBase = date.toISOString(); // Format: '2025-02-17T10:30:45.123Z'\n\n    // Extract the full 6 decimal places of microseconds\n    const microsRemainder = Math.abs(Number(micros % 1000000n));\n    const fractionalPart = String(microsRemainder).padStart(6, '0');\n\n    // Replace the 3-digit millisecond part with the full 6-digit microsecond part\n    return isoBase.replace(/\\.\\d{3}Z$/, `.${fractionalPart}Z`);\n  }\n\n  since(other: Timestamp): TimeDuration {\n    return new TimeDuration(\n      this.__timestamp_micros_since_unix_epoch__ -\n        other.__timestamp_micros_since_unix_epoch__\n    );\n  }\n}\n","import { Timestamp } from './timestamp';\nimport { AlgebraicType } from './algebraic_type.ts';\n\nexport type UuidAlgebraicType = {\n  tag: 'Product';\n  value: {\n    elements: [\n      {\n        name: '__uuid__';\n        algebraicType: { tag: 'U128' };\n      },\n    ];\n  };\n};\n\n/**\n * Supported UUID versions.\n *\n * - `Nil`  The \"Nil\" UUID (all zeros)\n * - `V4`   Version 4: random\n * - `V7`   Version 7: timestamp + counter + random\n * - `Max`  The \"Max\" UUID (all ones)\n */\ntype UuidVersion = 'Nil' | 'V4' | 'V7' | 'Max';\n\n/**\n * A universally unique identifier (UUID).\n *\n * Supports UUID `Nil`, `Max`, `V4` (random), and `V7`\n * (timestamp + counter + random).\n *\n * Internally represented as an unsigned 128-bit between 0 and `MAX_UUID_BIGINT`.\n */\nexport class Uuid {\n  __uuid__: bigint;\n\n  /**\n   * The nil UUID (all zeros).\n   *\n   * @example\n   * ```ts\n   * const uuid = Uuid.NIL;\n   * console.assert(\n   *   uuid.toString() === \"00000000-0000-0000-0000-000000000000\"\n   * );\n   * ```\n   */\n  static readonly NIL = new Uuid(0n);\n  static readonly MAX_UUID_BIGINT = 0xffffffffffffffffffffffffffffffffn;\n  /**\n   * The max UUID (all ones).\n   *\n   * @example\n   * ```ts\n   * const uuid = Uuid.MAX;\n   * console.assert(\n   *   uuid.toString() === \"ffffffff-ffff-ffff-ffff-ffffffffffff\"\n   * );\n   * ```\n   */\n  static readonly MAX = new Uuid(Uuid.MAX_UUID_BIGINT);\n\n  /**\n   * Create a UUID from a raw 128-bit value.\n   *\n   * @param u - Unsigned 128-bit integer\n   * @throws {Error} If the value is outside the valid UUID range\n   */\n  constructor(u: bigint) {\n    // Must fit in exactly 16 bytes\n    if (u < 0n || u > Uuid.MAX_UUID_BIGINT) {\n      throw new Error('Invalid UUID: must be between 0 and `MAX_UUID_BIGINT`');\n    }\n    this.__uuid__ = u;\n  }\n\n  /**\n   * Create a UUID `v4` from explicit random bytes.\n   *\n   * This method assumes the bytes are already sufficiently random.\n   * It only sets the appropriate bits for the UUID version and variant.\n   *\n   * @param bytes - Exactly 16 random bytes\n   * @returns A UUID `v4`\n   * @throws {Error} If `bytes.length !== 16`\n   *\n   * @example\n   * ```ts\n   * const randomBytes = new Uint8Array(16);\n   * const uuid = Uuid.fromRandomBytesV4(randomBytes);\n   *\n   * console.assert(\n   *   uuid.toString() === \"00000000-0000-4000-8000-000000000000\"\n   * );\n   * ```\n   */\n  static fromRandomBytesV4(bytes: Uint8Array): Uuid {\n    if (bytes.length !== 16) throw new Error('UUID v4 requires 16 bytes');\n    const arr = new Uint8Array(bytes);\n    arr[6] = (arr[6] & 0x0f) | 0x40; // version 4\n    arr[8] = (arr[8] & 0x3f) | 0x80; // variant\n    return new Uuid(Uuid.bytesToBigInt(arr));\n  }\n\n  /**\n   * Generate a UUID `v7` using a monotonic counter from `0` to `2^31 - 1`,\n   * a timestamp, and 4 random bytes.\n   *\n   * The counter wraps around on overflow.\n   *\n   * The UUID `v7` is structured as follows:\n   *\n   * ```ascii\n   * \n   * | B0  | B1  | B2  | B3  | B4  | B5              |         B6        |\n   * \n   * |                 unix_ts_ms                    |      version 7    |\n   * \n   * \n   * | B7           | B8      | B9  | B10 | B11  | B12 | B13 | B14 | B15 |\n   * \n   * | counter_high | variant |    counter_low   |        random         |\n   * \n   * ```\n   *\n   * @param counter - Mutable monotonic counter (31-bit)\n   * @param now - Timestamp since the Unix epoch\n   * @param randomBytes - Exactly 4 random bytes\n   * @returns A UUID `v7`\n   *\n   * @throws {Error} If the `counter` is negative\n   * @throws {Error} If the `timestamp` is before the Unix epoch\n   * @throws {Error} If `randomBytes.length !== 4`\n   *\n   * @example\n   * ```ts\n   * const now = Timestamp.fromMillis(1_686_000_000_000n);\n   * const counter = { value: 1 };\n   * const randomBytes = new Uint8Array(4);\n   *\n   * const uuid = Uuid.fromCounterV7(counter, now, randomBytes);\n   *\n   * console.assert(\n   *   uuid.toString() === \"0000647e-5180-7000-8000-000200000000\"\n   * );\n   * ```\n   */\n  static fromCounterV7(\n    counter: { value: number },\n    now: Timestamp,\n    randomBytes: Uint8Array\n  ): Uuid {\n    if (randomBytes.length !== 4) {\n      throw new Error('`fromCounterV7` requires `randomBytes.length == 4`');\n    }\n\n    if (counter.value < 0) {\n      throw new Error('`fromCounterV7` uuid `counter` must be non-negative');\n    }\n\n    if (now.__timestamp_micros_since_unix_epoch__ < 0) {\n      throw new Error('`fromCounterV7` `timestamp` before unix epoch');\n    }\n\n    // 31-bit monotonic counter with wraparound\n    const counterVal = counter.value;\n    counter.value = (counterVal + 1) & 0x7fff_ffff;\n\n    // 48-bit unix timestamp (ms)\n    const tsMs = now.toMillis() & 0xffff_ffff_ffffn;\n\n    const bytes = new Uint8Array(16);\n\n    // unix_ts_ms (48 bits)\n    bytes[0] = Number((tsMs >> 40n) & 0xffn);\n    bytes[1] = Number((tsMs >> 32n) & 0xffn);\n    bytes[2] = Number((tsMs >> 24n) & 0xffn);\n    bytes[3] = Number((tsMs >> 16n) & 0xffn);\n    bytes[4] = Number((tsMs >> 8n) & 0xffn);\n    bytes[5] = Number(tsMs & 0xffn);\n\n    // Counter bits (31 bits total)\n    bytes[7] = (counterVal >>> 23) & 0xff;\n    bytes[9] = (counterVal >>> 15) & 0xff;\n    bytes[10] = (counterVal >>> 7) & 0xff;\n    bytes[11] = ((counterVal & 0x7f) << 1) & 0xff;\n\n    // Random bytes\n    bytes[12] |= randomBytes[0] & 0x7f;\n    bytes[13] = randomBytes[1];\n    bytes[14] = randomBytes[2];\n    bytes[15] = randomBytes[3];\n\n    // Version 7\n    bytes[6] = (bytes[6] & 0x0f) | 0x70;\n\n    // Variant RFC4122\n    bytes[8] = (bytes[8] & 0x3f) | 0x80;\n\n    return new Uuid(Uuid.bytesToBigInt(bytes));\n  }\n\n  /**\n   * Parse a UUID from a string representation.\n   *\n   * @param s - UUID string\n   * @returns Parsed UUID\n   * @throws {Error} If the string is not a valid UUID\n   *\n   * @example\n   * ```ts\n   * const s = \"01888d6e-5c00-7000-8000-000000000000\";\n   * const uuid = Uuid.parse(s);\n   *\n   * console.assert(uuid.toString() === s);\n   * ```\n   */\n  static parse(s: string): Uuid {\n    const hex = s.replace(/-/g, '');\n    if (hex.length !== 32) throw new Error('Invalid hex UUID');\n\n    let v = 0n;\n    for (let i = 0; i < 32; i += 2) {\n      v = (v << 8n) | BigInt(parseInt(hex.slice(i, i + 2), 16));\n    }\n    return new Uuid(v);\n  }\n\n  /** Convert to string (hyphenated form). */\n  toString(): string {\n    const bytes = Uuid.bigIntToBytes(this.__uuid__);\n    const hex = [...bytes].map(b => b.toString(16).padStart(2, '0')).join('');\n\n    // Format as 8-4-4-4-12\n    return (\n      hex.slice(0, 8) +\n      '-' +\n      hex.slice(8, 12) +\n      '-' +\n      hex.slice(12, 16) +\n      '-' +\n      hex.slice(16, 20) +\n      '-' +\n      hex.slice(20)\n    );\n  }\n\n  /** Convert to bigint (u128). */\n  asBigInt(): bigint {\n    return this.__uuid__;\n  }\n\n  /** Return a `Uint8Array` of 16 bytes. */\n  toBytes(): Uint8Array {\n    return Uuid.bigIntToBytes(this.__uuid__);\n  }\n\n  private static bytesToBigInt(bytes: Uint8Array): bigint {\n    let result = 0n;\n    for (const b of bytes) result = (result << 8n) | BigInt(b);\n    return result;\n  }\n\n  private static bigIntToBytes(value: bigint): Uint8Array {\n    const bytes = new Uint8Array(16);\n    for (let i = 15; i >= 0; i--) {\n      bytes[i] = Number(value & 0xffn);\n      value >>= 8n;\n    }\n    return bytes;\n  }\n\n  /**\n   * Returns the version of this UUID.\n   *\n   * This represents the algorithm used to generate the value.\n   *\n   * @returns A `UuidVersion`\n   * @throws {Error} If the version field is not recognized\n   */\n  getVersion(): UuidVersion {\n    const version = (this.toBytes()[6] >> 4) & 0x0f;\n\n    switch (version) {\n      case 4:\n        return 'V4';\n      case 7:\n        return 'V7';\n      default:\n        if (this == Uuid.NIL) {\n          return 'Nil';\n        }\n        if (this == Uuid.MAX) {\n          return 'Max';\n        }\n        throw new Error(`Unsupported UUID version: ${version}`);\n    }\n  }\n\n  /**\n   * Extract the monotonic counter from a UUIDv7.\n   *\n   * Intended for testing and diagnostics.\n   * Behavior is undefined if called on a non-V7 UUID.\n   *\n   * @returns 31-bit counter value\n   */\n  getCounter(): number {\n    const bytes = this.toBytes(); // big-endian, 16 bytes\n\n    const high = bytes[7]; // bits 30..23\n    const mid1 = bytes[9]; // bits 22..15\n    const mid2 = bytes[10]; // bits 14..7\n    const low = bytes[11] >>> 1; // bits 6..0\n\n    // reconstruct 31-bit counter\n    return (high << 23) | (mid1 << 15) | (mid2 << 7) | low | 0; // force 32-bit int\n  }\n\n  compareTo(other: Uuid): number {\n    if (this.__uuid__ < other.__uuid__) return -1;\n    if (this.__uuid__ > other.__uuid__) return 1;\n\n    return 0;\n  }\n\n  static getAlgebraicType(): UuidAlgebraicType {\n    return AlgebraicType.Product({\n      elements: [\n        {\n          name: '__uuid__',\n          algebraicType: AlgebraicType.U128,\n        },\n      ],\n    });\n  }\n}\n","export default class BinaryReader {\n  /**\n   * The DataView used to read values from the binary data.\n   *\n   * Note: The DataView's `byteOffset` is relative to the beginning of the\n   * underlying ArrayBuffer, not the start of the provided Uint8Array input.\n   * This `BinaryReader`'s `#offset` field is used to track the current read position\n   * relative to the start of the provided Uint8Array input.\n   */\n  view: DataView;\n\n  /**\n   * Represents the offset (in bytes) relative to the start of the DataView\n   * and provided Uint8Array input.\n   *\n   * Note: This is *not* the absolute byte offset within the underlying ArrayBuffer.\n   */\n  offset: number = 0;\n\n  constructor(input: Uint8Array | DataView) {\n    this.view =\n      input instanceof DataView\n        ? input\n        : new DataView(input.buffer, input.byteOffset, input.byteLength);\n    this.offset = 0;\n  }\n\n  reset(view: DataView) {\n    this.view = view;\n    this.offset = 0;\n  }\n\n  get remaining(): number {\n    return this.view.byteLength - this.offset;\n  }\n\n  /** Ensure we have at least `n` bytes left to read */\n  #ensure(n: number): void {\n    if (this.offset + n > this.view.byteLength) {\n      throw new RangeError(\n        `Tried to read ${n} byte(s) at relative offset ${this.offset}, but only ${this.remaining} byte(s) remain`\n      );\n    }\n  }\n\n  readUInt8Array(): Uint8Array {\n    const length = this.readU32();\n    this.#ensure(length);\n    return this.readBytes(length);\n  }\n\n  readBool(): boolean {\n    const value = this.view.getUint8(this.offset);\n    this.offset += 1;\n    return value !== 0;\n  }\n\n  readByte(): number {\n    const value = this.view.getUint8(this.offset);\n    this.offset += 1;\n    return value;\n  }\n\n  readBytes(length: number): Uint8Array {\n    // Create a Uint8Array view over the DataView's buffer at the current offset\n    // The #view.buffer is the whole ArrayBuffer, so we need to account for the\n    // #view's starting position in that buffer (#view.byteOffset) and the current #offset\n    const array = new Uint8Array(\n      this.view.buffer,\n      this.view.byteOffset + this.offset,\n      length\n    );\n    this.offset += length;\n    return array;\n  }\n\n  readI8(): number {\n    const value = this.view.getInt8(this.offset);\n    this.offset += 1;\n    return value;\n  }\n\n  readU8(): number {\n    return this.readByte();\n  }\n\n  readI16(): number {\n    const value = this.view.getInt16(this.offset, true);\n    this.offset += 2;\n    return value;\n  }\n\n  readU16(): number {\n    const value = this.view.getUint16(this.offset, true);\n    this.offset += 2;\n    return value;\n  }\n\n  readI32(): number {\n    const value = this.view.getInt32(this.offset, true);\n    this.offset += 4;\n    return value;\n  }\n\n  readU32(): number {\n    const value = this.view.getUint32(this.offset, true);\n    this.offset += 4;\n    return value;\n  }\n\n  readI64(): bigint {\n    const value = this.view.getBigInt64(this.offset, true);\n    this.offset += 8;\n    return value;\n  }\n\n  readU64(): bigint {\n    const value = this.view.getBigUint64(this.offset, true);\n    this.offset += 8;\n    return value;\n  }\n\n  readU128(): bigint {\n    const lowerPart = this.view.getBigUint64(this.offset, true);\n    const upperPart = this.view.getBigUint64(this.offset + 8, true);\n    this.offset += 16;\n\n    return (upperPart << BigInt(64)) + lowerPart;\n  }\n\n  readI128(): bigint {\n    const lowerPart = this.view.getBigUint64(this.offset, true);\n    const upperPart = this.view.getBigInt64(this.offset + 8, true);\n    this.offset += 16;\n\n    return (upperPart << BigInt(64)) + lowerPart;\n  }\n\n  readU256(): bigint {\n    const p0 = this.view.getBigUint64(this.offset, true);\n    const p1 = this.view.getBigUint64(this.offset + 8, true);\n    const p2 = this.view.getBigUint64(this.offset + 16, true);\n    const p3 = this.view.getBigUint64(this.offset + 24, true);\n    this.offset += 32;\n\n    return (\n      (p3 << BigInt(3 * 64)) +\n      (p2 << BigInt(2 * 64)) +\n      (p1 << BigInt(1 * 64)) +\n      p0\n    );\n  }\n\n  readI256(): bigint {\n    const p0 = this.view.getBigUint64(this.offset, true);\n    const p1 = this.view.getBigUint64(this.offset + 8, true);\n    const p2 = this.view.getBigUint64(this.offset + 16, true);\n    const p3 = this.view.getBigInt64(this.offset + 24, true);\n    this.offset += 32;\n\n    return (\n      (p3 << BigInt(3 * 64)) +\n      (p2 << BigInt(2 * 64)) +\n      (p1 << BigInt(1 * 64)) +\n      p0\n    );\n  }\n\n  readF32(): number {\n    const value = this.view.getFloat32(this.offset, true);\n    this.offset += 4;\n    return value;\n  }\n\n  readF64(): number {\n    const value = this.view.getFloat64(this.offset, true);\n    this.offset += 8;\n    return value;\n  }\n\n  readString(): string {\n    const uint8Array = this.readUInt8Array();\n    return new TextDecoder('utf-8').decode(uint8Array);\n  }\n}\n","import { fromByteArray } from 'base64-js';\n\nconst ArrayBufferPrototypeTransfer =\n  ArrayBuffer.prototype.transfer ??\n  function (this: ArrayBuffer, newByteLength) {\n    if (newByteLength === undefined) {\n      return this.slice();\n    } else if (newByteLength <= this.byteLength) {\n      return this.slice(0, newByteLength);\n    } else {\n      const copy = new Uint8Array(newByteLength);\n      copy.set(new Uint8Array(this));\n      return copy.buffer;\n    }\n  };\n\nexport class ResizableBuffer {\n  buffer: ArrayBuffer;\n  view: DataView;\n\n  constructor(init: number | ArrayBuffer) {\n    this.buffer = typeof init === 'number' ? new ArrayBuffer(init) : init;\n    this.view = new DataView(this.buffer);\n  }\n\n  get capacity(): number {\n    return this.buffer.byteLength;\n  }\n\n  grow(newSize: number) {\n    if (newSize <= this.buffer.byteLength) return;\n    this.buffer = ArrayBufferPrototypeTransfer.call(this.buffer, newSize);\n    this.view = new DataView(this.buffer);\n  }\n}\n\nexport default class BinaryWriter {\n  buffer: ResizableBuffer;\n  offset: number = 0;\n\n  constructor(init: number | ResizableBuffer) {\n    this.buffer = typeof init === 'number' ? new ResizableBuffer(init) : init;\n  }\n\n  reset(buffer: ResizableBuffer) {\n    this.buffer = buffer;\n    this.offset = 0;\n  }\n\n  expandBuffer(additionalCapacity: number): void {\n    const minCapacity = this.offset + additionalCapacity + 1;\n    if (minCapacity <= this.buffer.capacity) return;\n    let newCapacity = this.buffer.capacity * 2;\n    if (newCapacity < minCapacity) newCapacity = minCapacity;\n    this.buffer.grow(newCapacity);\n  }\n\n  toBase64(): string {\n    return fromByteArray(this.getBuffer());\n  }\n\n  getBuffer(): Uint8Array {\n    return new Uint8Array(this.buffer.buffer, 0, this.offset);\n  }\n\n  get view() {\n    return this.buffer.view;\n  }\n\n  writeUInt8Array(value: Uint8Array): void {\n    const length = value.length;\n\n    this.expandBuffer(4 + length);\n\n    this.writeU32(length);\n    new Uint8Array(this.buffer.buffer, this.offset).set(value);\n    this.offset += length;\n  }\n\n  writeBool(value: boolean): void {\n    this.expandBuffer(1);\n    this.view.setUint8(this.offset, value ? 1 : 0);\n    this.offset += 1;\n  }\n\n  writeByte(value: number): void {\n    this.expandBuffer(1);\n    this.view.setUint8(this.offset, value);\n    this.offset += 1;\n  }\n\n  writeI8(value: number): void {\n    this.expandBuffer(1);\n    this.view.setInt8(this.offset, value);\n    this.offset += 1;\n  }\n\n  writeU8(value: number): void {\n    this.expandBuffer(1);\n    this.view.setUint8(this.offset, value);\n    this.offset += 1;\n  }\n\n  writeI16(value: number): void {\n    this.expandBuffer(2);\n    this.view.setInt16(this.offset, value, true);\n    this.offset += 2;\n  }\n\n  writeU16(value: number): void {\n    this.expandBuffer(2);\n    this.view.setUint16(this.offset, value, true);\n    this.offset += 2;\n  }\n\n  writeI32(value: number): void {\n    this.expandBuffer(4);\n    this.view.setInt32(this.offset, value, true);\n    this.offset += 4;\n  }\n\n  writeU32(value: number): void {\n    this.expandBuffer(4);\n    this.view.setUint32(this.offset, value, true);\n    this.offset += 4;\n  }\n\n  writeI64(value: bigint): void {\n    this.expandBuffer(8);\n    this.view.setBigInt64(this.offset, value, true);\n    this.offset += 8;\n  }\n\n  writeU64(value: bigint): void {\n    this.expandBuffer(8);\n    this.view.setBigUint64(this.offset, value, true);\n    this.offset += 8;\n  }\n\n  writeU128(value: bigint): void {\n    this.expandBuffer(16);\n    const lowerPart = value & BigInt('0xFFFFFFFFFFFFFFFF');\n    const upperPart = value >> BigInt(64);\n    this.view.setBigUint64(this.offset, lowerPart, true);\n    this.view.setBigUint64(this.offset + 8, upperPart, true);\n    this.offset += 16;\n  }\n\n  writeI128(value: bigint): void {\n    this.expandBuffer(16);\n    const lowerPart = value & BigInt('0xFFFFFFFFFFFFFFFF');\n    const upperPart = value >> BigInt(64);\n    this.view.setBigInt64(this.offset, lowerPart, true);\n    this.view.setBigInt64(this.offset + 8, upperPart, true);\n    this.offset += 16;\n  }\n\n  writeU256(value: bigint): void {\n    this.expandBuffer(32);\n    const low_64_mask = BigInt('0xFFFFFFFFFFFFFFFF');\n    const p0 = value & low_64_mask;\n    const p1 = (value >> BigInt(64 * 1)) & low_64_mask;\n    const p2 = (value >> BigInt(64 * 2)) & low_64_mask;\n    const p3 = value >> BigInt(64 * 3);\n    this.view.setBigUint64(this.offset + 8 * 0, p0, true);\n    this.view.setBigUint64(this.offset + 8 * 1, p1, true);\n    this.view.setBigUint64(this.offset + 8 * 2, p2, true);\n    this.view.setBigUint64(this.offset + 8 * 3, p3, true);\n    this.offset += 32;\n  }\n\n  writeI256(value: bigint): void {\n    this.expandBuffer(32);\n    const low_64_mask = BigInt('0xFFFFFFFFFFFFFFFF');\n    const p0 = value & low_64_mask;\n    const p1 = (value >> BigInt(64 * 1)) & low_64_mask;\n    const p2 = (value >> BigInt(64 * 2)) & low_64_mask;\n    const p3 = value >> BigInt(64 * 3);\n    this.view.setBigUint64(this.offset + 8 * 0, p0, true);\n    this.view.setBigUint64(this.offset + 8 * 1, p1, true);\n    this.view.setBigUint64(this.offset + 8 * 2, p2, true);\n    this.view.setBigInt64(this.offset + 8 * 3, p3, true);\n    this.offset += 32;\n  }\n\n  writeF32(value: number): void {\n    this.expandBuffer(4);\n    this.view.setFloat32(this.offset, value, true);\n    this.offset += 4;\n  }\n\n  writeF64(value: number): void {\n    this.expandBuffer(8);\n    this.view.setFloat64(this.offset, value, true);\n    this.offset += 8;\n  }\n\n  writeString(value: string): void {\n    const encoder = new TextEncoder();\n    const encodedString = encoder.encode(value);\n    this.writeUInt8Array(encodedString);\n  }\n}\n","import BinaryReader from './binary_reader';\nimport BinaryWriter from './binary_writer';\nimport type { CamelCase, SnakeCase } from './type_util';\n\n/**\n * Converts a string to PascalCase (UpperCamelCase).\n * @param str The string to convert\n * @returns The converted string\n */\nexport function toPascalCase(s: string): string {\n  const str = s.replace(/([-_][a-z])/gi, $1 => {\n    return $1.toUpperCase().replace('-', '').replace('_', '');\n  });\n\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\n\nexport function deepEqual(obj1: any, obj2: any): boolean {\n  // If both are strictly equal (covers primitives and reference equality), return true\n  if (obj1 === obj2) return true;\n\n  // If either is a primitive type or one is null, return false since we already checked for strict equality\n  if (\n    typeof obj1 !== 'object' ||\n    obj1 === null ||\n    typeof obj2 !== 'object' ||\n    obj2 === null\n  ) {\n    return false;\n  }\n\n  // Get keys of both objects\n  const keys1 = Object.keys(obj1);\n  const keys2 = Object.keys(obj2);\n\n  // If number of keys is different, return false\n  if (keys1.length !== keys2.length) return false;\n\n  // Check all keys and compare values recursively\n  for (const key of keys1) {\n    if (!keys2.includes(key) || !deepEqual(obj1[key], obj2[key])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexport function uint8ArrayToHexString(array: Uint8Array): string {\n  return Array.prototype.map\n    .call(array.reverse(), x => ('00' + x.toString(16)).slice(-2))\n    .join('');\n}\n\nexport function uint8ArrayToU128(array: Uint8Array): bigint {\n  if (array.length != 16) {\n    throw new Error(`Uint8Array is not 16 bytes long: ${array}`);\n  }\n  return new BinaryReader(array).readU128();\n}\n\nexport function uint8ArrayToU256(array: Uint8Array): bigint {\n  if (array.length != 32) {\n    throw new Error(`Uint8Array is not 32 bytes long: [${array}]`);\n  }\n  return new BinaryReader(array).readU256();\n}\n\nexport function hexStringToUint8Array(str: string): Uint8Array {\n  if (str.startsWith('0x')) {\n    str = str.slice(2);\n  }\n  const matches = str.match(/.{1,2}/g) || [];\n  const data = Uint8Array.from(\n    matches.map((byte: string) => parseInt(byte, 16))\n  );\n  return data.reverse();\n}\n\nexport function hexStringToU128(str: string): bigint {\n  return uint8ArrayToU128(hexStringToUint8Array(str));\n}\n\nexport function hexStringToU256(str: string): bigint {\n  return uint8ArrayToU256(hexStringToUint8Array(str));\n}\n\nexport function u128ToUint8Array(data: bigint): Uint8Array {\n  const writer = new BinaryWriter(16);\n  writer.writeU128(data);\n  return writer.getBuffer();\n}\n\nexport function u128ToHexString(data: bigint): string {\n  return uint8ArrayToHexString(u128ToUint8Array(data));\n}\n\nexport function u256ToUint8Array(data: bigint): Uint8Array {\n  const writer = new BinaryWriter(32);\n  writer.writeU256(data);\n  return writer.getBuffer();\n}\n\nexport function u256ToHexString(data: bigint): string {\n  return uint8ArrayToHexString(u256ToUint8Array(data));\n}\n\n/**\n * Type safe conversion from a string like \"some_identifier-name\" to \"someIdentifierName\".\n * @param str The string to convert\n * @returns The converted string\n */\nexport function toCamelCase<T extends string>(str: T): CamelCase<T> {\n  return str\n    .replace(/[-_]+/g, '_') // collapse runs to a single separator (no backtracking issue)\n    .replace(/_([a-zA-Z0-9])/g, (_, c) => c.toUpperCase()) as CamelCase<T>;\n}\n\n/** Type safe conversion from a string like \"some_Identifier-name\" to \"some_identifier_name\".\n * @param str The string to convert\n * @returns The converted string\n */\nexport function toSnakeCase<T extends string>(str: T): SnakeCase<T> {\n  return str\n    .replace(/([A-Z])/g, '_$1') // insert underscores before capitals\n    .replace(/[-\\s]+/g, '_') // replace spaces and dashes with underscores\n    .toLowerCase() as SnakeCase<T>;\n}\n\nimport type { AlgebraicType } from './algebraic_type';\nimport type { Typespace } from './autogen/types';\nimport type { ColumnBuilder, TypeBuilder } from './type_builders';\nimport type { ParamsObj } from './reducers';\n\nexport function bsatnBaseSize(typespace: Typespace, ty: AlgebraicType): number {\n  const assumedArrayLength = 4;\n  while (ty.tag === 'Ref') ty = typespace.types[ty.value];\n  if (ty.tag === 'Product') {\n    let sum = 0;\n    for (const { algebraicType: elem } of ty.value.elements) {\n      sum += bsatnBaseSize(typespace, elem);\n    }\n    return sum;\n  } else if (ty.tag === 'Sum') {\n    let min = Infinity;\n    for (const { algebraicType: vari } of ty.value.variants) {\n      const vSize = bsatnBaseSize(typespace, vari);\n      if (vSize < min) min = vSize;\n    }\n    if (min === Infinity) min = 0;\n    return 4 + min;\n  } else if (ty.tag == 'Array') {\n    return 4 + assumedArrayLength * bsatnBaseSize(typespace, ty.value);\n  }\n  return {\n    String: 4 + assumedArrayLength,\n    Sum: 1,\n    Bool: 1,\n    I8: 1,\n    U8: 1,\n    I16: 2,\n    U16: 2,\n    I32: 4,\n    U32: 4,\n    F32: 4,\n    I64: 8,\n    U64: 8,\n    F64: 8,\n    I128: 16,\n    U128: 16,\n    I256: 32,\n    U256: 32,\n  }[ty.tag];\n}\n\nexport type CoerceTypeBuilder<\n  Col extends TypeBuilder<any, any> | ColumnBuilder<any, any, any>,\n> = Col extends ColumnBuilder<any, any> ? Col['typeBuilder'] : Col;\n\nexport type CoerceParams<Params extends ParamsObj> = {\n  [k in keyof Params & string]: CoerceTypeBuilder<Params[k]>;\n};\n\nexport function coerceParams<Params extends ParamsObj>(\n  params: Params\n): CoerceParams<Params> {\n  return Object.fromEntries(\n    Object.entries(params).map(([n, c]) => [\n      n,\n      'typeBuilder' in c ? c.typeBuilder : c,\n    ])\n  ) as CoerceParams<Params>;\n}\n\nexport const hasOwn: <K extends PropertyKey>(\n  o: object,\n  k: K\n) => o is K extends PropertyKey ? { [k in K]: unknown } : never =\n  Object.hasOwn as any;\n","import { AlgebraicType } from './algebraic_type';\nimport { hexStringToU256, u256ToHexString, u256ToUint8Array } from './util';\n\nexport type IdentityAlgebraicType = {\n  tag: 'Product';\n  value: {\n    elements: [{ name: '__identity__'; algebraicType: { tag: 'U256' } }];\n  };\n};\n\n/**\n * A unique identifier for a user connected to a database.\n */\nexport class Identity {\n  __identity__: bigint;\n\n  /**\n   * Creates a new `Identity`.\n   *\n   * `data` can be a hexadecimal string or a `bigint`.\n   */\n  constructor(data: string | bigint) {\n    // we get a JSON with __identity__ when getting a token with a JSON API\n    // and an bigint when using BSATN\n    this.__identity__ = typeof data === 'string' ? hexStringToU256(data) : data;\n  }\n\n  /**\n   * Get the algebraic type representation of the {@link Identity} type.\n   * @returns The algebraic type representation of the type.\n   */\n  static getAlgebraicType(): IdentityAlgebraicType {\n    return AlgebraicType.Product({\n      elements: [{ name: '__identity__', algebraicType: AlgebraicType.U256 }],\n    });\n  }\n\n  /**\n   * Check if two identities are equal.\n   */\n  isEqual(other: Identity): boolean {\n    return this.toHexString() === other.toHexString();\n  }\n\n  /**\n   * Check if two identities are equal.\n   */\n  equals(other: Identity): boolean {\n    return this.isEqual(other);\n  }\n\n  /**\n   * Print the identity as a hexadecimal string.\n   */\n  toHexString(): string {\n    return u256ToHexString(this.__identity__);\n  }\n\n  /**\n   * Convert the address to a Uint8Array.\n   */\n  toUint8Array(): Uint8Array {\n    return u256ToUint8Array(this.__identity__);\n  }\n\n  /**\n   * Parse an Identity from a hexadecimal string.\n   */\n  static fromString(str: string): Identity {\n    return new Identity(str);\n  }\n\n  /**\n   * Zero identity (0x0000000000000000000000000000000000000000000000000000000000000000)\n   */\n  static zero(): Identity {\n    return new Identity(0n);\n  }\n\n  toString(): string {\n    return this.toHexString();\n  }\n}\n","import type {\n  AlgebraicTypeType,\n  ProductTypeType,\n  SumTypeType,\n} from './algebraic_type';\n\nexport type Ref = { tag: 'Ref'; value: number };\nexport type Sum = { tag: 'Sum'; value: SumTypeType };\nexport type Product = { tag: 'Product'; value: ProductTypeType };\nexport type Array = { tag: 'Array'; value: AlgebraicTypeType };\nexport type String = { tag: 'String' };\nexport type Bool = { tag: 'Bool' };\nexport type I8 = { tag: 'I8' };\nexport type U8 = { tag: 'U8' };\nexport type I16 = { tag: 'I16' };\nexport type U16 = { tag: 'U16' };\nexport type I32 = { tag: 'I32' };\nexport type U32 = { tag: 'U32' };\nexport type I64 = { tag: 'I64' };\nexport type U64 = { tag: 'U64' };\nexport type I128 = { tag: 'I128' };\nexport type U128 = { tag: 'U128' };\nexport type I256 = { tag: 'I256' };\nexport type U256 = { tag: 'U256' };\nexport type F32 = { tag: 'F32' };\nexport type F64 = { tag: 'F64' };\n","import { TimeDuration } from './time_duration';\nimport { Timestamp } from './timestamp';\nimport { Uuid } from './uuid';\nimport { ConnectionId } from './connection_id';\nimport BinaryReader from './binary_reader';\nimport BinaryWriter from './binary_writer';\nimport { Identity } from './identity';\nimport * as AlgebraicTypeVariants from './algebraic_type_variants';\nimport { hasOwn } from './util';\n\ntype TypespaceType = {\n  types: AlgebraicTypeType[];\n};\n\nexport type ProductTypeType = {\n  elements: ProductTypeElement[];\n};\n\n/**\n * A factor / element of a product type.\n *\n * An element consist of an optional name and a type.\n *\n * NOTE: Each element has an implicit element tag based on its order.\n * Uniquely identifies an element similarly to protobuf tags.\n */\nexport type ProductTypeElement = {\n  name: string | undefined;\n  algebraicType: AlgebraicTypeType;\n};\n\nexport type SumTypeType = {\n  variants: SumTypeVariant[];\n};\n\n/**\n * A variant of a sum type.\n *\n * NOTE: Each element has an implicit element tag based on its order.\n * Uniquely identifies an element similarly to protobuf tags.\n */\nexport type SumTypeVariant = {\n  name: string | undefined;\n  algebraicType: AlgebraicTypeType;\n};\n\nexport type AlgebraicTypeType =\n  | AlgebraicTypeVariants.Ref\n  | AlgebraicTypeVariants.Sum\n  | AlgebraicTypeVariants.Product\n  | AlgebraicTypeVariants.Array\n  | AlgebraicTypeVariants.String\n  | AlgebraicTypeVariants.Bool\n  | AlgebraicTypeVariants.I8\n  | AlgebraicTypeVariants.U8\n  | AlgebraicTypeVariants.I16\n  | AlgebraicTypeVariants.U16\n  | AlgebraicTypeVariants.I32\n  | AlgebraicTypeVariants.U32\n  | AlgebraicTypeVariants.I64\n  | AlgebraicTypeVariants.U64\n  | AlgebraicTypeVariants.I128\n  | AlgebraicTypeVariants.U128\n  | AlgebraicTypeVariants.I256\n  | AlgebraicTypeVariants.U256\n  | AlgebraicTypeVariants.F32\n  | AlgebraicTypeVariants.F64;\n\nexport type AlgebraicType = AlgebraicTypeType;\n\n/**\n * The variant types of the Algebraic Type tagged union.\n */\nexport { AlgebraicTypeVariants };\n\nexport type Serializer<T> = (writer: BinaryWriter, value: T) => void;\n\nexport type Deserializer<T> = (reader: BinaryReader) => T;\n\n// Caches to prevent `makeSerializer`/`makeDeserializer` from recursing\n// infinitely when called on recursive types.\n//\n// We check for recursion in `{Product,Sum}Type.make{Deser,Ser}ializer` rather\n// than in `AlgebraciType.make{Deser,Ser}ializer` because we need to store the\n// [de]serializer in the cache before recursing into its fields/variants, and\n// we wouldn't be able to do that in the `AlgebraicType` functions.\nconst SERIALIZERS = new Map<ProductType | SumType, Serializer<any>>();\nconst DESERIALIZERS = new Map<ProductType | SumType, Deserializer<any>>();\n\n// A value with helper functions to construct the type.\nexport const AlgebraicType = {\n  Ref: (value: number): AlgebraicTypeVariants.Ref => ({ tag: 'Ref', value }),\n  Sum: <T extends SumTypeType>(value: T): { tag: 'Sum'; value: T } => ({\n    tag: 'Sum',\n    value,\n  }),\n  Product: <T extends ProductTypeType>(\n    value: T\n  ): { tag: 'Product'; value: T } => ({\n    tag: 'Product',\n    value,\n  }),\n  Array: <T extends AlgebraicTypeType>(\n    value: T\n  ): { tag: 'Array'; value: T } => ({\n    tag: 'Array',\n    value,\n  }),\n  String: { tag: 'String' } as const,\n  Bool: { tag: 'Bool' } as const,\n  I8: { tag: 'I8' } as const,\n  U8: { tag: 'U8' } as const,\n  I16: { tag: 'I16' } as const,\n  U16: { tag: 'U16' } as const,\n  I32: { tag: 'I32' } as const,\n  U32: { tag: 'U32' } as const,\n  I64: { tag: 'I64' } as const,\n  U64: { tag: 'U64' } as const,\n  I128: { tag: 'I128' } as const,\n  U128: { tag: 'U128' } as const,\n  I256: { tag: 'I256' } as const,\n  U256: { tag: 'U256' } as const,\n  F32: { tag: 'F32' } as const,\n  F64: { tag: 'F64' } as const,\n  makeSerializer(\n    ty: AlgebraicTypeType,\n    typespace?: TypespaceType\n  ): Serializer<any> {\n    if (ty.tag === 'Ref') {\n      if (!typespace)\n        throw new Error('cannot serialize refs without a typespace');\n      while (ty.tag === 'Ref') ty = typespace.types[ty.value];\n    }\n    switch (ty.tag) {\n      case 'Product':\n        return ProductType.makeSerializer(ty.value, typespace);\n      case 'Sum':\n        return SumType.makeSerializer(ty.value, typespace);\n      case 'Array':\n        if (ty.value.tag === 'U8') {\n          return serializeUint8Array;\n        } else {\n          const serialize = AlgebraicType.makeSerializer(ty.value, typespace);\n          return (writer, value) => {\n            writer.writeU32(value.length);\n            for (const elem of value) {\n              serialize(writer, elem);\n            }\n          };\n        }\n      default:\n        return primitiveSerializers[ty.tag];\n    }\n  },\n  /** @deprecated Use `makeSerializer` instead. */\n  serializeValue(\n    writer: BinaryWriter,\n    ty: AlgebraicTypeType,\n    value: any,\n    typespace?: TypespaceType\n  ) {\n    AlgebraicType.makeSerializer(ty, typespace)(writer, value);\n  },\n  makeDeserializer(\n    ty: AlgebraicTypeType,\n    typespace?: TypespaceType\n  ): Deserializer<any> {\n    if (ty.tag === 'Ref') {\n      if (!typespace)\n        throw new Error('cannot deserialize refs without a typespace');\n      while (ty.tag === 'Ref') ty = typespace.types[ty.value];\n    }\n    switch (ty.tag) {\n      case 'Product':\n        return ProductType.makeDeserializer(ty.value, typespace);\n      case 'Sum':\n        return SumType.makeDeserializer(ty.value, typespace);\n      case 'Array':\n        if (ty.value.tag === 'U8') {\n          return deserializeUint8Array;\n        } else {\n          const deserialize = AlgebraicType.makeDeserializer(\n            ty.value,\n            typespace\n          );\n          return reader => {\n            const length = reader.readU32();\n            const result: any[] = Array(length);\n            for (let i = 0; i < length; i++) {\n              result[i] = deserialize(reader);\n            }\n            return result;\n          };\n        }\n      default:\n        return primitiveDeserializers[ty.tag];\n    }\n  },\n  /** @deprecated Use `makeDeserializer` instead. */\n  deserializeValue(\n    reader: BinaryReader,\n    ty: AlgebraicTypeType,\n    typespace?: TypespaceType\n  ): any {\n    return AlgebraicType.makeDeserializer(ty, typespace)(reader);\n  },\n  /**\n   * Convert a value of the algebraic type into something that can be used as a key in a map.\n   * There are no guarantees about being able to order it.\n   * This is only guaranteed to be comparable to other values of the same type.\n   * @param value A value of the algebraic type\n   * @returns Something that can be used as a key in a map.\n   */\n  intoMapKey: function (\n    ty: AlgebraicTypeType,\n    value: any\n  ): ComparablePrimitive {\n    switch (ty.tag) {\n      case 'U8':\n      case 'U16':\n      case 'U32':\n      case 'U64':\n      case 'U128':\n      case 'U256':\n      case 'I8':\n      case 'I16':\n      case 'I32':\n      case 'I64':\n      case 'I128':\n      case 'I256':\n      case 'F32':\n      case 'F64':\n      case 'String':\n      case 'Bool':\n        return value;\n      case 'Product':\n        return ProductType.intoMapKey(ty.value, value);\n      default: {\n        // The fallback is to serialize and base64 encode the bytes.\n        const writer = new BinaryWriter(10);\n        AlgebraicType.serializeValue(writer, ty, value);\n        return writer.toBase64();\n      }\n    }\n  },\n};\n\nfunction bindCall<F extends (this: any, ...args: any[]) => any>(\n  f: F\n): (recv: ThisParameterType<F>, ...args: Parameters<F>) => ReturnType<F> {\n  return Function.prototype.call.bind(f);\n}\n\ntype Primitives = Exclude<\n  AlgebraicType['tag'],\n  'Ref' | 'Sum' | 'Product' | 'Array'\n>;\n\nconst primitiveSerializers: Record<Primitives, Serializer<any>> = {\n  Bool: bindCall(BinaryWriter.prototype.writeBool),\n  I8: bindCall(BinaryWriter.prototype.writeI8),\n  U8: bindCall(BinaryWriter.prototype.writeU8),\n  I16: bindCall(BinaryWriter.prototype.writeI16),\n  U16: bindCall(BinaryWriter.prototype.writeU16),\n  I32: bindCall(BinaryWriter.prototype.writeI32),\n  U32: bindCall(BinaryWriter.prototype.writeU32),\n  I64: bindCall(BinaryWriter.prototype.writeI64),\n  U64: bindCall(BinaryWriter.prototype.writeU64),\n  I128: bindCall(BinaryWriter.prototype.writeI128),\n  U128: bindCall(BinaryWriter.prototype.writeU128),\n  I256: bindCall(BinaryWriter.prototype.writeI256),\n  U256: bindCall(BinaryWriter.prototype.writeU256),\n  F32: bindCall(BinaryWriter.prototype.writeF32),\n  F64: bindCall(BinaryWriter.prototype.writeF64),\n  String: bindCall(BinaryWriter.prototype.writeString),\n};\nObject.freeze(primitiveSerializers);\n\nconst serializeUint8Array = bindCall(BinaryWriter.prototype.writeUInt8Array);\n\nconst primitiveDeserializers: Record<Primitives, Deserializer<any>> = {\n  Bool: bindCall(BinaryReader.prototype.readBool),\n  I8: bindCall(BinaryReader.prototype.readI8),\n  U8: bindCall(BinaryReader.prototype.readU8),\n  I16: bindCall(BinaryReader.prototype.readI16),\n  U16: bindCall(BinaryReader.prototype.readU16),\n  I32: bindCall(BinaryReader.prototype.readI32),\n  U32: bindCall(BinaryReader.prototype.readU32),\n  I64: bindCall(BinaryReader.prototype.readI64),\n  U64: bindCall(BinaryReader.prototype.readU64),\n  I128: bindCall(BinaryReader.prototype.readI128),\n  U128: bindCall(BinaryReader.prototype.readU128),\n  I256: bindCall(BinaryReader.prototype.readI256),\n  U256: bindCall(BinaryReader.prototype.readU256),\n  F32: bindCall(BinaryReader.prototype.readF32),\n  F64: bindCall(BinaryReader.prototype.readF64),\n  String: bindCall(BinaryReader.prototype.readString),\n};\nObject.freeze(primitiveDeserializers);\n\nconst deserializeUint8Array = bindCall(BinaryReader.prototype.readUInt8Array);\n\ntype FixedSizePrimitives = Exclude<Primitives, 'String'>;\n\nconst primitiveSizes: Record<FixedSizePrimitives, number> = {\n  Bool: 1,\n  I8: 1,\n  U8: 1,\n  I16: 2,\n  U16: 2,\n  I32: 4,\n  U32: 4,\n  I64: 8,\n  U64: 8,\n  I128: 16,\n  U128: 16,\n  I256: 32,\n  U256: 32,\n  F32: 4,\n  F64: 8,\n};\n\nconst fixedSizePrimitives = new Set(Object.keys(primitiveSizes));\n\ntype FixedSizeProductType = {\n  elements: { name: string; algebraicType: { tag: FixedSizePrimitives } }[];\n};\n\nconst isFixedSizeProduct = (ty: ProductType): ty is FixedSizeProductType =>\n  ty.elements.every(({ algebraicType }) =>\n    fixedSizePrimitives.has(algebraicType.tag)\n  );\n\nconst productSize = (ty: FixedSizeProductType): number =>\n  ty.elements.reduce(\n    (acc, { algebraicType }) => acc + primitiveSizes[algebraicType.tag],\n    0\n  );\n\ntype JSPrimitives = Exclude<\n  FixedSizePrimitives,\n  'I128' | 'U128' | 'I256' | 'U256'\n>;\n\nconst primitiveJSName: Record<JSPrimitives, string> = {\n  Bool: 'Uint8',\n  I8: 'Int8',\n  U8: 'Uint8',\n  I16: 'Int16',\n  U16: 'Uint16',\n  I32: 'Int32',\n  U32: 'Uint32',\n  I64: 'BigInt64',\n  U64: 'BigUint64',\n  F32: 'Float32',\n  F64: 'Float64',\n};\n\ntype SpecialProducts = {\n  __time_duration_micros__: TimeDuration;\n  __timestamp_micros_since_unix_epoch__: Timestamp;\n  __identity__: Identity;\n  __connection_id__: ConnectionId;\n  __uuid__: Uuid;\n};\n\nconst specialProductDeserializers: {\n  [k in keyof SpecialProducts]: Deserializer<SpecialProducts[k]>;\n} = {\n  __time_duration_micros__: reader => new TimeDuration(reader.readI64()),\n  __timestamp_micros_since_unix_epoch__: reader =>\n    new Timestamp(reader.readI64()),\n  __identity__: reader => new Identity(reader.readU256()),\n  __connection_id__: reader => new ConnectionId(reader.readU128()),\n  __uuid__: reader => new Uuid(reader.readU128()),\n};\nObject.freeze(specialProductDeserializers);\n\nconst unitDeserializer: Deserializer<{}> = () => ({});\n\nconst getElementInitializer = (element: ProductTypeElement) => {\n  let init: string;\n  switch (element.algebraicType.tag) {\n    case 'String':\n      init = \"''\";\n      break;\n    case 'Bool':\n      init = 'false';\n      break;\n    case 'I8':\n    case 'U8':\n    case 'I16':\n    case 'U16':\n    case 'I32':\n    case 'U32':\n      init = '0';\n      break;\n    case 'I64':\n    case 'U64':\n    case 'I128':\n    case 'U128':\n    case 'I256':\n    case 'U256':\n      init = '0n';\n      break;\n    case 'F32':\n    case 'F64':\n      init = '0.0';\n      break;\n    default:\n      init = 'undefined';\n  }\n  return `${element.name!}: ${init}`;\n};\n\n/**\n * A structural product type  of the factors given by `elements`.\n *\n * This is also known as `struct` and `tuple` in many languages,\n * but note that unlike most languages, products in SATs are *[structural]* and not nominal.\n * When checking whether two nominal types are the same,\n * their names and/or declaration sites (e.g., module / namespace) are considered.\n * Meanwhile, a structural type system would only check the structure of the type itself,\n * e.g., the names of its fields and their types in the case of a record.\n * The name \"product\" comes from category theory.\n *\n * See also: https://ncatlab.org/nlab/show/product+type.\n *\n * These structures are known as product types because the number of possible values in product\n * ```ignore\n * { N_0: T_0, N_1: T_1, ..., N_n: T_n }\n * ```\n * is:\n * ```ignore\n *  (i  0..n). values(T_i)\n * ```\n * so for example, `values({ A: U64, B: Bool }) = values(U64) * values(Bool)`.\n *\n * [structural]: https://en.wikipedia.org/wiki/Structural_type_system\n */\nexport type ProductType = ProductTypeType;\n\nexport const ProductType = {\n  makeSerializer(\n    ty: ProductTypeType,\n    typespace?: TypespaceType\n  ): Serializer<any> {\n    let serializer = SERIALIZERS.get(ty);\n    if (serializer != null) return serializer;\n\n    if (isFixedSizeProduct(ty)) {\n      const size = productSize(ty);\n      const body = `\\\n\"use strict\";\nwriter.expandBuffer(${size});\nconst view = writer.view;\n${ty.elements\n  .map(({ name, algebraicType: { tag } }) =>\n    tag in primitiveJSName\n      ? `\\\nview.set${primitiveJSName[tag as JSPrimitives]}(writer.offset, value.${name!}, ${primitiveSizes[tag] > 1 ? 'true' : ''});\nwriter.offset += ${primitiveSizes[tag]};`\n      : `writer.write${tag}(value.${name});`\n  )\n  .join('\\n')}`;\n      serializer = Function('writer', 'value', body) as Serializer<any>;\n      SERIALIZERS.set(ty, serializer);\n      return serializer;\n    }\n\n    // Because V8 forces us to generate our code as a string, rather than a proper syntax tree,\n    // we can't have our `body` close over values.\n    // Instead, we construct an object with the values we'd otherwise \"close over\" in `serializers`,\n    // and use `Function.prototype.bind` to pass it as the `this` argument.\n    //\n    // We populate `serializers` after constructing this type's `serializer`\n    // so that it can close over itself, in the case that `ty` is recursive.\n    const serializers: Record<string, Serializer<any>> = {};\n    const body =\n      '\"use strict\";\\n' +\n      ty.elements\n        .map(\n          element => `this.${element.name!}(writer, value.${element.name!});`\n        )\n        .join('\\n');\n    serializer = Function('writer', 'value', body).bind(\n      serializers\n    ) as Serializer<any>;\n    // In case `ty` is recursive, we cache the function *before* before computing\n    // `serializers`, so that a recursive `makeSerializer` with the same `ty` has\n    // an exit condition.\n    SERIALIZERS.set(ty, serializer);\n    for (const { name, algebraicType } of ty.elements) {\n      serializers[name!] = AlgebraicType.makeSerializer(\n        algebraicType,\n        typespace\n      );\n    }\n    Object.freeze(serializers);\n    return serializer;\n  },\n  /** @deprecated Use `makeSerializer` instead. */\n  serializeValue(\n    writer: BinaryWriter,\n    ty: ProductTypeType,\n    value: any,\n    typespace?: TypespaceType\n  ): void {\n    ProductType.makeSerializer(ty, typespace)(writer, value);\n  },\n  makeDeserializer(\n    ty: ProductTypeType,\n    typespace?: TypespaceType\n  ): Deserializer<any> {\n    switch (ty.elements.length) {\n      case 0:\n        return unitDeserializer;\n      case 1: {\n        const fieldName = ty.elements[0].name!;\n        if (hasOwn(specialProductDeserializers, fieldName))\n          return specialProductDeserializers[\n            fieldName as keyof SpecialProducts\n          ];\n      }\n    }\n\n    let deserializer = DESERIALIZERS.get(ty);\n    if (deserializer != null) return deserializer;\n\n    if (isFixedSizeProduct(ty)) {\n      const body = `\\\n\"use strict\";\nconst result = { ${ty.elements.map(getElementInitializer).join(', ')} };\nconst view = reader.view;\n${ty.elements\n  .map(({ name, algebraicType: { tag } }) =>\n    tag in primitiveJSName\n      ? `\\\nresult.${name} = view.get${primitiveJSName[tag as JSPrimitives]}(reader.offset, ${primitiveSizes[tag] > 1 ? 'true' : ''});\nreader.offset += ${primitiveSizes[tag]};`\n      : `result.${name} = reader.read${tag}();`\n  )\n  .join('\\n')}\nreturn result;`;\n      deserializer = Function('reader', body) as Deserializer<any>;\n      DESERIALIZERS.set(ty, deserializer);\n      return deserializer;\n    }\n\n    // Because V8 forces us to generate our code as a string, rather than a proper syntax tree,\n    // we can't have our `body` close over values.\n    // Instead, we construct an object with the values we'd otherwise \"close over\" in `deserializers`,\n    // and use `Function.prototype.bind` to pass it as the `this` argument.\n    //\n    // We populate `deserializers` after constructing this type's `deserializer`\n    // so that it can close over itself, in the case that `ty` is recursive.\n    const deserializers: Record<string, Deserializer<any>> = {};\n    deserializer = Function(\n      'reader',\n      `\\\n\"use strict\";\nconst result = { ${ty.elements.map(getElementInitializer).join(', ')} };\n${ty.elements.map(({ name }) => `result.${name!} = this.${name!}(reader);`).join('\\n')}\nreturn result;`\n    ).bind(deserializers) as Deserializer<any>;\n    // In case `ty` is recursive, we cache the function *before* before computing\n    // `deserializers`, so that a recursive `makeDeserializer` with the same `ty` has\n    // an exit condition.\n    DESERIALIZERS.set(ty, deserializer);\n    for (const { name, algebraicType } of ty.elements) {\n      deserializers[name!] = AlgebraicType.makeDeserializer(\n        algebraicType,\n        typespace\n      );\n    }\n    Object.freeze(deserializers);\n    return deserializer;\n  },\n  /** @deprecated Use `makeDeserializer` instead. */\n  deserializeValue(\n    reader: BinaryReader,\n    ty: ProductTypeType,\n    typespace?: TypespaceType\n  ): any {\n    return ProductType.makeDeserializer(ty, typespace)(reader);\n  },\n  intoMapKey(ty: ProductTypeType, value: any): ComparablePrimitive {\n    if (ty.elements.length === 1) {\n      const fieldName = ty.elements[0].name!;\n      if (hasOwn(specialProductDeserializers, fieldName)) {\n        return value[fieldName];\n      }\n    }\n    // The fallback is to serialize and base64 encode the bytes.\n    const writer = new BinaryWriter(10);\n    AlgebraicType.serializeValue(writer, AlgebraicType.Product(ty), value);\n    return writer.toBase64();\n  },\n};\n\nexport type SumType = SumTypeType;\n\n/**\n * Unlike most languages, sums in SATS are *[structural]* and not nominal.\n * When checking whether two nominal types are the same,\n * their names and/or declaration sites (e.g., module / namespace) are considered.\n * Meanwhile, a structural type system would only check the structure of the type itself,\n * e.g., the names of its variants and their inner data types in the case of a sum.\n *\n * This is also known as a discriminated union (implementation) or disjoint union.\n * Another name is [coproduct (category theory)](https://ncatlab.org/nlab/show/coproduct).\n *\n * These structures are known as sum types because the number of possible values a sum\n * ```ignore\n * { N_0(T_0), N_1(T_1), ..., N_n(T_n) }\n * ```\n * is:\n * ```ignore\n *  (i  0..n). values(T_i)\n * ```\n * so for example, `values({ A(U64), B(Bool) }) = values(U64) + values(Bool)`.\n *\n * See also: https://ncatlab.org/nlab/show/sum+type.\n *\n * [structural]: https://en.wikipedia.org/wiki/Structural_type_system\n */\nexport const SumType = {\n  makeSerializer(ty: SumTypeType, typespace?: TypespaceType): Serializer<any> {\n    if (\n      ty.variants.length == 2 &&\n      ty.variants[0].name === 'some' &&\n      ty.variants[1].name === 'none'\n    ) {\n      const serialize = AlgebraicType.makeSerializer(\n        ty.variants[0].algebraicType,\n        typespace\n      );\n      return (writer, value) => {\n        if (value !== null && value !== undefined) {\n          writer.writeByte(0);\n          serialize(writer, value);\n        } else {\n          writer.writeByte(1);\n        }\n      };\n    } else if (\n      ty.variants.length == 2 &&\n      ty.variants[0].name === 'ok' &&\n      ty.variants[1].name === 'err'\n    ) {\n      const serializeOk = AlgebraicType.makeSerializer(\n        ty.variants[0].algebraicType,\n        typespace\n      );\n      const serializeErr = AlgebraicType.makeSerializer(\n        ty.variants[0].algebraicType,\n        typespace\n      );\n\n      return (writer, value) => {\n        if ('ok' in value) {\n          writer.writeU8(0);\n          serializeOk(writer, value.ok);\n        } else if ('err' in value) {\n          writer.writeU8(1);\n          serializeErr(writer, value.err);\n        } else {\n          throw new TypeError(\n            'could not serialize result: object had neither a `ok` nor an `err` field'\n          );\n        }\n      };\n    } else {\n      let serializer = SERIALIZERS.get(ty);\n      if (serializer != null) return serializer;\n\n      const serializers: Record<string, Serializer<any>> = {};\n\n      const body = `\\\nswitch (value.tag) {\n${ty.variants\n  .map(\n    ({ name }, i) => `\\\n  case ${JSON.stringify(name!)}:\n    writer.writeByte(${i});\n    return this.${name!}(writer, value.value);`\n  )\n  .join('\\n')}\n  default:\n    throw new TypeError(\n      \\`Could not serialize sum type; unknown tag \\${value.tag}\\`\n    )\n}\n`;\n\n      serializer = Function('writer', 'value', body).bind(\n        serializers\n      ) as Serializer<any>;\n\n      // In case `ty` is recursive, we cache the function *before* before computing\n      // `variants`, so that a recursive `makeSerializer` with the same `ty` has\n      // an exit condition.\n      SERIALIZERS.set(ty, serializer);\n\n      for (const { name, algebraicType } of ty.variants) {\n        serializers[name!] = AlgebraicType.makeSerializer(\n          algebraicType,\n          typespace\n        );\n      }\n      Object.freeze(serializers);\n      return serializer;\n    }\n  },\n  /** @deprecated Use `makeSerializer` instead. */\n  serializeValue(\n    writer: BinaryWriter,\n    ty: SumTypeType,\n    value: any,\n    typespace?: TypespaceType\n  ): void {\n    SumType.makeSerializer(ty, typespace)(writer, value);\n  },\n  makeDeserializer(\n    ty: SumTypeType,\n    typespace?: TypespaceType\n  ): Deserializer<any> {\n    // In TypeScript we handle Option values as a special case\n    // we don't represent the some and none variants, but instead\n    // we represent the value directly.\n    //\n    // For these special cases, we don't do dynamic codegen, since that has the\n    // most benefit in cases where the object has a different shape. Since\n    // option/result always have the same number of variants, there's not as\n    // much benefit for the amount of work.\n    if (\n      ty.variants.length == 2 &&\n      ty.variants[0].name === 'some' &&\n      ty.variants[1].name === 'none'\n    ) {\n      const deserialize = AlgebraicType.makeDeserializer(\n        ty.variants[0].algebraicType,\n        typespace\n      );\n      return reader => {\n        const tag = reader.readU8();\n        if (tag === 0) {\n          return deserialize(reader);\n        } else if (tag === 1) {\n          return undefined;\n        } else {\n          throw `Can't deserialize an option type, couldn't find ${tag} tag`;\n        }\n      };\n    } else if (\n      ty.variants.length == 2 &&\n      ty.variants[0].name === 'ok' &&\n      ty.variants[1].name === 'err'\n    ) {\n      const deserializeOk = AlgebraicType.makeDeserializer(\n        ty.variants[0].algebraicType,\n        typespace\n      );\n      const deserializeErr = AlgebraicType.makeDeserializer(\n        ty.variants[1].algebraicType,\n        typespace\n      );\n      return reader => {\n        const tag = reader.readByte();\n        if (tag === 0) {\n          return { ok: deserializeOk(reader) };\n        } else if (tag === 1) {\n          return { err: deserializeErr(reader) };\n        } else {\n          throw `Can't deserialize a result type, couldn't find ${tag} tag`;\n        }\n      };\n    } else {\n      let deserializer = DESERIALIZERS.get(ty);\n      if (deserializer != null) return deserializer;\n      const deserializers: Record<string, Deserializer<any>> = {};\n      deserializer = Function(\n        'reader',\n        `switch (reader.readU8()) {\\n${ty.variants\n          .map(\n            ({ name }, i) =>\n              `case ${i}: return { tag: ${JSON.stringify(name!)}, value: this.${name!}(reader) };`\n          )\n          .join('\\n')} }`\n      ).bind(deserializers) as Deserializer<any>;\n      // In case `ty` is recursive, we cache the function *before* before computing\n      // `deserializers`, so that a recursive `makeDeserializer` with the same `ty` has\n      // an exit condition.\n      DESERIALIZERS.set(ty, deserializer);\n      for (const { name, algebraicType } of ty.variants) {\n        deserializers[name!] = AlgebraicType.makeDeserializer(\n          algebraicType,\n          typespace\n        );\n      }\n      Object.freeze(deserializers);\n      return deserializer;\n    }\n  },\n  /** @deprecated Use `makeDeserializer` instead. */\n  deserializeValue(\n    reader: BinaryReader,\n    ty: SumTypeType,\n    typespace?: TypespaceType\n  ): any {\n    return SumType.makeDeserializer(ty, typespace)(reader);\n  },\n};\n\nexport type ComparablePrimitive = number | string | boolean | bigint;\n","import { AlgebraicType } from './algebraic_type';\nimport { hexStringToU128, u128ToHexString, u128ToUint8Array } from './util';\n\nexport type ConnectionIdAlgebraicType = {\n  tag: 'Product';\n  value: {\n    elements: [{ name: '__connection_id__'; algebraicType: { tag: 'U128' } }];\n  };\n};\n\n/**\n * A unique identifier for a client connected to a database.\n */\nexport class ConnectionId {\n  __connection_id__: bigint;\n\n  /**\n   * Creates a new `ConnectionId`.\n   */\n  constructor(data: bigint) {\n    this.__connection_id__ = data;\n  }\n\n  /**\n   * Get the algebraic type representation of the {@link ConnectionId} type.\n   * @returns The algebraic type representation of the type.\n   */\n  static getAlgebraicType(): ConnectionIdAlgebraicType {\n    return AlgebraicType.Product({\n      elements: [\n        { name: '__connection_id__', algebraicType: AlgebraicType.U128 },\n      ],\n    });\n  }\n\n  isZero(): boolean {\n    return this.__connection_id__ === BigInt(0);\n  }\n\n  static nullIfZero(addr: ConnectionId): ConnectionId | null {\n    if (addr.isZero()) {\n      return null;\n    } else {\n      return addr;\n    }\n  }\n\n  static random(): ConnectionId {\n    function randomU8(): number {\n      return Math.floor(Math.random() * 0xff);\n    }\n    let result = BigInt(0);\n    for (let i = 0; i < 16; i++) {\n      result = (result << BigInt(8)) | BigInt(randomU8());\n    }\n    return new ConnectionId(result);\n  }\n\n  /**\n   * Compare two connection IDs for equality.\n   */\n  isEqual(other: ConnectionId): boolean {\n    return this.__connection_id__ == other.__connection_id__;\n  }\n\n  /**\n   * Check if two connection IDs are equal.\n   */\n  equals(other: ConnectionId): boolean {\n    return this.isEqual(other);\n  }\n\n  /**\n   * Print the connection ID as a hexadecimal string.\n   */\n  toHexString(): string {\n    return u128ToHexString(this.__connection_id__);\n  }\n\n  /**\n   * Convert the connection ID to a Uint8Array.\n   */\n  toUint8Array(): Uint8Array {\n    return u128ToUint8Array(this.__connection_id__);\n  }\n\n  /**\n   * Parse a connection ID from a hexadecimal string.\n   */\n  static fromString(str: string): ConnectionId {\n    return new ConnectionId(hexStringToU128(str));\n  }\n\n  static fromStringOrNull(str: string): ConnectionId | null {\n    const addr = ConnectionId.fromString(str);\n    if (addr.isZero()) {\n      return null;\n    } else {\n      return addr;\n    }\n  }\n}\n","/**\n * An error thrown by a reducer that indicates a problem to the sender.\n *\n * When this error is thrown by a reducer, the sender will be notified\n * that the reducer failed gracefully with the given message.\n */\nexport class SenderError extends Error {\n  constructor(message: string) {\n    super(message);\n  }\n  get name(): string {\n    return 'SenderError';\n  }\n}\n\n/**\n * An internal reducer error returned by the server runtime.\n */\nexport class InternalError extends Error {\n  constructor(message: string) {\n    super(message);\n  }\n  get name(): string {\n    return 'InternalError';\n  }\n}\n","import BinaryReader from './binary_reader';\n\nexport interface ParseableType<T> {\n  deserialize: (reader: BinaryReader) => T;\n}\n\nexport function parseValue<T>(ty: ParseableType<T>, src: Uint8Array): T {\n  const reader = new BinaryReader(src);\n  return ty.deserialize(reader);\n}\n","import { AlgebraicType } from './algebraic_type';\nimport { TimeDuration, type TimeDurationAlgebraicType } from './time_duration';\nimport { Timestamp, type TimestampAlgebraicType } from './timestamp';\n\nexport type ScheduleAtAlgebraicType = {\n  tag: 'Sum';\n  value: {\n    variants: [\n      { name: 'Interval'; algebraicType: TimeDurationAlgebraicType },\n      { name: 'Time'; algebraicType: TimestampAlgebraicType },\n    ];\n  };\n};\n\ntype ScheduleAtType = Interval | Time;\n\nexport const ScheduleAt: {\n  interval: (micros: bigint) => ScheduleAtType;\n  time: (microsSinceUnixEpoch: bigint) => ScheduleAtType;\n  /**\n   * Get the algebraic type representation of the {@link ScheduleAt} type.\n   * @returns The algebraic type representation of the type.\n   */\n  getAlgebraicType(): ScheduleAtAlgebraicType;\n  isScheduleAt(\n    algebraicType: AlgebraicType\n  ): algebraicType is ScheduleAtAlgebraicType;\n} = {\n  interval(value: bigint): ScheduleAtType {\n    return Interval(value);\n  },\n  time(value: bigint): ScheduleAtType {\n    return Time(value);\n  },\n  getAlgebraicType(): ScheduleAtAlgebraicType {\n    return AlgebraicType.Sum({\n      variants: [\n        {\n          name: 'Interval',\n          algebraicType: TimeDuration.getAlgebraicType(),\n        },\n        { name: 'Time', algebraicType: Timestamp.getAlgebraicType() },\n      ],\n    });\n  },\n  isScheduleAt(\n    algebraicType: AlgebraicType\n  ): algebraicType is ScheduleAtAlgebraicType {\n    if (algebraicType.tag !== 'Sum') {\n      return false;\n    }\n    const variants = algebraicType.value.variants;\n    if (variants.length !== 2) {\n      return false;\n    }\n    const intervalVariant = variants.find(v => v.name === 'Interval');\n    const timeVariant = variants.find(v => v.name === 'Time');\n    if (!intervalVariant || !timeVariant) {\n      return false;\n    }\n    return (\n      TimeDuration.isTimeDuration(intervalVariant.algebraicType) &&\n      Timestamp.isTimestamp(timeVariant.algebraicType)\n    );\n  },\n};\n\nexport type Interval = {\n  tag: 'Interval';\n  value: TimeDuration;\n};\nexport const Interval = (micros: bigint): Interval => ({\n  tag: 'Interval',\n  value: new TimeDuration(micros),\n});\nexport type Time = {\n  tag: 'Time';\n  value: Timestamp;\n};\nexport const Time = (microsSinceUnixEpoch: bigint): Time => ({\n  tag: 'Time',\n  value: new Timestamp(microsSinceUnixEpoch),\n});\n\nexport default ScheduleAt;\nexport type ScheduleAt = ScheduleAtType;\n","import { AlgebraicType } from './algebraic_type';\n\nexport type OptionAlgebraicType<T extends AlgebraicType = AlgebraicType> = {\n  tag: 'Sum';\n  value: {\n    variants: [\n      { name: 'some'; algebraicType: T },\n      {\n        name: 'none';\n        algebraicType: { tag: 'Product'; value: { elements: [] } };\n      },\n    ];\n  };\n};\n\nexport const Option: {\n  getAlgebraicType<T extends AlgebraicType = AlgebraicType>(\n    innerType: T\n  ): OptionAlgebraicType<T>;\n} = {\n  getAlgebraicType<T extends AlgebraicType = AlgebraicType>(\n    innerType: T\n  ): OptionAlgebraicType<T> {\n    return AlgebraicType.Sum({\n      variants: [\n        { name: 'some', algebraicType: innerType },\n        {\n          name: 'none',\n          algebraicType: AlgebraicType.Product({ elements: [] }),\n        },\n      ],\n    });\n  },\n};\n","import { AlgebraicType } from './algebraic_type';\n\nexport type ResultAlgebraicType<\n  T extends AlgebraicType = AlgebraicType,\n  E extends AlgebraicType = AlgebraicType,\n> = {\n  tag: 'Sum';\n  value: {\n    variants: [\n      { name: 'ok'; algebraicType: T },\n      { name: 'err'; algebraicType: E },\n    ];\n  };\n};\n\nexport const Result: {\n  getAlgebraicType<\n    T extends AlgebraicType = AlgebraicType,\n    E extends AlgebraicType = AlgebraicType,\n  >(\n    okType: T,\n    errType: E\n  ): ResultAlgebraicType<T, E>;\n} = {\n  getAlgebraicType<\n    T extends AlgebraicType = AlgebraicType,\n    E extends AlgebraicType = AlgebraicType,\n  >(okType: T, errType: E): ResultAlgebraicType<T, E> {\n    return AlgebraicType.Sum({\n      variants: [\n        { name: 'ok', algebraicType: okType },\n        { name: 'err', algebraicType: errType },\n      ],\n    });\n  },\n};\n","import { ConnectionId } from './connection_id';\nimport { Identity } from './identity';\nimport type { ColumnIndex, IndexColumns, IndexOpts } from './indexes';\nimport type { UntypedSchemaDef } from './schema';\nimport type { UntypedTableSchema } from './table_schema';\nimport { Timestamp } from './timestamp';\nimport type {\n  ColumnBuilder,\n  ColumnMetadata,\n  RowBuilder,\n  TypeBuilder,\n} from './type_builders';\nimport type { Values } from './type_util';\n\n/**\n * Helper to get the set of table names.\n */\nexport type TableNames<SchemaDef extends UntypedSchemaDef> = Values<\n  SchemaDef['tables']\n>['accessorName'] &\n  string;\n\n/** helper: pick the table def object from the schema by its name */\nexport type TableDefByName<\n  SchemaDef extends UntypedSchemaDef,\n  Name extends TableNames<SchemaDef>,\n> = Extract<Values<SchemaDef['tables']>, { accessorName: Name }>;\n\n// internal only  NOT exported.\n// This is how we make sure queries are only created with our helpers.\nconst QueryBrand = Symbol('QueryBrand');\n\nexport interface TableTypedQuery<TableDef extends TypedTableDef> {\n  readonly [QueryBrand]: true;\n  readonly __table?: TableDef;\n}\n\nexport interface RowTypedQuery<Row, ST> {\n  readonly [QueryBrand]: true;\n  // Phantom type to track the row type.\n  readonly __row?: Row;\n  readonly __algebraicType?: ST;\n}\n\nexport type Query<TableDef extends TypedTableDef> = RowTypedQuery<\n  RowType<TableDef>,\n  TableDef['rowType']\n>;\n\nexport const isRowTypedQuery = (val: unknown): val is RowTypedQuery<any, any> =>\n  !!val && typeof val === 'object' && QueryBrand in (val as object);\n\nexport const isTypedQuery = (val: unknown): val is TableTypedQuery<any> =>\n  !!val && typeof val === 'object' && QueryBrand in (val as object);\n\nexport function toSql(q: Query<any>): string {\n  return (q as unknown as { toSql(): string }).toSql();\n}\n\n// A query builder with a single table.\ntype From<TableDef extends TypedTableDef> = RowTypedQuery<\n  RowType<TableDef>,\n  TableDef['rowType']\n> &\n  Readonly<{\n    toSql(): string;\n    where(\n      predicate: (row: RowExpr<TableDef>) => BooleanExpr<TableDef>\n    ): From<TableDef>;\n    rightSemijoin<RightTable extends TypedTableDef>(\n      other: TableRef<RightTable>,\n      on: (\n        left: IndexedRowExpr<TableDef>,\n        right: IndexedRowExpr<RightTable>\n      ) => BooleanExpr<TableDef | RightTable>\n    ): SemijoinBuilder<RightTable>;\n    leftSemijoin<RightTable extends TypedTableDef>(\n      other: TableRef<RightTable>,\n      on: (\n        left: IndexedRowExpr<TableDef>,\n        right: IndexedRowExpr<RightTable>\n      ) => BooleanExpr<TableDef | RightTable>\n    ): SemijoinBuilder<TableDef>;\n    /** @deprecated No longer needed  builder is already a valid query. */\n    build(): Query<TableDef>;\n  }>;\n\n// A query builder with a semijoin.\ntype SemijoinBuilder<TableDef extends TypedTableDef> = RowTypedQuery<\n  RowType<TableDef>,\n  TableDef['rowType']\n> &\n  Readonly<{\n    toSql(): string;\n    where(\n      predicate: (row: RowExpr<TableDef>) => BooleanExpr<TableDef>\n    ): SemijoinBuilder<TableDef>;\n    /** @deprecated No longer needed  builder is already a valid query. */\n    build(): Query<TableDef>;\n  }>;\n\nclass SemijoinImpl<TableDef extends TypedTableDef>\n  implements SemijoinBuilder<TableDef>, TableTypedQuery<TableDef>\n{\n  readonly [QueryBrand] = true;\n  readonly type = 'semijoin' as const;\n  constructor(\n    readonly sourceQuery: FromBuilder<TableDef>,\n    readonly filterQuery: FromBuilder<any>,\n    readonly joinCondition: BooleanExpr<any>\n  ) {\n    if (sourceQuery.table.sourceName === filterQuery.table.sourceName) {\n      // TODO: Handle aliasing properly instead of just forbidding it.\n      throw new Error('Cannot semijoin a table to itself');\n    }\n  }\n\n  build(): Query<TableDef> {\n    return this as Query<TableDef>;\n  }\n\n  where(\n    predicate: (row: RowExpr<TableDef>) => BooleanExpr<TableDef>\n  ): SemijoinImpl<TableDef> {\n    const nextSourceQuery = this.sourceQuery.where(predicate);\n    return new SemijoinImpl<TableDef>(\n      nextSourceQuery,\n      this.filterQuery,\n      this.joinCondition\n    );\n  }\n\n  toSql(): string {\n    const left = this.filterQuery;\n    const right = this.sourceQuery;\n    const leftTable = quoteIdentifier(left.table.sourceName);\n    const rightTable = quoteIdentifier(right.table.sourceName);\n    let sql = `SELECT ${rightTable}.* FROM ${leftTable} JOIN ${rightTable} ON ${booleanExprToSql(this.joinCondition)}`;\n\n    const clauses: string[] = [];\n    if (left.whereClause) {\n      clauses.push(booleanExprToSql(left.whereClause));\n    }\n    if (right.whereClause) {\n      clauses.push(booleanExprToSql(right.whereClause));\n    }\n\n    if (clauses.length > 0) {\n      const whereSql =\n        clauses.length === 1\n          ? clauses[0]\n          : clauses.map(wrapInParens).join(' AND ');\n      sql += ` WHERE ${whereSql}`;\n    }\n\n    return sql;\n  }\n}\n\nclass FromBuilder<TableDef extends TypedTableDef>\n  implements From<TableDef>, TableTypedQuery<TableDef>\n{\n  readonly [QueryBrand] = true;\n  constructor(\n    readonly table: TableRef<TableDef>,\n    readonly whereClause?: BooleanExpr<TableDef>\n  ) {}\n\n  where(\n    predicate: (row: RowExpr<TableDef>) => BooleanExpr<TableDef>\n  ): FromBuilder<TableDef> {\n    const newCondition = predicate(this.table.cols);\n    const nextWhere = this.whereClause\n      ? this.whereClause.and(newCondition)\n      : newCondition;\n    return new FromBuilder<TableDef>(this.table, nextWhere);\n  }\n\n  rightSemijoin<OtherTable extends TypedTableDef>(\n    right: TableRef<OtherTable>,\n    on: (\n      left: IndexedRowExpr<TableDef>,\n      right: IndexedRowExpr<OtherTable>\n    ) => BooleanExpr<TableDef | OtherTable>\n  ): SemijoinBuilder<OtherTable> {\n    const sourceQuery = new FromBuilder(right);\n    const joinCondition = on(\n      this.table.indexedCols,\n      right.indexedCols\n    ) as BooleanExpr<any>;\n    return new SemijoinImpl<OtherTable>(sourceQuery, this, joinCondition);\n  }\n\n  leftSemijoin<OtherTable extends TypedTableDef>(\n    right: TableRef<OtherTable>,\n    on: (\n      left: IndexedRowExpr<TableDef>,\n      right: IndexedRowExpr<OtherTable>\n    ) => BooleanExpr<TableDef | OtherTable>\n  ): SemijoinBuilder<TableDef> {\n    const filterQuery = new FromBuilder(right);\n    const joinCondition = on(\n      this.table.indexedCols,\n      right.indexedCols\n    ) as BooleanExpr<any>;\n    return new SemijoinImpl<TableDef>(this, filterQuery, joinCondition);\n  }\n\n  toSql(): string {\n    return renderSelectSqlWithJoins(this.table, this.whereClause);\n  }\n\n  build(): Query<TableDef> {\n    return this as Query<TableDef>;\n  }\n}\n\nexport type QueryBuilder<SchemaDef extends UntypedSchemaDef> = {\n  readonly [Tbl in Values<\n    SchemaDef['tables']\n  > as Tbl['accessorName']]: TableRef<Tbl> & From<Tbl>;\n} & {};\n\n/**\n * A runtime reference to a table. This materializes the RowExpr for us.\n * TODO: Maybe add the full SchemaDef to the type signature depending on how joins will work.\n */\nexport type TableRef<TableDef extends TypedTableDef> = Readonly<{\n  type: 'table';\n  sourceName: TableDef['sourceName'];\n  accessorName: string;\n  cols: RowExpr<TableDef>;\n  indexedCols: IndexedRowExpr<TableDef>;\n  tableDef: TableDef;\n  // Delegated UntypedTableDef properties for compatibility.\n  columns: TableDef['columns'];\n  indexes: TableDef['indexes'];\n  rowType: TableDef['rowType'];\n  constraints: any;\n}>;\n\nclass TableRefImpl<TableDef extends TypedTableDef>\n  implements TableRef<TableDef>, From<TableDef>\n{\n  readonly [QueryBrand] = true;\n  readonly type = 'table' as const;\n  sourceName: string;\n  accessorName: string;\n  cols: RowExpr<TableDef>;\n  indexedCols: IndexedRowExpr<TableDef>;\n  tableDef: TableDef;\n  // Delegate UntypedTableDef properties from tableDef so this can be used as a table def.\n  get columns() {\n    return this.tableDef.columns;\n  }\n  get indexes() {\n    return this.tableDef.indexes;\n  }\n  get rowType() {\n    return this.tableDef.rowType;\n  }\n  get constraints() {\n    return (this.tableDef as any).constraints;\n  }\n  constructor(tableDef: TableDef) {\n    this.sourceName = tableDef.sourceName;\n    this.accessorName = tableDef.accessorName;\n    this.cols = createRowExpr(tableDef);\n    // this.indexedCols = createIndexedRowExpr(tableDef, this.cols);\n    // TODO: we could create an indexedRowExpr to avoid having the extra columns.\n    // Right now, the objects we pass will actually have all the columns, but the\n    // type system will consider it an error.\n    this.indexedCols = this.cols;\n    this.tableDef = tableDef;\n    Object.freeze(this);\n  }\n\n  asFrom(): FromBuilder<TableDef> {\n    return new FromBuilder<TableDef>(this);\n  }\n\n  rightSemijoin<RightTable extends TypedTableDef>(\n    other: TableRef<RightTable>,\n    on: (\n      left: IndexedRowExpr<TableDef>,\n      right: IndexedRowExpr<RightTable>\n    ) => EqExpr<TableDef | RightTable>\n  ): SemijoinBuilder<RightTable> {\n    return this.asFrom().rightSemijoin(other, on);\n  }\n\n  leftSemijoin<RightTable extends TypedTableDef>(\n    other: TableRef<RightTable>,\n    on: (\n      left: IndexedRowExpr<TableDef>,\n      right: IndexedRowExpr<RightTable>\n    ) => EqExpr<TableDef | RightTable>\n  ): SemijoinBuilder<TableDef> {\n    return this.asFrom().leftSemijoin(other, on);\n  }\n\n  build(): Query<TableDef> {\n    return this.asFrom().build();\n  }\n\n  toSql(): string {\n    return this.asFrom().toSql();\n  }\n\n  where(\n    predicate: (row: RowExpr<TableDef>) => BooleanExpr<TableDef>\n  ): FromBuilder<TableDef> {\n    return this.asFrom().where(predicate);\n  }\n}\n\nexport function createTableRefFromDef<TableDef extends TypedTableDef>(\n  tableDef: TableDef\n): TableRef<TableDef> {\n  return new TableRefImpl<TableDef>(tableDef);\n}\n\nexport function makeQueryBuilder<SchemaDef extends UntypedSchemaDef>(\n  schema: SchemaDef\n): QueryBuilder<SchemaDef> {\n  const qb = Object.create(null) as QueryBuilder<SchemaDef>;\n  for (const table of Object.values(schema.tables)) {\n    const ref = createTableRefFromDef(\n      table as TableDefByName<SchemaDef, TableNames<SchemaDef>>\n    );\n    (qb as Record<string, TableRef<any>>)[table.accessorName] = ref;\n  }\n  return Object.freeze(qb) as QueryBuilder<SchemaDef>;\n}\n\nfunction createRowExpr<TableDef extends TypedTableDef>(\n  tableDef: TableDef\n): RowExpr<TableDef> {\n  const row: Record<string, ColumnExpr<TableDef, any>> = {};\n  for (const columnName of Object.keys(tableDef.columns) as Array<\n    keyof TableDef['columns'] & string\n  >) {\n    const columnBuilder = tableDef.columns[columnName];\n    const column = new ColumnExpression<TableDef, typeof columnName>(\n      tableDef.sourceName,\n      columnName,\n      columnBuilder.typeBuilder.algebraicType as InferSpacetimeTypeOfColumn<\n        TableDef,\n        typeof columnName\n      >\n    );\n    row[columnName] = Object.freeze(column);\n  }\n  return Object.freeze(row) as RowExpr<TableDef>;\n}\n\nfunction renderSelectSqlWithJoins<Table extends TypedTableDef>(\n  table: TableRef<Table>,\n  where?: BooleanExpr<Table>,\n  extraClauses: readonly string[] = []\n): string {\n  const quotedTable = quoteIdentifier(table.sourceName);\n  const sql = `SELECT * FROM ${quotedTable}`;\n  const clauses: string[] = [];\n  if (where) clauses.push(booleanExprToSql(where));\n  clauses.push(...extraClauses);\n  if (clauses.length === 0) return sql;\n  const whereSql =\n    clauses.length === 1 ? clauses[0] : clauses.map(wrapInParens).join(' AND ');\n  return `${sql} WHERE ${whereSql}`;\n}\n\n// TODO: Just use UntypedTableDef if they end up being the same.\nexport type TypedTableDef<\n  Columns extends Record<\n    string,\n    ColumnBuilder<any, any, ColumnMetadata<any>>\n  > = Record<string, ColumnBuilder<any, any, ColumnMetadata<any>>>,\n> = {\n  sourceName: string;\n  accessorName: string;\n  columns: Columns;\n  indexes: readonly IndexOpts<any>[];\n  rowType: RowBuilder<Columns>['algebraicType']['value'];\n};\n\nexport type TableSchemaAsTableDef<TSchema extends UntypedTableSchema> = {\n  name: TSchema['tableName'];\n  columns: TSchema['rowType']['row'];\n  indexes: TSchema['idxs'];\n};\n\ntype RowType<TableDef extends TypedTableDef> = {\n  [K in keyof TableDef['columns']]: TableDef['columns'][K] extends ColumnBuilder<\n    infer T,\n    any,\n    any\n  >\n    ? T\n    : never;\n};\n\n// TODO: Consider making a smaller version of these types that doesn't expose the internals.\n// Restricting it later should not break anyone in practice.\nexport type ColumnExpr<\n  TableDef extends TypedTableDef,\n  ColumnName extends ColumnNames<TableDef>,\n> = ColumnExpression<TableDef, ColumnName>;\n\ntype ColumnSpacetimeType<Col extends ColumnExpr<any, any>> =\n  Col extends ColumnExpr<infer T, infer N>\n    ? InferSpacetimeTypeOfColumn<T, N>\n    : never;\n\n// TODO: This checks that they match, but we also need to make sure that they are comparable types,\n// since you can use product types at all.\ntype ColumnSameSpacetime<\n  ThisTable extends TypedTableDef,\n  ThisCol extends ColumnNames<ThisTable>,\n  OtherCol extends ColumnExpr<any, any>,\n> = [InferSpacetimeTypeOfColumn<ThisTable, ThisCol>] extends [\n  ColumnSpacetimeType<OtherCol>,\n]\n  ? [ColumnSpacetimeType<OtherCol>] extends [\n      InferSpacetimeTypeOfColumn<ThisTable, ThisCol>,\n    ]\n    ? OtherCol\n    : never\n  : never;\n\n// Helper to get the table back from a column.\ntype ExtractTable<Col extends ColumnExpr<any, any>> =\n  Col extends ColumnExpr<infer T, any> ? T : never;\n\nexport class ColumnExpression<\n  TableDef extends TypedTableDef,\n  ColumnName extends ColumnNames<TableDef>,\n> {\n  readonly type = 'column' as const;\n  readonly column: ColumnName;\n  readonly table: TableDef['sourceName'];\n  // phantom: actual runtime value is undefined\n  readonly tsValueType?: RowType<TableDef>[ColumnName];\n  readonly spacetimeType: InferSpacetimeTypeOfColumn<TableDef, ColumnName>;\n\n  constructor(\n    table: TableDef['sourceName'],\n    column: ColumnName,\n    spacetimeType: InferSpacetimeTypeOfColumn<TableDef, ColumnName>\n  ) {\n    this.table = table;\n    this.column = column;\n    this.spacetimeType = spacetimeType;\n  }\n\n  eq(\n    literal: LiteralValue & RowType<TableDef>[ColumnName]\n  ): BooleanExpr<TableDef>;\n  eq<OtherCol extends ColumnExpr<any, any>>(\n    value: ColumnSameSpacetime<TableDef, ColumnName, OtherCol>\n  ): BooleanExpr<TableDef | ExtractTable<OtherCol>>;\n\n  eq(x: any): any {\n    return new BooleanExpr({\n      type: 'eq',\n      left: this as unknown as ValueExpr<TableDef, any>,\n      right: normalizeValue(x) as ValueExpr<TableDef, any>,\n    });\n  }\n\n  ne(\n    literal: LiteralValue & RowType<TableDef>[ColumnName]\n  ): BooleanExpr<TableDef>;\n  ne<OtherCol extends ColumnExpr<any, any>>(\n    value: ColumnSameSpacetime<TableDef, ColumnName, OtherCol>\n  ): BooleanExpr<TableDef | ExtractTable<OtherCol>>;\n\n  ne(x: any): any {\n    return new BooleanExpr({\n      type: 'ne',\n      left: this as unknown as ValueExpr<TableDef, any>,\n      right: normalizeValue(x) as ValueExpr<TableDef, any>,\n    });\n  }\n\n  lt(\n    literal: LiteralValue & RowType<TableDef>[ColumnName]\n  ): BooleanExpr<TableDef>;\n  lt<OtherCol extends ColumnExpr<any, any>>(\n    value: ColumnSameSpacetime<TableDef, ColumnName, OtherCol>\n  ): BooleanExpr<TableDef | ExtractTable<OtherCol>>;\n\n  lt(x: any): any {\n    return new BooleanExpr({\n      type: 'lt',\n      left: this as unknown as ValueExpr<TableDef, any>,\n      right: normalizeValue(x) as ValueExpr<TableDef, any>,\n    });\n  }\n\n  lte(\n    literal: LiteralValue & RowType<TableDef>[ColumnName]\n  ): BooleanExpr<TableDef>;\n  lte<OtherCol extends ColumnExpr<any, any>>(\n    value: ColumnSameSpacetime<TableDef, ColumnName, OtherCol>\n  ): BooleanExpr<TableDef | ExtractTable<OtherCol>>;\n\n  lte(x: any): any {\n    return new BooleanExpr({\n      type: 'lte',\n      left: this as unknown as ValueExpr<TableDef, any>,\n      right: normalizeValue(x) as ValueExpr<TableDef, any>,\n    });\n  }\n\n  gt(\n    literal: LiteralValue & RowType<TableDef>[ColumnName]\n  ): BooleanExpr<TableDef>;\n  gt<OtherCol extends ColumnExpr<any, any>>(\n    value: ColumnSameSpacetime<TableDef, ColumnName, OtherCol>\n  ): BooleanExpr<TableDef | ExtractTable<OtherCol>>;\n\n  gt(x: any): any {\n    return new BooleanExpr({\n      type: 'gt',\n      left: this as unknown as ValueExpr<TableDef, any>,\n      right: normalizeValue(x) as ValueExpr<TableDef, any>,\n    });\n  }\n\n  gte(\n    literal: LiteralValue & RowType<TableDef>[ColumnName]\n  ): BooleanExpr<TableDef>;\n  gte<OtherCol extends ColumnExpr<any, any>>(\n    value: ColumnSameSpacetime<TableDef, ColumnName, OtherCol>\n  ): BooleanExpr<TableDef | ExtractTable<OtherCol>>;\n\n  gte(x: any): any {\n    return new BooleanExpr({\n      type: 'gte',\n      left: this as unknown as ValueExpr<TableDef, any>,\n      right: normalizeValue(x) as ValueExpr<TableDef, any>,\n    });\n  }\n}\n\n/**\n * Helper to get the spacetime type of a column.\n */\ntype InferSpacetimeTypeOfColumn<\n  TableDef extends TypedTableDef,\n  ColumnName extends ColumnNames<TableDef>,\n> =\n  TableDef['columns'][ColumnName]['typeBuilder'] extends TypeBuilder<\n    any,\n    infer U\n  >\n    ? U\n    : never;\n\ntype ColumnNames<TableDef extends TypedTableDef> = keyof RowType<TableDef> &\n  string;\n\n// For composite indexes, we only consider it as an index over the first column in the index.\ntype FirstIndexColumn<I extends IndexOpts<any>> =\n  IndexColumns<I> extends readonly [infer Head extends string, ...infer _Rest]\n    ? Head\n    : never;\n\n// Columns that are indexed by something in the indexes: [...] part.\ntype ExplicitIndexedColumns<TableDef extends TypedTableDef> =\n  TableDef['indexes'][number] extends infer I\n    ? I extends IndexOpts<ColumnNames<TableDef>>\n      ? FirstIndexColumn<I> & ColumnNames<TableDef>\n      : never\n    : never;\n\n// Columns with an index defined on the column definition.\ntype MetadataIndexedColumns<TableDef extends TypedTableDef> = {\n  [K in ColumnNames<TableDef>]: ColumnIndex<\n    K,\n    TableDef['columns'][K]['columnMetadata']\n  > extends never\n    ? never\n    : K;\n}[ColumnNames<TableDef>];\n\nexport type IndexedColumnNames<TableDef extends TypedTableDef> =\n  | ExplicitIndexedColumns<TableDef>\n  | MetadataIndexedColumns<TableDef>;\n\nexport type IndexedRowExpr<TableDef extends TypedTableDef> = Readonly<{\n  readonly [C in IndexedColumnNames<TableDef>]: ColumnExpr<TableDef, C>;\n}>;\n\n/**\n * Acts as a row when writing filters for queries. It is a way to get column references.\n */\nexport type RowExpr<TableDef extends TypedTableDef> = Readonly<{\n  readonly [C in ColumnNames<TableDef>]: ColumnExpr<TableDef, C>;\n}>;\n\n/**\n * Union of ColumnExprs from Table whose spacetimeType is compatible with Value\n * (produces a union of ColumnExpr<Table, C> for matching columns).\n */\nexport type ColumnExprForValue<Table extends TypedTableDef, Value> = {\n  [C in ColumnNames<Table>]: InferSpacetimeTypeOfColumn<Table, C> extends Value\n    ? ColumnExpr<Table, C>\n    : never;\n}[ColumnNames<Table>];\n\ntype LiteralValue =\n  | string\n  | number\n  | bigint\n  | boolean\n  | Identity\n  | Timestamp\n  | ConnectionId;\n\ntype ValueLike = LiteralValue | ColumnExpr<any, any> | LiteralExpr<any>;\ntype ValueInput<TableDef extends TypedTableDef> =\n  | ValueLike\n  | ValueExpr<TableDef, any>;\n\nexport type ValueExpr<TableDef extends TypedTableDef, Value> =\n  | LiteralExpr<Value & LiteralValue>\n  | ColumnExprForValue<TableDef, Value>;\n\ntype LiteralExpr<Value> = {\n  type: 'literal';\n  value: Value;\n};\n\nexport function literal<Value extends LiteralValue>(\n  value: Value\n): ValueExpr<never, Value> {\n  return { type: 'literal', value };\n}\n\n// This is here to take literal values and wrap them in an AST node.\nfunction normalizeValue(val: ValueInput<any>): ValueExpr<any, any> {\n  if ((val as LiteralExpr<any>).type === 'literal')\n    return val as LiteralExpr<any>;\n  if (\n    typeof val === 'object' &&\n    val != null &&\n    'type' in (val as any) &&\n    (val as any).type === 'column'\n  ) {\n    return val as ColumnExpr<any, any>;\n  }\n  return literal(val as LiteralValue);\n}\n\ntype EqExpr<Table extends TypedTableDef = any> = BooleanExpr<Table>;\n\ntype BooleanExprData<Table extends TypedTableDef> = (\n  | {\n      type: 'eq' | 'ne' | 'gt' | 'lt' | 'gte' | 'lte';\n      left: ValueExpr<Table, any>;\n      right: ValueExpr<Table, any>;\n    }\n  | {\n      type: 'and';\n      clauses: readonly [\n        BooleanExprData<Table>,\n        BooleanExprData<Table>,\n        ...BooleanExprData<Table>[],\n      ];\n    }\n  | {\n      type: 'or';\n      clauses: readonly [\n        BooleanExprData<Table>,\n        BooleanExprData<Table>,\n        ...BooleanExprData<Table>[],\n      ];\n    }\n  | {\n      type: 'not';\n      clause: BooleanExprData<Table>;\n    }\n) & {\n  _tableType?: Table;\n};\n\nexport class BooleanExpr<Table extends TypedTableDef> {\n  constructor(readonly data: BooleanExprData<Table>) {}\n\n  and(other: BooleanExpr<Table>): BooleanExpr<Table> {\n    return new BooleanExpr({ type: 'and', clauses: [this.data, other.data] });\n  }\n\n  or(other: BooleanExpr<Table>): BooleanExpr<Table> {\n    return new BooleanExpr({ type: 'or', clauses: [this.data, other.data] });\n  }\n\n  not(): BooleanExpr<Table> {\n    return new BooleanExpr({ type: 'not', clause: this.data });\n  }\n}\n\nexport function not<T extends TypedTableDef>(\n  clause: BooleanExpr<T>\n): BooleanExpr<T> {\n  return new BooleanExpr({ type: 'not', clause: clause.data });\n}\n\nexport function and<T extends TypedTableDef>(\n  ...clauses: readonly [BooleanExpr<T>, BooleanExpr<T>, ...BooleanExpr<T>[]]\n): BooleanExpr<T> {\n  return new BooleanExpr({\n    type: 'and',\n    clauses: clauses.map(c => c.data) as [\n      BooleanExprData<T>,\n      BooleanExprData<T>,\n      ...BooleanExprData<T>[],\n    ],\n  });\n}\n\nexport function or<T extends TypedTableDef>(\n  ...clauses: readonly [BooleanExpr<T>, BooleanExpr<T>, ...BooleanExpr<T>[]]\n): BooleanExpr<T> {\n  return new BooleanExpr({\n    type: 'or',\n    clauses: clauses.map(c => c.data) as [\n      BooleanExprData<T>,\n      BooleanExprData<T>,\n      ...BooleanExprData<T>[],\n    ],\n  });\n}\n\nfunction booleanExprToSql<Table extends TypedTableDef>(\n  expr: BooleanExpr<Table> | BooleanExprData<Table>,\n  tableAlias?: string\n): string {\n  const data = expr instanceof BooleanExpr ? expr.data : expr;\n  switch (data.type) {\n    case 'eq':\n      return `${valueExprToSql(data.left, tableAlias)} = ${valueExprToSql(data.right, tableAlias)}`;\n    case 'ne':\n      return `${valueExprToSql(data.left, tableAlias)} <> ${valueExprToSql(data.right, tableAlias)}`;\n    case 'gt':\n      return `${valueExprToSql(data.left, tableAlias)} > ${valueExprToSql(data.right, tableAlias)}`;\n    case 'gte':\n      return `${valueExprToSql(data.left, tableAlias)} >= ${valueExprToSql(data.right, tableAlias)}`;\n    case 'lt':\n      return `${valueExprToSql(data.left, tableAlias)} < ${valueExprToSql(data.right, tableAlias)}`;\n    case 'lte':\n      return `${valueExprToSql(data.left, tableAlias)} <= ${valueExprToSql(data.right, tableAlias)}`;\n    case 'and':\n      return data.clauses\n        .map(c => booleanExprToSql(c, tableAlias))\n        .map(wrapInParens)\n        .join(' AND ');\n    case 'or':\n      return data.clauses\n        .map(c => booleanExprToSql(c, tableAlias))\n        .map(wrapInParens)\n        .join(' OR ');\n    case 'not':\n      return `NOT ${wrapInParens(booleanExprToSql(data.clause, tableAlias))}`;\n  }\n}\n\nfunction wrapInParens(sql: string): string {\n  return `(${sql})`;\n}\n\nfunction valueExprToSql<Table extends TypedTableDef>(\n  expr: ValueExpr<Table, any>,\n  tableAlias?: string\n): string {\n  if (isLiteralExpr(expr)) {\n    return literalValueToSql(expr.value);\n  }\n  const table = tableAlias ?? expr.table;\n  return `${quoteIdentifier(table)}.${quoteIdentifier(expr.column)}`;\n}\n\nfunction literalValueToSql(value: unknown): string {\n  if (value === null || value === undefined) {\n    return 'NULL';\n  }\n  if (value instanceof Identity || value instanceof ConnectionId) {\n    // We use this hex string syntax.\n    return `0x${value.toHexString()}`;\n  }\n  if (value instanceof Timestamp) {\n    return `'${value.toISOString()}'`;\n  }\n  switch (typeof value) {\n    case 'number':\n    case 'bigint':\n      return String(value);\n    case 'boolean':\n      return value ? 'TRUE' : 'FALSE';\n    case 'string':\n      return `'${value.replace(/'/g, \"''\")}'`;\n    default:\n      // It might be safer to error here?\n      return `'${JSON.stringify(value).replace(/'/g, \"''\")}'`;\n  }\n}\n\nfunction quoteIdentifier(name: string): string {\n  return `\"${name.replace(/\"/g, '\"\"')}\"`;\n}\n\nfunction isLiteralExpr<Value>(\n  expr: ValueExpr<any, Value>\n): expr is LiteralExpr<Value & LiteralValue> {\n  return (expr as LiteralExpr<Value>).type === 'literal';\n}\n\n/**\n * Evaluate a BooleanExpr against a row at runtime for client-side filtering.\n */\nexport function evaluateBooleanExpr(\n  expr: BooleanExpr<any>,\n  row: Record<string, any>\n): boolean {\n  return evaluateData(expr.data, row);\n}\n\nfunction evaluateData(\n  data: BooleanExprData<any>,\n  row: Record<string, any>\n): boolean {\n  switch (data.type) {\n    case 'eq':\n      return resolveValue(data.left, row) === resolveValue(data.right, row);\n    case 'ne':\n      return resolveValue(data.left, row) !== resolveValue(data.right, row);\n    case 'gt':\n      return resolveValue(data.left, row) > resolveValue(data.right, row);\n    case 'gte':\n      return resolveValue(data.left, row) >= resolveValue(data.right, row);\n    case 'lt':\n      return resolveValue(data.left, row) < resolveValue(data.right, row);\n    case 'lte':\n      return resolveValue(data.left, row) <= resolveValue(data.right, row);\n    case 'and':\n      return data.clauses.every(c => evaluateData(c, row));\n    case 'or':\n      return data.clauses.some(c => evaluateData(c, row));\n    case 'not':\n      return !evaluateData(data.clause, row);\n  }\n}\n\nfunction resolveValue(\n  expr: ValueExpr<any, any>,\n  row: Record<string, any>\n): any {\n  if (isLiteralExpr(expr)) {\n    return toComparableValue(expr.value);\n  }\n  return toComparableValue(row[expr.column]);\n}\n\ntype TimestampLike = {\n  __timestamp_micros_since_unix_epoch__: bigint;\n};\n\ntype HexSerializableLike = {\n  toHexString: () => string;\n};\n\nfunction isHexSerializableLike(value: unknown): value is HexSerializableLike {\n  return (\n    !!value &&\n    typeof value === 'object' &&\n    typeof (value as { toHexString?: unknown }).toHexString === 'function'\n  );\n}\n\n// Check if this value is a Timestamp-like object. This is here because\n// running locally can end up with different versions of the Timestamp class,\n// which breaks the simple instanceof version.\nfunction isTimestampLike(value: unknown): value is TimestampLike {\n  if (!value || typeof value !== 'object') return false;\n\n  if (value instanceof Timestamp) return true;\n\n  const micros = (value as Record<string, unknown>)[\n    '__timestamp_micros_since_unix_epoch__'\n  ];\n  return typeof micros === 'bigint';\n}\n\n// Exported for tests.\nexport function toComparableValue(value: any): any {\n  // Handle `ConnectionId` and `Identity`.\n  if (isHexSerializableLike(value)) {\n    return value.toHexString();\n  }\n  if (isTimestampLike(value)) {\n    return value.__timestamp_micros_since_unix_epoch__;\n  }\n  return value;\n}\n\n/**\n * Extract the table name from a query builder expression.\n */\nexport function getQueryTableName(query: any): string {\n  if (query.table) return query.table.name; // FromBuilder\n  if (query.name) return query.name; // TableRefImpl\n  if (query.sourceQuery) return query.sourceQuery.table.name; // SemijoinImpl (source table)\n  throw new Error('Cannot extract table name from query');\n}\n\n/**\n * Extract the accessor name from a query builder expression.\n */\nexport function getQueryAccessorName(query: any): string {\n  if (query.table) return query.table.accessorName; // FromBuilder\n  if (query.accessorName) return query.accessorName; // TableRefImpl\n  if (query.sourceQuery) return query.sourceQuery.table.accessorName; // SemijoinImpl\n  throw new Error('Cannot extract accessor name from query');\n}\n\n/**\n * Extract the BooleanExpr from a query builder, if any.\n */\nexport function getQueryWhereClause(query: any): BooleanExpr<any> | undefined {\n  if (query.whereClause) return query.whereClause; // FromBuilder\n  return undefined; // TableRefImpl has no where clause\n}\n\n// TODO: Fix this.\nfunction _createIndexedRowExpr<TableDef extends TypedTableDef>(\n  tableDef: TableDef,\n  cols: RowExpr<TableDef>\n): IndexedRowExpr<TableDef> {\n  const indexed = new Set<ColumnNames<TableDef>>();\n  for (const idx of tableDef.indexes) {\n    if ('columns' in idx) {\n      const [first] = idx.columns;\n      if (first) indexed.add(first);\n    } else if ('column' in idx) {\n      indexed.add(idx.column);\n    }\n  }\n  const pickedEntries = [...indexed].map(name => [name, cols[name]]);\n  return Object.freeze(\n    Object.fromEntries(pickedEntries)\n  ) as IndexedRowExpr<TableDef>;\n}\n","import type { ConnectionId } from './connection_id';\nimport type { Identity } from './identity';\nimport type { ScheduleAt } from './schedule_at';\nimport type { TimeDuration } from './time_duration';\nimport type { Timestamp } from './timestamp';\n\ntype DoNotPrettify =\n  | Identity\n  | ConnectionId\n  | Timestamp\n  | TimeDuration\n  | ScheduleAt;\n\n/**\n * Utility to make TS show cleaner types by flattening intersections.\n */\nexport type Prettify<T> = T extends DoNotPrettify\n  ? T\n  : { [K in keyof T]: T[K] } & {};\n\n/**\n * Helper function to sets a field in an object\n */\nexport type SetField<T, F extends string, V> = Prettify<\n  Omit<T, F> & { [K in F]: V }\n>;\n\n/**\n * Sets a field in an object\n * @param x The original object\n * @param t The object containing the field to set\n * @returns A new object with the field set\n */\nexport function set<T, F extends string, V>(\n  x: T,\n  t: { [k in F]: V }\n): SetField<T, F, V> {\n  return { ...x, ...t } as SetField<T, F, V>;\n}\n\n/**\n * Helper to extract the value types from an object type\n */\nexport type Values<T> = T[keyof T];\n\n/**\n * A helper type to collapse a tuple into a single type if it has only one element.\n */\nexport type CollapseTuple<A extends any[]> = A extends [infer T] ? T : A;\n\ntype CamelCaseImpl<S extends string> = S extends `${infer Head}_${infer Tail}`\n  ? `${Head}${Capitalize<CamelCaseImpl<Tail>>}`\n  : S extends `${infer Head}-${infer Tail}`\n    ? `${Head}${Capitalize<CamelCaseImpl<Tail>>}`\n    : S;\n\n/**\n * Convert \"Some_identifier-name\" -> \"someIdentifierName\"\n * - No spaces; allowed separators: \"_\" and \"-\"\n * - Normalizes the *first* character to lowercase (e.g. \"User_Name\" -> \"userName\")\n */\nexport type CamelCase<S extends string> = Uncapitalize<CamelCaseImpl<S>>;\n\n/** Type safe conversion from \"some_identifier-name\" to \"some_identifier_name\"\n * - No spaces; allowed separators: \"_\" and \"-\"\n * - Normalizes the *first* character to lowercase (e.g. \"User_Name\" -> \"user_name\")\n */\nexport type SnakeCase<S extends string> = S extends `${infer Head}${infer Tail}`\n  ? Tail extends Uncapitalize<Tail>\n    ? `${Lowercase<Head>}${SnakeCase<Tail>}`\n    : `${Lowercase<Head>}_${SnakeCase<Tail>}`\n  : Lowercase<S>;\n\ntype PascalCaseImpl<S extends string> = S extends `${infer Head}_${infer Tail}`\n  ? `${Capitalize<Head>}${PascalCaseImpl<Tail>}`\n  : S extends `${infer Head}-${infer Tail}`\n    ? `${Capitalize<Head>}${PascalCaseImpl<Tail>}`\n    : Capitalize<S>;\n\n/**\n * Convert \"some_identifier-name\" -> \"SomeIdentifierName\"\n * - No spaces; allowed separators: \"_\" and \"-\"\n * - Normalizes the *first* character to uppercase (e.g. \"user_name\" -> \"UserName\")\n */\nexport type PascalCase<S extends string> = PascalCaseImpl<S>;\n\n/**\n * Check if a metadata type has fields that are incompatible with default values.\n * Default values cannot be combined with isPrimaryKey, isUnique, or isAutoIncrement.\n */\nexport type HasDefaultIncompatibleFields<M> = M extends {\n  isPrimaryKey: true;\n}\n  ? true\n  : M extends { isUnique: true }\n    ? true\n    : M extends { isAutoIncrement: true }\n      ? true\n      : false;\n\n/**\n * Check if a metadata type has a default value set.\n */\nexport type HasDefaultValue<M> = M extends { defaultValue: any } ? true : false;\n\n/**\n * Validate that a column's metadata doesn't have invalid combinations.\n * Returns the metadata type if valid, or an error type if invalid.\n */\nexport type ValidateColumnMetadata<M> =\n  HasDefaultValue<M> extends true\n    ? HasDefaultIncompatibleFields<M> extends true\n      ? InvalidColumnMetadata<'default() cannot be combined with primaryKey(), unique(), or autoInc()'>\n      : M\n    : M;\n\n/**\n * Error type for invalid column metadata combinations.\n * This type is designed to cause a compile-time error with a descriptive message.\n */\nexport type InvalidColumnMetadata<Message extends string> = {\n  __error: Message;\n  __brand: 'InvalidColumnMetadata';\n};\n","import { AlgebraicType, type AlgebraicTypeVariants } from './algebraic_type';\nimport type BinaryReader from './binary_reader';\nimport type BinaryWriter from './binary_writer';\nimport { ConnectionId, type ConnectionIdAlgebraicType } from './connection_id';\nimport { Identity, type IdentityAlgebraicType } from './identity';\nimport { Option, type OptionAlgebraicType } from './option';\nimport { Result, type ResultAlgebraicType } from './result';\nimport ScheduleAt, { type ScheduleAtAlgebraicType } from './schedule_at';\nimport type { CoerceRow } from './table';\nimport { TimeDuration, type TimeDurationAlgebraicType } from './time_duration';\nimport { Timestamp, type TimestampAlgebraicType } from './timestamp';\nimport { set, type Prettify, type SetField } from './type_util';\nimport { Uuid, type UuidAlgebraicType } from './uuid';\n\n// Used in codegen files\nexport { type AlgebraicTypeType } from './algebraic_type';\n\n/**\n * Helper type to extract the TypeScript type from a TypeBuilder\n */\nexport type InferTypeOfTypeBuilder<T extends TypeBuilder<any, any>> =\n  T extends TypeBuilder<infer U, any> ? Prettify<U> : never;\n\n/**\n * Helper type to extract the Spacetime type from a TypeBuilder\n */\nexport type InferSpacetimeTypeOfTypeBuilder<T extends TypeBuilder<any, any>> =\n  T extends TypeBuilder<any, infer U> ? U : never;\n\n/**\n * Helper type to extract the TypeScript type from a TypeBuilder\n */\nexport type Infer<T> = T extends RowObj\n  ? InferTypeOfRow<T>\n  : T extends TypeBuilder<any, any>\n    ? InferTypeOfTypeBuilder<T>\n    : never;\n\n/**\n * Helper type to extract the type of a row from an object.\n */\nexport type InferTypeOfRow<T extends RowObj> = {\n  [K in keyof T & string]: InferTypeOfTypeBuilder<CollapseColumn<T[K]>>;\n};\n\n/**\n * Helper type to extract the type of a row from an object.\n */\nexport type InferSpacetimeTypeOfRow<T extends RowObj> = {\n  [K in keyof T & string]: InferSpacetimeTypeOfTypeBuilder<\n    CollapseColumn<T[K]>\n  >;\n};\n\n/**\n * Helper type to extract the Spacetime type from a row object.\n */\ntype CollapseColumn<\n  T extends TypeBuilder<any, any> | ColumnBuilder<any, any, any>,\n> = T extends ColumnBuilder<any, any, any> ? T['typeBuilder'] : T;\n\n/**\n * A type representing an object which is used to define the type of\n * a row in a table.\n */\nexport type RowObj = Record<\n  string,\n  TypeBuilder<any, any> | ColumnBuilder<any, any, ColumnMetadata<any>>\n>;\n\n/**\n * Type which converts the elements of RowObj to a ProductType elements array\n */\ntype ElementsArrayFromRowObj<Obj extends RowObj> = Array<\n  {\n    [N in keyof Obj & string]: {\n      name: N;\n      algebraicType: InferSpacetimeTypeOfTypeBuilder<CollapseColumn<Obj[N]>>;\n    };\n  }[keyof Obj & string]\n>;\n\n/**\n * A type which converts the elements of RowObj to a TypeScript object type.\n * It works by `Infer`ing the types of the column builders which are the values of\n * the keys in the object passed in.\n *\n * e.g. { a: I32TypeBuilder, b: StringBuilder } -> { a: number, b: string }\n */\ntype RowType<Row extends RowObj> = {\n  [K in keyof Row]: InferTypeOfTypeBuilder<CollapseColumn<Row[K]>>;\n};\n\n/**\n * Type which represents a valid argument to the ProductColumnBuilder\n */\nexport type ElementsObj = Record<string, TypeBuilder<any, any>>;\n\n/**\n * Type which converts the elements of ElementsObj to a ProductType elements array\n */\ntype ElementsArrayFromElementsObj<Obj extends ElementsObj> = Array<\n  {\n    [N in keyof Obj & string]: {\n      name: N;\n      algebraicType: InferSpacetimeTypeOfTypeBuilder<Obj[N]>;\n    };\n  }[keyof Obj & string]\n>;\n\n/**\n * A type which converts the elements of ElementsObj to a TypeScript object type.\n * It works by `Infer`ing the types of the column builders which are the values of\n * the keys in the object passed in.\n *\n * e.g. { a: I32TypeBuilder, b: StringBuilder } -> { a: number, b: string }\n */\ntype ObjectType<Elements extends ElementsObj> = {\n  [K in keyof Elements]: InferTypeOfTypeBuilder<Elements[K]>;\n};\n\nexport type VariantsObj = Record<string, TypeBuilder<any, any>>;\ntype SimpleVariantsObj = Record<string, UnitBuilder>;\n\ntype IsUnit<B> = B extends UnitBuilder ? true : false;\n\n/**\n * A type which converts the elements of ElementsObj to a TypeScript object type.\n * It works by `Infer`ing the types of the column builders which are the values of\n * the keys in the object passed in.\n *\n * e.g. { A: I32TypeBuilder, B: StringBuilder } -> { tag: \"A\", value: number } | { tag: \"B\", value: string }\n */\ntype EnumType<Variants extends VariantsObj> = {\n  [K in keyof Variants & string]: IsUnit<Variants[K]> extends true\n    ? { tag: K }\n    : { tag: K; value: InferTypeOfTypeBuilder<Variants[K]> };\n}[keyof Variants & string];\n\n/**\n * Type which converts the elements of VariantsObj to a SumType variants array\n */\ntype VariantsArrayFromVariantsObj<Obj extends VariantsObj> = {\n  name: keyof Obj & string;\n  algebraicType: InferSpacetimeTypeOfTypeBuilder<Obj[keyof Obj & string]>;\n}[];\n\n/**\n * A generic type builder that captures both the TypeScript type\n * and the corresponding `AlgebraicType`.\n */\nexport class TypeBuilder<Type, SpacetimeType extends AlgebraicType>\n  implements Optional<Type, SpacetimeType>\n{\n  /**\n   * The TypeScript phantom type. This is not stored at runtime,\n   * but is visible to the compiler\n   */\n  readonly type!: Type;\n\n  /**\n   * The SpacetimeDB algebraic type (runtime value). In addition to storing\n   * the runtime representation of the `AlgebraicType`, it also captures\n   * the TypeScript type information of the `AlgebraicType`. That is to say\n   * the value is not merely an `AlgebraicType`, but is constructed to be\n   * the corresponding concrete `AlgebraicType` for the TypeScript type `Type`.\n   *\n   * e.g. `string` corresponds to `AlgebraicType.String`\n   */\n  readonly algebraicType: SpacetimeType;\n\n  constructor(algebraicType: SpacetimeType) {\n    this.algebraicType = algebraicType;\n  }\n\n  optional(): OptionBuilder<typeof this> {\n    return new OptionBuilder(this);\n  }\n\n  serialize(writer: BinaryWriter, value: Type): void {\n    const serialize = (this.serialize = AlgebraicType.makeSerializer(\n      this.algebraicType\n    ));\n    serialize(writer, value);\n  }\n\n  deserialize(reader: BinaryReader): Type {\n    const deserialize = (this.deserialize = AlgebraicType.makeDeserializer(\n      this.algebraicType\n    ));\n    return deserialize(reader);\n  }\n}\n\n/**\n * Interface for types that can be converted into a column builder with primary key metadata.\n *\n * Implementing this interface allows a type to be marked as the primary key of a table column\n * in a type-safe manner. The `primaryKey()` method returns a new `ColumnBuilder` instance\n * with the metadata updated to indicate that the column is a primary key.\n *\n * @typeParam Type - The TypeScript type of the column's value.\n * @typeParam SpacetimeType - The corresponding SpacetimeDB algebraic type.\n * @typeParam M - The metadata type for the column, defaulting to `DefaultMetadata`.\n *\n * @remarks\n * - This interface is typically implemented by type builders for primitive and complex types.\n * - The returned `ColumnBuilder` will have its metadata extended with `{ isPrimaryKey: true }`.\n * - **Cannot be combined with `default()`.**\n */\ninterface PrimaryKeyable<\n  Type,\n  SpacetimeType extends AlgebraicType,\n  M extends ColumnMetadata<Type> = DefaultMetadata,\n> {\n  /**\n   * Specify this column as primary key\n   * @remarks Cannot be combined with `default()`.\n   */\n  primaryKey(): ColumnBuilder<\n    Type,\n    SpacetimeType,\n    SetField<M, 'isPrimaryKey', true>\n  >;\n}\n\n/**\n * Interface for types that can be converted into a column builder with unique metadata.\n *\n * Implementing this interface allows a type to be marked as unique in a table column\n * in a type-safe manner. The `unique()` method returns a new `ColumnBuilder` instance\n * with the metadata updated to indicate that the column is unique.\n *\n * @typeParam Type - The TypeScript type of the column's value.\n * @typeParam SpacetimeType - The corresponding SpacetimeDB algebraic type.\n * @typeParam M - The metadata type for the column, defaulting to `DefaultMetadata`.\n *\n * @remarks\n * - This interface is typically implemented by type builders for primitive and complex types.\n * - The returned `ColumnBuilder` will have its metadata extended with `{ isUnique: true }`.\n * - **Cannot be combined with `default()`.**\n */\ninterface Uniqueable<\n  Type,\n  SpacetimeType extends AlgebraicType,\n  M extends ColumnMetadata<Type> = DefaultMetadata,\n> {\n  /**\n   * Specify this column as unique\n   * @remarks Cannot be combined with `default()`.\n   */\n  unique(): ColumnBuilder<Type, SpacetimeType, SetField<M, 'isUnique', true>>;\n}\n\n/**\n * Interface for types that can be converted into a column builder with index metadata.\n *\n * Implementing this interface allows a type to be indexed in a table column\n * in a type-safe manner. The `index()` method returns a new `ColumnBuilder` instance\n * with the metadata updated to indicate the index type.\n *\n * @typeParam Type - The TypeScript type of the column's value.\n * @typeParam SpacetimeType - The corresponding SpacetimeDB algebraic type.\n * @typeParam M - The metadata type for the column, defaulting to `DefaultMetadata`.\n *\n * @remarks\n * - This interface is typically implemented by type builders for primitive and complex types.\n * - The returned `ColumnBuilder` will have its metadata extended with `{ indexType: N }`.\n * - Indexing a column may have implications for performance and query optimization.\n */\ninterface Indexable<\n  Type,\n  SpacetimeType extends AlgebraicType,\n  M extends ColumnMetadata<Type> = DefaultMetadata,\n> {\n  /**\n   * Specify the index type for this column\n   * @param algorithm The index algorithm to use\n   */\n  index(): ColumnBuilder<\n    Type,\n    SpacetimeType,\n    SetField<M, 'indexType', 'btree'>\n  >;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): ColumnBuilder<Type, SpacetimeType, SetField<M, 'indexType', N>>;\n}\n\n/**\n * Interface for types that can be converted into a column builder with auto-increment metadata.\n *\n * Implementing this interface allows a type to be marked as auto-incrementing in a table column\n * in a type-safe manner. The `autoInc()` method returns a new `ColumnBuilder` instance\n * with the metadata updated to indicate that the column is auto-incrementing.\n *\n * @typeParam Type - The TypeScript type of the column's value.\n * @typeParam SpacetimeType - The corresponding SpacetimeDB algebraic type.\n * @typeParam M - The metadata type for the column, defaulting to `DefaultMetadata`.\n *\n * @remarks\n * - This interface is typically implemented by type builders for primitive and complex types.\n * - The returned `ColumnBuilder` will have its metadata extended with `{ isAutoIncrement: true }`.\n * - **Cannot be combined with `default()`.**\n */\ninterface AutoIncrementable<\n  Type,\n  SpacetimeType extends AlgebraicType,\n  M extends ColumnMetadata<Type> = DefaultMetadata,\n> {\n  /**\n   * Specify this column as auto-incrementing\n   * @remarks Cannot be combined with `default()`.\n   */\n  autoInc(): ColumnBuilder<\n    Type,\n    SpacetimeType,\n    SetField<M, 'isAutoIncrement', true>\n  >;\n}\n\n/**\n * Interface for types that can be converted into an optional type.\n * All {@link TypeBuilder}s implement this interface, however since the `optional()` method\n * returns an {@link OptionBuilder}, {@link OptionBuilder} controls what metadata is allowed\n * to be configured for the column. This allows us to restrict whether things like indexes\n * or unique constraints can be applied to optional columns.\n *\n * For this reason {@link ColumnBuilder} does not implement this interface.\n */\ninterface Optional<Type, SpacetimeType extends AlgebraicType> {\n  /**\n   * Specify this column as optional\n   */\n  optional(this: TypeBuilder<Type, SpacetimeType>): OptionBuilder<typeof this>;\n}\n\n/**\n * Interface for types that can be converted into a column builder with default value metadata.\n * Implementing this interface allows a type to have a default value specified in a table column\n * in a type-safe manner. The `default()` method returns a new `ColumnBuilder` instance\n * with the metadata updated to include the specified default value.\n *\n * @typeParam Type - The TypeScript type of the column's value.\n * @typeParam SpacetimeType - The corresponding SpacetimeDB algebraic type.\n * @typeParam M - The metadata type for the column, defaulting to `DefaultMetadata`.\n *\n * @remarks\n * - This interface is typically implemented by type builders for primitive and complex types.\n * - The returned `ColumnBuilder` will have its metadata extended with `{ default: value }`.\n * - The default value must be of the same type as the column's TypeScript type.\n * - This method can be called multiple times; the last call takes precedence.\n * - **Cannot be combined with `primaryKey()`, `unique()`, or `autoInc()`.**\n */\ninterface Defaultable<\n  Type,\n  SpacetimeType extends AlgebraicType,\n  M extends ColumnMetadata<Type> = DefaultMetadata,\n> {\n  /**\n   * Specify a default value for this column\n   * @param value The default value for the column\n   * @example\n   * ```typescript\n   * const col = t.i32().default(42);\n   * ```\n   * @remarks\n   * - This method can be called multiple times; the last call takes precedence.\n   * - The default value must be of the same type as the column's TypeScript type.\n   * - Cannot be combined with `primaryKey()`, `unique()`, or `autoInc()`.\n   */\n  default(\n    value: Type\n  ): ColumnBuilder<Type, SpacetimeType, SetField<M, 'defaultValue', Type>>;\n}\n\ninterface Nameable<\n  Type,\n  SpacetimeType extends AlgebraicType,\n  M extends ColumnMetadata<Type> = DefaultMetadata,\n> {\n  /**\n   * Specify the in-database name for this column.\n   */\n  name<const Name extends string>(\n    name: Name\n  ): Nameable<Type, SpacetimeType, SetField<M, 'name', Name>>;\n}\n\nexport class U8Builder\n  extends TypeBuilder<number, AlgebraicTypeVariants.U8>\n  implements\n    Indexable<number, AlgebraicTypeVariants.U8>,\n    Uniqueable<number, AlgebraicTypeVariants.U8>,\n    PrimaryKeyable<number, AlgebraicTypeVariants.U8>,\n    AutoIncrementable<number, AlgebraicTypeVariants.U8>,\n    Defaultable<number, AlgebraicTypeVariants.U8>,\n    Nameable<number, AlgebraicTypeVariants.U8>\n{\n  constructor() {\n    super(AlgebraicType.U8);\n  }\n  index(): U8ColumnBuilder<SetField<DefaultMetadata, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): U8ColumnBuilder<SetField<DefaultMetadata, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): U8ColumnBuilder<SetField<DefaultMetadata, 'indexType', IndexTypes>> {\n    return new U8ColumnBuilder(\n      this,\n      set(defaultMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): U8ColumnBuilder<SetField<DefaultMetadata, 'isUnique', true>> {\n    return new U8ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));\n  }\n  primaryKey(): U8ColumnBuilder<\n    SetField<DefaultMetadata, 'isPrimaryKey', true>\n  > {\n    return new U8ColumnBuilder(\n      this,\n      set(defaultMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): U8ColumnBuilder<\n    SetField<DefaultMetadata, 'isAutoIncrement', true>\n  > {\n    return new U8ColumnBuilder(\n      this,\n      set(defaultMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: number\n  ): U8ColumnBuilder<SetField<DefaultMetadata, 'defaultValue', number>> {\n    return new U8ColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): U8ColumnBuilder<SetField<DefaultMetadata, 'name', Name>> {\n    return new U8ColumnBuilder(this, set(defaultMetadata, { name }));\n  }\n}\n\nexport class U16Builder\n  extends TypeBuilder<number, AlgebraicTypeVariants.U16>\n  implements\n    Indexable<number, AlgebraicTypeVariants.U16>,\n    Uniqueable<number, AlgebraicTypeVariants.U16>,\n    PrimaryKeyable<number, AlgebraicTypeVariants.U16>,\n    AutoIncrementable<number, AlgebraicTypeVariants.U16>,\n    Defaultable<number, AlgebraicTypeVariants.U16>,\n    Nameable<number, AlgebraicTypeVariants.U16>\n{\n  constructor() {\n    super(AlgebraicType.U16);\n  }\n  index(): U16ColumnBuilder<SetField<DefaultMetadata, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): U16ColumnBuilder<SetField<DefaultMetadata, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): U16ColumnBuilder<SetField<DefaultMetadata, 'indexType', IndexTypes>> {\n    return new U16ColumnBuilder(\n      this,\n      set(defaultMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): U16ColumnBuilder<SetField<DefaultMetadata, 'isUnique', true>> {\n    return new U16ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));\n  }\n  primaryKey(): U16ColumnBuilder<\n    SetField<DefaultMetadata, 'isPrimaryKey', true>\n  > {\n    return new U16ColumnBuilder(\n      this,\n      set(defaultMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): U16ColumnBuilder<\n    SetField<DefaultMetadata, 'isAutoIncrement', true>\n  > {\n    return new U16ColumnBuilder(\n      this,\n      set(defaultMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: number\n  ): U16ColumnBuilder<SetField<DefaultMetadata, 'defaultValue', number>> {\n    return new U16ColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): U16ColumnBuilder<SetField<DefaultMetadata, 'name', Name>> {\n    return new U16ColumnBuilder(this, set(defaultMetadata, { name }));\n  }\n}\n\nexport class U32Builder\n  extends TypeBuilder<number, AlgebraicTypeVariants.U32>\n  implements\n    Indexable<number, AlgebraicTypeVariants.U32>,\n    Uniqueable<number, AlgebraicTypeVariants.U32>,\n    PrimaryKeyable<number, AlgebraicTypeVariants.U32>,\n    AutoIncrementable<number, AlgebraicTypeVariants.U32>,\n    Defaultable<number, AlgebraicTypeVariants.U32>,\n    Nameable<number, AlgebraicTypeVariants.U32>\n{\n  constructor() {\n    super(AlgebraicType.U32);\n  }\n  index(): U32ColumnBuilder<SetField<DefaultMetadata, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): U32ColumnBuilder<SetField<DefaultMetadata, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): U32ColumnBuilder<SetField<DefaultMetadata, 'indexType', IndexTypes>> {\n    return new U32ColumnBuilder(\n      this,\n      set(defaultMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): U32ColumnBuilder<SetField<DefaultMetadata, 'isUnique', true>> {\n    return new U32ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));\n  }\n  primaryKey(): U32ColumnBuilder<\n    SetField<DefaultMetadata, 'isPrimaryKey', true>\n  > {\n    return new U32ColumnBuilder(\n      this,\n      set(defaultMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): U32ColumnBuilder<\n    SetField<DefaultMetadata, 'isAutoIncrement', true>\n  > {\n    return new U32ColumnBuilder(\n      this,\n      set(defaultMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: number\n  ): U32ColumnBuilder<SetField<DefaultMetadata, 'defaultValue', number>> {\n    return new U32ColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): U32ColumnBuilder<SetField<DefaultMetadata, 'name', Name>> {\n    return new U32ColumnBuilder(this, set(defaultMetadata, { name }));\n  }\n}\n\nexport class U64Builder\n  extends TypeBuilder<bigint, AlgebraicTypeVariants.U64>\n  implements\n    Indexable<bigint, AlgebraicTypeVariants.U64>,\n    Uniqueable<bigint, AlgebraicTypeVariants.U64>,\n    PrimaryKeyable<bigint, AlgebraicTypeVariants.U64>,\n    AutoIncrementable<bigint, AlgebraicTypeVariants.U64>,\n    Defaultable<bigint, AlgebraicTypeVariants.U64>,\n    Nameable<bigint, AlgebraicTypeVariants.U64>\n{\n  constructor() {\n    super(AlgebraicType.U64);\n  }\n  index(): U64ColumnBuilder<SetField<DefaultMetadata, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): U64ColumnBuilder<SetField<DefaultMetadata, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): U64ColumnBuilder<SetField<DefaultMetadata, 'indexType', IndexTypes>> {\n    return new U64ColumnBuilder(\n      this,\n      set(defaultMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): U64ColumnBuilder<SetField<DefaultMetadata, 'isUnique', true>> {\n    return new U64ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));\n  }\n  primaryKey(): U64ColumnBuilder<\n    SetField<DefaultMetadata, 'isPrimaryKey', true>\n  > {\n    return new U64ColumnBuilder(\n      this,\n      set(defaultMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): U64ColumnBuilder<\n    SetField<DefaultMetadata, 'isAutoIncrement', true>\n  > {\n    return new U64ColumnBuilder(\n      this,\n      set(defaultMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: bigint\n  ): U64ColumnBuilder<SetField<DefaultMetadata, 'defaultValue', bigint>> {\n    return new U64ColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): U64ColumnBuilder<SetField<DefaultMetadata, 'name', Name>> {\n    return new U64ColumnBuilder(this, set(defaultMetadata, { name }));\n  }\n}\n\nexport class U128Builder\n  extends TypeBuilder<bigint, AlgebraicTypeVariants.U128>\n  implements\n    Indexable<bigint, AlgebraicTypeVariants.U128>,\n    Uniqueable<bigint, AlgebraicTypeVariants.U128>,\n    PrimaryKeyable<bigint, AlgebraicTypeVariants.U128>,\n    AutoIncrementable<bigint, AlgebraicTypeVariants.U128>,\n    Defaultable<bigint, AlgebraicTypeVariants.U128>,\n    Nameable<bigint, AlgebraicTypeVariants.U128>\n{\n  constructor() {\n    super(AlgebraicType.U128);\n  }\n  index(): U128ColumnBuilder<SetField<DefaultMetadata, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): U128ColumnBuilder<SetField<DefaultMetadata, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): U128ColumnBuilder<SetField<DefaultMetadata, 'indexType', IndexTypes>> {\n    return new U128ColumnBuilder(\n      this,\n      set(defaultMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): U128ColumnBuilder<SetField<DefaultMetadata, 'isUnique', true>> {\n    return new U128ColumnBuilder(\n      this,\n      set(defaultMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): U128ColumnBuilder<\n    SetField<DefaultMetadata, 'isPrimaryKey', true>\n  > {\n    return new U128ColumnBuilder(\n      this,\n      set(defaultMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): U128ColumnBuilder<\n    SetField<DefaultMetadata, 'isAutoIncrement', true>\n  > {\n    return new U128ColumnBuilder(\n      this,\n      set(defaultMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: bigint\n  ): U128ColumnBuilder<SetField<DefaultMetadata, 'defaultValue', bigint>> {\n    return new U128ColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): U128ColumnBuilder<SetField<DefaultMetadata, 'name', Name>> {\n    return new U128ColumnBuilder(this, set(defaultMetadata, { name }));\n  }\n}\n\nexport class U256Builder\n  extends TypeBuilder<bigint, AlgebraicTypeVariants.U256>\n  implements\n    Indexable<bigint, AlgebraicTypeVariants.U256>,\n    Uniqueable<bigint, AlgebraicTypeVariants.U256>,\n    PrimaryKeyable<bigint, AlgebraicTypeVariants.U256>,\n    AutoIncrementable<bigint, AlgebraicTypeVariants.U256>,\n    Defaultable<bigint, AlgebraicTypeVariants.U256>,\n    Nameable<bigint, AlgebraicTypeVariants.U256>\n{\n  constructor() {\n    super(AlgebraicType.U256);\n  }\n  index(): U256ColumnBuilder<SetField<DefaultMetadata, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): U256ColumnBuilder<SetField<DefaultMetadata, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): U256ColumnBuilder<SetField<DefaultMetadata, 'indexType', IndexTypes>> {\n    return new U256ColumnBuilder(\n      this,\n      set(defaultMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): U256ColumnBuilder<SetField<DefaultMetadata, 'isUnique', true>> {\n    return new U256ColumnBuilder(\n      this,\n      set(defaultMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): U256ColumnBuilder<\n    SetField<DefaultMetadata, 'isPrimaryKey', true>\n  > {\n    return new U256ColumnBuilder(\n      this,\n      set(defaultMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): U256ColumnBuilder<\n    SetField<DefaultMetadata, 'isAutoIncrement', true>\n  > {\n    return new U256ColumnBuilder(\n      this,\n      set(defaultMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: bigint\n  ): U256ColumnBuilder<SetField<DefaultMetadata, 'defaultValue', bigint>> {\n    return new U256ColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): U256ColumnBuilder<SetField<DefaultMetadata, 'name', Name>> {\n    return new U256ColumnBuilder(this, set(defaultMetadata, { name }));\n  }\n}\n\nexport class I8Builder\n  extends TypeBuilder<number, AlgebraicTypeVariants.I8>\n  implements\n    Indexable<number, AlgebraicTypeVariants.I8>,\n    Uniqueable<number, AlgebraicTypeVariants.I8>,\n    PrimaryKeyable<number, AlgebraicTypeVariants.I8>,\n    AutoIncrementable<number, AlgebraicTypeVariants.I8>,\n    Defaultable<number, AlgebraicTypeVariants.I8>,\n    Nameable<number, AlgebraicTypeVariants.I8>\n{\n  constructor() {\n    super(AlgebraicType.I8);\n  }\n  index(): I8ColumnBuilder<SetField<DefaultMetadata, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): I8ColumnBuilder<SetField<DefaultMetadata, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): I8ColumnBuilder<SetField<DefaultMetadata, 'indexType', IndexTypes>> {\n    return new I8ColumnBuilder(\n      this,\n      set(defaultMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): I8ColumnBuilder<SetField<DefaultMetadata, 'isUnique', true>> {\n    return new I8ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));\n  }\n  primaryKey(): I8ColumnBuilder<\n    SetField<DefaultMetadata, 'isPrimaryKey', true>\n  > {\n    return new I8ColumnBuilder(\n      this,\n      set(defaultMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): I8ColumnBuilder<\n    SetField<DefaultMetadata, 'isAutoIncrement', true>\n  > {\n    return new I8ColumnBuilder(\n      this,\n      set(defaultMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: number\n  ): I8ColumnBuilder<SetField<DefaultMetadata, 'defaultValue', number>> {\n    return new I8ColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): I8ColumnBuilder<SetField<DefaultMetadata, 'name', Name>> {\n    return new I8ColumnBuilder(this, set(defaultMetadata, { name }));\n  }\n}\n\nexport class I16Builder\n  extends TypeBuilder<number, AlgebraicTypeVariants.I16>\n  implements\n    Indexable<number, AlgebraicTypeVariants.I16>,\n    Uniqueable<number, AlgebraicTypeVariants.I16>,\n    PrimaryKeyable<number, AlgebraicTypeVariants.I16>,\n    AutoIncrementable<number, AlgebraicTypeVariants.I16>,\n    Defaultable<number, AlgebraicTypeVariants.I16>,\n    Nameable<number, AlgebraicTypeVariants.I16>\n{\n  constructor() {\n    super(AlgebraicType.I16);\n  }\n  index(): I16ColumnBuilder<SetField<DefaultMetadata, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): I16ColumnBuilder<SetField<DefaultMetadata, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): I16ColumnBuilder<SetField<DefaultMetadata, 'indexType', IndexTypes>> {\n    return new I16ColumnBuilder(\n      this,\n      set(defaultMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): I16ColumnBuilder<SetField<DefaultMetadata, 'isUnique', true>> {\n    return new I16ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));\n  }\n  primaryKey(): I16ColumnBuilder<\n    SetField<DefaultMetadata, 'isPrimaryKey', true>\n  > {\n    return new I16ColumnBuilder(\n      this,\n      set(defaultMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): I16ColumnBuilder<\n    SetField<DefaultMetadata, 'isAutoIncrement', true>\n  > {\n    return new I16ColumnBuilder(\n      this,\n      set(defaultMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: number\n  ): I16ColumnBuilder<SetField<DefaultMetadata, 'defaultValue', number>> {\n    return new I16ColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): I16ColumnBuilder<SetField<DefaultMetadata, 'name', Name>> {\n    return new I16ColumnBuilder(this, set(defaultMetadata, { name }));\n  }\n}\n\nexport class I32Builder\n  extends TypeBuilder<number, AlgebraicTypeVariants.I32>\n  implements\n    TypeBuilder<number, AlgebraicTypeVariants.I32>,\n    Indexable<number, AlgebraicTypeVariants.I32>,\n    Uniqueable<number, AlgebraicTypeVariants.I32>,\n    PrimaryKeyable<number, AlgebraicTypeVariants.I32>,\n    AutoIncrementable<number, AlgebraicTypeVariants.I32>,\n    Defaultable<number, AlgebraicTypeVariants.I32>,\n    Nameable<number, AlgebraicTypeVariants.I32>\n{\n  constructor() {\n    super(AlgebraicType.I32);\n  }\n  index(): I32ColumnBuilder<SetField<DefaultMetadata, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): I32ColumnBuilder<SetField<DefaultMetadata, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): I32ColumnBuilder<SetField<DefaultMetadata, 'indexType', IndexTypes>> {\n    return new I32ColumnBuilder(\n      this,\n      set(defaultMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): I32ColumnBuilder<SetField<DefaultMetadata, 'isUnique', true>> {\n    return new I32ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));\n  }\n  primaryKey(): I32ColumnBuilder<\n    SetField<DefaultMetadata, 'isPrimaryKey', true>\n  > {\n    return new I32ColumnBuilder(\n      this,\n      set(defaultMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): I32ColumnBuilder<\n    SetField<DefaultMetadata, 'isAutoIncrement', true>\n  > {\n    return new I32ColumnBuilder(\n      this,\n      set(defaultMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: number\n  ): I32ColumnBuilder<SetField<DefaultMetadata, 'defaultValue', number>> {\n    return new I32ColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): I32ColumnBuilder<SetField<DefaultMetadata, 'name', Name>> {\n    return new I32ColumnBuilder(this, set(defaultMetadata, { name }));\n  }\n}\n\nexport class I64Builder\n  extends TypeBuilder<bigint, AlgebraicTypeVariants.I64>\n  implements\n    Indexable<bigint, AlgebraicTypeVariants.I64>,\n    Uniqueable<bigint, AlgebraicTypeVariants.I64>,\n    PrimaryKeyable<bigint, AlgebraicTypeVariants.I64>,\n    AutoIncrementable<bigint, AlgebraicTypeVariants.I64>,\n    Defaultable<bigint, AlgebraicTypeVariants.I64>,\n    Nameable<bigint, AlgebraicTypeVariants.I64>\n{\n  constructor() {\n    super(AlgebraicType.I64);\n  }\n  index(): I64ColumnBuilder<SetField<DefaultMetadata, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): I64ColumnBuilder<SetField<DefaultMetadata, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): I64ColumnBuilder<SetField<DefaultMetadata, 'indexType', IndexTypes>> {\n    return new I64ColumnBuilder(\n      this,\n      set(defaultMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): I64ColumnBuilder<SetField<DefaultMetadata, 'isUnique', true>> {\n    return new I64ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));\n  }\n  primaryKey(): I64ColumnBuilder<\n    SetField<DefaultMetadata, 'isPrimaryKey', true>\n  > {\n    return new I64ColumnBuilder(\n      this,\n      set(defaultMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): I64ColumnBuilder<\n    SetField<DefaultMetadata, 'isAutoIncrement', true>\n  > {\n    return new I64ColumnBuilder(\n      this,\n      set(defaultMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: bigint\n  ): I64ColumnBuilder<SetField<DefaultMetadata, 'defaultValue', bigint>> {\n    return new I64ColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): I64ColumnBuilder<SetField<DefaultMetadata, 'name', Name>> {\n    return new I64ColumnBuilder(this, set(defaultMetadata, { name }));\n  }\n}\n\nexport class I128Builder\n  extends TypeBuilder<bigint, AlgebraicTypeVariants.I128>\n  implements\n    Indexable<bigint, AlgebraicTypeVariants.I128>,\n    Uniqueable<bigint, AlgebraicTypeVariants.I128>,\n    PrimaryKeyable<bigint, AlgebraicTypeVariants.I128>,\n    AutoIncrementable<bigint, AlgebraicTypeVariants.I128>,\n    Defaultable<bigint, AlgebraicTypeVariants.I128>,\n    Nameable<bigint, AlgebraicTypeVariants.I128>\n{\n  constructor() {\n    super(AlgebraicType.I128);\n  }\n  index(): I128ColumnBuilder<SetField<DefaultMetadata, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): I128ColumnBuilder<SetField<DefaultMetadata, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): I128ColumnBuilder<SetField<DefaultMetadata, 'indexType', IndexTypes>> {\n    return new I128ColumnBuilder(\n      this,\n      set(defaultMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): I128ColumnBuilder<SetField<DefaultMetadata, 'isUnique', true>> {\n    return new I128ColumnBuilder(\n      this,\n      set(defaultMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): I128ColumnBuilder<\n    SetField<DefaultMetadata, 'isPrimaryKey', true>\n  > {\n    return new I128ColumnBuilder(\n      this,\n      set(defaultMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): I128ColumnBuilder<\n    SetField<DefaultMetadata, 'isAutoIncrement', true>\n  > {\n    return new I128ColumnBuilder(\n      this,\n      set(defaultMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: bigint\n  ): I128ColumnBuilder<SetField<DefaultMetadata, 'defaultValue', bigint>> {\n    return new I128ColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): I128ColumnBuilder<SetField<DefaultMetadata, 'name', Name>> {\n    return new I128ColumnBuilder(this, set(defaultMetadata, { name }));\n  }\n}\n\nexport class I256Builder\n  extends TypeBuilder<bigint, AlgebraicTypeVariants.I256>\n  implements\n    Indexable<bigint, AlgebraicTypeVariants.I256>,\n    Uniqueable<bigint, AlgebraicTypeVariants.I256>,\n    PrimaryKeyable<bigint, AlgebraicTypeVariants.I256>,\n    AutoIncrementable<bigint, AlgebraicTypeVariants.I256>,\n    Defaultable<bigint, AlgebraicTypeVariants.I256>,\n    Nameable<bigint, AlgebraicTypeVariants.I256>\n{\n  constructor() {\n    super(AlgebraicType.I256);\n  }\n  index(): I256ColumnBuilder<SetField<DefaultMetadata, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): I256ColumnBuilder<SetField<DefaultMetadata, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): I256ColumnBuilder<SetField<DefaultMetadata, 'indexType', IndexTypes>> {\n    return new I256ColumnBuilder(\n      this,\n      set(defaultMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): I256ColumnBuilder<SetField<DefaultMetadata, 'isUnique', true>> {\n    return new I256ColumnBuilder(\n      this,\n      set(defaultMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): I256ColumnBuilder<\n    SetField<DefaultMetadata, 'isPrimaryKey', true>\n  > {\n    return new I256ColumnBuilder(\n      this,\n      set(defaultMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): I256ColumnBuilder<\n    SetField<DefaultMetadata, 'isAutoIncrement', true>\n  > {\n    return new I256ColumnBuilder(\n      this,\n      set(defaultMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: bigint\n  ): I256ColumnBuilder<SetField<DefaultMetadata, 'defaultValue', bigint>> {\n    return new I256ColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): I256ColumnBuilder<SetField<DefaultMetadata, 'name', Name>> {\n    return new I256ColumnBuilder(this, set(defaultMetadata, { name }));\n  }\n}\n\nexport class F32Builder\n  extends TypeBuilder<number, AlgebraicTypeVariants.F32>\n  implements\n    Defaultable<number, AlgebraicTypeVariants.F32>,\n    Nameable<number, AlgebraicTypeVariants.F32>\n{\n  constructor() {\n    super(AlgebraicType.F32);\n  }\n  default(\n    value: number\n  ): F32ColumnBuilder<SetField<DefaultMetadata, 'defaultValue', number>> {\n    return new F32ColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): F32ColumnBuilder<SetField<DefaultMetadata, 'name', Name>> {\n    return new F32ColumnBuilder(this, set(defaultMetadata, { name }));\n  }\n}\n\nexport class F64Builder\n  extends TypeBuilder<number, AlgebraicTypeVariants.F64>\n  implements\n    Defaultable<number, AlgebraicTypeVariants.F64>,\n    Nameable<number, AlgebraicTypeVariants.F64>\n{\n  constructor() {\n    super(AlgebraicType.F64);\n  }\n  default(\n    value: number\n  ): F64ColumnBuilder<SetField<DefaultMetadata, 'defaultValue', number>> {\n    return new F64ColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): F64ColumnBuilder<SetField<DefaultMetadata, 'name', Name>> {\n    return new F64ColumnBuilder(this, set(defaultMetadata, { name }));\n  }\n}\n\nexport class BoolBuilder\n  extends TypeBuilder<boolean, AlgebraicTypeVariants.Bool>\n  implements\n    Indexable<boolean, AlgebraicTypeVariants.Bool>,\n    Uniqueable<boolean, AlgebraicTypeVariants.Bool>,\n    PrimaryKeyable<boolean, AlgebraicTypeVariants.Bool>,\n    Defaultable<boolean, AlgebraicTypeVariants.Bool>,\n    Nameable<boolean, AlgebraicTypeVariants.Bool>\n{\n  constructor() {\n    super(AlgebraicType.Bool);\n  }\n  index(): BoolColumnBuilder<SetField<DefaultMetadata, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): BoolColumnBuilder<SetField<DefaultMetadata, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): BoolColumnBuilder<SetField<DefaultMetadata, 'indexType', IndexTypes>> {\n    return new BoolColumnBuilder(\n      this,\n      set(defaultMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): BoolColumnBuilder<SetField<DefaultMetadata, 'isUnique', true>> {\n    return new BoolColumnBuilder(\n      this,\n      set(defaultMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): BoolColumnBuilder<\n    SetField<DefaultMetadata, 'isPrimaryKey', true>\n  > {\n    return new BoolColumnBuilder(\n      this,\n      set(defaultMetadata, { isPrimaryKey: true })\n    );\n  }\n  default(\n    value: boolean\n  ): BoolColumnBuilder<SetField<DefaultMetadata, 'defaultValue', boolean>> {\n    return new BoolColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): BoolColumnBuilder<SetField<DefaultMetadata, 'name', Name>> {\n    return new BoolColumnBuilder(this, set(defaultMetadata, { name }));\n  }\n}\n\nexport class StringBuilder\n  extends TypeBuilder<string, AlgebraicTypeVariants.String>\n  implements\n    Indexable<string, AlgebraicTypeVariants.String>,\n    Uniqueable<string, AlgebraicTypeVariants.String>,\n    PrimaryKeyable<string, AlgebraicTypeVariants.String>,\n    Defaultable<string, AlgebraicTypeVariants.String>,\n    Nameable<string, AlgebraicTypeVariants.String>\n{\n  constructor() {\n    super(AlgebraicType.String);\n  }\n  index(): StringColumnBuilder<SetField<DefaultMetadata, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): StringColumnBuilder<SetField<DefaultMetadata, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): StringColumnBuilder<SetField<DefaultMetadata, 'indexType', IndexTypes>> {\n    return new StringColumnBuilder(\n      this,\n      set(defaultMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): StringColumnBuilder<SetField<DefaultMetadata, 'isUnique', true>> {\n    return new StringColumnBuilder(\n      this,\n      set(defaultMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): StringColumnBuilder<\n    SetField<DefaultMetadata, 'isPrimaryKey', true>\n  > {\n    return new StringColumnBuilder(\n      this,\n      set(defaultMetadata, { isPrimaryKey: true })\n    );\n  }\n  default(\n    value: string\n  ): StringColumnBuilder<SetField<DefaultMetadata, 'defaultValue', string>> {\n    return new StringColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): StringColumnBuilder<SetField<DefaultMetadata, 'name', Name>> {\n    return new StringColumnBuilder(this, set(defaultMetadata, { name }));\n  }\n}\n\nexport class ArrayBuilder<Element extends TypeBuilder<any, any>>\n  extends TypeBuilder<\n    Array<InferTypeOfTypeBuilder<Element>>,\n    { tag: 'Array'; value: InferSpacetimeTypeOfTypeBuilder<Element> }\n  >\n  implements\n    Defaultable<Array<InferTypeOfTypeBuilder<Element>>, any>,\n    Nameable<Array<InferTypeOfTypeBuilder<Element>>, any>\n{\n  element: Element;\n\n  constructor(element: Element) {\n    super(AlgebraicType.Array(element.algebraicType));\n    this.element = element;\n  }\n  default(\n    value: Array<InferTypeOfTypeBuilder<Element>>\n  ): ArrayColumnBuilder<\n    Element,\n    SetField<DefaultMetadata, 'defaultValue', any>\n  > {\n    return new ArrayColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): ArrayColumnBuilder<Element, SetField<DefaultMetadata, 'name', Name>> {\n    return new ArrayColumnBuilder(this, set(defaultMetadata, { name }));\n  }\n}\n\nexport class ByteArrayBuilder\n  extends TypeBuilder<\n    Uint8Array,\n    { tag: 'Array'; value: AlgebraicTypeVariants.U8 }\n  >\n  implements Defaultable<Uint8Array, any>, Nameable<Uint8Array, any>\n{\n  constructor() {\n    super(AlgebraicType.Array(AlgebraicType.U8));\n  }\n  default(\n    value: Uint8Array\n  ): ByteArrayColumnBuilder<SetField<DefaultMetadata, 'defaultValue', any>> {\n    return new ByteArrayColumnBuilder(\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): ByteArrayColumnBuilder<SetField<DefaultMetadata, 'name', Name>> {\n    return new ByteArrayColumnBuilder(set(defaultMetadata, { name }));\n  }\n}\n\nexport class OptionBuilder<Value extends TypeBuilder<any, any>>\n  extends TypeBuilder<\n    InferTypeOfTypeBuilder<Value> | undefined,\n    OptionAlgebraicType<InferSpacetimeTypeOfTypeBuilder<Value>>\n  >\n  implements\n    Defaultable<\n      InferTypeOfTypeBuilder<Value> | undefined,\n      OptionAlgebraicType<InferSpacetimeTypeOfTypeBuilder<Value>>\n    >,\n    Nameable<\n      InferTypeOfTypeBuilder<Value> | undefined,\n      OptionAlgebraicType<InferSpacetimeTypeOfTypeBuilder<Value>>\n    >\n{\n  value: Value;\n\n  constructor(value: Value) {\n    super(Option.getAlgebraicType(value.algebraicType));\n    this.value = value;\n  }\n  default(\n    value: InferTypeOfTypeBuilder<Value> | undefined\n  ): OptionColumnBuilder<\n    Value,\n    SetField<\n      DefaultMetadata,\n      'defaultValue',\n      InferTypeOfTypeBuilder<Value> | undefined\n    >\n  > {\n    return new OptionColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): OptionColumnBuilder<Value, SetField<DefaultMetadata, 'name', Name>> {\n    return new OptionColumnBuilder(this, set(defaultMetadata, { name }));\n  }\n}\n\ntype ElementsToProductType<Elements extends ElementsObj> = {\n  tag: 'Product';\n  value: { elements: ElementsArrayFromElementsObj<Elements> };\n};\n\nexport class ProductBuilder<Elements extends ElementsObj>\n  extends TypeBuilder<ObjectType<Elements>, ElementsToProductType<Elements>>\n  implements\n    Defaultable<ObjectType<Elements>, ElementsToProductType<Elements>>,\n    Nameable<ObjectType<Elements>, ElementsToProductType<Elements>>\n{\n  readonly typeName: string | undefined;\n  readonly elements: Elements;\n  constructor(elements: Elements, name?: string) {\n    function elementsArrayFromElementsObj<Obj extends ElementsObj>(obj: Obj) {\n      return Object.keys(obj).map(key => ({\n        name: key,\n        // Lazily resolve the underlying object's algebraicType.\n        // This will call obj[key].algebraicType only when someone\n        // actually reads this property.\n        get algebraicType() {\n          return obj[key].algebraicType;\n        },\n      }));\n    }\n    super(\n      AlgebraicType.Product({\n        elements: elementsArrayFromElementsObj(elements),\n      })\n    );\n    this.typeName = name;\n    this.elements = elements;\n  }\n  default(\n    value: ObjectType<Elements>\n  ): ProductColumnBuilder<\n    Elements,\n    SetField<DefaultMetadata, 'defaultValue', any>\n  > {\n    return new ProductColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): ProductColumnBuilder<Elements, SetField<DefaultMetadata, 'name', Name>> {\n    return new ProductColumnBuilder(this, set(defaultMetadata, { name }));\n  }\n}\n\nexport class ResultBuilder<\n    Ok extends TypeBuilder<any, any>,\n    Err extends TypeBuilder<any, any>,\n  >\n  extends TypeBuilder<\n    InferTypeOfTypeBuilder<Ok> | InferTypeOfTypeBuilder<Err>,\n    ResultAlgebraicType<\n      InferSpacetimeTypeOfTypeBuilder<Ok>,\n      InferSpacetimeTypeOfTypeBuilder<Err>\n    >\n  >\n  implements\n    Defaultable<\n      InferTypeOfTypeBuilder<Ok> | InferTypeOfTypeBuilder<Err>,\n      ResultAlgebraicType<\n        InferSpacetimeTypeOfTypeBuilder<Ok>,\n        InferSpacetimeTypeOfTypeBuilder<Err>\n      >\n    >\n{\n  ok: Ok;\n  err: Err;\n\n  constructor(ok: Ok, err: Err) {\n    super(Result.getAlgebraicType(ok.algebraicType, err.algebraicType));\n    this.ok = ok;\n    this.err = err;\n  }\n  default(\n    value: InferTypeOfTypeBuilder<Ok> | InferTypeOfTypeBuilder<Err>\n  ): ResultColumnBuilder<\n    Ok,\n    Err,\n    SetField<\n      DefaultMetadata,\n      'defaultValue',\n      InferTypeOfTypeBuilder<Ok> | InferTypeOfTypeBuilder<Err>\n    >\n  > {\n    return new ResultColumnBuilder<\n      Ok,\n      Err,\n      SetField<\n        DefaultMetadata,\n        'defaultValue',\n        InferTypeOfTypeBuilder<Ok> | InferTypeOfTypeBuilder<Err>\n      >\n    >(this, set(defaultMetadata, { defaultValue: value }));\n  }\n}\n\nclass UnitBuilder extends TypeBuilder<\n  {},\n  { tag: 'Product'; value: { elements: [] } }\n> {\n  constructor() {\n    super({ tag: 'Product', value: { elements: [] } });\n  }\n}\n\nexport class RowBuilder<Row extends RowObj> extends TypeBuilder<\n  RowType<CoerceRow<Row>>,\n  {\n    tag: 'Product';\n    value: { elements: ElementsArrayFromRowObj<CoerceRow<Row>> };\n  }\n> {\n  readonly row: CoerceRow<Row>;\n  typeName: string | undefined;\n  constructor(row: Row, name?: string) {\n    const mappedRow = Object.fromEntries(\n      Object.entries(row).map(([colName, builder]) => [\n        colName,\n        builder instanceof ColumnBuilder\n          ? builder\n          : new ColumnBuilder(builder, {}),\n      ])\n    ) as CoerceRow<Row>;\n\n    const elements = Object.keys(mappedRow).map(name => ({\n      name,\n      get algebraicType() {\n        return mappedRow[name].typeBuilder.algebraicType;\n      },\n    }));\n\n    super(AlgebraicType.Product({ elements }));\n    this.row = mappedRow;\n    this.typeName = name;\n  }\n}\n\n// Value type produced for a given variant key + builder\ntype EnumValue<K extends string, B extends TypeBuilder<any, any>> =\n  IsUnit<B> extends true\n    ? { tag: K }\n    : { tag: K; value: InferTypeOfTypeBuilder<B> };\n\ntype VariantConstructor<K extends string, V extends TypeBuilder<any, any>> =\n  IsUnit<V> extends true\n    ? EnumValue<K, V>\n    : (value: InferTypeOfTypeBuilder<V>) => EnumValue<K, V>;\n\ntype SumBuilderVariantConstructors<Variants extends VariantsObj> = {\n  [K in keyof Variants & string]: VariantConstructor<K, Variants[K]>;\n};\n\nexport type SumBuilder<Variants extends VariantsObj> =\n  SumBuilderImpl<Variants> & SumBuilderVariantConstructors<Variants>;\n\ntype VariantsToSumType<Variants extends VariantsObj> = {\n  tag: 'Sum';\n  value: { variants: VariantsArrayFromVariantsObj<Variants> };\n};\n\nclass SumBuilderImpl<Variants extends VariantsObj>\n  extends TypeBuilder<EnumType<Variants>, VariantsToSumType<Variants>>\n  implements\n    Defaultable<EnumType<Variants>, VariantsToSumType<Variants>>,\n    Nameable<EnumType<Variants>, VariantsToSumType<Variants>>\n{\n  readonly variants: Variants;\n  readonly typeName: string | undefined;\n\n  constructor(variants: Variants, name?: string) {\n    function variantsArrayFromVariantsObj<Variants extends VariantsObj>(\n      variants: Variants\n    ) {\n      return (Object.keys(variants) as Array<keyof Variants>).map(key => ({\n        name: key as string,\n        // Lazily resolve the underlying object's algebraicType.\n        // This will call obj[key].algebraicType only when someone\n        // actually reads this property.\n        get algebraicType() {\n          return variants[key].algebraicType;\n        },\n      }));\n    }\n    super(\n      AlgebraicType.Sum({\n        variants: variantsArrayFromVariantsObj(variants),\n      })\n    );\n\n    this.variants = variants;\n    this.typeName = name;\n\n    for (const key of Object.keys(variants) as Array<keyof Variants & string>) {\n      const desc = Object.getOwnPropertyDescriptor(variants, key);\n\n      const isAccessor =\n        !!desc &&\n        (typeof desc.get === 'function' || typeof desc.set === 'function');\n\n      let isUnit = false;\n\n      if (!isAccessor) {\n        // Only read variants[key] if it's a *data* property\n        // otherwise assume non-unit because it's a getter\n        const variant = variants[key];\n        isUnit = variant instanceof UnitBuilder;\n      }\n\n      if (isUnit) {\n        // Unit: expose a read-only VALUE (no call)\n        const constant = this.create(key as any) as EnumValue<\n          typeof key,\n          Variants[typeof key]\n        >;\n        Object.defineProperty(this, key, {\n          value: constant,\n          writable: false,\n          enumerable: true,\n          configurable: false,\n        });\n      } else {\n        const fn = ((value: any) =>\n          this.create(key as any, value)) as VariantConstructor<\n          typeof key & string,\n          Variants[typeof key]\n        >;\n\n        Object.defineProperty(this, key, {\n          value: fn,\n          writable: false,\n          enumerable: true,\n          configurable: false,\n        });\n      }\n    }\n  }\n\n  /**\n   * Create a value of this sum type.\n   * - Unit variants: create('bar')\n   * - Payload variants: create('foo', value)\n   */\n  private create<K extends keyof Variants & string>(\n    tag: K\n  ): EnumValue<K, Variants[K]>;\n  private create<K extends keyof Variants & string>(\n    tag: K,\n    value: InferTypeOfTypeBuilder<Variants[K]>\n  ): EnumValue<K, Variants[K]>;\n  private create(tag: string, value?: unknown) {\n    return value === undefined ? { tag } : { tag, value };\n  }\n\n  default(\n    value: EnumType<Variants>\n  ): SumColumnBuilder<\n    Variants,\n    SetField<DefaultMetadata, 'defaultValue', any>\n  > {\n    return new SumColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): SumColumnBuilder<Variants, SetField<DefaultMetadata, 'name', Name>> {\n    return new SumColumnBuilder(this, set(defaultMetadata, { name }));\n  }\n}\n\nexport const SumBuilder: {\n  new <Variants extends VariantsObj>(\n    variants: Variants,\n    name?: string\n  ): SumBuilder<Variants>;\n  [Symbol.hasInstance](x: any): x is SumBuilder<VariantsObj>;\n} = SumBuilderImpl as any;\n\nclass SimpleSumBuilderImpl<Variants extends SimpleVariantsObj>\n  extends SumBuilderImpl<Variants>\n  implements\n    Indexable<\n      EnumType<Variants>,\n      {\n        tag: 'Sum';\n        value: { variants: VariantsArrayFromVariantsObj<Variants> };\n      }\n    >,\n    PrimaryKeyable<\n      EnumType<Variants>,\n      {\n        tag: 'Sum';\n        value: { variants: VariantsArrayFromVariantsObj<Variants> };\n      }\n    >\n{\n  index(): SimpleSumColumnBuilder<\n    Variants,\n    SetField<DefaultMetadata, 'indexType', 'btree'>\n  >;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): SimpleSumColumnBuilder<\n    Variants,\n    SetField<DefaultMetadata, 'indexType', N>\n  >;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): SimpleSumColumnBuilder<\n    Variants,\n    SetField<DefaultMetadata, 'indexType', IndexTypes>\n  > {\n    return new SimpleSumColumnBuilder(\n      this,\n      set(defaultMetadata, { indexType: algorithm })\n    );\n  }\n  primaryKey(): SimpleSumColumnBuilder<\n    Variants,\n    SetField<DefaultMetadata, 'isPrimaryKey', true>\n  > {\n    return new SimpleSumColumnBuilder(\n      this,\n      set(defaultMetadata, { isPrimaryKey: true })\n    );\n  }\n}\n\nexport const SimpleSumBuilder: {\n  new <Variants extends SimpleVariantsObj>(\n    variants: Variants,\n    name?: string\n  ): SimpleSumBuilderImpl<Variants> & SumBuilderVariantConstructors<Variants>;\n} = SimpleSumBuilderImpl as any;\n\nexport type SimpleSumBuilder<Variants extends SimpleVariantsObj> =\n  SimpleSumBuilderImpl<Variants> & SumBuilderVariantConstructors<Variants>;\n\nexport class ScheduleAtBuilder\n  extends TypeBuilder<ScheduleAt, ScheduleAtAlgebraicType>\n  implements\n    Defaultable<ScheduleAt, ScheduleAtAlgebraicType>,\n    Nameable<ScheduleAt, ScheduleAtAlgebraicType>\n{\n  constructor() {\n    super(ScheduleAt.getAlgebraicType());\n  }\n  default(\n    value: ScheduleAt\n  ): ScheduleAtColumnBuilder<\n    SetField<DefaultMetadata, 'defaultValue', ScheduleAt>\n  > {\n    return new ScheduleAtColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): ScheduleAtColumnBuilder<SetField<DefaultMetadata, 'name', Name>> {\n    return new ScheduleAtColumnBuilder(this, set(defaultMetadata, { name }));\n  }\n}\n\nexport class IdentityBuilder\n  extends TypeBuilder<Identity, IdentityAlgebraicType>\n  implements\n    Indexable<Identity, IdentityAlgebraicType>,\n    Uniqueable<Identity, IdentityAlgebraicType>,\n    PrimaryKeyable<Identity, IdentityAlgebraicType>,\n    Defaultable<Identity, IdentityAlgebraicType>,\n    Nameable<Identity, IdentityAlgebraicType>\n{\n  constructor() {\n    super(Identity.getAlgebraicType());\n  }\n  index(): IdentityColumnBuilder<\n    SetField<DefaultMetadata, 'indexType', 'btree'>\n  >;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): IdentityColumnBuilder<SetField<DefaultMetadata, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): IdentityColumnBuilder<SetField<DefaultMetadata, 'indexType', IndexTypes>> {\n    return new IdentityColumnBuilder(\n      this,\n      set(defaultMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): IdentityColumnBuilder<SetField<DefaultMetadata, 'isUnique', true>> {\n    return new IdentityColumnBuilder(\n      this,\n      set(defaultMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): IdentityColumnBuilder<\n    SetField<DefaultMetadata, 'isPrimaryKey', true>\n  > {\n    return new IdentityColumnBuilder(\n      this,\n      set(defaultMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): IdentityColumnBuilder<\n    SetField<DefaultMetadata, 'isAutoIncrement', true>\n  > {\n    return new IdentityColumnBuilder(\n      this,\n      set(defaultMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: Identity\n  ): IdentityColumnBuilder<\n    SetField<DefaultMetadata, 'defaultValue', Identity>\n  > {\n    return new IdentityColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): IdentityColumnBuilder<SetField<DefaultMetadata, 'name', Name>> {\n    return new IdentityColumnBuilder(this, set(defaultMetadata, { name }));\n  }\n}\n\nexport class ConnectionIdBuilder\n  extends TypeBuilder<ConnectionId, ConnectionIdAlgebraicType>\n  implements\n    Indexable<ConnectionId, ConnectionIdAlgebraicType>,\n    Uniqueable<ConnectionId, ConnectionIdAlgebraicType>,\n    PrimaryKeyable<ConnectionId, ConnectionIdAlgebraicType>,\n    Defaultable<ConnectionId, ConnectionIdAlgebraicType>,\n    Nameable<ConnectionId, ConnectionIdAlgebraicType>\n{\n  constructor() {\n    super(ConnectionId.getAlgebraicType());\n  }\n  index(): ConnectionIdColumnBuilder<\n    SetField<DefaultMetadata, 'indexType', 'btree'>\n  >;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): ConnectionIdColumnBuilder<SetField<DefaultMetadata, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): ConnectionIdColumnBuilder<\n    SetField<DefaultMetadata, 'indexType', IndexTypes>\n  > {\n    return new ConnectionIdColumnBuilder(\n      this,\n      set(defaultMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): ConnectionIdColumnBuilder<\n    SetField<DefaultMetadata, 'isUnique', true>\n  > {\n    return new ConnectionIdColumnBuilder(\n      this,\n      set(defaultMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): ConnectionIdColumnBuilder<\n    SetField<DefaultMetadata, 'isPrimaryKey', true>\n  > {\n    return new ConnectionIdColumnBuilder(\n      this,\n      set(defaultMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): ConnectionIdColumnBuilder<\n    SetField<DefaultMetadata, 'isAutoIncrement', true>\n  > {\n    return new ConnectionIdColumnBuilder(\n      this,\n      set(defaultMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: ConnectionId\n  ): ConnectionIdColumnBuilder<\n    SetField<DefaultMetadata, 'defaultValue', ConnectionId>\n  > {\n    return new ConnectionIdColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): ConnectionIdColumnBuilder<SetField<DefaultMetadata, 'name', Name>> {\n    return new ConnectionIdColumnBuilder(this, set(defaultMetadata, { name }));\n  }\n}\n\nexport class TimestampBuilder\n  extends TypeBuilder<Timestamp, TimestampAlgebraicType>\n  implements\n    Indexable<Timestamp, TimestampAlgebraicType>,\n    Uniqueable<Timestamp, TimestampAlgebraicType>,\n    PrimaryKeyable<Timestamp, TimestampAlgebraicType>,\n    Defaultable<Timestamp, TimestampAlgebraicType>,\n    Nameable<Timestamp, TimestampAlgebraicType>\n{\n  constructor() {\n    super(Timestamp.getAlgebraicType());\n  }\n  index(): TimestampColumnBuilder<\n    SetField<DefaultMetadata, 'indexType', 'btree'>\n  >;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): TimestampColumnBuilder<SetField<DefaultMetadata, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): TimestampColumnBuilder<\n    SetField<DefaultMetadata, 'indexType', IndexTypes>\n  > {\n    return new TimestampColumnBuilder(\n      this,\n      set(defaultMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): TimestampColumnBuilder<\n    SetField<DefaultMetadata, 'isUnique', true>\n  > {\n    return new TimestampColumnBuilder(\n      this,\n      set(defaultMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): TimestampColumnBuilder<\n    SetField<DefaultMetadata, 'isPrimaryKey', true>\n  > {\n    return new TimestampColumnBuilder(\n      this,\n      set(defaultMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): TimestampColumnBuilder<\n    SetField<DefaultMetadata, 'isAutoIncrement', true>\n  > {\n    return new TimestampColumnBuilder(\n      this,\n      set(defaultMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: Timestamp\n  ): TimestampColumnBuilder<\n    SetField<DefaultMetadata, 'defaultValue', Timestamp>\n  > {\n    return new TimestampColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): TimestampColumnBuilder<SetField<DefaultMetadata, 'name', Name>> {\n    return new TimestampColumnBuilder(this, set(defaultMetadata, { name }));\n  }\n}\n\nexport class TimeDurationBuilder\n  extends TypeBuilder<TimeDuration, TimeDurationAlgebraicType>\n  implements\n    Indexable<TimeDuration, TimeDurationAlgebraicType>,\n    Uniqueable<TimeDuration, TimeDurationAlgebraicType>,\n    PrimaryKeyable<TimeDuration, TimeDurationAlgebraicType>,\n    Defaultable<TimeDuration, TimeDurationAlgebraicType>,\n    Nameable<TimeDuration, TimeDurationAlgebraicType>\n{\n  constructor() {\n    super(TimeDuration.getAlgebraicType());\n  }\n  index(): TimeDurationColumnBuilder<\n    SetField<DefaultMetadata, 'indexType', 'btree'>\n  >;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): TimeDurationColumnBuilder<SetField<DefaultMetadata, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): TimeDurationColumnBuilder<\n    SetField<DefaultMetadata, 'indexType', IndexTypes>\n  > {\n    return new TimeDurationColumnBuilder(\n      this,\n      set(defaultMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): TimeDurationColumnBuilder<\n    SetField<DefaultMetadata, 'isUnique', true>\n  > {\n    return new TimeDurationColumnBuilder(\n      this,\n      set(defaultMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): TimeDurationColumnBuilder<\n    SetField<DefaultMetadata, 'isPrimaryKey', true>\n  > {\n    return new TimeDurationColumnBuilder(\n      this,\n      set(defaultMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): TimeDurationColumnBuilder<\n    SetField<DefaultMetadata, 'isAutoIncrement', true>\n  > {\n    return new TimeDurationColumnBuilder(\n      this,\n      set(defaultMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: TimeDuration\n  ): TimeDurationColumnBuilder<\n    SetField<DefaultMetadata, 'defaultValue', TimeDuration>\n  > {\n    return new TimeDurationColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): TimeDurationColumnBuilder<SetField<DefaultMetadata, 'name', Name>> {\n    return new TimeDurationColumnBuilder(this, set(defaultMetadata, { name }));\n  }\n}\n\nexport class UuidBuilder\n  extends TypeBuilder<Uuid, UuidAlgebraicType>\n  implements\n    Indexable<Uuid, UuidAlgebraicType>,\n    Uniqueable<Uuid, UuidAlgebraicType>,\n    PrimaryKeyable<Uuid, UuidAlgebraicType>,\n    Defaultable<Uuid, UuidAlgebraicType>,\n    Nameable<Uuid, UuidAlgebraicType>\n{\n  constructor() {\n    super(Uuid.getAlgebraicType());\n  }\n  index(): UuidColumnBuilder<SetField<DefaultMetadata, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): UuidColumnBuilder<SetField<DefaultMetadata, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): UuidColumnBuilder<SetField<DefaultMetadata, 'indexType', IndexTypes>> {\n    return new UuidColumnBuilder(\n      this,\n      set(defaultMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): UuidColumnBuilder<SetField<DefaultMetadata, 'isUnique', true>> {\n    return new UuidColumnBuilder(\n      this,\n      set(defaultMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): UuidColumnBuilder<\n    SetField<DefaultMetadata, 'isPrimaryKey', true>\n  > {\n    return new UuidColumnBuilder(\n      this,\n      set(defaultMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): UuidColumnBuilder<\n    SetField<DefaultMetadata, 'isAutoIncrement', true>\n  > {\n    return new UuidColumnBuilder(\n      this,\n      set(defaultMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: Uuid\n  ): UuidColumnBuilder<SetField<DefaultMetadata, 'defaultValue', Uuid>> {\n    return new UuidColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): UuidColumnBuilder<SetField<DefaultMetadata, 'name', Name>> {\n    return new UuidColumnBuilder(this, set(defaultMetadata, { name }));\n  }\n}\n\n/**\n * The type of index types that can be applied to a column.\n * `undefined` is the default\n */\nexport type IndexTypes = 'btree' | 'direct' | 'hash' | undefined;\n\n/**\n * Metadata describing column constraints and index type\n */\nexport type ColumnMetadata<Type = any> = {\n  isPrimaryKey?: true;\n  isUnique?: true;\n  isAutoIncrement?: true;\n  indexType?: IndexTypes;\n  defaultValue?: Type;\n  name?: string;\n};\n\n/**\n * Default metadata state type for a newly created column\n */\ntype DefaultMetadata = object;\n\n/**\n * Default metadata state value for a newly created column\n */\nconst defaultMetadata: ColumnMetadata<never> = {};\n\n/**\n * A column builder allows you to incrementally specify constraints\n * and metadata for a column in a type-safe way.\n *\n * It carries both a phantom TypeScript type (the `Type`) and\n * runtime algebraic type information.\n *\n * IMPORTANT! We have deliberately chosen to not have {@link ColumnBuilder}\n * extend {@link TypeBuilder} so that you cannot pass a {@link ColumnBuilder}\n * where a {@link TypeBuilder} is expected. i.e. We want to maintain\n * contravariance for functions that accept {@link TypeBuilder} parameters.\n */\nexport class ColumnBuilder<\n  Type,\n  SpacetimeType extends AlgebraicType,\n  M extends ColumnMetadata<Type> = DefaultMetadata,\n> {\n  typeBuilder: TypeBuilder<Type, SpacetimeType>;\n  columnMetadata: M;\n\n  constructor(typeBuilder: TypeBuilder<Type, SpacetimeType>, metadata: M) {\n    this.typeBuilder = typeBuilder;\n    this.columnMetadata = metadata;\n  }\n\n  serialize(writer: BinaryWriter, value: Type): void {\n    this.typeBuilder.serialize(writer, value);\n  }\n\n  deserialize(reader: BinaryReader): Type {\n    return this.typeBuilder.deserialize(reader);\n  }\n}\n\nexport class U8ColumnBuilder<M extends ColumnMetadata<number> = DefaultMetadata>\n  extends ColumnBuilder<number, AlgebraicTypeVariants.U8, M>\n  implements\n    Indexable<number, AlgebraicTypeVariants.U8>,\n    Uniqueable<number, AlgebraicTypeVariants.U8>,\n    PrimaryKeyable<number, AlgebraicTypeVariants.U8>,\n    AutoIncrementable<number, AlgebraicTypeVariants.U8>,\n    Defaultable<number, AlgebraicTypeVariants.U8>,\n    Nameable<number, AlgebraicTypeVariants.U8>\n{\n  index(): U8ColumnBuilder<SetField<M, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): U8ColumnBuilder<SetField<M, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): U8ColumnBuilder<SetField<M, 'indexType', IndexTypes>> {\n    return new U8ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): U8ColumnBuilder<SetField<M, 'isUnique', true>> {\n    return new U8ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): U8ColumnBuilder<SetField<M, 'isPrimaryKey', true>> {\n    return new U8ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): U8ColumnBuilder<SetField<M, 'isAutoIncrement', true>> {\n    return new U8ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isAutoIncrement: true as const })\n    );\n  }\n  default(value: number): U8ColumnBuilder<SetField<M, 'defaultValue', number>> {\n    return new U8ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, {\n        defaultValue: value,\n      })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): U8ColumnBuilder<SetField<M, 'name', Name>> {\n    return new U8ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\nexport class U16ColumnBuilder<\n    M extends ColumnMetadata<number> = DefaultMetadata,\n  >\n  extends ColumnBuilder<number, AlgebraicTypeVariants.U16, M>\n  implements\n    Indexable<number, AlgebraicTypeVariants.U16>,\n    Uniqueable<number, AlgebraicTypeVariants.U16>,\n    PrimaryKeyable<number, AlgebraicTypeVariants.U16>,\n    AutoIncrementable<number, AlgebraicTypeVariants.U16>,\n    Defaultable<number, AlgebraicTypeVariants.U16>,\n    Nameable<number, AlgebraicTypeVariants.U16>\n{\n  index(): U16ColumnBuilder<SetField<M, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): U16ColumnBuilder<SetField<M, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): U16ColumnBuilder<SetField<M, 'indexType', IndexTypes>> {\n    return new U16ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): U16ColumnBuilder<SetField<M, 'isUnique', true>> {\n    return new U16ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): U16ColumnBuilder<SetField<M, 'isPrimaryKey', true>> {\n    return new U16ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): U16ColumnBuilder<SetField<M, 'isAutoIncrement', true>> {\n    return new U16ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: number\n  ): U16ColumnBuilder<SetField<M, 'defaultValue', number>> {\n    return new U16ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, {\n        defaultValue: value,\n      })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): U16ColumnBuilder<SetField<M, 'name', Name>> {\n    return new U16ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\nexport class U32ColumnBuilder<\n    M extends ColumnMetadata<number> = DefaultMetadata,\n  >\n  extends ColumnBuilder<number, AlgebraicTypeVariants.U32, M>\n  implements\n    Indexable<number, AlgebraicTypeVariants.U32>,\n    Uniqueable<number, AlgebraicTypeVariants.U32>,\n    PrimaryKeyable<number, AlgebraicTypeVariants.U32>,\n    AutoIncrementable<number, AlgebraicTypeVariants.U32>,\n    Defaultable<number, AlgebraicTypeVariants.U32>,\n    Nameable<number, AlgebraicTypeVariants.U32>\n{\n  index(): U32ColumnBuilder<SetField<M, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): U32ColumnBuilder<SetField<M, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): U32ColumnBuilder<SetField<M, 'indexType', IndexTypes>> {\n    return new U32ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): U32ColumnBuilder<SetField<M, 'isUnique', true>> {\n    return new U32ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): U32ColumnBuilder<SetField<M, 'isPrimaryKey', true>> {\n    return new U32ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): U32ColumnBuilder<SetField<M, 'isAutoIncrement', true>> {\n    return new U32ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: number\n  ): U32ColumnBuilder<SetField<M, 'defaultValue', number>> {\n    return new U32ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, {\n        defaultValue: value,\n      })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): U32ColumnBuilder<SetField<M, 'name', Name>> {\n    return new U32ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\nexport class U64ColumnBuilder<\n    M extends ColumnMetadata<bigint> = DefaultMetadata,\n  >\n  extends ColumnBuilder<bigint, AlgebraicTypeVariants.U64, M>\n  implements\n    Indexable<bigint, AlgebraicTypeVariants.U64>,\n    Uniqueable<bigint, AlgebraicTypeVariants.U64>,\n    PrimaryKeyable<bigint, AlgebraicTypeVariants.U64>,\n    AutoIncrementable<bigint, AlgebraicTypeVariants.U64>,\n    Defaultable<bigint, AlgebraicTypeVariants.U64>,\n    Nameable<bigint, AlgebraicTypeVariants.U64>\n{\n  index(): U64ColumnBuilder<SetField<M, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): U64ColumnBuilder<SetField<M, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): U64ColumnBuilder<SetField<M, 'indexType', IndexTypes>> {\n    return new U64ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): U64ColumnBuilder<SetField<M, 'isUnique', true>> {\n    return new U64ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): U64ColumnBuilder<SetField<M, 'isPrimaryKey', true>> {\n    return new U64ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): U64ColumnBuilder<SetField<M, 'isAutoIncrement', true>> {\n    return new U64ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: bigint\n  ): U64ColumnBuilder<SetField<M, 'defaultValue', bigint>> {\n    return new U64ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, {\n        defaultValue: value,\n      })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): U64ColumnBuilder<SetField<M, 'name', Name>> {\n    return new U64ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\nexport class U128ColumnBuilder<\n    M extends ColumnMetadata<bigint> = DefaultMetadata,\n  >\n  extends ColumnBuilder<bigint, AlgebraicTypeVariants.U128, M>\n  implements\n    Indexable<bigint, AlgebraicTypeVariants.U128>,\n    Uniqueable<bigint, AlgebraicTypeVariants.U128>,\n    PrimaryKeyable<bigint, AlgebraicTypeVariants.U128>,\n    AutoIncrementable<bigint, AlgebraicTypeVariants.U128>,\n    Defaultable<bigint, AlgebraicTypeVariants.U128>,\n    Nameable<bigint, AlgebraicTypeVariants.U128>\n{\n  index(): U128ColumnBuilder<SetField<M, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): U128ColumnBuilder<SetField<M, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): U128ColumnBuilder<SetField<M, 'indexType', IndexTypes>> {\n    return new U128ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): U128ColumnBuilder<SetField<M, 'isUnique', true>> {\n    return new U128ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): U128ColumnBuilder<SetField<M, 'isPrimaryKey', true>> {\n    return new U128ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): U128ColumnBuilder<SetField<M, 'isAutoIncrement', true>> {\n    return new U128ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: bigint\n  ): U128ColumnBuilder<SetField<M, 'defaultValue', bigint>> {\n    return new U128ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, {\n        defaultValue: value,\n      })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): U128ColumnBuilder<SetField<M, 'name', Name>> {\n    return new U128ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\nexport class U256ColumnBuilder<\n    M extends ColumnMetadata<bigint> = DefaultMetadata,\n  >\n  extends ColumnBuilder<bigint, AlgebraicTypeVariants.U256, M>\n  implements\n    Indexable<bigint, AlgebraicTypeVariants.U256>,\n    Uniqueable<bigint, AlgebraicTypeVariants.U256>,\n    PrimaryKeyable<bigint, AlgebraicTypeVariants.U256>,\n    AutoIncrementable<bigint, AlgebraicTypeVariants.U256>,\n    Defaultable<bigint, AlgebraicTypeVariants.U256>,\n    Nameable<bigint, AlgebraicTypeVariants.U256>\n{\n  index(): U256ColumnBuilder<SetField<M, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): U256ColumnBuilder<SetField<M, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): U256ColumnBuilder<SetField<M, 'indexType', IndexTypes>> {\n    return new U256ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): U256ColumnBuilder<SetField<M, 'isUnique', true>> {\n    return new U256ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): U256ColumnBuilder<SetField<M, 'isPrimaryKey', true>> {\n    return new U256ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): U256ColumnBuilder<SetField<M, 'isAutoIncrement', true>> {\n    return new U256ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: bigint\n  ): U256ColumnBuilder<SetField<M, 'defaultValue', bigint>> {\n    return new U256ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, {\n        defaultValue: value,\n      })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): U256ColumnBuilder<SetField<M, 'name', Name>> {\n    return new U256ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\nexport class I8ColumnBuilder<M extends ColumnMetadata<number> = DefaultMetadata>\n  extends ColumnBuilder<number, AlgebraicTypeVariants.I8, M>\n  implements\n    Indexable<number, AlgebraicTypeVariants.I8>,\n    Uniqueable<number, AlgebraicTypeVariants.I8>,\n    PrimaryKeyable<number, AlgebraicTypeVariants.I8>,\n    AutoIncrementable<number, AlgebraicTypeVariants.I8>,\n    Defaultable<number, AlgebraicTypeVariants.I8>,\n    Nameable<number, AlgebraicTypeVariants.I8>\n{\n  index(): I8ColumnBuilder<SetField<M, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): I8ColumnBuilder<SetField<M, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): I8ColumnBuilder<SetField<M, 'indexType', IndexTypes>> {\n    return new I8ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): I8ColumnBuilder<SetField<M, 'isUnique', true>> {\n    return new I8ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): I8ColumnBuilder<SetField<M, 'isPrimaryKey', true>> {\n    return new I8ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): I8ColumnBuilder<SetField<M, 'isAutoIncrement', true>> {\n    return new I8ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(value: number): I8ColumnBuilder<SetField<M, 'defaultValue', number>> {\n    return new I8ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, {\n        defaultValue: value,\n      })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): I8ColumnBuilder<SetField<M, 'name', Name>> {\n    return new I8ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\nexport class I16ColumnBuilder<\n    M extends ColumnMetadata<number> = DefaultMetadata,\n  >\n  extends ColumnBuilder<number, AlgebraicTypeVariants.I16, M>\n  implements\n    Indexable<number, AlgebraicTypeVariants.I16>,\n    Uniqueable<number, AlgebraicTypeVariants.I16>,\n    PrimaryKeyable<number, AlgebraicTypeVariants.I16>,\n    AutoIncrementable<number, AlgebraicTypeVariants.I16>,\n    Defaultable<number, AlgebraicTypeVariants.I16>,\n    Nameable<number, AlgebraicTypeVariants.I16>\n{\n  index(): I16ColumnBuilder<SetField<M, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): I16ColumnBuilder<SetField<M, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): I16ColumnBuilder<SetField<M, 'indexType', IndexTypes>> {\n    return new I16ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): I16ColumnBuilder<SetField<M, 'isUnique', true>> {\n    return new I16ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): I16ColumnBuilder<SetField<M, 'isPrimaryKey', true>> {\n    return new I16ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): I16ColumnBuilder<SetField<M, 'isAutoIncrement', true>> {\n    return new I16ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: number\n  ): I16ColumnBuilder<SetField<M, 'defaultValue', number>> {\n    return new I16ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, {\n        defaultValue: value,\n      })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): I16ColumnBuilder<SetField<M, 'name', Name>> {\n    return new I16ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\nexport class I32ColumnBuilder<\n    M extends ColumnMetadata<number> = DefaultMetadata,\n  >\n  extends ColumnBuilder<number, AlgebraicTypeVariants.I32, M>\n  implements\n    Indexable<number, AlgebraicTypeVariants.I32>,\n    Uniqueable<number, AlgebraicTypeVariants.I32>,\n    PrimaryKeyable<number, AlgebraicTypeVariants.I32>,\n    AutoIncrementable<number, AlgebraicTypeVariants.I32>,\n    Defaultable<number, AlgebraicTypeVariants.I32>,\n    Nameable<number, AlgebraicTypeVariants.I32>\n{\n  index(): I32ColumnBuilder<SetField<M, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): I32ColumnBuilder<SetField<M, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): I32ColumnBuilder<SetField<M, 'indexType', IndexTypes>> {\n    return new I32ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): I32ColumnBuilder<SetField<M, 'isUnique', true>> {\n    return new I32ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): I32ColumnBuilder<SetField<M, 'isPrimaryKey', true>> {\n    return new I32ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): I32ColumnBuilder<SetField<M, 'isAutoIncrement', true>> {\n    return new I32ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: number\n  ): I32ColumnBuilder<SetField<M, 'defaultValue', number>> {\n    return new I32ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, {\n        defaultValue: value,\n      })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): I32ColumnBuilder<SetField<M, 'name', Name>> {\n    return new I32ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\nexport class I64ColumnBuilder<\n    M extends ColumnMetadata<bigint> = DefaultMetadata,\n  >\n  extends ColumnBuilder<bigint, AlgebraicTypeVariants.I64, M>\n  implements\n    Indexable<bigint, AlgebraicTypeVariants.I64>,\n    Uniqueable<bigint, AlgebraicTypeVariants.I64>,\n    PrimaryKeyable<bigint, AlgebraicTypeVariants.I64>,\n    AutoIncrementable<bigint, AlgebraicTypeVariants.I64>,\n    Defaultable<bigint, AlgebraicTypeVariants.I64>,\n    Nameable<bigint, AlgebraicTypeVariants.I64>\n{\n  index(): I64ColumnBuilder<SetField<M, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): I64ColumnBuilder<SetField<M, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): I64ColumnBuilder<SetField<M, 'indexType', IndexTypes>> {\n    return new I64ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): I64ColumnBuilder<SetField<M, 'isUnique', true>> {\n    return new I64ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): I64ColumnBuilder<SetField<M, 'isPrimaryKey', true>> {\n    return new I64ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): I64ColumnBuilder<SetField<M, 'isAutoIncrement', true>> {\n    return new I64ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: bigint\n  ): I64ColumnBuilder<SetField<M, 'defaultValue', bigint>> {\n    return new I64ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, {\n        defaultValue: value,\n      })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): I64ColumnBuilder<SetField<M, 'name', Name>> {\n    return new I64ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\nexport class I128ColumnBuilder<\n    M extends ColumnMetadata<bigint> = DefaultMetadata,\n  >\n  extends ColumnBuilder<bigint, AlgebraicTypeVariants.I128, M>\n  implements\n    Indexable<bigint, AlgebraicTypeVariants.I128>,\n    Uniqueable<bigint, AlgebraicTypeVariants.I128>,\n    PrimaryKeyable<bigint, AlgebraicTypeVariants.I128>,\n    AutoIncrementable<bigint, AlgebraicTypeVariants.I128>,\n    Defaultable<bigint, AlgebraicTypeVariants.I128>,\n    Nameable<bigint, AlgebraicTypeVariants.I128>\n{\n  index(): I128ColumnBuilder<SetField<M, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): I128ColumnBuilder<SetField<M, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): I128ColumnBuilder<SetField<M, 'indexType', IndexTypes>> {\n    return new I128ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): I128ColumnBuilder<SetField<M, 'isUnique', true>> {\n    return new I128ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): I128ColumnBuilder<SetField<M, 'isPrimaryKey', true>> {\n    return new I128ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): I128ColumnBuilder<SetField<M, 'isAutoIncrement', true>> {\n    return new I128ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: bigint\n  ): I128ColumnBuilder<SetField<M, 'defaultValue', bigint>> {\n    return new I128ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, {\n        defaultValue: value,\n      })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): I128ColumnBuilder<SetField<M, 'name', Name>> {\n    return new I128ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\nexport class I256ColumnBuilder<\n    M extends ColumnMetadata<bigint> = DefaultMetadata,\n  >\n  extends ColumnBuilder<bigint, AlgebraicTypeVariants.I256, M>\n  implements\n    Indexable<bigint, AlgebraicTypeVariants.I256>,\n    Uniqueable<bigint, AlgebraicTypeVariants.I256>,\n    PrimaryKeyable<bigint, AlgebraicTypeVariants.I256>,\n    AutoIncrementable<bigint, AlgebraicTypeVariants.I256>,\n    Defaultable<bigint, AlgebraicTypeVariants.I256>,\n    Nameable<bigint, AlgebraicTypeVariants.I256>\n{\n  index(): I256ColumnBuilder<SetField<M, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): I256ColumnBuilder<SetField<M, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): I256ColumnBuilder<SetField<M, 'indexType', IndexTypes>> {\n    return new I256ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): I256ColumnBuilder<SetField<M, 'isUnique', true>> {\n    return new I256ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): I256ColumnBuilder<SetField<M, 'isPrimaryKey', true>> {\n    return new I256ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): I256ColumnBuilder<SetField<M, 'isAutoIncrement', true>> {\n    return new I256ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: bigint\n  ): I256ColumnBuilder<SetField<M, 'defaultValue', bigint>> {\n    return new I256ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, {\n        defaultValue: value,\n      })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): I256ColumnBuilder<SetField<M, 'name', Name>> {\n    return new I256ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\nexport class F32ColumnBuilder<\n    M extends ColumnMetadata<number> = DefaultMetadata,\n  >\n  extends ColumnBuilder<number, AlgebraicTypeVariants.F32, M>\n  implements\n    Defaultable<number, AlgebraicTypeVariants.F32>,\n    Nameable<number, AlgebraicTypeVariants.F32>\n{\n  default(\n    value: number\n  ): F32ColumnBuilder<SetField<M, 'defaultValue', number>> {\n    return new F32ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, {\n        defaultValue: value,\n      })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): F32ColumnBuilder<SetField<M, 'name', Name>> {\n    return new F32ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\nexport class F64ColumnBuilder<\n    M extends ColumnMetadata<number> = DefaultMetadata,\n  >\n  extends ColumnBuilder<number, AlgebraicTypeVariants.F64, M>\n  implements\n    Defaultable<number, AlgebraicTypeVariants.F64>,\n    Nameable<number, AlgebraicTypeVariants.F64>\n{\n  default(\n    value: number\n  ): F64ColumnBuilder<SetField<M, 'defaultValue', number>> {\n    return new F64ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, {\n        defaultValue: value,\n      })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): F64ColumnBuilder<SetField<M, 'name', Name>> {\n    return new F64ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\nexport class BoolColumnBuilder<\n    M extends ColumnMetadata<boolean> = DefaultMetadata,\n  >\n  extends ColumnBuilder<boolean, AlgebraicTypeVariants.Bool, M>\n  implements\n    Indexable<boolean, AlgebraicTypeVariants.Bool>,\n    Uniqueable<boolean, AlgebraicTypeVariants.Bool>,\n    PrimaryKeyable<boolean, AlgebraicTypeVariants.Bool>,\n    Defaultable<boolean, AlgebraicTypeVariants.Bool>,\n    Nameable<boolean, AlgebraicTypeVariants.Bool>\n{\n  index(): BoolColumnBuilder<SetField<M, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): BoolColumnBuilder<SetField<M, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): BoolColumnBuilder<SetField<M, 'indexType', IndexTypes>> {\n    return new BoolColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): BoolColumnBuilder<SetField<M, 'isUnique', true>> {\n    return new BoolColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): BoolColumnBuilder<SetField<M, 'isPrimaryKey', true>> {\n    return new BoolColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isPrimaryKey: true })\n    );\n  }\n  default(\n    value: boolean\n  ): BoolColumnBuilder<SetField<M, 'defaultValue', boolean>> {\n    return new BoolColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, {\n        defaultValue: value,\n      })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): BoolColumnBuilder<SetField<M, 'name', Name>> {\n    return new BoolColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\nexport class StringColumnBuilder<\n    M extends ColumnMetadata<string> = DefaultMetadata,\n  >\n  extends ColumnBuilder<string, AlgebraicTypeVariants.String, M>\n  implements\n    Indexable<string, AlgebraicTypeVariants.String>,\n    Uniqueable<string, AlgebraicTypeVariants.String>,\n    PrimaryKeyable<string, AlgebraicTypeVariants.String>,\n    Defaultable<string, AlgebraicTypeVariants.String>,\n    Nameable<string, AlgebraicTypeVariants.String>\n{\n  index(): StringColumnBuilder<SetField<M, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): StringColumnBuilder<SetField<M, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): StringColumnBuilder<SetField<M, 'indexType', IndexTypes>> {\n    return new StringColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): StringColumnBuilder<SetField<M, 'isUnique', true>> {\n    return new StringColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): StringColumnBuilder<SetField<M, 'isPrimaryKey', true>> {\n    return new StringColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isPrimaryKey: true })\n    );\n  }\n  default(\n    value: string\n  ): StringColumnBuilder<SetField<M, 'defaultValue', string>> {\n    return new StringColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, {\n        defaultValue: value,\n      })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): StringColumnBuilder<SetField<M, 'name', Name>> {\n    return new StringColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\nexport class ArrayColumnBuilder<\n    Element extends TypeBuilder<any, any>,\n    M extends ColumnMetadata<\n      Array<InferTypeOfTypeBuilder<Element>>\n    > = DefaultMetadata,\n  >\n  extends ColumnBuilder<\n    Array<InferTypeOfTypeBuilder<Element>>,\n    { tag: 'Array'; value: InferSpacetimeTypeOfTypeBuilder<Element> },\n    M\n  >\n  implements\n    Defaultable<\n      Array<InferTypeOfTypeBuilder<Element>>,\n      AlgebraicTypeVariants.Array\n    >,\n    Nameable<\n      Array<InferTypeOfTypeBuilder<Element>>,\n      AlgebraicTypeVariants.Array\n    >\n{\n  default(\n    value: Array<InferTypeOfTypeBuilder<Element>>\n  ): ArrayColumnBuilder<\n    Element,\n    SetField<M, 'defaultValue', Array<InferTypeOfTypeBuilder<Element>>>\n  > {\n    return new ArrayColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, {\n        defaultValue: value,\n      })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): ArrayColumnBuilder<Element, SetField<M, 'name', Name>> {\n    return new ArrayColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\ntype ByteArrayType = {\n  tag: 'Array';\n  value: AlgebraicTypeVariants.U8;\n};\n\nexport class ByteArrayColumnBuilder<\n    M extends ColumnMetadata<Uint8Array> = DefaultMetadata,\n  >\n  extends ColumnBuilder<Uint8Array, ByteArrayType, M>\n  implements\n    Defaultable<Uint8Array, ByteArrayType, M>,\n    Nameable<Uint8Array, ByteArrayType, M>\n{\n  constructor(metadata: M) {\n    super(new TypeBuilder(AlgebraicType.Array(AlgebraicType.U8)), metadata);\n  }\n  default(\n    value: Uint8Array\n  ): ByteArrayColumnBuilder<SetField<M, 'defaultValue', Uint8Array>> {\n    return new ByteArrayColumnBuilder(\n      set(this.columnMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): ByteArrayColumnBuilder<SetField<M, 'name', Name>> {\n    return new ByteArrayColumnBuilder(set(this.columnMetadata, { name }));\n  }\n}\n\nexport class OptionColumnBuilder<\n    Value extends TypeBuilder<any, any>,\n    M extends ColumnMetadata<\n      InferTypeOfTypeBuilder<Value> | undefined\n    > = DefaultMetadata,\n  >\n  extends ColumnBuilder<\n    InferTypeOfTypeBuilder<Value> | undefined,\n    OptionAlgebraicType<InferSpacetimeTypeOfTypeBuilder<Value>>,\n    M\n  >\n  implements\n    Defaultable<\n      InferTypeOfTypeBuilder<Value> | undefined,\n      OptionAlgebraicType<InferSpacetimeTypeOfTypeBuilder<Value>>\n    >,\n    Nameable<\n      InferTypeOfTypeBuilder<Value> | undefined,\n      OptionAlgebraicType<InferSpacetimeTypeOfTypeBuilder<Value>>\n    >\n{\n  default(\n    value: InferTypeOfTypeBuilder<Value> | undefined\n  ): OptionColumnBuilder<\n    Value,\n    SetField<M, 'defaultValue', InferTypeOfTypeBuilder<Value> | undefined>\n  > {\n    return new OptionColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, {\n        defaultValue: value,\n      })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): OptionColumnBuilder<Value, SetField<M, 'name', Name>> {\n    return new OptionColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\nexport class ResultColumnBuilder<\n    Ok extends TypeBuilder<any, any>,\n    Err extends TypeBuilder<any, any>,\n    M extends ColumnMetadata<\n      InferTypeOfTypeBuilder<Ok> | InferTypeOfTypeBuilder<Err>\n    > = DefaultMetadata,\n  >\n  extends ColumnBuilder<\n    InferTypeOfTypeBuilder<Ok> | InferTypeOfTypeBuilder<Err>,\n    ResultAlgebraicType<\n      InferSpacetimeTypeOfTypeBuilder<Ok>,\n      InferSpacetimeTypeOfTypeBuilder<Err>\n    >,\n    M\n  >\n  implements\n    Defaultable<\n      InferTypeOfTypeBuilder<Ok> | InferTypeOfTypeBuilder<Err>,\n      ResultAlgebraicType<\n        InferSpacetimeTypeOfTypeBuilder<Ok>,\n        InferSpacetimeTypeOfTypeBuilder<Err>\n      >\n    >\n{\n  constructor(typeBuilder: TypeBuilder<any, any>, metadata: M) {\n    super(typeBuilder, metadata);\n  }\n\n  default(\n    value: InferTypeOfTypeBuilder<Ok> | InferTypeOfTypeBuilder<Err>\n  ): ResultColumnBuilder<\n    Ok,\n    Err,\n    SetField<\n      M,\n      'defaultValue',\n      InferTypeOfTypeBuilder<Ok> | InferTypeOfTypeBuilder<Err>\n    >\n  > {\n    return new ResultColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, {\n        defaultValue: value,\n      })\n    );\n  }\n}\n\nexport class ProductColumnBuilder<\n    Elements extends ElementsObj,\n    M extends ColumnMetadata<ObjectType<Elements>> = DefaultMetadata,\n  >\n  extends ColumnBuilder<\n    ObjectType<Elements>,\n    ElementsToProductType<Elements>,\n    M\n  >\n  implements\n    Defaultable<ObjectType<Elements>, ElementsToProductType<Elements>>,\n    Nameable<ObjectType<Elements>, ElementsToProductType<Elements>>\n{\n  default(\n    value: ObjectType<Elements>\n  ): ProductColumnBuilder<\n    Elements,\n    SetField<DefaultMetadata, 'defaultValue', any>\n  > {\n    return new ProductColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): ProductColumnBuilder<Elements, SetField<DefaultMetadata, 'name', Name>> {\n    return new ProductColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\nexport class SumColumnBuilder<\n    Variants extends VariantsObj,\n    M extends ColumnMetadata<EnumType<Variants>> = DefaultMetadata,\n  >\n  extends ColumnBuilder<EnumType<Variants>, VariantsToSumType<Variants>, M>\n  implements\n    Defaultable<EnumType<Variants>, VariantsToSumType<Variants>>,\n    Nameable<EnumType<Variants>, VariantsToSumType<Variants>>\n{\n  default(\n    value: EnumType<Variants>\n  ): SumColumnBuilder<\n    Variants,\n    SetField<DefaultMetadata, 'defaultValue', any>\n  > {\n    return new SumColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): SumColumnBuilder<Variants, SetField<DefaultMetadata, 'name', Name>> {\n    return new SumColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\nexport class SimpleSumColumnBuilder<\n    Variants extends VariantsObj,\n    M extends ColumnMetadata<EnumType<Variants>> = DefaultMetadata,\n  >\n  extends SumColumnBuilder<Variants, M>\n  implements\n    Indexable<EnumType<Variants>, AlgebraicTypeVariants.Sum>,\n    PrimaryKeyable<EnumType<Variants>, AlgebraicTypeVariants.Sum>\n{\n  index(): SimpleSumColumnBuilder<\n    Variants,\n    SetField<DefaultMetadata, 'indexType', 'btree'>\n  >;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): SimpleSumColumnBuilder<\n    Variants,\n    SetField<DefaultMetadata, 'indexType', N>\n  >;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): SimpleSumColumnBuilder<\n    Variants,\n    SetField<DefaultMetadata, 'indexType', IndexTypes>\n  > {\n    return new SimpleSumColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { indexType: algorithm })\n    );\n  }\n  primaryKey(): SimpleSumColumnBuilder<\n    Variants,\n    SetField<DefaultMetadata, 'isPrimaryKey', true>\n  > {\n    return new SimpleSumColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isPrimaryKey: true })\n    );\n  }\n}\n\nexport class ScheduleAtColumnBuilder<\n    M extends ColumnMetadata<ScheduleAt> = DefaultMetadata,\n  >\n  extends ColumnBuilder<ScheduleAt, ScheduleAtAlgebraicType, M>\n  implements\n    Defaultable<ScheduleAt, ScheduleAtAlgebraicType>,\n    Nameable<ScheduleAt, ScheduleAtAlgebraicType>\n{\n  default(\n    value: ScheduleAt\n  ): ScheduleAtColumnBuilder<SetField<M, 'defaultValue', ScheduleAt>> {\n    return new ScheduleAtColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): ScheduleAtColumnBuilder<SetField<M, 'name', Name>> {\n    return new ScheduleAtColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\nexport class IdentityColumnBuilder<\n    M extends ColumnMetadata<Identity> = DefaultMetadata,\n  >\n  extends ColumnBuilder<Identity, IdentityAlgebraicType, M>\n  implements\n    Indexable<Identity, IdentityAlgebraicType>,\n    Uniqueable<Identity, IdentityAlgebraicType>,\n    PrimaryKeyable<Identity, IdentityAlgebraicType>,\n    Defaultable<Identity, IdentityAlgebraicType>,\n    Nameable<Identity, IdentityAlgebraicType>\n{\n  index(): IdentityColumnBuilder<SetField<M, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): IdentityColumnBuilder<SetField<M, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): IdentityColumnBuilder<SetField<M, 'indexType', IndexTypes>> {\n    return new IdentityColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): IdentityColumnBuilder<SetField<M, 'isUnique', true>> {\n    return new IdentityColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): IdentityColumnBuilder<SetField<M, 'isPrimaryKey', true>> {\n    return new IdentityColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isPrimaryKey: true })\n    );\n  }\n  default(\n    value: Identity\n  ): IdentityColumnBuilder<SetField<M, 'defaultValue', Identity>> {\n    return new IdentityColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): IdentityColumnBuilder<SetField<M, 'name', Name>> {\n    return new IdentityColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\nexport class ConnectionIdColumnBuilder<\n    M extends ColumnMetadata<ConnectionId> = DefaultMetadata,\n  >\n  extends ColumnBuilder<ConnectionId, ConnectionIdAlgebraicType, M>\n  implements\n    Indexable<ConnectionId, ConnectionIdAlgebraicType>,\n    Uniqueable<ConnectionId, ConnectionIdAlgebraicType>,\n    PrimaryKeyable<ConnectionId, ConnectionIdAlgebraicType>,\n    Defaultable<ConnectionId, ConnectionIdAlgebraicType>,\n    Nameable<ConnectionId, ConnectionIdAlgebraicType>\n{\n  index(): ConnectionIdColumnBuilder<SetField<M, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): ConnectionIdColumnBuilder<SetField<M, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): ConnectionIdColumnBuilder<SetField<M, 'indexType', IndexTypes>> {\n    return new ConnectionIdColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): ConnectionIdColumnBuilder<SetField<M, 'isUnique', true>> {\n    return new ConnectionIdColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): ConnectionIdColumnBuilder<SetField<M, 'isPrimaryKey', true>> {\n    return new ConnectionIdColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isPrimaryKey: true })\n    );\n  }\n  default(\n    value: ConnectionId\n  ): ConnectionIdColumnBuilder<SetField<M, 'defaultValue', ConnectionId>> {\n    return new ConnectionIdColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): ConnectionIdColumnBuilder<SetField<M, 'name', Name>> {\n    return new ConnectionIdColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\nexport class TimestampColumnBuilder<\n    M extends ColumnMetadata<Timestamp> = DefaultMetadata,\n  >\n  extends ColumnBuilder<Timestamp, TimestampAlgebraicType, M>\n  implements\n    Indexable<Timestamp, TimestampAlgebraicType>,\n    Uniqueable<Timestamp, TimestampAlgebraicType>,\n    PrimaryKeyable<Timestamp, TimestampAlgebraicType>,\n    Defaultable<Timestamp, TimestampAlgebraicType>,\n    Nameable<Timestamp, TimestampAlgebraicType>\n{\n  index(): TimestampColumnBuilder<SetField<M, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): TimestampColumnBuilder<SetField<M, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): TimestampColumnBuilder<SetField<M, 'indexType', IndexTypes>> {\n    return new TimestampColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): TimestampColumnBuilder<SetField<M, 'isUnique', true>> {\n    return new TimestampColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): TimestampColumnBuilder<SetField<M, 'isPrimaryKey', true>> {\n    return new TimestampColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isPrimaryKey: true })\n    );\n  }\n  default(\n    value: Timestamp\n  ): TimestampColumnBuilder<SetField<M, 'defaultValue', Timestamp>> {\n    return new TimestampColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): TimestampColumnBuilder<SetField<M, 'name', Name>> {\n    return new TimestampColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\nexport class TimeDurationColumnBuilder<\n    M extends ColumnMetadata<TimeDuration> = DefaultMetadata,\n  >\n  extends ColumnBuilder<TimeDuration, TimeDurationAlgebraicType, M>\n  implements\n    Indexable<TimeDuration, TimeDurationAlgebraicType>,\n    Uniqueable<TimeDuration, TimeDurationAlgebraicType>,\n    PrimaryKeyable<TimeDuration, TimeDurationAlgebraicType>,\n    Defaultable<TimeDuration, TimeDurationAlgebraicType>,\n    Nameable<TimeDuration, TimeDurationAlgebraicType>\n{\n  index(): TimeDurationColumnBuilder<SetField<M, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): TimeDurationColumnBuilder<SetField<M, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): TimeDurationColumnBuilder<SetField<M, 'indexType', IndexTypes>> {\n    return new TimeDurationColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): TimeDurationColumnBuilder<SetField<M, 'isUnique', true>> {\n    return new TimeDurationColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): TimeDurationColumnBuilder<SetField<M, 'isPrimaryKey', true>> {\n    return new TimeDurationColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isPrimaryKey: true })\n    );\n  }\n  default(\n    value: TimeDuration\n  ): TimeDurationColumnBuilder<SetField<M, 'defaultValue', TimeDuration>> {\n    return new TimeDurationColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): TimeDurationColumnBuilder<SetField<M, 'name', Name>> {\n    return new TimeDurationColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\nexport class UuidColumnBuilder<M extends ColumnMetadata<Uuid> = DefaultMetadata>\n  extends ColumnBuilder<Uuid, UuidAlgebraicType, M>\n  implements\n    Indexable<Uuid, UuidAlgebraicType>,\n    Uniqueable<Uuid, UuidAlgebraicType>,\n    PrimaryKeyable<Uuid, UuidAlgebraicType>,\n    Defaultable<Uuid, UuidAlgebraicType>,\n    Nameable<Uuid, UuidAlgebraicType>\n{\n  index(): UuidColumnBuilder<SetField<M, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): UuidColumnBuilder<SetField<M, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): UuidColumnBuilder<SetField<M, 'indexType', IndexTypes>> {\n    return new UuidColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): UuidColumnBuilder<SetField<M, 'isUnique', true>> {\n    return new UuidColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): UuidColumnBuilder<SetField<M, 'isPrimaryKey', true>> {\n    return new UuidColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isPrimaryKey: true })\n    );\n  }\n  default(value: Uuid): UuidColumnBuilder<SetField<M, 'defaultValue', Uuid>> {\n    return new UuidColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): UuidColumnBuilder<SetField<M, 'name', Name>> {\n    return new UuidColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\nexport class RefBuilder<Type, SpacetimeType> extends TypeBuilder<\n  Type,\n  AlgebraicTypeVariants.Ref\n> {\n  readonly ref: number;\n  /** The phantom type of the pointee of this ref. */\n  private readonly __spacetimeType!: SpacetimeType;\n  constructor(ref: number) {\n    super(AlgebraicType.Ref(ref));\n    this.ref = ref;\n  }\n}\n\ninterface EnumFn {\n  /**\n   * Creates a simple sum type whose cases are all unit variants.\n   * Each string in the array becomes a case of the enum.\n   *\n   * Example:\n   * ```ts\n   * t.enum(\"Color\", [\"red\", \"green\", \"blue\"]);\n   * ```\n   */\n  <Case extends string>(\n    name: string,\n    cases: readonly [Case, ...Case[]]\n  ): SimpleSumBuilderImpl<Record<Case, UnitBuilder>>;\n\n  /**\n   * Creates an empty simple sum type (no cases, equivalent to `never`).\n   * This can be useful for code generation or placeholder types.\n   * Example:\n   * ```ts\n   * t.enum(\"Never\", []);\n   * ```\n   */\n  (name: string, cases: []): SimpleSumBuilderImpl<Record<never, UnitBuilder>>;\n\n  /**\n   * Creates a full sum type, where each case can have a payload.\n   * Each value in the object must be a {@link TypeBuilder}.\n   *\n   * Example:\n   * ```ts\n   * t.enum(\"Result\", { Ok: t.unit(), Err: t.string() });\n   * ```\n   */\n  <Obj extends VariantsObj>(name: string, obj: Obj): SumBuilder<Obj>;\n}\n\nconst enumImpl = ((nameOrObj: any, maybeObj?: any) => {\n  let obj: any = nameOrObj;\n  let name: string | undefined = undefined;\n\n  if (typeof nameOrObj === 'string') {\n    if (!maybeObj) {\n      throw new TypeError(\n        'When providing a name, you must also provide the variants object or array.'\n      );\n    }\n    obj = maybeObj;\n    name = nameOrObj;\n  }\n\n  // Simple sum (array form)\n  if (Array.isArray(obj)) {\n    const simpleVariantsObj: Record<string, UnitBuilder> = {};\n    for (const variant of obj) {\n      simpleVariantsObj[variant] = new UnitBuilder();\n    }\n    return new SimpleSumBuilderImpl(simpleVariantsObj, name);\n  }\n\n  // Regular sum (object form)\n  return new SumBuilder(obj, name);\n}) as EnumFn;\n\n/**\n * A collection of factory functions for creating various SpacetimeDB algebraic types\n * to be used in table definitions. Each function returns a corresponding builder\n * for a specific type, such as `BoolBuilder`, `StringBuilder`, or `F64Builder`.\n *\n * These builders are used to define the schema of tables in SpacetimeDB, and each\n * builder implements the {@link TypeBuilder} interface, allowing for type-safe\n * schema construction in TypeScript.\n *\n * @remarks\n * - Primitive types (e.g., `bool`, `string`, `number`) map to their respective TypeScript types.\n * - Integer and floating-point types (e.g., `i8`, `u64`, `f32`) are represented as `number` or `bigint` in TypeScript.\n * - Complex types such as `object`, `array`, and `enum` allow for nested and structured schemas.\n * - The `scheduleAt` builder is a special column type for scheduling.\n *\n * @see {@link TypeBuilder}\n */\nexport const t = {\n  /**\n   * Creates a new `Bool` {@link AlgebraicType} to be used in table definitions\n   * Represented as `boolean` in TypeScript.\n   * @returns A new {@link BoolBuilder} instance\n   */\n  bool: (): BoolBuilder => new BoolBuilder(),\n\n  /**\n   * Creates a new `String` {@link AlgebraicType} to be used in table definitions\n   * Represented as `string` in TypeScript.\n   * @returns A new {@link StringBuilder} instance\n   */\n  string: (): StringBuilder => new StringBuilder(),\n\n  /**\n   * Creates a new `F64` {@link AlgebraicType} to be used in table definitions\n   * Represented as `number` in TypeScript.\n   * @returns A new {@link F64Builder} instance\n   */\n  number: (): F64Builder => new F64Builder(),\n\n  /**\n   * Creates a new `I8` {@link AlgebraicType} to be used in table definitions\n   * Represented as `number` in TypeScript.\n   * @returns A new {@link I8Builder} instance\n   */\n  i8: (): I8Builder => new I8Builder(),\n\n  /**\n   * Creates a new `U8` {@link AlgebraicType} to be used in table definitions\n   * Represented as `number` in TypeScript.\n   * @returns A new {@link U8Builder} instance\n   */\n  u8: (): U8Builder => new U8Builder(),\n\n  /**\n   * Creates a new `I16` {@link AlgebraicType} to be used in table definitions\n   * Represented as `number` in TypeScript.\n   * @returns A new {@link I16Builder} instance\n   */\n  i16: (): I16Builder => new I16Builder(),\n\n  /**\n   * Creates a new `U16` {@link AlgebraicType} to be used in table definitions\n   * Represented as `number` in TypeScript.\n   * @returns A new {@link U16Builder} instance\n   */\n  u16: (): U16Builder => new U16Builder(),\n\n  /**\n   * Creates a new `I32` {@link AlgebraicType} to be used in table definitions\n   * Represented as `number` in TypeScript.\n   * @returns A new {@link I32Builder} instance\n   */\n  i32: (): I32Builder => new I32Builder(),\n\n  /**\n   * Creates a new `U32` {@link AlgebraicType} to be used in table definitions\n   * Represented as `number` in TypeScript.\n   * @returns A new {@link U32Builder} instance\n   */\n  u32: (): U32Builder => new U32Builder(),\n\n  /**\n   * Creates a new `I64` {@link AlgebraicType} to be used in table definitions\n   * Represented as `bigint` in TypeScript.\n   * @returns A new {@link I64Builder} instance\n   */\n  i64: (): I64Builder => new I64Builder(),\n\n  /**\n   * Creates a new `U64` {@link AlgebraicType} to be used in table definitions\n   * Represented as `bigint` in TypeScript.\n   * @returns A new {@link U64Builder} instance\n   */\n  u64: (): U64Builder => new U64Builder(),\n\n  /**\n   * Creates a new `I128` {@link AlgebraicType} to be used in table definitions\n   * Represented as `bigint` in TypeScript.\n   * @returns A new {@link I128Builder} instance\n   */\n  i128: (): I128Builder => new I128Builder(),\n\n  /**\n   * Creates a new `U128` {@link AlgebraicType} to be used in table definitions\n   * Represented as `bigint` in TypeScript.\n   * @returns A new {@link U128Builder} instance\n   */\n  u128: (): U128Builder => new U128Builder(),\n\n  /**\n   * Creates a new `I256` {@link AlgebraicType} to be used in table definitions\n   * Represented as `bigint` in TypeScript.\n   * @returns A new {@link I256Builder} instance\n   */\n  i256: (): I256Builder => new I256Builder(),\n\n  /**\n   * Creates a new `U256` {@link AlgebraicType} to be used in table definitions\n   * Represented as `bigint` in TypeScript.\n   * @returns A new {@link U256Builder} instance\n   */\n  u256: (): U256Builder => new U256Builder(),\n\n  /**\n   * Creates a new `F32` {@link AlgebraicType} to be used in table definitions\n   * Represented as `number` in TypeScript.\n   * @returns A new {@link F32Builder} instance\n   */\n  f32: (): F32Builder => new F32Builder(),\n\n  /**\n   * Creates a new `F64` {@link AlgebraicType} to be used in table definitions\n   * Represented as `number` in TypeScript.\n   * @returns A new {@link F64Builder} instance\n   */\n  f64: (): F64Builder => new F64Builder(),\n\n  /**\n   * Creates a new `Product` {@link AlgebraicType} to be used in table definitions. Product types in SpacetimeDB\n   * are essentially the same as objects in JavaScript/TypeScript.\n   * Properties of the object must also be {@link TypeBuilder}s.\n   * Represented as an object with specific properties in TypeScript.\n   *\n   * @param name (optional) A display name for the product type. If omitted, an anonymous product type is created.\n   * @param obj The object defining the properties of the type, whose property\n   * values must be {@link TypeBuilder}s.\n   * @returns A new {@link ProductBuilder} instance.\n   */\n  object: ((nameOrObj: any, maybeObj?: any) => {\n    if (typeof nameOrObj === 'string') {\n      if (!maybeObj) {\n        throw new TypeError(\n          'When providing a name, you must also provide the object.'\n        );\n      }\n      return new ProductBuilder(maybeObj, nameOrObj);\n    }\n    return new ProductBuilder(nameOrObj, undefined);\n  }) as {\n    <Obj extends ElementsObj>(name: string, obj: Obj): ProductBuilder<Obj>;\n    // TODO: Currently names are not optional\n    // <Obj extends ElementsObj>(obj: Obj): ProductBuilder<Obj>;\n  },\n\n  /**\n   * Creates a new `Row` {@link AlgebraicType} to be used in table definitions. Row types in SpacetimeDB\n   * are similar to `Product` types, but are specifically used to define the schema of a table row.\n   * Properties of the object must also be {@link TypeBuilder} or {@link ColumnBuilder}s.\n   *\n   * You can represent a `Row` as either a {@link RowObj} or an {@link RowBuilder} type when\n   * defining a table schema.\n   *\n   * The {@link RowBuilder} type is useful when you want to create a type which can be used anywhere\n   * a {@link TypeBuilder} is accepted, such as in nested objects or arrays, or as the argument\n   * to a scheduled function.\n   *\n   * @param obj The object defining the properties of the row, whose property\n   * values must be {@link TypeBuilder}s or {@link ColumnBuilder}s.\n   * @returns A new {@link RowBuilder} instance\n   */\n  row: (<Obj extends RowObj>(\n    nameOrObj: string | Obj,\n    maybeObj?: Obj\n  ): RowBuilder<Obj> => {\n    const [obj, name] =\n      typeof nameOrObj === 'string'\n        ? [maybeObj!, nameOrObj]\n        : [nameOrObj, undefined];\n    return new RowBuilder(obj, name);\n  }) as {\n    <Obj extends RowObj>(obj: Obj): RowBuilder<Obj>;\n    <Obj extends RowObj>(name: string, obj: Obj): RowBuilder<Obj>;\n  },\n\n  /**\n   * Creates a new `Array` {@link AlgebraicType} to be used in table definitions.\n   * Represented as an array in TypeScript.\n   * @param element The element type of the array, which must be a `TypeBuilder`.\n   * @returns A new {@link ArrayBuilder} instance\n   */\n  array<Element extends TypeBuilder<any, any>>(\n    e: Element\n  ): ArrayBuilder<Element> {\n    return new ArrayBuilder(e);\n  },\n\n  enum: enumImpl,\n\n  /**\n   * This is a special helper function for conveniently creating `Product` type columns with no fields.\n   *\n   * @returns A new {@link ProductBuilder} instance with no fields.\n   */\n  unit(): UnitBuilder {\n    return new UnitBuilder();\n  },\n\n  /**\n   * Creates a lazily-evaluated {@link TypeBuilder}. This is useful for creating\n   * recursive types, such as a tree or linked list.\n   * @param thunk A function that returns a {@link TypeBuilder}.\n   * @returns A proxy {@link TypeBuilder} that evaluates the thunk on first access.\n   */\n  lazy<Build extends () => TypeBuilder<any, any>>(\n    thunk: Build\n  ): ReturnType<Build> {\n    type B = ReturnType<Build>;\n    let cached: B | null = null;\n    const get = (): B => (cached ??= thunk() as B);\n\n    const proxy = new Proxy({} as unknown as B, {\n      get(_t, prop, recv) {\n        const target = get() as any;\n        const val = Reflect.get(target, prop, recv);\n        return typeof val === 'function' ? val.bind(target) : val;\n      },\n      set(_t, prop, value, recv) {\n        return Reflect.set(get() as any, prop, value, recv);\n      },\n      has(_t, prop) {\n        return prop in (get() as any);\n      },\n      ownKeys() {\n        return Reflect.ownKeys(get() as any);\n      },\n      getOwnPropertyDescriptor(_t, prop) {\n        return Object.getOwnPropertyDescriptor(get() as any, prop);\n      },\n      getPrototypeOf() {\n        // makes `instanceof TypeBuilder` work if you care about it\n        return Object.getPrototypeOf(get() as any);\n      },\n    }) as B;\n\n    return proxy;\n  },\n\n  /**\n   * This is a special helper function for conveniently creating {@link ScheduleAt} type columns.\n   * @returns A new ColumnBuilder instance with the {@link ScheduleAt} type.\n   */\n  scheduleAt: (): ScheduleAtBuilder => {\n    return new ScheduleAtBuilder();\n  },\n\n  /**\n   * This is a convenience method for creating a column with the {@link Option} type.\n   * You can create a column of the same type by constructing an enum with a `some` and `none` variant.\n   * @param value The type of the value contained in the `some` variant of the `Option`.\n   * @returns A new {@link OptionBuilder} instance with the {@link Option} type.\n   */\n  option<Value extends TypeBuilder<any, any>>(\n    value: Value\n  ): OptionBuilder<Value> {\n    return new OptionBuilder(value);\n  },\n\n  /**\n   * This is a convenience method for creating a column with the {@link Result} type.\n   * You can create a column of the same type by constructing an enum with an `ok` and `err` variant.\n   * @param ok The type of the value contained in the `ok` variant of the `Result`.\n   * @param err The type of the value contained in the `err` variant of the `Result`.\n   * @returns A new {@link ResultBuilder} instance with the {@link Result} type.\n   */\n  result<Ok extends TypeBuilder<any, any>, Err extends TypeBuilder<any, any>>(\n    ok: Ok,\n    err: Err\n  ): ResultBuilder<Ok, Err> {\n    return new ResultBuilder(ok, err);\n  },\n\n  /**\n   * This is a convenience method for creating a column with the {@link Identity} type.\n   * You can create a column of the same type by constructing an `object` with a single `__identity__` element.\n   * @returns A new {@link TypeBuilder} instance with the {@link Identity} type.\n   */\n  identity: (): IdentityBuilder => {\n    return new IdentityBuilder();\n  },\n\n  /**\n   * This is a convenience method for creating a column with the {@link ConnectionId} type.\n   * You can create a column of the same type by constructing an `object` with a single `__connection_id__` element.\n   * @returns A new {@link TypeBuilder} instance with the {@link ConnectionId} type.\n   */\n  connectionId: (): ConnectionIdBuilder => {\n    return new ConnectionIdBuilder();\n  },\n\n  /**\n   * This is a convenience method for creating a column with the {@link Timestamp} type.\n   * You can create a column of the same type by constructing an `object` with a single `__timestamp_micros_since_unix_epoch__` element.\n   * @returns A new {@link TypeBuilder} instance with the {@link Timestamp} type.\n   */\n  timestamp: (): TimestampBuilder => {\n    return new TimestampBuilder();\n  },\n\n  /**\n   * This is a convenience method for creating a column with the {@link TimeDuration} type.\n   * You can create a column of the same type by constructing an `object` with a single `__time_duration_micros__` element.\n   * @returns A new {@link TypeBuilder} instance with the {@link TimeDuration} type.\n   */\n  timeDuration: (): TimeDurationBuilder => {\n    return new TimeDurationBuilder();\n  },\n\n  /**\n   * This is a convenience method for creating a column with the {@link Uuid} type.\n   * You can create a column of the same type by constructing an `object` with a single `__uuid__` element.\n   * @returns A new {@link TypeBuilder} instance with the {@link Uuid} type.\n   */\n  uuid: (): UuidBuilder => {\n    return new UuidBuilder();\n  },\n\n  /**\n   * This is a convenience method for creating a column with the `ByteArray` type.\n   * You can create a column of the same type by constructing an `array` of `u8`.\n   * The TypeScript representation is {@link Uint8Array}.\n   * @returns A new {@link ByteArrayBuilder} instance with the `ByteArray` type.\n   */\n  byteArray: (): ByteArrayBuilder => {\n    return new ByteArrayBuilder();\n  },\n} as const;\nexport default t;\n","// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE\n// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.\n\n/* eslint-disable */\n/* tslint:disable */\nimport {\n  TypeBuilder as __TypeBuilder,\n  t as __t,\n  type AlgebraicTypeType as __AlgebraicTypeType,\n  type Infer as __Infer,\n} from '../../lib/type_builders';\n\nexport const BsatnRowList = __t.object('BsatnRowList', {\n  get sizeHint() {\n    return RowSizeHint;\n  },\n  rowsData: __t.byteArray(),\n});\nexport type BsatnRowList = __Infer<typeof BsatnRowList>;\n\nexport const CallProcedure = __t.object('CallProcedure', {\n  requestId: __t.u32(),\n  flags: __t.u8(),\n  procedure: __t.string(),\n  args: __t.byteArray(),\n});\nexport type CallProcedure = __Infer<typeof CallProcedure>;\n\nexport const CallReducer = __t.object('CallReducer', {\n  requestId: __t.u32(),\n  flags: __t.u8(),\n  reducer: __t.string(),\n  args: __t.byteArray(),\n});\nexport type CallReducer = __Infer<typeof CallReducer>;\n\n// The tagged union or sum type for the algebraic type `ClientMessage`.\nexport const ClientMessage = __t.enum('ClientMessage', {\n  get Subscribe() {\n    return Subscribe;\n  },\n  get Unsubscribe() {\n    return Unsubscribe;\n  },\n  get OneOffQuery() {\n    return OneOffQuery;\n  },\n  get CallReducer() {\n    return CallReducer;\n  },\n  get CallProcedure() {\n    return CallProcedure;\n  },\n});\nexport type ClientMessage = __Infer<typeof ClientMessage>;\n\nexport const EventTableRows = __t.object('EventTableRows', {\n  get events() {\n    return BsatnRowList;\n  },\n});\nexport type EventTableRows = __Infer<typeof EventTableRows>;\n\nexport const InitialConnection = __t.object('InitialConnection', {\n  identity: __t.identity(),\n  connectionId: __t.connectionId(),\n  token: __t.string(),\n});\nexport type InitialConnection = __Infer<typeof InitialConnection>;\n\nexport const OneOffQuery = __t.object('OneOffQuery', {\n  requestId: __t.u32(),\n  queryString: __t.string(),\n});\nexport type OneOffQuery = __Infer<typeof OneOffQuery>;\n\nexport const OneOffQueryResult = __t.object('OneOffQueryResult', {\n  requestId: __t.u32(),\n  get result() {\n    return __t.result(QueryRows, __t.string());\n  },\n});\nexport type OneOffQueryResult = __Infer<typeof OneOffQueryResult>;\n\nexport const PersistentTableRows = __t.object('PersistentTableRows', {\n  get inserts() {\n    return BsatnRowList;\n  },\n  get deletes() {\n    return BsatnRowList;\n  },\n});\nexport type PersistentTableRows = __Infer<typeof PersistentTableRows>;\n\nexport const ProcedureResult = __t.object('ProcedureResult', {\n  get status() {\n    return ProcedureStatus;\n  },\n  timestamp: __t.timestamp(),\n  totalHostExecutionDuration: __t.timeDuration(),\n  requestId: __t.u32(),\n});\nexport type ProcedureResult = __Infer<typeof ProcedureResult>;\n\n// The tagged union or sum type for the algebraic type `ProcedureStatus`.\nexport const ProcedureStatus = __t.enum('ProcedureStatus', {\n  Returned: __t.byteArray(),\n  InternalError: __t.string(),\n});\nexport type ProcedureStatus = __Infer<typeof ProcedureStatus>;\n\nexport const QueryRows = __t.object('QueryRows', {\n  get tables() {\n    return __t.array(SingleTableRows);\n  },\n});\nexport type QueryRows = __Infer<typeof QueryRows>;\n\nexport const QuerySetId = __t.object('QuerySetId', {\n  id: __t.u32(),\n});\nexport type QuerySetId = __Infer<typeof QuerySetId>;\n\nexport const QuerySetUpdate = __t.object('QuerySetUpdate', {\n  get querySetId() {\n    return QuerySetId;\n  },\n  get tables() {\n    return __t.array(TableUpdate);\n  },\n});\nexport type QuerySetUpdate = __Infer<typeof QuerySetUpdate>;\n\nexport const ReducerOk = __t.object('ReducerOk', {\n  retValue: __t.byteArray(),\n  get transactionUpdate() {\n    return TransactionUpdate;\n  },\n});\nexport type ReducerOk = __Infer<typeof ReducerOk>;\n\n// The tagged union or sum type for the algebraic type `ReducerOutcome`.\nexport const ReducerOutcome = __t.enum('ReducerOutcome', {\n  get Ok() {\n    return ReducerOk;\n  },\n  OkEmpty: __t.unit(),\n  Err: __t.byteArray(),\n  InternalError: __t.string(),\n});\nexport type ReducerOutcome = __Infer<typeof ReducerOutcome>;\n\nexport const ReducerResult = __t.object('ReducerResult', {\n  requestId: __t.u32(),\n  timestamp: __t.timestamp(),\n  get result() {\n    return ReducerOutcome;\n  },\n});\nexport type ReducerResult = __Infer<typeof ReducerResult>;\n\n// The tagged union or sum type for the algebraic type `RowSizeHint`.\nexport const RowSizeHint = __t.enum('RowSizeHint', {\n  FixedSize: __t.u16(),\n  RowOffsets: __t.array(__t.u64()),\n});\nexport type RowSizeHint = __Infer<typeof RowSizeHint>;\n\n// The tagged union or sum type for the algebraic type `ServerMessage`.\nexport const ServerMessage = __t.enum('ServerMessage', {\n  get InitialConnection() {\n    return InitialConnection;\n  },\n  get SubscribeApplied() {\n    return SubscribeApplied;\n  },\n  get UnsubscribeApplied() {\n    return UnsubscribeApplied;\n  },\n  get SubscriptionError() {\n    return SubscriptionError;\n  },\n  get TransactionUpdate() {\n    return TransactionUpdate;\n  },\n  get OneOffQueryResult() {\n    return OneOffQueryResult;\n  },\n  get ReducerResult() {\n    return ReducerResult;\n  },\n  get ProcedureResult() {\n    return ProcedureResult;\n  },\n});\nexport type ServerMessage = __Infer<typeof ServerMessage>;\n\nexport const SingleTableRows = __t.object('SingleTableRows', {\n  table: __t.string(),\n  get rows() {\n    return BsatnRowList;\n  },\n});\nexport type SingleTableRows = __Infer<typeof SingleTableRows>;\n\nexport const Subscribe = __t.object('Subscribe', {\n  requestId: __t.u32(),\n  get querySetId() {\n    return QuerySetId;\n  },\n  queryStrings: __t.array(__t.string()),\n});\nexport type Subscribe = __Infer<typeof Subscribe>;\n\nexport const SubscribeApplied = __t.object('SubscribeApplied', {\n  requestId: __t.u32(),\n  get querySetId() {\n    return QuerySetId;\n  },\n  get rows() {\n    return QueryRows;\n  },\n});\nexport type SubscribeApplied = __Infer<typeof SubscribeApplied>;\n\nexport const SubscriptionError = __t.object('SubscriptionError', {\n  requestId: __t.option(__t.u32()),\n  get querySetId() {\n    return QuerySetId;\n  },\n  error: __t.string(),\n});\nexport type SubscriptionError = __Infer<typeof SubscriptionError>;\n\nexport const TableUpdate = __t.object('TableUpdate', {\n  tableName: __t.string(),\n  get rows() {\n    return __t.array(TableUpdateRows);\n  },\n});\nexport type TableUpdate = __Infer<typeof TableUpdate>;\n\n// The tagged union or sum type for the algebraic type `TableUpdateRows`.\nexport const TableUpdateRows = __t.enum('TableUpdateRows', {\n  get PersistentTable() {\n    return PersistentTableRows;\n  },\n  get EventTable() {\n    return EventTableRows;\n  },\n});\nexport type TableUpdateRows = __Infer<typeof TableUpdateRows>;\n\nexport const TransactionUpdate = __t.object('TransactionUpdate', {\n  get querySets() {\n    return __t.array(QuerySetUpdate);\n  },\n});\nexport type TransactionUpdate = __Infer<typeof TransactionUpdate>;\n\nexport const Unsubscribe = __t.object('Unsubscribe', {\n  requestId: __t.u32(),\n  get querySetId() {\n    return QuerySetId;\n  },\n  get flags() {\n    return UnsubscribeFlags;\n  },\n});\nexport type Unsubscribe = __Infer<typeof Unsubscribe>;\n\nexport const UnsubscribeApplied = __t.object('UnsubscribeApplied', {\n  requestId: __t.u32(),\n  get querySetId() {\n    return QuerySetId;\n  },\n  get rows() {\n    return __t.option(QueryRows);\n  },\n});\nexport type UnsubscribeApplied = __Infer<typeof UnsubscribeApplied>;\n\n// The tagged union or sum type for the algebraic type `UnsubscribeFlags`.\nexport const UnsubscribeFlags = __t.enum('UnsubscribeFlags', {\n  Default: __t.unit(),\n  SendDroppedRows: __t.unit(),\n});\nexport type UnsubscribeFlags = __Infer<typeof UnsubscribeFlags>;\n","// eslint-disable-next-line @typescript-eslint/no-unsafe-function-type\nexport class EventEmitter<Key, Callback extends Function = Function> {\n  #events: Map<Key, Set<Callback>> = new Map();\n\n  on(event: Key, callback: Callback): void {\n    let callbacks = this.#events.get(event);\n    if (!callbacks) {\n      callbacks = new Set();\n      this.#events.set(event, callbacks);\n    }\n    callbacks.add(callback);\n  }\n\n  off(event: Key, callback: Callback): void {\n    const callbacks = this.#events.get(event);\n    if (!callbacks) {\n      return;\n    }\n    callbacks.delete(callback);\n  }\n\n  emit(event: Key, ...args: any[]): void {\n    const callbacks = this.#events.get(event);\n    if (!callbacks) {\n      return;\n    }\n\n    for (const callback of callbacks) {\n      callback(...args);\n    }\n  }\n}\n","import { stringify as ssStringify } from 'safe-stable-stringify';\nimport { u128ToHexString, u256ToHexString } from '../lib/util';\nexport type LogLevel = 'info' | 'warn' | 'error' | 'debug' | 'trace';\n\nconst LogLevelIdentifierIcon = {\n  component: '',\n  info: '',\n  warn: '',\n  error: '',\n  debug: '',\n  trace: '',\n};\n\nconst LogStyle = {\n  component:\n    'color: #fff; background-color: #8D6FDD; padding: 2px 5px; border-radius: 3px;',\n  info: 'color: #fff; background-color: #007bff; padding: 2px 5px; border-radius: 3px;',\n  warn: 'color: #fff; background-color: #ffc107; padding: 2px 5px; border-radius: 3px;',\n  error:\n    'color: #fff; background-color: #dc3545; padding: 2px 5px; border-radius: 3px;',\n  debug:\n    'color: #fff; background-color: #28a745; padding: 2px 5px; border-radius: 3px;',\n  trace:\n    'color: #fff; background-color: #17a2b8; padding: 2px 5px; border-radius: 3px;',\n};\n\nconst LogTextStyle = {\n  component: 'color: #8D6FDD;',\n  info: 'color: #007bff;',\n  warn: 'color: #ffc107;',\n  error: 'color: #dc3545;',\n  debug: 'color: #28a745;',\n  trace: 'color: #17a2b8;',\n};\n\nconst LogLevelRank: Record<LogLevel, number> = {\n  error: 0,\n  warn: 1,\n  info: 2,\n  debug: 3,\n  trace: 4,\n};\n\nlet globalLogLevel: LogLevel = 'info';\n\nexport const setGlobalLogLevel = (level: LogLevel): void => {\n  globalLogLevel = level;\n};\n\nexport const getGlobalLogLevel = (): LogLevel => globalLogLevel;\n\nconst shouldLog = (level: LogLevel): boolean =>\n  LogLevelRank[level] <= LogLevelRank[globalLogLevel];\n\n// Lazy can be a function or the actual thing, so we can make verbose logs cheap when disabled.\ntype Lazy<T> = T | (() => T);\nconst resolveLazy = <T>(v: Lazy<T>): T =>\n  typeof v === 'function' ? (v as () => T)() : v;\n\nconst toHex = (bytes: Uint8Array): string =>\n  Array.from(bytes)\n    .map(b => b.toString(16).padStart(2, '0'))\n    .join('');\nconst ARRAY_TRUNCATION_THRESHOLD = 25;\nconst ARRAY_PREVIEW_COUNT = 10;\n\nconst SENSITIVE_KEYS = new Set([\n  'token',\n  'authToken',\n  'authorization',\n  'accessToken',\n  'refreshToken',\n]);\n\nexport const stringify = (value: unknown): string | undefined =>\n  ssStringify(value, (key, current) => {\n    if (SENSITIVE_KEYS.has(key)) {\n      return '[REDACTED]';\n    }\n    if (\n      current &&\n      typeof current === 'object' &&\n      '__identity__' in current &&\n      typeof (current as { __identity__: unknown }).__identity__ === 'bigint'\n    ) {\n      return u256ToHexString(\n        (current as { __identity__: bigint }).__identity__\n      );\n    }\n    if (\n      current &&\n      typeof current === 'object' &&\n      '__connection_id__' in current &&\n      typeof (current as { __connection_id__: unknown }).__connection_id__ ===\n        'bigint'\n    ) {\n      return u128ToHexString(\n        (current as { __connection_id__: bigint }).__connection_id__\n      );\n    }\n    if (current instanceof Uint8Array) {\n      if (current.length < 25) {\n        return `0x${toHex(current)}`;\n      }\n      const head = current.subarray(0, 10);\n      return `Uint8Array(len=${current.length}, head=0x${toHex(head)})`;\n    }\n    if (\n      Array.isArray(current) &&\n      current.length >= ARRAY_TRUNCATION_THRESHOLD\n    ) {\n      const head = ssStringify(current.slice(0, ARRAY_PREVIEW_COUNT));\n      return `Array(len=${current.length}, head=${head ?? '[]'})`;\n    }\n    return current;\n  });\n\nexport const stdbLogger = (\n  level: LogLevel,\n  message: Lazy<any>,\n  ...args: Lazy<any>\n): void => {\n  if (!shouldLog(level)) {\n    return;\n  }\n  const resolvedMessage = resolveLazy(message);\n  const resolvedArgs = args.map(resolveLazy);\n  console.log(\n    `%c${LogLevelIdentifierIcon[level]} ${level.toUpperCase()}%c ${resolvedMessage}`,\n    LogStyle[level],\n    LogTextStyle[level],\n    ...resolvedArgs\n  );\n};\n","import { EventEmitter } from './event_emitter.ts';\n\nimport { stdbLogger } from './logger.ts';\nimport { deepEqual, type ComparablePrimitive } from '../';\nimport type { EventContextInterface, TableDefForTableName } from './index.ts';\nimport type { RowType, TableIndexes, UntypedTableDef } from '../lib/table.ts';\nimport type { ClientTableCoreImplementable } from './client_table.ts';\nimport type { UntypedRemoteModule } from './spacetime_module.ts';\nimport type { TableNamesOf } from '../lib/schema.ts';\nimport type {\n  ReadonlyIndex,\n  ReadonlyIndexes,\n  ReadonlyRangedIndex,\n  ReadonlyUniqueIndex,\n  UntypedIndex,\n} from '../lib/indexes.ts';\nimport type { Bound } from '../server/range.ts';\nimport type { Prettify } from '../lib/type_util.ts';\n\nexport type Operation<\n  RowType extends Record<string, any> = Record<string, any>,\n> = {\n  type: 'insert' | 'delete';\n  // For tables with a primary key, this is the primary key value, as a primitive or string.\n  // Otherwise, it is an encoding of the full row.\n  rowId: ComparablePrimitive;\n  row: RowType;\n};\n\nexport type TableUpdate<TableDef extends UntypedTableDef> = {\n  tableName: string;\n  operations: Operation<RowType<TableDef>>[];\n};\n\nexport type PendingCallback = {\n  type: 'insert' | 'delete' | 'update';\n  table: string;\n  cb: () => void;\n};\n\n// Strict scalar compare for index term values.\nconst scalarCompare = (x: any, y: any): number => {\n  if (x === y) return 0;\n  // Compare booleans/numbers/bigints/strings with JS ordering.\n  return x < y ? -1 : 1;\n};\n\nexport type TableIndexView<\n  RemoteModule extends UntypedRemoteModule,\n  TableName extends TableNamesOf<RemoteModule>,\n> = ReadonlyIndexes<\n  TableDefForTableName<RemoteModule, TableName>,\n  TableIndexes<TableDefForTableName<RemoteModule, TableName>>\n>;\n\nexport type TableCache<\n  RemoteModule extends UntypedRemoteModule,\n  TableName extends TableNamesOf<RemoteModule>,\n> = TableCacheImpl<RemoteModule, TableName> &\n  TableIndexView<RemoteModule, TableName>;\n\n/**\n * Builder to generate calls to query a `table` in the database\n */\nexport class TableCacheImpl<\n  RemoteModule extends UntypedRemoteModule,\n  TableName extends TableNamesOf<RemoteModule>,\n> implements ClientTableCoreImplementable<RemoteModule, TableName>\n{\n  private rows: Map<\n    ComparablePrimitive,\n    [RowType<TableDefForTableName<RemoteModule, TableName>>, number]\n  >;\n  private tableDef: TableDefForTableName<RemoteModule, TableName>;\n  private emitter: EventEmitter<'insert' | 'delete' | 'update'>;\n\n  /**\n   * @param name the table name\n   * @param primaryKeyCol column index designated as `#[primarykey]`\n   * @param primaryKey column name designated as `#[primarykey]`\n   * @param entityClass the entityClass\n   */\n  constructor(tableDef: TableDefForTableName<RemoteModule, TableName>) {\n    this.tableDef = tableDef;\n    this.rows = new Map();\n    this.emitter = new EventEmitter();\n    // Build indexes\n    const indexesDef = this.tableDef.indexes || [];\n    for (const idx of indexesDef) {\n      // TODO: don't do this. See comment in `tableToSchema` in `schema.ts`\n      const idxDef = idx as UntypedIndex<\n        keyof TableDefForTableName<RemoteModule, TableName>['columns'] & string\n      >;\n      const index = this.#makeReadonlyIndex(this.tableDef, idxDef);\n      (this as any)[idxDef.name] = index;\n    }\n  }\n\n  // TODO: this just scans the whole table; we should build proper index structures\n  #makeReadonlyIndex<\n    I extends UntypedIndex<\n      keyof TableDefForTableName<RemoteModule, TableName>['columns'] & string\n    >,\n  >(\n    tableDef: TableDefForTableName<RemoteModule, TableName>,\n    idx: I\n  ): ReadonlyIndex<TableDefForTableName<RemoteModule, TableName>, I> {\n    type TableDef = TableDefForTableName<RemoteModule, TableName>;\n    type Row = Prettify<RowType<TableDef>>;\n\n    // We do not yet support non-btree indexes\n    if (idx.algorithm !== 'btree') {\n      throw new Error('Only btree indexes are supported in TableCacheImpl');\n    }\n\n    const columns = idx.columns;\n\n    // Extract the tuple key for this btree index (column order preserved)\n    const getKey = (row: Row): readonly unknown[] => columns.map(c => row[c]);\n\n    // The servers ranged scan fixes all prefix cols to equality and applies\n    // the bound only to the *last* term. We mirror that.\n    //\n    // rangeArg for multi-col index is:\n    //   [...prefixEqualValues, (lastTerm | Range<lastTerm>)]\n    //\n    // If only one element is provided, its the last term (scalar or Range).\n    const matchRange = (row: Row, rangeArg: any): boolean => {\n      const key = getKey(row);\n\n      // Normalize rangeArg into an array.\n      // With multi-col b-tree, IndexScanRangeBounds always yields at least one element.\n      const arr = Array.isArray(rangeArg) ? rangeArg : [rangeArg];\n\n      const prefixLen = Math.max(0, arr.length - 1);\n      // Check equality over the prefix (all but the last provided element)\n      for (let i = 0; i < prefixLen; i++) {\n        if (!deepEqual(key[i], arr[i])) return false;\n      }\n\n      const lastProvided = arr[arr.length - 1];\n      const kLast = key[prefixLen];\n\n      // If the last provided is a Range<T>, apply bounds; otherwise equality.\n      if (\n        lastProvided &&\n        typeof lastProvided === 'object' &&\n        'from' in lastProvided &&\n        'to' in lastProvided\n      ) {\n        // Range<T>\n        const from = lastProvided.from as Bound<any>;\n        const to = lastProvided.to as Bound<any>;\n\n        // Lower bound\n        if (from.tag !== 'unbounded') {\n          const c = scalarCompare(kLast, from.value);\n          if (c < 0) return false;\n          if (c === 0 && from.tag === 'excluded') return false;\n        }\n\n        // Upper bound\n        if (to.tag !== 'unbounded') {\n          const c = scalarCompare(kLast, to.value);\n          if (c > 0) return false;\n          if (c === 0 && to.tag === 'excluded') return false;\n        }\n\n        // All good on last term; any remaining columns (if any) are unconstrained,\n        // which matches server behavior for a prefix scan.\n        return true;\n      } else {\n        // Equality on the last provided element\n        if (!deepEqual(kLast, lastProvided)) return false;\n        // Any remaining columns are unconstrained (prefix equality only).\n        return true;\n      }\n    };\n\n    // An index is unique if it shares all columns with a unique constraint\n    const isUnique = tableDef.constraints.some(constraint => {\n      if (constraint.constraint !== 'unique') {\n        return false;\n      }\n      return deepEqual(constraint.columns, idx.columns);\n    });\n\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const self = this;\n    if (isUnique) {\n      const impl: ReadonlyUniqueIndex<TableDef, I> = {\n        find: (colVal: any): Row | null => {\n          // For unique btree, caller supplies the *full* key (tuple if multi-col).\n          const expected = Array.isArray(colVal) ? colVal : [colVal];\n          for (const row of self.iter()) {\n            if (deepEqual(getKey(row), expected)) return row;\n          }\n          return null;\n        },\n      };\n      return impl as ReadonlyIndex<TableDef, I>;\n    } else {\n      const impl: ReadonlyRangedIndex<TableDef, I> = {\n        *filter(range: any): IteratorObject<Row, undefined> {\n          for (const row of self.iter()) {\n            if (matchRange(row, range)) yield row;\n          }\n        },\n      };\n      return impl as ReadonlyIndex<TableDef, I>;\n    }\n  }\n\n  /**\n   * @returns number of rows in the table\n   */\n  count(): bigint {\n    return BigInt(this.rows.size);\n  }\n\n  /**\n   * @returns The values of the rows in the table\n   */\n  iter(): IteratorObject<\n    Prettify<RowType<TableDefForTableName<RemoteModule, TableName>>>,\n    undefined\n  > {\n    function* generator(\n      rows: Map<\n        ComparablePrimitive,\n        [RowType<TableDefForTableName<RemoteModule, TableName>>, number]\n      >\n    ): IteratorObject<\n      Prettify<RowType<TableDefForTableName<RemoteModule, TableName>>>,\n      undefined\n    > {\n      for (const [row] of rows.values()) {\n        yield row as Prettify<\n          RowType<TableDefForTableName<RemoteModule, TableName>>\n        >;\n      }\n    }\n    return generator(this.rows);\n  }\n\n  /**\n   * Allows iteration over the rows in the table\n   * @returns An iterator over the rows in the table\n   */\n  [Symbol.iterator](): IteratorObject<\n    Prettify<RowType<TableDefForTableName<RemoteModule, TableName>>>,\n    undefined\n  > {\n    return this.iter();\n  }\n\n  applyOperations = (\n    operations: Operation<\n      RowType<TableDefForTableName<RemoteModule, TableName>>\n    >[],\n    ctx: EventContextInterface<RemoteModule>\n  ): PendingCallback[] => {\n    const pendingCallbacks: PendingCallback[] = [];\n\n    // Event tables: fire on_insert callbacks but don't store rows in the cache.\n    if (this.tableDef.isEvent) {\n      for (const op of operations) {\n        if (op.type === 'insert') {\n          pendingCallbacks.push({\n            type: 'insert',\n            table: this.tableDef.sourceName,\n            cb: () => {\n              this.emitter.emit('insert', ctx, op.row);\n            },\n          });\n        }\n      }\n      return pendingCallbacks;\n    }\n\n    // TODO: performance\n    const hasPrimaryKey = Object.values(this.tableDef.columns).some(\n      col => col.columnMetadata.isPrimaryKey === true\n    );\n    if (hasPrimaryKey) {\n      const insertMap = new Map<\n        ComparablePrimitive,\n        [\n          Operation<RowType<TableDefForTableName<RemoteModule, TableName>>>,\n          number,\n        ]\n      >();\n      const deleteMap = new Map<\n        ComparablePrimitive,\n        [\n          Operation<RowType<TableDefForTableName<RemoteModule, TableName>>>,\n          number,\n        ]\n      >();\n      for (const op of operations) {\n        if (op.type === 'insert') {\n          const [_, prevCount] = insertMap.get(op.rowId) || [op, 0];\n          insertMap.set(op.rowId, [op, prevCount + 1]);\n        } else {\n          const [_, prevCount] = deleteMap.get(op.rowId) || [op, 0];\n          deleteMap.set(op.rowId, [op, prevCount + 1]);\n        }\n      }\n      for (const [primaryKey, [insertOp, refCount]] of insertMap) {\n        const deleteEntry = deleteMap.get(primaryKey);\n        if (deleteEntry) {\n          const [_, deleteCount] = deleteEntry;\n          // In most cases the refCountDelta will be either 0 or refCount, but if\n          // an update moves a row in or out of the result set of different queries, then\n          // other deltas are possible.\n          const refCountDelta = refCount - deleteCount;\n          const maybeCb = this.update(\n            ctx,\n            primaryKey,\n            insertOp.row,\n            refCountDelta\n          );\n          if (maybeCb) {\n            pendingCallbacks.push(maybeCb);\n          }\n          deleteMap.delete(primaryKey);\n        } else {\n          const maybeCb = this.insert(ctx, insertOp, refCount);\n          if (maybeCb) {\n            pendingCallbacks.push(maybeCb);\n          }\n        }\n      }\n      for (const [deleteOp, refCount] of deleteMap.values()) {\n        const maybeCb = this.delete(ctx, deleteOp, refCount);\n        if (maybeCb) {\n          pendingCallbacks.push(maybeCb);\n        }\n      }\n    } else {\n      for (const op of operations) {\n        if (op.type === 'insert') {\n          const maybeCb = this.insert(ctx, op);\n          if (maybeCb) {\n            pendingCallbacks.push(maybeCb);\n          }\n        } else {\n          const maybeCb = this.delete(ctx, op);\n          if (maybeCb) {\n            pendingCallbacks.push(maybeCb);\n          }\n        }\n      }\n    }\n    return pendingCallbacks;\n  };\n\n  update = (\n    ctx: EventContextInterface<RemoteModule>,\n    rowId: ComparablePrimitive,\n    newRow: RowType<TableDefForTableName<RemoteModule, TableName>>,\n    refCountDelta: number = 0\n  ): PendingCallback | undefined => {\n    const existingEntry = this.rows.get(rowId);\n    if (!existingEntry) {\n      // TODO: this should throw an error and kill the connection.\n      stdbLogger(\n        'error',\n        `Updating a row that was not present in the cache. Table: ${this.tableDef.sourceName}, RowId: ${rowId}`\n      );\n      return undefined;\n    }\n    const [oldRow, previousCount] = existingEntry;\n    const refCount = Math.max(1, previousCount + refCountDelta);\n    if (previousCount + refCountDelta <= 0) {\n      stdbLogger(\n        'error',\n        `Negative reference count for in table ${this.tableDef.sourceName} row ${rowId} (${previousCount} + ${refCountDelta})`\n      );\n      return undefined;\n    }\n    this.rows.set(rowId, [newRow, refCount]);\n    // This indicates something is wrong, so we could arguably crash here.\n    if (previousCount === 0) {\n      stdbLogger(\n        'error',\n        `Updating a row id in table ${this.tableDef.sourceName} which was not present in the cache (rowId: ${rowId})`\n      );\n      return {\n        type: 'insert',\n        table: this.tableDef.sourceName,\n        cb: () => {\n          this.emitter.emit('insert', ctx, newRow);\n        },\n      };\n    }\n    return {\n      type: 'update',\n      table: this.tableDef.sourceName,\n      cb: () => {\n        this.emitter.emit('update', ctx, oldRow, newRow);\n      },\n    };\n  };\n\n  insert = (\n    ctx: EventContextInterface<RemoteModule>,\n    operation: Operation<\n      RowType<TableDefForTableName<RemoteModule, TableName>>\n    >,\n    count: number = 1\n  ): PendingCallback | undefined => {\n    const [_, previousCount] = this.rows.get(operation.rowId) || [\n      operation.row,\n      0,\n    ];\n    this.rows.set(operation.rowId, [operation.row, previousCount + count]);\n    if (previousCount === 0) {\n      return {\n        type: 'insert',\n        table: this.tableDef.sourceName,\n        cb: () => {\n          this.emitter.emit('insert', ctx, operation.row);\n        },\n      };\n    }\n    // It's possible to get a duplicate insert because rows can be returned from multiple queries.\n    return undefined;\n  };\n\n  delete = (\n    ctx: EventContextInterface<RemoteModule>,\n    operation: Operation<\n      RowType<TableDefForTableName<RemoteModule, TableName>>\n    >,\n    count: number = 1\n  ): PendingCallback | undefined => {\n    const [_, previousCount] = this.rows.get(operation.rowId) || [\n      operation.row,\n      0,\n    ];\n    // This should never happen.\n    if (previousCount === 0) {\n      stdbLogger('warn', 'Deleting a row that was not present in the cache');\n      return undefined;\n    }\n    // If this was the last reference, we are actually deleting the row.\n    if (previousCount <= count) {\n      // TODO: Log a warning/error if previousCount is less than count.\n      this.rows.delete(operation.rowId);\n      return {\n        type: 'delete',\n        table: this.tableDef.sourceName,\n        cb: () => {\n          this.emitter.emit('delete', ctx, operation.row);\n        },\n      };\n    }\n    this.rows.set(operation.rowId, [operation.row, previousCount - count]);\n    return undefined;\n  };\n\n  /**\n   * Register a callback for when a row is newly inserted into the database.\n   *\n   * ```ts\n   * ctx.db.user.onInsert((reducerEvent, user) => {\n   *   if (reducerEvent) {\n   *      console.log(\"New user on reducer\", reducerEvent, user);\n   *   } else {\n   *      console.log(\"New user received during subscription update on insert\", user);\n   *  }\n   * });\n   * ```\n   *\n   * @param cb Callback to be called when a new row is inserted\n   */\n  onInsert = (\n    cb: (\n      ctx: EventContextInterface<RemoteModule>,\n      row: Prettify<RowType<TableDefForTableName<RemoteModule, TableName>>>\n    ) => void\n  ): void => {\n    this.emitter.on('insert', cb);\n  };\n\n  /**\n   * Register a callback for when a row is deleted from the database.\n   *\n   * ```ts\n   * ctx.db.user.onDelete((reducerEvent, user) => {\n   *   if (reducerEvent) {\n   *      console.log(\"Deleted user on reducer\", reducerEvent, user);\n   *   } else {\n   *      console.log(\"Deleted user received during subscription update on update\", user);\n   *  }\n   * });\n   * ```\n   *\n   * @param cb Callback to be called when a new row is inserted\n   */\n  onDelete = (\n    cb: (\n      ctx: EventContextInterface<RemoteModule>,\n      row: Prettify<RowType<TableDefForTableName<RemoteModule, TableName>>>\n    ) => void\n  ): void => {\n    this.emitter.on('delete', cb);\n  };\n\n  /**\n   * Register a callback for when a row is updated into the database.\n   *\n   * ```ts\n   * ctx.db.user.onInsert((reducerEvent, oldUser, user) => {\n   *   if (reducerEvent) {\n   *      console.log(\"Updated user on reducer\", reducerEvent, user);\n   *   } else {\n   *      console.log(\"Updated user received during subscription update on delete\", user);\n   *  }\n   * });\n   * ```\n   *\n   * @param cb Callback to be called when a new row is inserted\n   */\n  onUpdate = (\n    cb: (\n      ctx: EventContextInterface<RemoteModule>,\n      oldRow: Prettify<RowType<TableDefForTableName<RemoteModule, TableName>>>,\n      row: Prettify<RowType<TableDefForTableName<RemoteModule, TableName>>>\n    ) => void\n  ): void => {\n    this.emitter.on('update', cb);\n  };\n\n  /**\n   * Remove a callback for when a row is newly inserted into the database.\n   *\n   * @param cb Callback to be removed\n   */\n  removeOnInsert = (\n    cb: (\n      ctx: EventContextInterface<RemoteModule>,\n      row: Prettify<RowType<TableDefForTableName<RemoteModule, TableName>>>\n    ) => void\n  ): void => {\n    this.emitter.off('insert', cb);\n  };\n\n  /**\n   * Remove a callback for when a row is deleted from the database.\n   *\n   * @param cb Callback to be removed\n   */\n  removeOnDelete = (\n    cb: (\n      ctx: EventContextInterface<RemoteModule>,\n      row: Prettify<RowType<TableDefForTableName<RemoteModule, TableName>>>\n    ) => void\n  ): void => {\n    this.emitter.off('delete', cb);\n  };\n\n  /**\n   * Remove a callback for when a row is updated into the database.\n   *\n   * @param cb Callback to be removed\n   */\n  removeOnUpdate = (\n    cb: (\n      ctx: EventContextInterface<RemoteModule>,\n      oldRow: Prettify<RowType<TableDefForTableName<RemoteModule, TableName>>>,\n      row: Prettify<RowType<TableDefForTableName<RemoteModule, TableName>>>\n    ) => void\n  ): void => {\n    this.emitter.off('update', cb);\n  };\n}\n","import type { TableNamesOf, UntypedSchemaDef } from '../lib/schema.ts';\nimport type { UntypedTableDef } from '../lib/table.ts';\nimport type { Values } from '../lib/type_util.ts';\nimport type { UntypedRemoteModule } from './spacetime_module.ts';\nimport { type TableCache, TableCacheImpl } from './table_cache.ts';\n\ntype TableName<SchemaDef> = [SchemaDef] extends [UntypedSchemaDef]\n  ? TableNamesOf<SchemaDef>\n  : string;\n\nexport type TableDefForTableName<\n  SchemaDef extends UntypedSchemaDef,\n  N extends TableName<SchemaDef>,\n> = [SchemaDef] extends [UntypedSchemaDef]\n  ? Values<SchemaDef['tables']> & { accessorName: N }\n  : UntypedTableDef & { accessorName: N };\n\ntype TableCacheForTableName<\n  RemoteModule extends UntypedRemoteModule,\n  TableName extends TableNamesOf<RemoteModule>,\n> = TableCache<RemoteModule, TableName>;\n\n/**\n * This is a helper class that provides a mapping from table names to their corresponding TableCache instances\n * while preserving the correspondence between the key and value type.\n */\nclass TableMap<RemoteModule extends UntypedRemoteModule> {\n  private readonly map: Map<\n    string,\n    TableCacheForTableName<RemoteModule, TableName<RemoteModule>>\n  > = new Map();\n\n  get<K extends TableName<RemoteModule>>(\n    key: K\n  ): TableCacheForTableName<RemoteModule, K> | undefined {\n    // Cast required: a Map<string, Union> can't refine the union to the exact K-specific member on get<K>(key: K).\n    return this.map.get(key) as\n      | TableCacheForTableName<RemoteModule, K>\n      | undefined;\n  }\n\n  set<K extends TableName<RemoteModule>>(\n    key: K,\n    value: TableCacheForTableName<RemoteModule, K>\n  ): this {\n    this.map.set(key, value);\n    return this;\n  }\n\n  has(key: TableName<RemoteModule>): boolean {\n    return this.map.has(key);\n  }\n\n  delete(key: TableName<RemoteModule>): boolean {\n    return this.map.delete(key);\n  }\n\n  // optional: iteration stays broadly typed (cannot express per-key relation here)\n  keys(): IterableIterator<string> {\n    return this.map.keys();\n  }\n  values(): IterableIterator<\n    TableCacheForTableName<RemoteModule, TableName<RemoteModule>>\n  > {\n    return this.map.values();\n  }\n  entries(): IterableIterator<\n    [string, TableCacheForTableName<RemoteModule, TableName<RemoteModule>>]\n  > {\n    return this.map.entries();\n  }\n  [Symbol.iterator]() {\n    return this.entries();\n  }\n}\n\n/**\n * ClientCache maintains a cache of TableCache instances for each table in the database.\n * It provides methods to get or create TableCache instances by table name,\n * ensuring type safety based on the provided SchemaDef.\n */\nexport class ClientCache<RemoteModule extends UntypedRemoteModule> {\n  /**\n   * The tables in the database.\n   */\n  readonly tables = new TableMap<RemoteModule>();\n\n  /**\n   * Returns the table with the given name.\n   * - If SchemaDef is a concrete schema, `name` is constrained to known table names,\n   *   and the return type matches that table.\n   * - If SchemaDef is undefined, `name` is string and the return type is untyped.\n   */\n  getTable<N extends TableName<RemoteModule>>(\n    name: N\n  ): TableCacheForTableName<RemoteModule, N> {\n    const table = this.tables.get(name);\n    if (!table) {\n      console.error(\n        'The table has not been registered for this client. Please register the table before using it. If you have registered global tables using the SpacetimeDBClient.registerTables() or `registerTable()` method, please make sure that is executed first!'\n      );\n      throw new Error(`Table ${String(name)} does not exist`);\n    }\n    return table;\n  }\n\n  /**\n   * Returns the table with the given name, creating it if needed.\n   * - Typed mode: `tableTypeInfo.tableName` is constrained to known names and\n   *   the return type matches that table.\n   * - Untyped mode: accepts any string and returns an untyped TableCache.\n   */\n  getOrCreateTable<N extends TableName<RemoteModule>>(\n    tableDef: TableDefForTableName<RemoteModule, N>\n  ): TableCacheForTableName<RemoteModule, N> {\n    const name = tableDef.accessorName;\n\n    const table = this.tables.get(name);\n    if (table) {\n      return table;\n    }\n\n    const newTable = new TableCacheImpl<RemoteModule, N>(\n      tableDef\n    ) as TableCache<RemoteModule, N>;\n    this.tables.set(name, newTable);\n    return newTable;\n  }\n}\n","export type PrereleaseId = string | number;\n\nexport type PreRelease = PrereleaseId[];\n\n// Compare pre-release identifiers according to the semver spec (https://semver.org/#spec-item-11).\nfunction comparePreReleases(a: PreRelease, b: PreRelease): number {\n  const len = Math.min(a.length, b.length);\n  for (let i = 0; i < len; i++) {\n    const aPart = a[i];\n    const bPart = b[i];\n    if (aPart === bPart) continue;\n    if (typeof aPart === 'number' && typeof bPart === 'number') {\n      return aPart - bPart;\n    }\n    if (typeof aPart === 'string' && typeof bPart === 'string') {\n      return aPart.localeCompare(bPart);\n    }\n    // According to item 11.4.3, numeric identifiers always have lower precedence than non-numeric identifiers.\n    // So if `a` is a string, it has higher precedence than `b`.\n    return typeof aPart === 'string' ? 1 : -1;\n  }\n  // See rule 11.4.4 in the semver spec.\n  return a.length - b.length;\n}\n\n// We don't use these, and they don't matter for version ordering, so I'm not going to parse it to spec.\nexport type BuildInfo = string;\n\n// This is exported for tests.\nexport class SemanticVersion {\n  major: number;\n  minor: number;\n  patch: number;\n  preRelease: PreRelease | null;\n  buildInfo: BuildInfo | null;\n\n  constructor(\n    major: number,\n    minor: number,\n    patch: number,\n    preRelease: PreRelease | null = null,\n    buildInfo: BuildInfo | null = null\n  ) {\n    this.major = major;\n    this.minor = minor;\n    this.patch = patch;\n    this.preRelease = preRelease;\n    this.buildInfo = buildInfo;\n  }\n\n  toString(): string {\n    let versionString = `${this.major}.${this.minor}.${this.patch}`;\n    if (this.preRelease) {\n      versionString += `-${this.preRelease.join('.')}`;\n    }\n    if (this.buildInfo) {\n      versionString += `+${this.buildInfo}`;\n    }\n    return versionString;\n  }\n\n  compare(other: SemanticVersion): number {\n    if (this.major !== other.major) {\n      return this.major - other.major;\n    }\n    if (this.minor !== other.minor) {\n      return this.minor - other.minor;\n    }\n    if (this.patch !== other.patch) {\n      return this.patch - other.patch;\n    }\n    if (this.preRelease && other.preRelease) {\n      return comparePreReleases(this.preRelease, other.preRelease);\n    }\n    if (this.preRelease) {\n      return -1; // The version without a pre-release is greater.\n    }\n    if (other.preRelease) {\n      return -1; // Since we don't have a pre-release, this version is greater.\n    }\n    return 0; // versions are equal\n  }\n\n  clone(): SemanticVersion {\n    return new SemanticVersion(\n      this.major,\n      this.minor,\n      this.patch,\n      this.preRelease ? [...this.preRelease] : null,\n      this.buildInfo\n    );\n  }\n\n  static parseVersionString(version: string): SemanticVersion {\n    const regex =\n      /^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(?:-([\\da-zA-Z-]+(?:\\.[\\da-zA-Z-]+)*))?(?:\\+([\\da-zA-Z-]+(?:\\.[\\da-zA-Z-]+)*))?$/;\n    const match = version.match(regex);\n    if (!match) {\n      throw new Error(`Invalid version string: ${version}`);\n    }\n\n    const major = parseInt(match[1], 10);\n    const minor = parseInt(match[2], 10);\n    const patch = parseInt(match[3], 10);\n    const preRelease = match[4]\n      ? match[4].split('.').map(id => (isNaN(Number(id)) ? id : Number(id)))\n      : null;\n    const buildInfo = match[5] || null;\n\n    return new SemanticVersion(major, minor, patch, preRelease, buildInfo);\n  }\n}\n\n// The SDK depends on some module information that was not generated before this version.\nexport const _MINIMUM_CLI_VERSION: SemanticVersion = new SemanticVersion(\n  1,\n  4,\n  0\n);\n\nexport function ensureMinimumVersionOrThrow(versionString?: string): void {\n  if (versionString === undefined) {\n    throw new Error(versionErrorMessage(versionString));\n  }\n  const version = SemanticVersion.parseVersionString(versionString);\n  if (version.compare(_MINIMUM_CLI_VERSION) < 0) {\n    throw new Error(versionErrorMessage(versionString));\n  }\n}\n\nfunction versionErrorMessage(incompatibleVersion?: string): string {\n  return `Module code was generated with an incompatible version of the spacetimedb cli (${incompatibleVersion}). Update the cli version to at least ${_MINIMUM_CLI_VERSION.toString()} and regenerate the bindings. You can upgrade to the latest cli version by running: spacetime version upgrade`;\n}\n","export async function decompress(\n  buffer: Uint8Array,\n  // Leaving it here to expand to brotli when it lands in the browsers and NodeJS\n  type: 'gzip',\n  chunkSize: number = 128 * 1024 // 128KB\n): Promise<Uint8Array> {\n  // Create a single ReadableStream to handle chunks\n  let offset = 0;\n  const readableStream = new ReadableStream({\n    pull(controller) {\n      if (offset < buffer.length) {\n        // Slice a chunk of the buffer and enqueue it\n        const chunk = buffer.subarray(\n          offset,\n          Math.min(offset + chunkSize, buffer.length)\n        );\n        controller.enqueue(chunk);\n        offset += chunkSize;\n      } else {\n        controller.close();\n      }\n    },\n  });\n\n  // Create a single DecompressionStream\n  const decompressionStream = new DecompressionStream(type);\n\n  // Pipe the ReadableStream through the DecompressionStream\n  const decompressedStream = readableStream.pipeThrough(decompressionStream);\n\n  // Collect the decompressed chunks efficiently\n  const reader = decompressedStream.getReader();\n  const chunks: Uint8Array[] = [];\n  let totalLength = 0;\n  let result: any;\n\n  while (!(result = await reader.read()).done) {\n    chunks.push(result.value);\n    totalLength += result.value.length;\n  }\n\n  // Allocate a single Uint8Array for the decompressed data\n  const decompressedArray = new Uint8Array(totalLength);\n  let chunkOffset = 0;\n\n  for (const chunk of chunks) {\n    decompressedArray.set(chunk, chunkOffset);\n    chunkOffset += chunk.length;\n  }\n\n  return decompressedArray;\n}\n","import { stdbLogger } from './logger';\n\nexport async function resolveWS(): Promise<typeof WebSocket> {\n  // Browser or Node >= 22 (or any env that exposes global WebSocket)\n  if (typeof (globalThis as any).WebSocket !== 'undefined') {\n    return (globalThis as any).WebSocket as typeof WebSocket;\n  }\n\n  // Node without a global WebSocket: lazily load undici's polyfill.\n  // Use an unstatable dynamic import so bundlers don't prebundle it.\n  const dynamicImport = new Function('m', 'return import(m)') as (\n    m: string\n  ) => Promise<any>;\n\n  try {\n    const { WebSocket: UndiciWS } = await dynamicImport('undici');\n    return UndiciWS as unknown as typeof WebSocket;\n  } catch (err) {\n    stdbLogger(\n      'warn',\n      '[spacetimedb-sdk] No global WebSocket found. ' +\n        'On Node 1821, please install `undici` (npm install undici) ' +\n        'to enable WebSocket support.'\n    );\n    throw err;\n  }\n}\n","import { decompress } from './decompress';\nimport { resolveWS } from './ws';\n\nexport class WebsocketDecompressAdapter {\n  onclose?: (...ev: any[]) => void;\n  onopen?: (...ev: any[]) => void;\n  onmessage?: (msg: { data: Uint8Array }) => void;\n  onerror?: (msg: ErrorEvent) => void;\n\n  #ws: WebSocket;\n\n  async #handleOnMessage(msg: MessageEvent) {\n    const buffer = new Uint8Array(msg.data);\n    let decompressed: Uint8Array;\n\n    if (buffer[0] === 0) {\n      decompressed = buffer.slice(1);\n    } else if (buffer[0] === 1) {\n      throw new Error(\n        'Brotli Compression not supported. Please use gzip or none compression in withCompression method on DbConnection.'\n      );\n    } else if (buffer[0] === 2) {\n      decompressed = await decompress(buffer.slice(1), 'gzip');\n    } else {\n      throw new Error(\n        'Unexpected Compression Algorithm. Please use `gzip` or `none`'\n      );\n    }\n\n    this.onmessage?.({ data: decompressed });\n  }\n\n  #handleOnOpen(msg: any) {\n    this.onopen?.(msg);\n  }\n\n  #handleOnError(msg: any) {\n    this.onerror?.(msg);\n  }\n\n  #handleOnClose(msg: any) {\n    this.onclose?.(msg);\n  }\n\n  send(msg: any): void {\n    this.#ws.send(msg);\n  }\n\n  close(): void {\n    this.#ws.close();\n  }\n\n  constructor(ws: WebSocket) {\n    this.onmessage = undefined;\n    this.onopen = undefined;\n    this.onmessage = undefined;\n    this.onerror = undefined;\n\n    ws.onmessage = this.#handleOnMessage.bind(this);\n    ws.onerror = this.#handleOnError.bind(this);\n    ws.onclose = this.#handleOnClose.bind(this);\n    ws.onopen = this.#handleOnOpen.bind(this);\n\n    ws.binaryType = 'arraybuffer';\n\n    this.#ws = ws;\n  }\n\n  static async createWebSocketFn({\n    url,\n    nameOrAddress,\n    wsProtocol,\n    authToken,\n    compression,\n    lightMode,\n    confirmedReads,\n  }: {\n    url: URL;\n    wsProtocol: string;\n    nameOrAddress: string;\n    authToken?: string;\n    compression: 'gzip' | 'none';\n    lightMode: boolean;\n    confirmedReads?: boolean;\n  }): Promise<WebsocketDecompressAdapter> {\n    const headers = new Headers();\n\n    const WS = await resolveWS();\n\n    // We swap our original token to a shorter-lived token\n    // to avoid sending the original via query params.\n    let temporaryAuthToken: string | undefined = undefined;\n    if (authToken) {\n      headers.set('Authorization', `Bearer ${authToken}`);\n      const tokenUrl = new URL('v1/identity/websocket-token', url);\n      tokenUrl.protocol = url.protocol === 'wss:' ? 'https:' : 'http:';\n\n      const response = await fetch(tokenUrl, { method: 'POST', headers });\n      if (response.ok) {\n        const { token } = await response.json();\n        temporaryAuthToken = token;\n      } else {\n        return Promise.reject(\n          new Error(`Failed to verify token: ${response.statusText}`)\n        );\n      }\n    }\n\n    const databaseUrl = new URL(`v1/database/${nameOrAddress}/subscribe`, url);\n    if (temporaryAuthToken) {\n      databaseUrl.searchParams.set('token', temporaryAuthToken);\n    }\n    databaseUrl.searchParams.set(\n      'compression',\n      compression === 'gzip' ? 'Gzip' : 'None'\n    );\n    if (lightMode) {\n      databaseUrl.searchParams.set('light', 'true');\n    }\n    if (confirmedReads !== undefined) {\n      databaseUrl.searchParams.set('confirmed', confirmedReads.toString());\n    }\n\n    const ws = new WS(databaseUrl.toString(), wsProtocol);\n\n    return new WebsocketDecompressAdapter(ws);\n  }\n}\n","import { DbConnectionImpl, type ConnectionEvent } from './db_connection_impl';\nimport { EventEmitter } from './event_emitter';\nimport type {\n  DbConnectionConfig,\n  ErrorContextInterface,\n  Identity,\n  RemoteModuleOf,\n} from '../';\nimport { ensureMinimumVersionOrThrow } from './version';\nimport { WebsocketDecompressAdapter } from './websocket_decompress_adapter';\n\n/**\n * The database client connection to a SpacetimeDB server.\n * NOTE: DbConnectionImpl<any> is used here because UntypedRemoteModule causes\n * variance issues with function paramters, and the end user will never be\n * constructing a DbConnectionBuilder directly since it's code generated. We will\n * always have a concrete RemoteModule type in those cases. Even if they user\n * did do this, they would just lose type safety on the RemoteModule.\n */\nexport class DbConnectionBuilder<DbConnection extends DbConnectionImpl<any>> {\n  #uri?: URL;\n  #nameOrAddress?: string;\n  #identity?: Identity;\n  #token?: string;\n  #emitter: EventEmitter<ConnectionEvent> = new EventEmitter();\n  #compression: 'gzip' | 'none' = 'gzip';\n  #lightMode: boolean = false;\n  #confirmedReads?: boolean;\n  #createWSFn: typeof WebsocketDecompressAdapter.createWebSocketFn;\n\n  /**\n   * Creates a new `DbConnectionBuilder` database client and set the initial parameters.\n   *\n   * Users are not expected to call this constructor directly. Instead, use the static method `DbConnection.builder()`.\n   *\n   * @param remoteModule The remote module to use to connect to the SpacetimeDB server.\n   * @param dbConnectionConstructor The constructor to use to create a new `DbConnection`.\n   */\n  constructor(\n    private remoteModule: RemoteModuleOf<DbConnection>,\n    private dbConnectionCtor: (\n      config: DbConnectionConfig<RemoteModuleOf<DbConnection>>\n    ) => DbConnection\n  ) {\n    this.#createWSFn = WebsocketDecompressAdapter.createWebSocketFn;\n  }\n\n  /**\n   * Set the URI of the SpacetimeDB server to connect to.\n   *\n   * @param uri The URI of the SpacetimeDB server to connect to.\n   *\n   **/\n  withUri(uri: string | URL): this {\n    this.#uri = new URL(uri);\n    return this;\n  }\n\n  /**\n   * Set the name or Identity of the remote database to connect to.\n   *\n   * @param nameOrAddress\n   *\n   * @returns The `DbConnectionBuilder` instance.\n   */\n  withDatabaseName(nameOrAddress: string): this {\n    this.#nameOrAddress = nameOrAddress;\n    return this;\n  }\n\n  /**\n   * Set the identity of the client to connect to the database.\n   *\n   * @param token The credentials to use to authenticate with SpacetimeDB. This\n   * is optional. You can store the token returned by the `onConnect` callback\n   * to use in future connections.\n   *\n   * @returns The `DbConnectionBuilder` instance.\n   */\n  withToken(token?: string): this {\n    this.#token = token;\n    return this;\n  }\n\n  withWSFn(\n    createWSFn: typeof WebsocketDecompressAdapter.createWebSocketFn\n  ): this {\n    this.#createWSFn = createWSFn;\n    return this;\n  }\n\n  /**\n   * Set the compression algorithm to use for the connection.\n   *\n   * @param compression The compression algorithm to use for the connection.\n   */\n  withCompression(compression: 'gzip' | 'none'): this {\n    this.#compression = compression;\n    return this;\n  }\n\n  /**\n   * Sets the connection to operate in light mode.\n   *\n   * Light mode is a mode that reduces the amount of data sent over the network.\n   *\n   * @param lightMode The light mode for the connection.\n   */\n  withLightMode(lightMode: boolean): this {\n    this.#lightMode = lightMode;\n    return this;\n  }\n\n  /**\n   * Sets the connection to use confirmed reads.\n   *\n   * When enabled, the server will send query results only after they are\n   * confirmed to be durable.\n   *\n   * What durable means depends on the server configuration: a single node\n   * server may consider a transaction durable once it is `fsync`'ed to disk,\n   * whereas a cluster may require that some number of replicas have\n   * acknowledge that they have stored the transactions.\n   *\n   * Note that enabling confirmed reads will increase the latency between a\n   * reducer call and the corresponding subscription update arriving at the\n   * client.\n   *\n   * If this method is not called, not preference is sent to the server, and\n   * the server will choose the default.\n   *\n   * @param confirmedReads `true` to enable confirmed reads, `false` to disable.\n   */\n  withConfirmedReads(confirmedReads: boolean): this {\n    this.#confirmedReads = confirmedReads;\n    return this;\n  }\n\n  /**\n   * Register a callback to be invoked upon authentication with the database.\n   *\n   * @param identity A unique identifier for a client connected to a database.\n   * @param token The credentials to use to authenticate with SpacetimeDB.\n   *\n   * @returns The `DbConnectionBuilder` instance.\n   *\n   * The callback will be invoked with the `Identity` and private authentication `token` provided by the database to identify this connection.\n   *\n   * If credentials were supplied to connect, those passed to the callback will be equivalent to the ones used to connect.\n   *\n   * If the initial connection was anonymous, a new set of credentials will be generated by the database to identify this user.\n   *\n   * The credentials passed to the callback can be saved and used to authenticate the same user in future connections.\n   *\n   * @example\n   *\n   * ```ts\n   * DbConnection.builder().onConnect((ctx, identity, token) => {\n   *  console.log(\"Connected to SpacetimeDB with identity:\", identity.toHexString());\n   * });\n   * ```\n   */\n  onConnect(\n    callback: (\n      connection: DbConnection,\n      identity: Identity,\n      token: string\n    ) => void\n  ): this {\n    this.#emitter.on('connect', callback);\n    return this;\n  }\n\n  /**\n   * Register a callback to be invoked upon an error.\n   *\n   * @example\n   *\n   * ```ts\n   * DbConnection.builder().onConnectError((ctx, error) => {\n   *   console.log(\"Error connecting to SpacetimeDB:\", error);\n   * });\n   * ```\n   */\n  onConnectError(\n    callback: (\n      ctx: ErrorContextInterface<RemoteModuleOf<DbConnection>>,\n      error: Error\n    ) => void\n  ): this {\n    this.#emitter.on('connectError', callback);\n    return this;\n  }\n\n  /**\n   * Registers a callback to run when a {@link DbConnection} whose connection initially succeeded\n   * is disconnected, either after a {@link DbConnection.disconnect()} call or due to an error.\n   *\n   * If the connection ended because of an error, the error is passed to the callback.\n   *\n   * The `callback` will be installed on the `DbConnection` created by `build`\n   * before initiating the connection, ensuring there's no opportunity for the disconnect to happen\n   * before the callback is installed.\n   *\n   * Note that this does not trigger if `build` fails\n   * or in cases where {@link DbConnectionBuilder.onConnectError} would trigger.\n   * This callback only triggers if the connection closes after `build` returns successfully\n   * and {@link DbConnectionBuilder.onConnect} is invoked, i.e., after the initial connection\n   * message is received.\n   *\n   * To simplify SDK implementation, at most one such callback can be registered.\n   * Calling `onDisconnect` on the same `DbConnectionBuilder` multiple times throws an error.\n   *\n   * Unlike callbacks registered via {@link DbConnection},\n   * no mechanism is provided to unregister the provided callback.\n   * This is a concession to ergonomics; there's no clean place to return a `CallbackId` from this method\n   * or from `build`.\n   *\n   * @param {function(error?: Error): void} callback - The callback to invoke upon disconnection.\n   * @throws {Error} Throws an error if called multiple times on the same `DbConnectionBuilder`.\n   */\n  onDisconnect(\n    callback: (\n      ctx: ErrorContextInterface<RemoteModuleOf<DbConnection>>,\n      error?: Error | undefined\n    ) => void\n  ): this {\n    this.#emitter.on('disconnect', callback);\n    return this;\n  }\n\n  getUri(): string {\n    return this.#uri?.toString() ?? '';\n  }\n\n  getModuleName(): string {\n    return this.#nameOrAddress ?? '';\n  }\n\n  /**\n   * Builds a new `DbConnection` with the parameters set on this `DbConnectionBuilder` and attempts to connect to the SpacetimeDB server.\n   *\n   * @returns A new `DbConnection` with the parameters set on this `DbConnectionBuilder`.\n   *\n   * @example\n   *\n   * ```ts\n   * const host = \"http://localhost:3000\";\n   * const name_or_address = \"database_name\"\n   * const auth_token = undefined;\n   * DbConnection.builder().withUri(host).withDatabaseName(name_or_address).withToken(auth_token).build();\n   * ```\n   */\n  build(): DbConnection {\n    if (!this.#uri) {\n      throw new Error('URI is required to connect to SpacetimeDB');\n    }\n\n    if (!this.#nameOrAddress) {\n      throw new Error(\n        'Database name or address is required to connect to SpacetimeDB'\n      );\n    }\n    // We could consider making this an `onConnectError` instead of throwing here.\n    // Ideally, it would be a compile time error, but I'm not sure how to accomplish that.\n    ensureMinimumVersionOrThrow(this.remoteModule.versionInfo?.cliVersion);\n\n    return this.dbConnectionCtor({\n      uri: this.#uri,\n      nameOrAddress: this.#nameOrAddress,\n      identity: this.#identity,\n      token: this.#token,\n      emitter: this.#emitter,\n      compression: this.#compression,\n      lightMode: this.#lightMode,\n      confirmedReads: this.#confirmedReads,\n      createWSFn: this.#createWSFn,\n      remoteModule: this.remoteModule,\n    });\n  }\n}\n","// Internal symbols not exported from the public SDK surface.\nexport const INTERNAL_REMOTE_MODULE = Symbol('INTERNAL_REMOTE_MODULE');\n","import type { DbConnectionImpl } from './db_connection_impl';\nimport { INTERNAL_REMOTE_MODULE } from './internal';\nimport type {\n  ErrorContextInterface,\n  SubscriptionEventContextInterface,\n} from './event_context';\nimport { EventEmitter } from './event_emitter';\nimport type { UntypedRemoteModule } from './spacetime_module';\nimport { isRowTypedQuery, toSql, type RowTypedQuery } from '../lib/query';\nimport type { Values } from '../lib/type_util';\n\nexport class SubscriptionBuilderImpl<RemoteModule extends UntypedRemoteModule> {\n  #onApplied?: (ctx: SubscriptionEventContextInterface<RemoteModule>) => void =\n    undefined;\n  #onError?: (ctx: ErrorContextInterface<RemoteModule>) => void = undefined;\n  constructor(private db: DbConnectionImpl<RemoteModule>) {}\n\n  /**\n   * Registers `callback` to run when this query is successfully added to our subscribed set,\n   * I.e. when its `SubscriptionApplied` message is received.\n   *\n   * The database state exposed via the `&EventContext` argument\n   * includes all the rows added to the client cache as a result of the new subscription.\n   *\n   * The event in the `&EventContext` argument is `Event::SubscribeApplied`.\n   *\n   * Multiple `on_applied` callbacks for the same query may coexist.\n   * No mechanism for un-registering `on_applied` callbacks is exposed.\n   *\n   * @param cb - Callback to run when the subscription is applied.\n   * @returns The current `SubscriptionBuilder` instance.\n   */\n  onApplied(\n    cb: (ctx: SubscriptionEventContextInterface<RemoteModule>) => void\n  ): SubscriptionBuilderImpl<RemoteModule> {\n    this.#onApplied = cb;\n    return this;\n  }\n\n  /**\n   * Registers `callback` to run when this query either:\n   * - Fails to be added to our subscribed set.\n   * - Is unexpectedly removed from our subscribed set.\n   *\n   * If the subscription had previously started and has been unexpectedly removed,\n   * the database state exposed via the `&EventContext` argument contains no rows\n   * from any subscriptions removed within the same error event.\n   * As proposed, it must therefore contain no rows.\n   *\n   * The event in the `&EventContext` argument is `Event::SubscribeError`,\n   * containing a dynamic error object with a human-readable description of the error\n   * for diagnostic purposes.\n   *\n   * Multiple `on_error` callbacks for the same query may coexist.\n   * No mechanism for un-registering `on_error` callbacks is exposed.\n   *\n   * @param cb - Callback to run when there is an error in subscription.\n   * @returns The current `SubscriptionBuilder` instance.\n   */\n  onError(\n    cb: (ctx: ErrorContextInterface<RemoteModule>) => void\n  ): SubscriptionBuilderImpl<RemoteModule> {\n    this.#onError = cb;\n    return this;\n  }\n\n  /**\n   * Subscribe to a single query. The results of the query will be merged into the client\n   * cache and deduplicated on the client.\n   *\n   * @param query_sql A `SQL` query to subscribe to.\n   *\n   * @example\n   *\n   * ```ts\n   * const subscription = connection.subscriptionBuilder().onApplied(() => {\n   *   console.log(\"SDK client cache initialized.\");\n   * }).subscribe(\"SELECT * FROM User\");\n   *\n   * subscription.unsubscribe();\n   * ```\n   */\n  subscribe(\n    query_sql: string | RowTypedQuery<any, any>\n  ): SubscriptionHandleImpl<RemoteModule>;\n  subscribe(\n    query_sql: Array<string | RowTypedQuery<any, any>>\n  ): SubscriptionHandleImpl<RemoteModule>;\n  subscribe(\n    queryFn: (\n      tables: Values<RemoteModule['tables']>\n    ) => RowTypedQuery<any, any> | RowTypedQuery<any, any>[]\n  ): SubscriptionHandleImpl<RemoteModule>;\n  subscribe(\n    query_sql:\n      | string\n      | RowTypedQuery<any, any>\n      | Array<string | RowTypedQuery<any, any>>\n      | ((tables: any) => RowTypedQuery<any, any> | RowTypedQuery<any, any>[])\n  ): SubscriptionHandleImpl<RemoteModule> {\n    let queries: Array<string | RowTypedQuery<any, any>>;\n    if (typeof query_sql === 'function') {\n      const tablesMap = this.db.getTablesMap?.();\n      const result = query_sql(tablesMap);\n      queries = Array.isArray(result) ? result : [result];\n    } else {\n      queries = Array.isArray(query_sql) ? query_sql : [query_sql];\n    }\n    if (queries.length === 0) {\n      throw new Error('Subscriptions must have at least one query');\n    }\n    const queryStrings = queries.map(q => {\n      if (typeof q === 'string') return q;\n      if (isRowTypedQuery(q)) return toSql(q);\n      throw new Error('Subscriptions must be SQL strings or typed queries');\n    });\n    return new SubscriptionHandleImpl(\n      this.db,\n      queryStrings,\n      this.#onApplied,\n      this.#onError\n    );\n  }\n\n  /**\n   * Subscribes to all rows from all tables.\n   *\n   * This method is intended as a convenience\n   * for applications where client-side memory use and network bandwidth are not concerns.\n   * Applications where these resources are a constraint\n   * should register more precise queries via `subscribe`\n   * in order to replicate only the subset of data which the client needs to function.\n   *\n   * This method should not be combined with `subscribe` on the same `DbConnection`.\n   * A connection may either `subscribe` to particular queries,\n   * or `subscribeToAllTables`, but not both.\n   * Attempting to call `subscribe`\n   * on a `DbConnection` that has previously used `subscribeToAllTables`,\n   * or vice versa, may misbehave in any number of ways,\n   * including dropping subscriptions, corrupting the client cache, or throwing errors.\n   */\n  subscribeToAllTables(): void {\n    const remoteModule = this.db[INTERNAL_REMOTE_MODULE]();\n    const queries = Object.values(remoteModule.tables).map(\n      table => `SELECT * FROM ${table.sourceName}`\n    );\n    this.subscribe(queries);\n  }\n}\n\nexport type SubscribeEvent = 'applied' | 'error' | 'end';\n\nexport class SubscriptionManager<RemoteModule extends UntypedRemoteModule> {\n  subscriptions: Map<\n    number,\n    {\n      handle: SubscriptionHandleImpl<RemoteModule>;\n      emitter: EventEmitter<SubscribeEvent>;\n    }\n  > = new Map();\n}\n\nexport class SubscriptionHandleImpl<RemoteModule extends UntypedRemoteModule> {\n  #querySetId: number;\n  #unsubscribeCalled: boolean = false;\n  #endedState: boolean = false;\n  #activeState: boolean = false;\n  #emitter: EventEmitter<SubscribeEvent, (...args: any[]) => void> =\n    new EventEmitter();\n\n  constructor(\n    private db: DbConnectionImpl<RemoteModule>,\n    querySql: string[],\n    onApplied?: (ctx: SubscriptionEventContextInterface<RemoteModule>) => void,\n    onError?: (ctx: ErrorContextInterface<RemoteModule>, error: Error) => void\n  ) {\n    this.#emitter.on(\n      'applied',\n      (ctx: SubscriptionEventContextInterface<RemoteModule>) => {\n        this.#activeState = true;\n        if (onApplied) {\n          onApplied(ctx);\n        }\n      }\n    );\n    this.#emitter.on(\n      'error',\n      (ctx: ErrorContextInterface<RemoteModule>, error: Error) => {\n        this.#activeState = false;\n        this.#endedState = true;\n        if (onError) {\n          onError(ctx, error);\n        }\n      }\n    );\n    this.#querySetId = this.db.registerSubscription(\n      this,\n      this.#emitter,\n      querySql\n    );\n  }\n\n  /**\n   * Consumes self and issues an `Unsubscribe` message,\n   * removing this query from the client's set of subscribed queries.\n   * It is only valid to call this method if `is_active()` is `true`.\n   */\n  unsubscribe(): void {\n    if (this.#unsubscribeCalled) {\n      throw new Error('Unsubscribe has already been called');\n    }\n    this.#unsubscribeCalled = true;\n    this.db.unregisterSubscription(this.#querySetId);\n    this.#emitter.on(\n      'end',\n      (_ctx: SubscriptionEventContextInterface<RemoteModule>) => {\n        this.#endedState = true;\n        this.#activeState = false;\n      }\n    );\n  }\n\n  /**\n   * Unsubscribes and also registers a callback to run upon success.\n   * I.e. when an `UnsubscribeApplied` message is received.\n   *\n   * If `Unsubscribe` returns an error,\n   * or if the `on_error` callback(s) are invoked before this subscription would end normally,\n   * the `on_end` callback is not invoked.\n   *\n   * @param onEnd - Callback to run upon successful unsubscribe.\n   */\n  unsubscribeThen(\n    onEnd: (ctx: SubscriptionEventContextInterface<RemoteModule>) => void\n  ): void {\n    if (this.#endedState) {\n      throw new Error('Subscription has already ended');\n    }\n    if (this.#unsubscribeCalled) {\n      throw new Error('Unsubscribe has already been called');\n    }\n    this.#unsubscribeCalled = true;\n    this.db.unregisterSubscription(this.#querySetId);\n    this.#emitter.on(\n      'end',\n      (ctx: SubscriptionEventContextInterface<RemoteModule>) => {\n        this.#endedState = true;\n        this.#activeState = false;\n        onEnd(ctx);\n      }\n    );\n  }\n\n  /**\n   * True if this `SubscriptionHandle` has ended,\n   * either due to an error or a call to `unsubscribe`.\n   *\n   * This is initially false, and becomes true when either the `on_end` or `on_error` callback is invoked.\n   * A subscription which has not yet been applied is not active, but is also not ended.\n   */\n  isEnded(): boolean {\n    return this.#endedState;\n  }\n\n  /**\n   * True if this `SubscriptionHandle` is active, meaning it has been successfully applied\n   * and has not since ended, either due to an error or a complete `unsubscribe` request-response pair.\n   *\n   * This corresponds exactly to the interval bounded at the start by the `on_applied` callback\n   * and at the end by either the `on_end` or `on_error` callback.\n   */\n  isActive(): boolean {\n    return this.#activeState;\n  }\n}\n","import { ConnectionId, ProductBuilder, ProductType } from '../';\nimport { AlgebraicType, type ComparablePrimitive } from '../';\nimport { BinaryReader } from '../';\nimport { BinaryWriter } from '../';\nimport {\n  BsatnRowList,\n  ClientMessage,\n  QueryRows,\n  QuerySetUpdate,\n  ServerMessage,\n  TableUpdateRows,\n  UnsubscribeFlags,\n} from './client_api/types';\nimport { ClientCache } from './client_cache.ts';\nimport { DbConnectionBuilder } from './db_connection_builder.ts';\nimport { INTERNAL_REMOTE_MODULE } from './internal.ts';\nimport { type DbContext } from './db_context.ts';\nimport type { Event } from './event.ts';\nimport {\n  type ErrorContextInterface,\n  type EventContextInterface,\n  type ReducerEventContextInterface,\n  type SubscriptionEventContextInterface,\n} from './event_context.ts';\nimport { EventEmitter } from './event_emitter.ts';\nimport type { Deserializer, Identity, InferTypeOfRow, Serializer } from '../';\nimport type {\n  ProcedureResultMessage,\n  ReducerResultMessage,\n} from './message_types.ts';\nimport type { ReducerEvent } from './reducer_event.ts';\nimport { type UntypedRemoteModule } from './spacetime_module.ts';\nimport { makeQueryBuilder } from '../lib/query';\nimport {\n  type TableCache,\n  type Operation,\n  type PendingCallback,\n  type TableUpdate as CacheTableUpdate,\n} from './table_cache.ts';\nimport { WebsocketDecompressAdapter } from './websocket_decompress_adapter.ts';\nimport type { WebsocketTestAdapter } from './websocket_test_adapter.ts';\nimport {\n  SubscriptionBuilderImpl,\n  SubscriptionHandleImpl,\n  SubscriptionManager,\n  type SubscribeEvent,\n} from './subscription_builder_impl.ts';\nimport { stdbLogger, stringify } from './logger.ts';\nimport { fromByteArray } from 'base64-js';\nimport type {\n  ReducerEventInfo,\n  ReducersView,\n  SubscriptionEventCallback,\n} from './reducers.ts';\nimport type { ClientDbView } from './db_view.ts';\nimport type { RowType, UntypedTableDef } from '../lib/table.ts';\nimport type { ProceduresView } from './procedures.ts';\nimport type { Values } from '../lib/type_util.ts';\nimport type { TransactionUpdate } from './client_api/types.ts';\nimport { InternalError, SenderError } from '../lib/errors.ts';\n\nexport {\n  DbConnectionBuilder,\n  SubscriptionBuilderImpl,\n  SubscriptionHandleImpl,\n  type TableCache,\n  type Event,\n};\n\nexport type RemoteModuleOf<C> =\n  C extends DbConnectionImpl<infer RM> ? RM : never;\n\nexport type {\n  DbContext,\n  EventContextInterface,\n  ReducerEventContextInterface,\n  SubscriptionEventContextInterface,\n  ErrorContextInterface,\n  ReducerEvent,\n};\n\nexport type ConnectionEvent = 'connect' | 'disconnect' | 'connectError';\n\nexport type DbConnectionConfig<RemoteModule extends UntypedRemoteModule> = {\n  uri: URL;\n  nameOrAddress: string;\n  identity?: Identity;\n  token?: string;\n  emitter: EventEmitter<ConnectionEvent>;\n  createWSFn: typeof WebsocketDecompressAdapter.createWebSocketFn;\n  compression: 'gzip' | 'none';\n  lightMode: boolean;\n  confirmedReads?: boolean;\n  remoteModule: RemoteModule;\n};\n\ntype ProcedureCallback = (result: ProcedureResultMessage['result']) => void;\n\nexport class DbConnectionImpl<RemoteModule extends UntypedRemoteModule>\n  implements DbContext<RemoteModule>\n{\n  /**\n   * Whether or not the connection is active.\n   */\n  isActive = false;\n\n  /**\n   * This connection's public identity.\n   */\n  identity?: Identity = undefined;\n\n  /**\n   * This connection's private authentication token.\n   */\n  token?: string = undefined;\n\n  /** @internal */\n  [INTERNAL_REMOTE_MODULE](): RemoteModule {\n    return this.#remoteModule;\n  }\n\n  /**\n   * The accessor field to access the tables in the database and associated\n   * callback functions.\n   */\n  db: ClientDbView<RemoteModule>;\n\n  /**\n   * The accessor field to access the reducers in the database.\n   */\n  reducers: ReducersView<RemoteModule>;\n\n  /**\n   * The accessor field to access the procedures in the database.\n   */\n  procedures: ProceduresView<RemoteModule>;\n\n  /**\n   * The `ConnectionId` of the connection to to the database.\n   */\n  connectionId: ConnectionId = ConnectionId.random();\n\n  // These fields are meant to be strictly private.\n  #queryId = 0;\n  #requestId = 0;\n  #eventId = 0;\n  #emitter: EventEmitter<ConnectionEvent>;\n  #messageQueue = Promise.resolve();\n  #outboundQueue: ClientMessage[] = [];\n  #subscriptionManager = new SubscriptionManager<RemoteModule>();\n  #remoteModule: RemoteModule;\n  #reducerCallbacks = new Map<\n    number,\n    (result: ReducerResultMessage['result']) => void\n  >();\n  #reducerCallInfo = new Map<number, { name: string; args: object }>();\n  #procedureCallbacks = new Map<number, ProcedureCallback>();\n  #rowDeserializers: Record<string, Deserializer<any>>;\n  #reducerArgsSerializers: Record<\n    string,\n    { serialize: Serializer<any>; deserialize: Deserializer<any> }\n  >;\n  #procedureSerializers: Record<\n    string,\n    { serializeArgs: Serializer<any>; deserializeReturn: Deserializer<any> }\n  >;\n  #sourceNameToTableDef: Record<string, Values<RemoteModule['tables']>>;\n\n  // These fields are not part of the public API, but in a pinch you\n  // could use JavaScript to access them by bypassing TypeScript's\n  // private fields.\n  // We use them in testing.\n  private clientCache: ClientCache<RemoteModule>;\n  private ws?: WebsocketDecompressAdapter | WebsocketTestAdapter;\n  private wsPromise: Promise<\n    WebsocketDecompressAdapter | WebsocketTestAdapter | undefined\n  >;\n\n  constructor({\n    uri,\n    nameOrAddress,\n    identity,\n    token,\n    emitter,\n    remoteModule,\n    createWSFn,\n    compression,\n    lightMode,\n    confirmedReads,\n  }: DbConnectionConfig<RemoteModule>) {\n    stdbLogger('info', 'Connecting to SpacetimeDB WS...');\n\n    // We use .toString() here because some versions of React Native contain a bug where the URL constructor\n    // incorrectly treats a URL instance as a plain string.\n    // This results in an attempt to call .endsWith() on it, leading to an error.\n    const url = new URL(uri.toString());\n    if (!/^wss?:/.test(uri.protocol)) {\n      url.protocol = url.protocol === 'https:' ? 'wss:' : 'ws:';\n    }\n\n    this.identity = identity;\n    this.token = token;\n\n    this.#remoteModule = remoteModule;\n    this.#emitter = emitter;\n\n    this.#rowDeserializers = Object.create(null);\n    this.#sourceNameToTableDef = Object.create(null);\n    for (const table of Object.values(remoteModule.tables)) {\n      this.#rowDeserializers[table.sourceName] = ProductType.makeDeserializer(\n        table.rowType\n      );\n      this.#sourceNameToTableDef[table.sourceName] = table as Values<\n        RemoteModule['tables']\n      >;\n    }\n\n    this.#reducerArgsSerializers = Object.create(null);\n    for (const reducer of remoteModule.reducers) {\n      this.#reducerArgsSerializers[reducer.name] = {\n        serialize: ProductType.makeSerializer(reducer.paramsType),\n        deserialize: ProductType.makeDeserializer(reducer.paramsType),\n      };\n    }\n\n    this.#procedureSerializers = Object.create(null);\n    for (const procedure of remoteModule.procedures) {\n      this.#procedureSerializers[procedure.name] = {\n        serializeArgs: ProductType.makeSerializer(\n          new ProductBuilder(procedure.params).algebraicType.value\n        ),\n        deserializeReturn: AlgebraicType.makeDeserializer(\n          procedure.returnType.algebraicType\n        ),\n      };\n    }\n\n    const connectionId = this.connectionId.toHexString();\n    url.searchParams.set('connection_id', connectionId);\n\n    this.clientCache = new ClientCache<RemoteModule>();\n    this.db = this.#makeDbView();\n    this.reducers = this.#makeReducers(remoteModule);\n    this.procedures = this.#makeProcedures(remoteModule);\n\n    this.wsPromise = createWSFn({\n      url,\n      nameOrAddress,\n      wsProtocol: 'v2.bsatn.spacetimedb',\n      authToken: token,\n      compression: compression,\n      lightMode: lightMode,\n      confirmedReads: confirmedReads,\n    })\n      .then(v => {\n        this.ws = v;\n\n        this.ws.onclose = () => {\n          this.#emitter.emit('disconnect', this);\n          this.isActive = false;\n        };\n        this.ws.onerror = (e: ErrorEvent) => {\n          this.#emitter.emit('connectError', this, e);\n          this.isActive = false;\n        };\n        this.ws.onopen = this.#handleOnOpen.bind(this);\n        this.ws.onmessage = this.#handleOnMessage.bind(this);\n        return v;\n      })\n      .catch(e => {\n        stdbLogger('error', 'Error connecting to SpacetimeDB WS');\n        this.#emitter.emit('connectError', this, e);\n\n        return undefined;\n      });\n  }\n\n  #getNextQueryId = () => {\n    const queryId = this.#queryId;\n    this.#queryId += 1;\n    return queryId;\n  };\n\n  #getNextRequestId = () => this.#requestId++;\n\n  #makeDbView(): ClientDbView<RemoteModule> {\n    const view = Object.create(null) as ClientDbView<RemoteModule>;\n\n    for (const tbl of Object.values(this.#sourceNameToTableDef)) {\n      // ClientDbView uses this name verbatim\n      const key = tbl.accessorName;\n      Object.defineProperty(view, key, {\n        enumerable: true,\n        configurable: false,\n        get: () => this.clientCache.getOrCreateTable(tbl),\n      });\n    }\n\n    return view;\n  }\n\n  #makeReducers(def: RemoteModule): ReducersView<RemoteModule> {\n    const out: Record<string, unknown> = {};\n\n    for (const reducer of def.reducers) {\n      const reducerName = reducer.name;\n      const key = reducer.accessorName;\n\n      const { serialize: serializeArgs } =\n        this.#reducerArgsSerializers[reducerName];\n\n      (out as any)[key] = (params: InferTypeOfRow<typeof reducer.params>) => {\n        const writer = new BinaryWriter(1024);\n        serializeArgs(writer, params);\n        const argsBuffer = writer.getBuffer();\n        return this.callReducer(reducerName, argsBuffer, params);\n      };\n    }\n\n    return out as ReducersView<RemoteModule>;\n  }\n\n  #makeProcedures(def: RemoteModule): ProceduresView<RemoteModule> {\n    const out: Record<string, unknown> = {};\n\n    for (const procedure of def.procedures) {\n      const procedureName = procedure.name;\n      const key = procedure.accessorName;\n\n      const { serializeArgs, deserializeReturn } =\n        this.#procedureSerializers[procedureName];\n\n      (out as any)[key] = (\n        params: InferTypeOfRow<typeof procedure.params>\n      ): Promise<any> => {\n        const writer = new BinaryWriter(1024);\n        serializeArgs(writer, params);\n        const argsBuffer = writer.getBuffer();\n        return this.callProcedure(procedureName, argsBuffer).then(returnBuf => {\n          return deserializeReturn(new BinaryReader(returnBuf));\n        });\n      };\n    }\n\n    return out as ProceduresView<RemoteModule>;\n  }\n\n  #makeEventContext(\n    event: Event<\n      ReducerEventInfo<\n        RemoteModule['reducers'][number]['name'],\n        InferTypeOfRow<RemoteModule['reducers'][number]['params']>\n      >\n    >\n  ): EventContextInterface<RemoteModule> {\n    // Bind methods to preserve `this` (#private fields safe)\n    return {\n      db: this.db,\n      reducers: this.reducers,\n      isActive: this.isActive,\n      subscriptionBuilder: this.subscriptionBuilder.bind(this),\n      disconnect: this.disconnect.bind(this),\n      event,\n    };\n  }\n\n  // NOTE: This is very important!!! This is the actual function that\n  // gets called when you call `connection.subscriptionBuilder()`.\n  // The `subscriptionBuilder` function which is generated, just shadows\n  // this function in the type system, but not the actual implementation!\n  // Do not remove this function, or shoot yourself in the foot please.\n  // It's not clear what would be a better way to do this at this exact\n  // moment.\n  subscriptionBuilder = (): SubscriptionBuilderImpl<RemoteModule> => {\n    return new SubscriptionBuilderImpl(this);\n  };\n\n  getTablesMap(): any {\n    return makeQueryBuilder({ tables: this.#remoteModule.tables } as any);\n  }\n\n  registerSubscription(\n    handle: SubscriptionHandleImpl<RemoteModule>,\n    handleEmitter: EventEmitter<\n      SubscribeEvent,\n      SubscriptionEventCallback<RemoteModule>\n    >,\n    querySql: string[]\n  ): number {\n    const querySetId = this.#getNextQueryId();\n    this.#subscriptionManager.subscriptions.set(querySetId, {\n      handle,\n      emitter: handleEmitter,\n    });\n    const requestId = this.#getNextRequestId();\n    this.#sendMessage(\n      ClientMessage.Subscribe({\n        queryStrings: querySql,\n        querySetId: { id: querySetId },\n        requestId,\n      })\n    );\n    return querySetId;\n  }\n\n  unregisterSubscription(querySetId: number): void {\n    const requestId = this.#getNextRequestId();\n    this.#sendMessage(\n      ClientMessage.Unsubscribe({\n        querySetId: { id: querySetId },\n        requestId,\n        flags: UnsubscribeFlags.SendDroppedRows,\n      })\n    );\n  }\n\n  #parseRowList(\n    type: 'insert' | 'delete',\n    tableName: string,\n    rowList: BsatnRowList\n  ): Operation[] {\n    const buffer = rowList.rowsData;\n    const reader = new BinaryReader(buffer);\n    const rows: Operation[] = [];\n\n    const deserializeRow = this.#rowDeserializers[tableName];\n    const table = this.#sourceNameToTableDef[tableName];\n    // TODO: performance\n    const columnsArray = Object.entries(table.columns);\n    const primaryKeyColumnEntry = columnsArray.find(\n      col => col[1].columnMetadata.isPrimaryKey\n    );\n    let previousOffset = 0;\n    while (reader.remaining > 0) {\n      const row = deserializeRow(reader);\n      let rowId: ComparablePrimitive | undefined = undefined;\n      if (primaryKeyColumnEntry !== undefined) {\n        const primaryKeyColName = primaryKeyColumnEntry[0];\n        const primaryKeyColType =\n          primaryKeyColumnEntry[1].typeBuilder.algebraicType;\n        rowId = AlgebraicType.intoMapKey(\n          primaryKeyColType,\n          row[primaryKeyColName]\n        );\n      } else {\n        // Get a view of the bytes for this row.\n        const rowBytes = buffer.subarray(previousOffset, reader.offset);\n        // Convert it to a base64 string, so we can use it as a map key.\n        const asBase64 = fromByteArray(rowBytes);\n        rowId = asBase64;\n      }\n      previousOffset = reader.offset;\n\n      rows.push({\n        type,\n        rowId,\n        row,\n      });\n    }\n    return rows;\n  }\n\n  // Take a bunch of table updates and ensure that there is at most one update per table.\n  #mergeTableUpdates(\n    updates: CacheTableUpdate<UntypedTableDef>[]\n  ): CacheTableUpdate<UntypedTableDef>[] {\n    const merged = new Map<string, Operation[]>();\n    for (const update of updates) {\n      const ops = merged.get(update.tableName);\n      if (ops) {\n        for (const op of update.operations) ops.push(op);\n      } else {\n        merged.set(update.tableName, update.operations.slice());\n      }\n    }\n    return Array.from(merged, ([tableName, operations]) => ({\n      tableName,\n      operations,\n    }));\n  }\n\n  #queryRowsToTableUpdates(\n    rows: QueryRows,\n    opType: 'insert' | 'delete'\n  ): CacheTableUpdate<UntypedTableDef>[] {\n    const updates: CacheTableUpdate<UntypedTableDef>[] = [];\n    for (const tableRows of rows.tables) {\n      updates.push({\n        tableName: tableRows.table,\n        operations: this.#parseRowList(opType, tableRows.table, tableRows.rows),\n      });\n    }\n    return this.#mergeTableUpdates(updates);\n  }\n\n  #tableUpdateRowsToOperations(\n    tableName: string,\n    rows: TableUpdateRows\n  ): Operation[] {\n    if (rows.tag === 'PersistentTable') {\n      const inserts = this.#parseRowList(\n        'insert',\n        tableName,\n        rows.value.inserts\n      );\n      const deletes = this.#parseRowList(\n        'delete',\n        tableName,\n        rows.value.deletes\n      );\n      return inserts.concat(deletes);\n    }\n    if (rows.tag === 'EventTable') {\n      // Event table rows are insert-only. The table cache handles skipping\n      // storage for event tables and only firing on_insert callbacks.\n      return this.#parseRowList('insert', tableName, rows.value.events);\n    }\n    return [];\n  }\n\n  #querySetUpdateToTableUpdates(\n    querySetUpdate: QuerySetUpdate\n  ): CacheTableUpdate<UntypedTableDef>[] {\n    const updates: CacheTableUpdate<UntypedTableDef>[] = [];\n    for (const tableUpdate of querySetUpdate.tables) {\n      let operations: Operation[] = [];\n      for (const rows of tableUpdate.rows) {\n        operations = operations.concat(\n          this.#tableUpdateRowsToOperations(tableUpdate.tableName, rows)\n        );\n      }\n      updates.push({\n        tableName: tableUpdate.tableName,\n        operations,\n      });\n    }\n    return this.#mergeTableUpdates(updates);\n  }\n\n  #sendEncoded(\n    wsResolved: WebsocketDecompressAdapter | WebsocketTestAdapter,\n    message: ClientMessage\n  ): void {\n    stdbLogger(\n      'trace',\n      () => `Sending message to server: ${stringify(message)}`\n    );\n    const writer = new BinaryWriter(1024);\n    ClientMessage.serialize(writer, message);\n    const encoded = writer.getBuffer();\n    wsResolved.send(encoded);\n  }\n\n  #flushOutboundQueue(\n    wsResolved: WebsocketDecompressAdapter | WebsocketTestAdapter\n  ): void {\n    if (!this.isActive || this.#outboundQueue.length === 0) {\n      return;\n    }\n    const pending = this.#outboundQueue.splice(0);\n    for (const message of pending) {\n      this.#sendEncoded(wsResolved, message);\n    }\n  }\n\n  #sendMessage(message: ClientMessage): void {\n    this.wsPromise.then(wsResolved => {\n      if (!wsResolved || !this.isActive) {\n        this.#outboundQueue.push(message);\n        return;\n      }\n      this.#flushOutboundQueue(wsResolved);\n      this.#sendEncoded(wsResolved, message);\n    });\n  }\n\n  #nextEventId(): string {\n    this.#eventId += 1;\n    return `${this.connectionId.toHexString()}:${this.#eventId}`;\n  }\n\n  /**\n   * Handles WebSocket onOpen event.\n   */\n  #handleOnOpen(): void {\n    this.isActive = true;\n    if (this.ws) {\n      this.#flushOutboundQueue(this.ws);\n    }\n  }\n\n  #applyTableUpdates(\n    tableUpdates: CacheTableUpdate<UntypedTableDef>[],\n    eventContext: EventContextInterface<RemoteModule>\n  ): PendingCallback[] {\n    const pendingCallbacks: PendingCallback[] = [];\n    for (const tableUpdate of tableUpdates) {\n      // Get table information for the table being updated\n      const tableName = tableUpdate.tableName;\n      const tableDef = this.#sourceNameToTableDef[tableName];\n      const table = this.clientCache.getOrCreateTable(tableDef);\n      const newCallbacks = table.applyOperations(\n        tableUpdate.operations as Operation<\n          RowType<Values<RemoteModule['tables']>>\n        >[],\n        eventContext\n      );\n      for (const callback of newCallbacks) {\n        pendingCallbacks.push(callback);\n      }\n    }\n    return pendingCallbacks;\n  }\n\n  #applyTransactionUpdates(\n    eventContext: EventContextInterface<RemoteModule>,\n    tu: TransactionUpdate\n  ): PendingCallback[] {\n    const allUpdates: CacheTableUpdate<UntypedTableDef>[] = [];\n    for (const querySetUpdate of tu.querySets) {\n      const tableUpdates = this.#querySetUpdateToTableUpdates(querySetUpdate);\n      for (const update of tableUpdates) {\n        allUpdates.push(update);\n      }\n      // TODO: When we have per-query storage, we will want to apply the per-query events here.\n    }\n    return this.#applyTableUpdates(\n      this.#mergeTableUpdates(allUpdates),\n      eventContext\n    );\n  }\n\n  async #processMessage(data: Uint8Array): Promise<void> {\n    const serverMessage = ServerMessage.deserialize(new BinaryReader(data));\n    stdbLogger(\n      'trace',\n      () => `Processing server message: ${stringify(serverMessage)}`\n    );\n    switch (serverMessage.tag) {\n      case 'InitialConnection': {\n        this.identity = serverMessage.value.identity;\n        if (!this.token && serverMessage.value.token) {\n          this.token = serverMessage.value.token;\n        }\n        this.connectionId = serverMessage.value.connectionId;\n        this.#emitter.emit('connect', this, this.identity, this.token);\n        break;\n      }\n      case 'SubscribeApplied': {\n        const querySetId = serverMessage.value.querySetId.id;\n        const subscription =\n          this.#subscriptionManager.subscriptions.get(querySetId);\n        if (!subscription) {\n          stdbLogger(\n            'error',\n            `Received SubscribeApplied for unknown querySetId ${querySetId}.`\n          );\n          return;\n        }\n        const event: Event<never> = {\n          id: this.#nextEventId(),\n          tag: 'SubscribeApplied',\n        };\n        const eventContext = this.#makeEventContext(event);\n        const tableUpdates = this.#queryRowsToTableUpdates(\n          serverMessage.value.rows,\n          'insert'\n        );\n        const callbacks = this.#applyTableUpdates(tableUpdates, eventContext);\n        const { event: _, ...subscriptionEventContext } = eventContext;\n        subscription.emitter.emit('applied', subscriptionEventContext);\n        stdbLogger(\n          'trace',\n          () => `Calling ${callbacks.length} triggered row callbacks`\n        );\n        for (const callback of callbacks) {\n          callback.cb();\n        }\n        break;\n      }\n      case 'UnsubscribeApplied': {\n        const querySetId = serverMessage.value.querySetId.id;\n        const subscription =\n          this.#subscriptionManager.subscriptions.get(querySetId);\n        if (!subscription) {\n          stdbLogger(\n            'error',\n            `Received UnsubscribeApplied for unknown querySetId ${querySetId}.`\n          );\n          return;\n        }\n        const event: Event<never> = {\n          id: this.#nextEventId(),\n          tag: 'UnsubscribeApplied',\n        };\n        const eventContext = this.#makeEventContext(event);\n        const tableUpdates = serverMessage.value.rows\n          ? this.#queryRowsToTableUpdates(serverMessage.value.rows, 'delete')\n          : [];\n        const callbacks = this.#applyTableUpdates(tableUpdates, eventContext);\n        const { event: _, ...subscriptionEventContext } = eventContext;\n        subscription.emitter.emit('end', subscriptionEventContext);\n        this.#subscriptionManager.subscriptions.delete(querySetId);\n        stdbLogger(\n          'trace',\n          () => `Calling ${callbacks.length} triggered row callbacks`\n        );\n        for (const callback of callbacks) {\n          callback.cb();\n        }\n        break;\n      }\n      case 'SubscriptionError': {\n        const querySetId = serverMessage.value.querySetId.id;\n        const error = Error(serverMessage.value.error);\n        const event: Event<never> = {\n          id: this.#nextEventId(),\n          tag: 'Error',\n          value: error,\n        };\n        const eventContext = this.#makeEventContext(event);\n        const errorContext = {\n          ...eventContext,\n          event: error,\n        };\n        const subscription =\n          this.#subscriptionManager.subscriptions.get(querySetId);\n        if (subscription) {\n          subscription.emitter.emit('error', errorContext, error);\n          this.#subscriptionManager.subscriptions.delete(querySetId);\n        } else {\n          stdbLogger(\n            'error',\n            `Received SubscriptionError for unknown querySetId ${querySetId}:`,\n            error\n          );\n        }\n        break;\n      }\n      case 'TransactionUpdate': {\n        const event: Event<never> = {\n          id: this.#nextEventId(),\n          tag: 'UnknownTransaction',\n        };\n        const eventContext = this.#makeEventContext(event);\n        const callbacks = this.#applyTransactionUpdates(\n          eventContext,\n          serverMessage.value\n        );\n        stdbLogger(\n          'trace',\n          () => `Calling ${callbacks.length} triggered row callbacks`\n        );\n        for (const callback of callbacks) {\n          callback.cb();\n        }\n        break;\n      }\n      case 'ReducerResult': {\n        const { requestId, result } = serverMessage.value;\n\n        if (result.tag === 'Ok') {\n          const reducerInfo = this.#reducerCallInfo.get(requestId);\n          const eventId: string = this.#nextEventId();\n          const event: Event<any> = reducerInfo\n            ? {\n                id: eventId,\n                tag: 'Reducer',\n                value: {\n                  timestamp: serverMessage.value.timestamp,\n                  outcome: result,\n                  reducer: {\n                    name: reducerInfo.name,\n                    args: reducerInfo.args,\n                  },\n                },\n              }\n            : {\n                id: eventId,\n                tag: 'UnknownTransaction',\n              };\n          const eventContext = this.#makeEventContext(event as any);\n\n          const callbacks = this.#applyTransactionUpdates(\n            eventContext,\n            result.value.transactionUpdate\n          );\n          stdbLogger(\n            'trace',\n            () => `Calling ${callbacks.length} triggered row callbacks`\n          );\n          for (const callback of callbacks) {\n            callback.cb();\n          }\n        }\n        this.#reducerCallInfo.delete(requestId);\n        const cb = this.#reducerCallbacks.get(requestId);\n        this.#reducerCallbacks.delete(requestId);\n        cb?.(result);\n        break;\n      }\n      case 'ProcedureResult': {\n        const { status, requestId } = serverMessage.value;\n        const result: ProcedureResultMessage['result'] =\n          status.tag === 'Returned'\n            ? { tag: 'Ok', value: status.value }\n            : { tag: 'Err', value: status.value };\n        const cb = this.#procedureCallbacks.get(requestId);\n        this.#procedureCallbacks.delete(requestId);\n        cb?.(result);\n        break;\n      }\n      case 'OneOffQueryResult': {\n        stdbLogger(\n          'warn',\n          'Received OneOffQueryResult but SDK does not expose one-off query APIs yet.'\n        );\n        break;\n      }\n    }\n  }\n\n  /**\n   * Handles WebSocket onMessage event.\n   * @param wsMessage MessageEvent object.\n   */\n  #handleOnMessage(wsMessage: { data: Uint8Array }): void {\n    // Utilize promise chaining to ensure that we process messages in order\n    // even though we are processing them asyncronously. This will not begin\n    // processing the next message until we await the processing of the\n    // current message.\n    this.#messageQueue = this.#messageQueue.then(() => {\n      return this.#processMessage(wsMessage.data);\n    });\n  }\n\n  /**\n   * Call a reducer on your SpacetimeDB module.\n   *\n   * @param reducerName The name of the reducer to call\n   * @param argsSerializer The arguments to pass to the reducer\n   */\n  callReducer(\n    reducerName: string,\n    argsBuffer: Uint8Array,\n    reducerArgs?: object\n  ): Promise<void> {\n    const { promise, resolve, reject } = Promise.withResolvers<void>();\n    const requestId = this.#getNextRequestId();\n    const message = ClientMessage.CallReducer({\n      reducer: reducerName,\n      args: argsBuffer,\n      requestId,\n      flags: 0,\n    });\n    this.#sendMessage(message);\n    if (reducerArgs) {\n      this.#reducerCallInfo.set(requestId, {\n        name: reducerName,\n        args: reducerArgs,\n      });\n    }\n    this.#reducerCallbacks.set(requestId, result => {\n      if (result.tag === 'Ok' || result.tag === 'OkEmpty') {\n        resolve();\n      } else {\n        if (result.tag === 'Err') {\n          /// Interpret the user-returned error as a string.\n          const reader = new BinaryReader(result.value);\n          const errorString = reader.readString();\n          reject(new SenderError(errorString));\n        } else if (result.tag === 'InternalError') {\n          reject(new InternalError(result.value));\n        } else {\n          const unreachable: never = result;\n          reject(new Error('Unexpected reducer result'));\n          void unreachable;\n        }\n      }\n    });\n    return promise;\n  }\n\n  /**\n   * Call a reducer on your SpacetimeDB module with typed arguments.\n   * @param reducerSchema The schema of the reducer to call\n   * @param callReducerFlags The flags for the reducer call\n   * @param params The arguments to pass to the reducer\n   */\n  callReducerWithParams(\n    reducerName: string,\n    // TODO: remove\n    _paramsType: ProductType,\n    params: object\n  ): Promise<void> {\n    const writer = new BinaryWriter(1024);\n    this.#reducerArgsSerializers[reducerName].serialize(writer, params);\n    const argsBuffer = writer.getBuffer();\n    return this.callReducer(reducerName, argsBuffer, params);\n  }\n\n  /**\n   * Call a reducer on your SpacetimeDB module.\n   *\n   * @param procedureName The name of the reducer to call\n   * @param argsBuffer The arguments to pass to the reducer\n   */\n  callProcedure(\n    procedureName: string,\n    argsBuffer: Uint8Array\n  ): Promise<Uint8Array> {\n    const { promise, resolve, reject } = Promise.withResolvers<Uint8Array>();\n    const requestId = this.#getNextRequestId();\n    const message = ClientMessage.CallProcedure({\n      procedure: procedureName,\n      args: argsBuffer,\n      requestId,\n      // reserved for future use - 0 is the only valid value\n      flags: 0,\n    });\n    this.#sendMessage(message);\n    this.#procedureCallbacks.set(requestId, result => {\n      if (result.tag === 'Ok') {\n        resolve(result.value);\n      } else {\n        reject(result.value);\n      }\n    });\n    return promise;\n  }\n\n  /**\n   * Call a reducer on your SpacetimeDB module with typed arguments.\n   * @param reducerSchema The schema of the reducer to call\n   * @param callReducerFlags The flags for the reducer call\n   * @param params The arguments to pass to the reducer\n   */\n  callProcedureWithParams(\n    procedureName: string,\n    // TODO: remove\n    _paramsType: ProductType,\n    params: object,\n    // TODO: remove\n    _returnType: AlgebraicType\n  ): Promise<any> {\n    const writer = new BinaryWriter(1024);\n    const { serializeArgs, deserializeReturn } =\n      this.#procedureSerializers[procedureName];\n    serializeArgs(writer, params);\n    const argsBuffer = writer.getBuffer();\n    return this.callProcedure(procedureName, argsBuffer).then(returnBuf => {\n      return deserializeReturn(new BinaryReader(returnBuf));\n    });\n  }\n\n  /**\n   * Close the current connection.\n   *\n   * @example\n   *\n   * ```ts\n   * const connection = DbConnection.builder().build();\n   * connection.disconnect()\n   * ```\n   */\n  disconnect(): void {\n    this.wsPromise.then(wsResolved => {\n      if (wsResolved) {\n        wsResolved.close();\n      }\n    });\n  }\n\n  private on(\n    eventName: ConnectionEvent,\n    callback: (ctx: DbConnectionImpl<RemoteModule>, ...args: any[]) => void\n  ): void {\n    this.#emitter.on(eventName, callback);\n  }\n\n  private off(\n    eventName: ConnectionEvent,\n    callback: (ctx: DbConnectionImpl<RemoteModule>, ...args: any[]) => void\n  ): void {\n    this.#emitter.off(eventName, callback);\n  }\n\n  private onConnect(\n    callback: (ctx: DbConnectionImpl<RemoteModule>, ...args: any[]) => void\n  ): void {\n    this.#emitter.on('connect', callback);\n  }\n\n  private onDisconnect(\n    callback: (ctx: DbConnectionImpl<RemoteModule>, ...args: any[]) => void\n  ): void {\n    this.#emitter.on('disconnect', callback);\n  }\n\n  private onConnectError(\n    callback: (ctx: DbConnectionImpl<RemoteModule>, ...args: any[]) => void\n  ): void {\n    this.#emitter.on('connectError', callback);\n  }\n\n  removeOnConnect(\n    callback: (ctx: DbConnectionImpl<RemoteModule>, ...args: any[]) => void\n  ): void {\n    this.#emitter.off('connect', callback);\n  }\n\n  removeOnDisconnect(\n    callback: (ctx: DbConnectionImpl<RemoteModule>, ...args: any[]) => void\n  ): void {\n    this.#emitter.off('disconnect', callback);\n  }\n\n  removeOnConnectError(\n    callback: (ctx: DbConnectionImpl<RemoteModule>, ...args: any[]) => void\n  ): void {\n    this.#emitter.off('connectError', callback);\n  }\n}\n","import {\n  AlgebraicType,\n  ProductType,\n  SumType,\n  type AlgebraicTypeType,\n  type AlgebraicTypeVariants,\n} from './algebraic_type';\nimport type {\n  CaseConversionPolicy,\n  RawModuleDefV10,\n  RawModuleDefV10Section,\n  RawScopedTypeNameV10,\n  RawTableDefV10,\n} from './autogen/types';\nimport type { UntypedIndex } from './indexes';\nimport type { UntypedTableDef } from './table';\nimport type { UntypedTableSchema } from './table_schema';\nimport {\n  ArrayBuilder,\n  OptionBuilder,\n  ProductBuilder,\n  RefBuilder,\n  ResultBuilder,\n  RowBuilder,\n  SumBuilder,\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  TypeBuilder,\n  type ElementsObj,\n  type Infer,\n  type InferSpacetimeTypeOfTypeBuilder,\n  type RowObj,\n  type VariantsObj,\n} from './type_builders';\nimport type { Values } from './type_util';\n\nexport type TableNamesOf<S extends UntypedSchemaDef> = Values<\n  S['tables']\n>['accessorName'];\n\n/**\n * An untyped representation of the database schema.\n */\nexport type UntypedSchemaDef = {\n  tables: Record<string, UntypedTableDef>;\n};\n\n/**\n * Helper type to convert an array of TableSchema into a schema definition\n */\nexport interface TablesToSchema<T extends Record<string, UntypedTableSchema>>\n  extends UntypedSchemaDef {\n  tables: {\n    readonly [AccName in keyof T & string]: TableToSchema<AccName, T[AccName]>;\n  };\n}\n\nexport interface TableToSchema<\n  AccName extends string,\n  T extends UntypedTableSchema,\n> extends UntypedTableDef {\n  accessorName: AccName;\n  columns: T['rowType']['row'];\n  rowType: T['rowSpacetimeType'];\n  indexes: T['idxs'];\n  constraints: T['constraints'];\n}\n\nexport function tablesToSchema<\n  const T extends Record<string, UntypedTableSchema>,\n>(ctx: ModuleContext, tables: T): TablesToSchema<T> {\n  return {\n    tables: Object.fromEntries(\n      Object.entries(tables).map(([accName, schema]) => [\n        accName,\n        tableToSchema(accName, schema, schema.tableDef(ctx, accName)),\n      ])\n    ) as TablesToSchema<T>['tables'],\n  };\n}\n\nexport function tableToSchema<\n  AccName extends string,\n  const T extends UntypedTableSchema,\n>(\n  accName: AccName,\n  schema: T,\n  tableDef: RawTableDefV10\n): TableToSchema<AccName, T> {\n  const getColName = (i: number) =>\n    schema.rowType.algebraicType.value.elements[i].name;\n\n  type AllowedCol = keyof T['rowType']['row'] & string;\n  return {\n    sourceName: accName,\n    accessorName: accName,\n    columns: schema.rowType.row, // typed as T[i]['rowType']['row'] under TablesToSchema<T>\n    rowType: schema.rowSpacetimeType,\n    constraints: tableDef.constraints.map(c => ({\n      name: c.sourceName,\n      constraint: 'unique',\n      columns: c.data.value.columns.map(getColName) as [string],\n    })),\n    // TODO: horrible horrible horrible. we smuggle this `Array<UntypedIndex>`\n    // by casting it to an `Array<IndexOpts>` as `TableToSchema` expects.\n    // This is then used in `TableCacheImpl.constructor` and who knows where else.\n    // We should stop lying about our types.\n    indexes: tableDef.indexes.map((idx): UntypedIndex<AllowedCol> => {\n      const columnIds =\n        idx.algorithm.tag === 'Direct'\n          ? [idx.algorithm.value]\n          : idx.algorithm.value;\n      return {\n        name: idx.accessorName!,\n        unique: tableDef.constraints.some(c =>\n          c.data.value.columns.every(col => columnIds.includes(col))\n        ),\n        algorithm: idx.algorithm.tag.toLowerCase() as 'btree',\n        columns: columnIds.map(getColName),\n      };\n    }) as T['idxs'],\n    tableDef,\n    ...(tableDef.isEvent ? { isEvent: true } : {}),\n  };\n}\n\ntype CompoundTypeCache = Map<\n  AlgebraicTypeVariants.Product | AlgebraicTypeVariants.Sum,\n  RefBuilder<any, any>\n>;\n\nexport type ModuleDef = {\n  [S in RawModuleDefV10Section as Uncapitalize<S['tag']>]: S['value'];\n};\n\ntype Section = RawModuleDefV10Section;\n\nexport class ModuleContext {\n  #compoundTypes: CompoundTypeCache = new Map();\n\n  /**\n   * The global module definition that gets populated by calls to `reducer()` and lifecycle hooks.\n   */\n  #moduleDef: ModuleDef = {\n    typespace: { types: [] },\n    tables: [],\n    reducers: [],\n    types: [],\n    rowLevelSecurity: [],\n    schedules: [],\n    procedures: [],\n    views: [],\n    lifeCycleReducers: [],\n    caseConversionPolicy: { tag: 'SnakeCase' },\n    explicitNames: {\n      entries: [],\n    },\n  };\n\n  get moduleDef(): ModuleDef {\n    return this.#moduleDef;\n  }\n\n  rawModuleDefV10(): RawModuleDefV10 {\n    const sections: Section[] = [];\n\n    const push = <T extends Section>(s: T | undefined) => {\n      if (s) sections.push(s);\n    };\n\n    const module = this.#moduleDef;\n\n    push(module.typespace && { tag: 'Typespace', value: module.typespace });\n    push(module.types && { tag: 'Types', value: module.types });\n    push(module.tables && { tag: 'Tables', value: module.tables });\n    push(module.reducers && { tag: 'Reducers', value: module.reducers });\n    push(module.procedures && { tag: 'Procedures', value: module.procedures });\n    push(module.views && { tag: 'Views', value: module.views });\n    push(module.schedules && { tag: 'Schedules', value: module.schedules });\n    push(\n      module.lifeCycleReducers && {\n        tag: 'LifeCycleReducers',\n        value: module.lifeCycleReducers,\n      }\n    );\n    push(\n      module.rowLevelSecurity && {\n        tag: 'RowLevelSecurity',\n        value: module.rowLevelSecurity,\n      }\n    );\n    push(\n      module.explicitNames && {\n        tag: 'ExplicitNames',\n        value: module.explicitNames,\n      }\n    );\n    push(\n      module.caseConversionPolicy && {\n        tag: 'CaseConversionPolicy',\n        value: module.caseConversionPolicy,\n      }\n    );\n    return { sections };\n  }\n\n  /**\n   * Set the case conversion policy for this module.\n   * Called by the settings mechanism.\n   */\n  setCaseConversionPolicy(policy: CaseConversionPolicy) {\n    this.#moduleDef.caseConversionPolicy = policy;\n  }\n\n  get typespace() {\n    return this.#moduleDef.typespace;\n  }\n\n  /**\n   * Resolves the actual type of a TypeBuilder by following its references until it reaches a non-ref type.\n   * @param typespace The typespace to resolve types against.\n   * @param typeBuilder The TypeBuilder to resolve.\n   * @returns The resolved algebraic type.\n   */\n  public resolveType<AT extends AlgebraicTypeType>(\n    typeBuilder: RefBuilder<any, AT>\n  ): AT {\n    let ty: AlgebraicType = typeBuilder.algebraicType;\n    while (ty.tag === 'Ref') {\n      ty = this.typespace.types[ty.value];\n    }\n    return ty as AT;\n  }\n\n  /**\n   * Adds a type to the module definition's typespace as a `Ref` if it is a named compound type (Product or Sum).\n   * Otherwise, returns the type as is.\n   * @param name\n   * @param ty\n   * @returns\n   */\n  public registerTypesRecursively<T extends TypeBuilder<any, AlgebraicType>>(\n    typeBuilder: T\n  ): T extends SumBuilder<any> | ProductBuilder<any> | RowBuilder<any>\n    ? RefBuilder<Infer<T>, InferSpacetimeTypeOfTypeBuilder<T>>\n    : T {\n    if (\n      (typeBuilder instanceof ProductBuilder && !isUnit(typeBuilder)) ||\n      typeBuilder instanceof SumBuilder ||\n      typeBuilder instanceof RowBuilder\n    ) {\n      return this.#registerCompoundTypeRecursively(typeBuilder) as any;\n    } else if (typeBuilder instanceof OptionBuilder) {\n      return new OptionBuilder(\n        this.registerTypesRecursively(typeBuilder.value)\n      ) as any;\n    } else if (typeBuilder instanceof ResultBuilder) {\n      return new ResultBuilder(\n        this.registerTypesRecursively(typeBuilder.ok),\n        this.registerTypesRecursively(typeBuilder.err)\n      ) as any;\n    } else if (typeBuilder instanceof ArrayBuilder) {\n      return new ArrayBuilder(\n        this.registerTypesRecursively(typeBuilder.element)\n      ) as any;\n    } else {\n      return typeBuilder as any;\n    }\n  }\n\n  #registerCompoundTypeRecursively<\n    T extends\n      | SumBuilder<VariantsObj>\n      | ProductBuilder<ElementsObj>\n      | RowBuilder<RowObj>,\n  >(typeBuilder: T): RefBuilder<Infer<T>, InferSpacetimeTypeOfTypeBuilder<T>> {\n    const ty = typeBuilder.algebraicType;\n    // NB! You must ensure that all TypeBuilder passed into this function\n    // have a name. This function ensures that nested types always have a\n    // name by assigning them one if they are missing it.\n    const name = typeBuilder.typeName;\n    if (name === undefined) {\n      throw new Error(\n        `Missing type name for ${typeBuilder.constructor.name ?? 'TypeBuilder'} ${JSON.stringify(typeBuilder)}`\n      );\n    }\n\n    let r = this.#compoundTypes.get(ty);\n    if (r != null) {\n      // Already added to typespace\n      return r;\n    }\n\n    // Recursively register nested compound types\n    const newTy =\n      typeBuilder instanceof RowBuilder || typeBuilder instanceof ProductBuilder\n        ? ({\n            tag: 'Product',\n            value: { elements: [] },\n          } as AlgebraicTypeVariants.Product)\n        : ({\n            tag: 'Sum',\n            value: { variants: [] },\n          } as AlgebraicTypeVariants.Sum);\n\n    r = new RefBuilder(this.#moduleDef.typespace.types.length);\n    this.#moduleDef.typespace.types.push(newTy);\n\n    this.#compoundTypes.set(ty, r);\n\n    if (typeBuilder instanceof RowBuilder) {\n      for (const [name, elem] of Object.entries(typeBuilder.row)) {\n        (newTy.value as ProductType).elements.push({\n          name,\n          algebraicType: this.registerTypesRecursively(elem.typeBuilder)\n            .algebraicType,\n        });\n      }\n    } else if (typeBuilder instanceof ProductBuilder) {\n      for (const [name, elem] of Object.entries(typeBuilder.elements)) {\n        (newTy.value as ProductType).elements.push({\n          name,\n          algebraicType: this.registerTypesRecursively(elem).algebraicType,\n        });\n      }\n    } else if (typeBuilder instanceof SumBuilder) {\n      for (const [name, variant] of Object.entries(typeBuilder.variants)) {\n        (newTy.value as SumType).variants.push({\n          name,\n          algebraicType: this.registerTypesRecursively(variant).algebraicType,\n        });\n      }\n    }\n\n    this.#moduleDef.types.push({\n      sourceName: splitName(name),\n      ty: r.ref,\n      customOrdering: true,\n    });\n\n    return r;\n  }\n}\n\nfunction isUnit(typeBuilder: ProductBuilder<ElementsObj>): boolean {\n  return (\n    typeBuilder.typeName == null &&\n    typeBuilder.algebraicType.value.elements.length === 0\n  );\n}\n\nexport function splitName(name: string): RawScopedTypeNameV10 {\n  const scope = name.split('.');\n  return { sourceName: scope.pop()!, scope };\n}\n","import {\n  ModuleContext,\n  tablesToSchema,\n  type TablesToSchema,\n  type UntypedSchemaDef,\n} from '../lib/schema';\nimport type { UntypedTableSchema } from '../lib/table_schema';\n\nclass Tables<S extends UntypedSchemaDef> {\n  constructor(readonly schemaType: S) {}\n}\n\n/**\n * Creates a schema from table definitions\n * @param handles - Array of table handles created by table() function\n * @returns ColumnBuilder representing the complete database schema\n * @example\n * ```ts\n * const spacetimedb = schema({\n *   user: table({}, userType),\n *   post: table({}, postType)\n * });\n * ```\n */\nexport function schema<const H extends Record<string, UntypedTableSchema>>(\n  tables: H\n): Tables<TablesToSchema<H>> {\n  const ctx = new ModuleContext();\n\n  return new Tables(tablesToSchema(ctx, tables));\n}\n\ntype HasAccessor = { accessorName: PropertyKey };\n\nexport type ConvertToAccessorMap<TableDefs extends readonly HasAccessor[]> = {\n  [Tbl in TableDefs[number] as Tbl['accessorName']]: Tbl;\n};\n\nexport function convertToAccessorMap<T extends readonly HasAccessor[]>(\n  arr: T\n): ConvertToAccessorMap<T> {\n  return Object.fromEntries(\n    arr.map(v => [v.accessorName, v])\n  ) as ConvertToAccessorMap<T>;\n}\n","// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE\n// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.\n\n/* eslint-disable */\n/* tslint:disable */\nimport {\n  TypeBuilder as __TypeBuilder,\n  t as __t,\n  type AlgebraicTypeType as __AlgebraicTypeType,\n  type Infer as __Infer,\n} from '../../lib/type_builders';\n\n// The tagged union or sum type for the algebraic type `AlgebraicType`.\nexport const AlgebraicType: __TypeBuilder<\n  __AlgebraicTypeType,\n  __AlgebraicTypeType\n> = __t.enum('AlgebraicType', {\n  Ref: __t.u32(),\n  get Sum() {\n    return SumType;\n  },\n  get Product() {\n    return ProductType;\n  },\n  get Array() {\n    return AlgebraicType;\n  },\n  String: __t.unit(),\n  Bool: __t.unit(),\n  I8: __t.unit(),\n  U8: __t.unit(),\n  I16: __t.unit(),\n  U16: __t.unit(),\n  I32: __t.unit(),\n  U32: __t.unit(),\n  I64: __t.unit(),\n  U64: __t.unit(),\n  I128: __t.unit(),\n  U128: __t.unit(),\n  I256: __t.unit(),\n  U256: __t.unit(),\n  F32: __t.unit(),\n  F64: __t.unit(),\n});\nexport type AlgebraicType = __Infer<typeof AlgebraicType>;\n\n// The tagged union or sum type for the algebraic type `CaseConversionPolicy`.\nexport const CaseConversionPolicy = __t.enum('CaseConversionPolicy', {\n  None: __t.unit(),\n  SnakeCase: __t.unit(),\n});\nexport type CaseConversionPolicy = __Infer<typeof CaseConversionPolicy>;\n\n// The tagged union or sum type for the algebraic type `ExplicitNameEntry`.\nexport const ExplicitNameEntry = __t.enum('ExplicitNameEntry', {\n  get Table() {\n    return NameMapping;\n  },\n  get Function() {\n    return NameMapping;\n  },\n  get Index() {\n    return NameMapping;\n  },\n});\nexport type ExplicitNameEntry = __Infer<typeof ExplicitNameEntry>;\n\nexport const ExplicitNames = __t.object('ExplicitNames', {\n  get entries() {\n    return __t.array(ExplicitNameEntry);\n  },\n});\nexport type ExplicitNames = __Infer<typeof ExplicitNames>;\n\n// The tagged union or sum type for the algebraic type `FunctionVisibility`.\nexport const FunctionVisibility = __t.enum('FunctionVisibility', {\n  Private: __t.unit(),\n  ClientCallable: __t.unit(),\n});\nexport type FunctionVisibility = __Infer<typeof FunctionVisibility>;\n\nexport const HttpHeaderPair = __t.object('HttpHeaderPair', {\n  name: __t.string(),\n  value: __t.byteArray(),\n});\nexport type HttpHeaderPair = __Infer<typeof HttpHeaderPair>;\n\nexport const HttpHeaders = __t.object('HttpHeaders', {\n  get entries() {\n    return __t.array(HttpHeaderPair);\n  },\n});\nexport type HttpHeaders = __Infer<typeof HttpHeaders>;\n\n// The tagged union or sum type for the algebraic type `HttpMethod`.\nexport const HttpMethod = __t.enum('HttpMethod', {\n  Get: __t.unit(),\n  Head: __t.unit(),\n  Post: __t.unit(),\n  Put: __t.unit(),\n  Delete: __t.unit(),\n  Connect: __t.unit(),\n  Options: __t.unit(),\n  Trace: __t.unit(),\n  Patch: __t.unit(),\n  Extension: __t.string(),\n});\nexport type HttpMethod = __Infer<typeof HttpMethod>;\n\nexport const HttpRequest = __t.object('HttpRequest', {\n  get method() {\n    return HttpMethod;\n  },\n  get headers() {\n    return HttpHeaders;\n  },\n  timeout: __t.option(__t.timeDuration()),\n  uri: __t.string(),\n  get version() {\n    return HttpVersion;\n  },\n});\nexport type HttpRequest = __Infer<typeof HttpRequest>;\n\nexport const HttpResponse = __t.object('HttpResponse', {\n  get headers() {\n    return HttpHeaders;\n  },\n  get version() {\n    return HttpVersion;\n  },\n  code: __t.u16(),\n});\nexport type HttpResponse = __Infer<typeof HttpResponse>;\n\n// The tagged union or sum type for the algebraic type `HttpVersion`.\nexport const HttpVersion = __t.enum('HttpVersion', {\n  Http09: __t.unit(),\n  Http10: __t.unit(),\n  Http11: __t.unit(),\n  Http2: __t.unit(),\n  Http3: __t.unit(),\n});\nexport type HttpVersion = __Infer<typeof HttpVersion>;\n\n// The tagged union or sum type for the algebraic type `IndexType`.\nexport const IndexType = __t.enum('IndexType', {\n  BTree: __t.unit(),\n  Hash: __t.unit(),\n});\nexport type IndexType = __Infer<typeof IndexType>;\n\n// The tagged union or sum type for the algebraic type `Lifecycle`.\nexport const Lifecycle = __t.enum('Lifecycle', {\n  Init: __t.unit(),\n  OnConnect: __t.unit(),\n  OnDisconnect: __t.unit(),\n});\nexport type Lifecycle = __Infer<typeof Lifecycle>;\n\n// The tagged union or sum type for the algebraic type `MiscModuleExport`.\nexport const MiscModuleExport = __t.enum('MiscModuleExport', {\n  get TypeAlias() {\n    return TypeAlias;\n  },\n});\nexport type MiscModuleExport = __Infer<typeof MiscModuleExport>;\n\nexport const NameMapping = __t.object('NameMapping', {\n  sourceName: __t.string(),\n  canonicalName: __t.string(),\n});\nexport type NameMapping = __Infer<typeof NameMapping>;\n\nexport const ProductType = __t.object('ProductType', {\n  get elements() {\n    return __t.array(ProductTypeElement);\n  },\n});\nexport type ProductType = __Infer<typeof ProductType>;\n\nexport const ProductTypeElement = __t.object('ProductTypeElement', {\n  name: __t.option(__t.string()),\n  get algebraicType() {\n    return AlgebraicType;\n  },\n});\nexport type ProductTypeElement = __Infer<typeof ProductTypeElement>;\n\nexport const RawColumnDefV8 = __t.object('RawColumnDefV8', {\n  colName: __t.string(),\n  get colType() {\n    return AlgebraicType;\n  },\n});\nexport type RawColumnDefV8 = __Infer<typeof RawColumnDefV8>;\n\nexport const RawColumnDefaultValueV10 = __t.object('RawColumnDefaultValueV10', {\n  colId: __t.u16(),\n  value: __t.byteArray(),\n});\nexport type RawColumnDefaultValueV10 = __Infer<typeof RawColumnDefaultValueV10>;\n\nexport const RawColumnDefaultValueV9 = __t.object('RawColumnDefaultValueV9', {\n  table: __t.string(),\n  colId: __t.u16(),\n  value: __t.byteArray(),\n});\nexport type RawColumnDefaultValueV9 = __Infer<typeof RawColumnDefaultValueV9>;\n\n// The tagged union or sum type for the algebraic type `RawConstraintDataV9`.\nexport const RawConstraintDataV9 = __t.enum('RawConstraintDataV9', {\n  get Unique() {\n    return RawUniqueConstraintDataV9;\n  },\n});\nexport type RawConstraintDataV9 = __Infer<typeof RawConstraintDataV9>;\n\nexport const RawConstraintDefV10 = __t.object('RawConstraintDefV10', {\n  sourceName: __t.option(__t.string()),\n  get data() {\n    return RawConstraintDataV9;\n  },\n});\nexport type RawConstraintDefV10 = __Infer<typeof RawConstraintDefV10>;\n\nexport const RawConstraintDefV8 = __t.object('RawConstraintDefV8', {\n  constraintName: __t.string(),\n  constraints: __t.u8(),\n  columns: __t.array(__t.u16()),\n});\nexport type RawConstraintDefV8 = __Infer<typeof RawConstraintDefV8>;\n\nexport const RawConstraintDefV9 = __t.object('RawConstraintDefV9', {\n  name: __t.option(__t.string()),\n  get data() {\n    return RawConstraintDataV9;\n  },\n});\nexport type RawConstraintDefV9 = __Infer<typeof RawConstraintDefV9>;\n\n// The tagged union or sum type for the algebraic type `RawIndexAlgorithm`.\nexport const RawIndexAlgorithm = __t.enum('RawIndexAlgorithm', {\n  BTree: __t.array(__t.u16()),\n  Hash: __t.array(__t.u16()),\n  Direct: __t.u16(),\n});\nexport type RawIndexAlgorithm = __Infer<typeof RawIndexAlgorithm>;\n\nexport const RawIndexDefV10 = __t.object('RawIndexDefV10', {\n  sourceName: __t.option(__t.string()),\n  accessorName: __t.option(__t.string()),\n  get algorithm() {\n    return RawIndexAlgorithm;\n  },\n});\nexport type RawIndexDefV10 = __Infer<typeof RawIndexDefV10>;\n\nexport const RawIndexDefV8 = __t.object('RawIndexDefV8', {\n  indexName: __t.string(),\n  isUnique: __t.bool(),\n  get indexType() {\n    return IndexType;\n  },\n  columns: __t.array(__t.u16()),\n});\nexport type RawIndexDefV8 = __Infer<typeof RawIndexDefV8>;\n\nexport const RawIndexDefV9 = __t.object('RawIndexDefV9', {\n  name: __t.option(__t.string()),\n  accessorName: __t.option(__t.string()),\n  get algorithm() {\n    return RawIndexAlgorithm;\n  },\n});\nexport type RawIndexDefV9 = __Infer<typeof RawIndexDefV9>;\n\nexport const RawLifeCycleReducerDefV10 = __t.object(\n  'RawLifeCycleReducerDefV10',\n  {\n    get lifecycleSpec() {\n      return Lifecycle;\n    },\n    functionName: __t.string(),\n  }\n);\nexport type RawLifeCycleReducerDefV10 = __Infer<\n  typeof RawLifeCycleReducerDefV10\n>;\n\n// The tagged union or sum type for the algebraic type `RawMiscModuleExportV9`.\nexport const RawMiscModuleExportV9 = __t.enum('RawMiscModuleExportV9', {\n  get ColumnDefaultValue() {\n    return RawColumnDefaultValueV9;\n  },\n  get Procedure() {\n    return RawProcedureDefV9;\n  },\n  get View() {\n    return RawViewDefV9;\n  },\n});\nexport type RawMiscModuleExportV9 = __Infer<typeof RawMiscModuleExportV9>;\n\n// The tagged union or sum type for the algebraic type `RawModuleDef`.\nexport const RawModuleDef = __t.enum('RawModuleDef', {\n  get V8BackCompat() {\n    return RawModuleDefV8;\n  },\n  get V9() {\n    return RawModuleDefV9;\n  },\n  get V10() {\n    return RawModuleDefV10;\n  },\n});\nexport type RawModuleDef = __Infer<typeof RawModuleDef>;\n\nexport const RawModuleDefV10 = __t.object('RawModuleDefV10', {\n  get sections() {\n    return __t.array(RawModuleDefV10Section);\n  },\n});\nexport type RawModuleDefV10 = __Infer<typeof RawModuleDefV10>;\n\n// The tagged union or sum type for the algebraic type `RawModuleDefV10Section`.\nexport const RawModuleDefV10Section = __t.enum('RawModuleDefV10Section', {\n  get Typespace() {\n    return Typespace;\n  },\n  get Types() {\n    return __t.array(RawTypeDefV10);\n  },\n  get Tables() {\n    return __t.array(RawTableDefV10);\n  },\n  get Reducers() {\n    return __t.array(RawReducerDefV10);\n  },\n  get Procedures() {\n    return __t.array(RawProcedureDefV10);\n  },\n  get Views() {\n    return __t.array(RawViewDefV10);\n  },\n  get Schedules() {\n    return __t.array(RawScheduleDefV10);\n  },\n  get LifeCycleReducers() {\n    return __t.array(RawLifeCycleReducerDefV10);\n  },\n  get RowLevelSecurity() {\n    return __t.array(RawRowLevelSecurityDefV9);\n  },\n  get CaseConversionPolicy() {\n    return CaseConversionPolicy;\n  },\n  get ExplicitNames() {\n    return ExplicitNames;\n  },\n});\nexport type RawModuleDefV10Section = __Infer<typeof RawModuleDefV10Section>;\n\nexport const RawModuleDefV8 = __t.object('RawModuleDefV8', {\n  get typespace() {\n    return Typespace;\n  },\n  get tables() {\n    return __t.array(TableDesc);\n  },\n  get reducers() {\n    return __t.array(ReducerDef);\n  },\n  get miscExports() {\n    return __t.array(MiscModuleExport);\n  },\n});\nexport type RawModuleDefV8 = __Infer<typeof RawModuleDefV8>;\n\nexport const RawModuleDefV9 = __t.object('RawModuleDefV9', {\n  get typespace() {\n    return Typespace;\n  },\n  get tables() {\n    return __t.array(RawTableDefV9);\n  },\n  get reducers() {\n    return __t.array(RawReducerDefV9);\n  },\n  get types() {\n    return __t.array(RawTypeDefV9);\n  },\n  get miscExports() {\n    return __t.array(RawMiscModuleExportV9);\n  },\n  get rowLevelSecurity() {\n    return __t.array(RawRowLevelSecurityDefV9);\n  },\n});\nexport type RawModuleDefV9 = __Infer<typeof RawModuleDefV9>;\n\nexport const RawProcedureDefV10 = __t.object('RawProcedureDefV10', {\n  sourceName: __t.string(),\n  get params() {\n    return ProductType;\n  },\n  get returnType() {\n    return AlgebraicType;\n  },\n  get visibility() {\n    return FunctionVisibility;\n  },\n});\nexport type RawProcedureDefV10 = __Infer<typeof RawProcedureDefV10>;\n\nexport const RawProcedureDefV9 = __t.object('RawProcedureDefV9', {\n  name: __t.string(),\n  get params() {\n    return ProductType;\n  },\n  get returnType() {\n    return AlgebraicType;\n  },\n});\nexport type RawProcedureDefV9 = __Infer<typeof RawProcedureDefV9>;\n\nexport const RawReducerDefV10 = __t.object('RawReducerDefV10', {\n  sourceName: __t.string(),\n  get params() {\n    return ProductType;\n  },\n  get visibility() {\n    return FunctionVisibility;\n  },\n  get okReturnType() {\n    return AlgebraicType;\n  },\n  get errReturnType() {\n    return AlgebraicType;\n  },\n});\nexport type RawReducerDefV10 = __Infer<typeof RawReducerDefV10>;\n\nexport const RawReducerDefV9 = __t.object('RawReducerDefV9', {\n  name: __t.string(),\n  get params() {\n    return ProductType;\n  },\n  get lifecycle() {\n    return __t.option(Lifecycle);\n  },\n});\nexport type RawReducerDefV9 = __Infer<typeof RawReducerDefV9>;\n\nexport const RawRowLevelSecurityDefV9 = __t.object('RawRowLevelSecurityDefV9', {\n  sql: __t.string(),\n});\nexport type RawRowLevelSecurityDefV9 = __Infer<typeof RawRowLevelSecurityDefV9>;\n\nexport const RawScheduleDefV10 = __t.object('RawScheduleDefV10', {\n  sourceName: __t.option(__t.string()),\n  tableName: __t.string(),\n  scheduleAtCol: __t.u16(),\n  functionName: __t.string(),\n});\nexport type RawScheduleDefV10 = __Infer<typeof RawScheduleDefV10>;\n\nexport const RawScheduleDefV9 = __t.object('RawScheduleDefV9', {\n  name: __t.option(__t.string()),\n  reducerName: __t.string(),\n  scheduledAtColumn: __t.u16(),\n});\nexport type RawScheduleDefV9 = __Infer<typeof RawScheduleDefV9>;\n\nexport const RawScopedTypeNameV10 = __t.object('RawScopedTypeNameV10', {\n  scope: __t.array(__t.string()),\n  sourceName: __t.string(),\n});\nexport type RawScopedTypeNameV10 = __Infer<typeof RawScopedTypeNameV10>;\n\nexport const RawScopedTypeNameV9 = __t.object('RawScopedTypeNameV9', {\n  scope: __t.array(__t.string()),\n  name: __t.string(),\n});\nexport type RawScopedTypeNameV9 = __Infer<typeof RawScopedTypeNameV9>;\n\nexport const RawSequenceDefV10 = __t.object('RawSequenceDefV10', {\n  sourceName: __t.option(__t.string()),\n  column: __t.u16(),\n  start: __t.option(__t.i128()),\n  minValue: __t.option(__t.i128()),\n  maxValue: __t.option(__t.i128()),\n  increment: __t.i128(),\n});\nexport type RawSequenceDefV10 = __Infer<typeof RawSequenceDefV10>;\n\nexport const RawSequenceDefV8 = __t.object('RawSequenceDefV8', {\n  sequenceName: __t.string(),\n  colPos: __t.u16(),\n  increment: __t.i128(),\n  start: __t.option(__t.i128()),\n  minValue: __t.option(__t.i128()),\n  maxValue: __t.option(__t.i128()),\n  allocated: __t.i128(),\n});\nexport type RawSequenceDefV8 = __Infer<typeof RawSequenceDefV8>;\n\nexport const RawSequenceDefV9 = __t.object('RawSequenceDefV9', {\n  name: __t.option(__t.string()),\n  column: __t.u16(),\n  start: __t.option(__t.i128()),\n  minValue: __t.option(__t.i128()),\n  maxValue: __t.option(__t.i128()),\n  increment: __t.i128(),\n});\nexport type RawSequenceDefV9 = __Infer<typeof RawSequenceDefV9>;\n\nexport const RawTableDefV10 = __t.object('RawTableDefV10', {\n  sourceName: __t.string(),\n  productTypeRef: __t.u32(),\n  primaryKey: __t.array(__t.u16()),\n  get indexes() {\n    return __t.array(RawIndexDefV10);\n  },\n  get constraints() {\n    return __t.array(RawConstraintDefV10);\n  },\n  get sequences() {\n    return __t.array(RawSequenceDefV10);\n  },\n  get tableType() {\n    return TableType;\n  },\n  get tableAccess() {\n    return TableAccess;\n  },\n  get defaultValues() {\n    return __t.array(RawColumnDefaultValueV10);\n  },\n  isEvent: __t.bool(),\n});\nexport type RawTableDefV10 = __Infer<typeof RawTableDefV10>;\n\nexport const RawTableDefV8 = __t.object('RawTableDefV8', {\n  tableName: __t.string(),\n  get columns() {\n    return __t.array(RawColumnDefV8);\n  },\n  get indexes() {\n    return __t.array(RawIndexDefV8);\n  },\n  get constraints() {\n    return __t.array(RawConstraintDefV8);\n  },\n  get sequences() {\n    return __t.array(RawSequenceDefV8);\n  },\n  tableType: __t.string(),\n  tableAccess: __t.string(),\n  scheduled: __t.option(__t.string()),\n});\nexport type RawTableDefV8 = __Infer<typeof RawTableDefV8>;\n\nexport const RawTableDefV9 = __t.object('RawTableDefV9', {\n  name: __t.string(),\n  productTypeRef: __t.u32(),\n  primaryKey: __t.array(__t.u16()),\n  get indexes() {\n    return __t.array(RawIndexDefV9);\n  },\n  get constraints() {\n    return __t.array(RawConstraintDefV9);\n  },\n  get sequences() {\n    return __t.array(RawSequenceDefV9);\n  },\n  get schedule() {\n    return __t.option(RawScheduleDefV9);\n  },\n  get tableType() {\n    return TableType;\n  },\n  get tableAccess() {\n    return TableAccess;\n  },\n});\nexport type RawTableDefV9 = __Infer<typeof RawTableDefV9>;\n\nexport const RawTypeDefV10 = __t.object('RawTypeDefV10', {\n  get sourceName() {\n    return RawScopedTypeNameV10;\n  },\n  ty: __t.u32(),\n  customOrdering: __t.bool(),\n});\nexport type RawTypeDefV10 = __Infer<typeof RawTypeDefV10>;\n\nexport const RawTypeDefV9 = __t.object('RawTypeDefV9', {\n  get name() {\n    return RawScopedTypeNameV9;\n  },\n  ty: __t.u32(),\n  customOrdering: __t.bool(),\n});\nexport type RawTypeDefV9 = __Infer<typeof RawTypeDefV9>;\n\nexport const RawUniqueConstraintDataV9 = __t.object(\n  'RawUniqueConstraintDataV9',\n  {\n    columns: __t.array(__t.u16()),\n  }\n);\nexport type RawUniqueConstraintDataV9 = __Infer<\n  typeof RawUniqueConstraintDataV9\n>;\n\nexport const RawViewDefV10 = __t.object('RawViewDefV10', {\n  sourceName: __t.string(),\n  index: __t.u32(),\n  isPublic: __t.bool(),\n  isAnonymous: __t.bool(),\n  get params() {\n    return ProductType;\n  },\n  get returnType() {\n    return AlgebraicType;\n  },\n});\nexport type RawViewDefV10 = __Infer<typeof RawViewDefV10>;\n\nexport const RawViewDefV9 = __t.object('RawViewDefV9', {\n  name: __t.string(),\n  index: __t.u32(),\n  isPublic: __t.bool(),\n  isAnonymous: __t.bool(),\n  get params() {\n    return ProductType;\n  },\n  get returnType() {\n    return AlgebraicType;\n  },\n});\nexport type RawViewDefV9 = __Infer<typeof RawViewDefV9>;\n\nexport const ReducerDef = __t.object('ReducerDef', {\n  name: __t.string(),\n  get args() {\n    return __t.array(ProductTypeElement);\n  },\n});\nexport type ReducerDef = __Infer<typeof ReducerDef>;\n\nexport const SumType = __t.object('SumType', {\n  get variants() {\n    return __t.array(SumTypeVariant);\n  },\n});\nexport type SumType = __Infer<typeof SumType>;\n\nexport const SumTypeVariant = __t.object('SumTypeVariant', {\n  name: __t.option(__t.string()),\n  get algebraicType() {\n    return AlgebraicType;\n  },\n});\nexport type SumTypeVariant = __Infer<typeof SumTypeVariant>;\n\n// The tagged union or sum type for the algebraic type `TableAccess`.\nexport const TableAccess = __t.enum('TableAccess', {\n  Public: __t.unit(),\n  Private: __t.unit(),\n});\nexport type TableAccess = __Infer<typeof TableAccess>;\n\nexport const TableDesc = __t.object('TableDesc', {\n  get schema() {\n    return RawTableDefV8;\n  },\n  data: __t.u32(),\n});\nexport type TableDesc = __Infer<typeof TableDesc>;\n\n// The tagged union or sum type for the algebraic type `TableType`.\nexport const TableType = __t.enum('TableType', {\n  System: __t.unit(),\n  User: __t.unit(),\n});\nexport type TableType = __Infer<typeof TableType>;\n\nexport const TypeAlias = __t.object('TypeAlias', {\n  name: __t.string(),\n  ty: __t.u32(),\n});\nexport type TypeAlias = __Infer<typeof TypeAlias>;\n\nexport const Typespace = __t.object('Typespace', {\n  get types() {\n    return __t.array(AlgebraicType);\n  },\n});\nexport type Typespace = __Infer<typeof Typespace>;\n\n// The tagged union or sum type for the algebraic type `ViewResultHeader`.\nexport const ViewResultHeader = __t.enum('ViewResultHeader', {\n  RowData: __t.unit(),\n  RawSql: __t.string(),\n});\nexport type ViewResultHeader = __Infer<typeof ViewResultHeader>;\n","import type { ProcedureExport, ReducerExport, t } from '../server';\nimport type { errors } from '../server/errors';\nimport {\n  ExplicitNameEntry,\n  RawColumnDefaultValueV10,\n  RawConstraintDefV10,\n  RawIndexAlgorithm,\n  RawIndexDefV10,\n  RawSequenceDefV10,\n  RawTableDefV10,\n} from './autogen/types';\nimport BinaryWriter from './binary_writer';\nimport type { AllUnique, ConstraintOpts } from './constraints';\nimport type {\n  ColumnIndex,\n  IndexColumns,\n  Indexes,\n  IndexOpts,\n  ReadonlyIndexes,\n} from './indexes';\nimport ScheduleAt from './schedule_at';\nimport type { TableSchema } from './table_schema';\nimport {\n  RowBuilder,\n  type ColumnBuilder,\n  type ColumnMetadata,\n  type InferTypeOfRow,\n  type RowObj,\n  type TypeBuilder,\n} from './type_builders';\nimport type {\n  InvalidColumnMetadata,\n  Prettify,\n  ValidateColumnMetadata,\n} from './type_util';\nimport { toPascalCase } from './util';\n\nexport type AlgebraicTypeRef = number;\ntype ColId = number;\ntype ColList = ColId[];\n\n/**\n * Check if any column in the row has invalid metadata.\n */\ntype HasInvalidColumn<Row extends RowObj> =\n  // this checks if Row exactly equals RowObj - if it does, we can't\n  // do type-system-level checking, so just let it pass\n  (<G>() => G extends Row ? 1 : 2) extends <G>() => G extends RowObj ? 1 : 2\n    ? false\n    : {\n          [K in keyof Row]: Row[K] extends ColumnBuilder<any, any, infer M>\n            ? ValidateColumnMetadata<M> extends InvalidColumnMetadata<any>\n              ? true\n              : false\n            : false;\n        }[keyof Row] extends false\n      ? false\n      : true;\n\n/**\n * Extract the names of columns that have invalid metadata.\n */\ntype InvalidColumnNames<Row extends RowObj> = {\n  [K in keyof Row]: Row[K] extends ColumnBuilder<any, any, infer M>\n    ? ValidateColumnMetadata<M> extends InvalidColumnMetadata<any>\n      ? K & string\n      : never\n    : never;\n}[keyof Row];\n\n/**\n * A descriptive error type that surfaces the validation error.\n * The type name itself contains the error message for better CLI output.\n */\ntype ERROR_default_cannot_be_combined_with_primaryKey_unique_or_autoInc<\n  InvalidColumns extends string,\n> = {\n  _invalidColumns: InvalidColumns;\n  _fix: 'Remove either default() or the constraint (primaryKey/unique/autoInc) from these columns';\n};\n\n/**\n * A helper type to extract the row type from a TableDef\n */\nexport type RowType<TableDef extends Pick<UntypedTableDef, 'columns'>> =\n  InferTypeOfRow<TableDef['columns']>;\n\n/**\n * Coerces a column which may be a TypeBuilder or ColumnBuilder into a ColumnBuilder\n */\nexport type CoerceColumn<\n  Col extends TypeBuilder<any, any> | ColumnBuilder<any, any, any>,\n> =\n  Col extends TypeBuilder<infer T, infer U>\n    ? ColumnBuilder<T, U, ColumnMetadata<any>>\n    : Col;\n\n/**\n * Coerces a RowObj where TypeBuilders are replaced with ColumnBuilders\n */\nexport type CoerceRow<Row extends RowObj> = {\n  [k in keyof Row & string]: CoerceColumn<Row[k]>;\n};\n\n/**\n * Helper type to coerce an array of IndexOpts\n */\ntype CoerceArray<X extends IndexOpts<any>[]> = X;\n\n/**\n * An untyped representation of a table's schema.\n */\nexport type UntypedTableDef = {\n  sourceName: string;\n  accessorName: string;\n  columns: Record<string, ColumnBuilder<any, any, ColumnMetadata<any>>>;\n  // This is really just a ProductType where all the elements have names.\n  rowType: RowBuilder<RowObj>['algebraicType']['value'];\n  indexes: readonly IndexOpts<any>[];\n  constraints: readonly ConstraintOpts<any>[];\n  tableDef: RawTableDefV10;\n  isEvent?: boolean;\n};\n\n/**\n * A type representing the indexes defined on a table.\n */\nexport type TableIndexes<TableDef extends UntypedTableDef> = {\n  [K in keyof TableDef['columns'] & string as ColumnIndex<\n    K,\n    TableDef['columns'][K]['columnMetadata']\n  > extends never\n    ? never\n    : K]: ColumnIndex<K, TableDef['columns'][K]['columnMetadata']>;\n} & {\n  [I in TableDef['indexes'][number] as I['accessor'] & {}]: TableIndexFromDef<\n    TableDef,\n    I\n  >;\n};\n\ntype TableIndexFromDef<\n  TableDef extends UntypedTableDef,\n  I extends IndexOpts<keyof TableDef['columns'] & string>,\n> =\n  NormalizeIndexColumns<TableDef, I> extends infer Cols extends ReadonlyArray<\n    keyof TableDef['columns'] & string\n  >\n    ? {\n        name: I['accessor'];\n        unique: AllUnique<TableDef, Cols>;\n        algorithm: Lowercase<I['algorithm']>;\n        columns: Cols;\n      }\n    : never;\n\ntype NormalizeIndexColumns<\n  TableDef extends UntypedTableDef,\n  I extends IndexOpts<keyof TableDef['columns'] & string>,\n> =\n  IndexColumns<I> extends ReadonlyArray<keyof TableDef['columns'] & string>\n    ? IndexColumns<I>\n    : never;\n\n/**\n * Options for configuring a database table.\n * - `name`: The name of the table.\n * - `public`: Whether the table is publicly accessible. Defaults to `false`.\n * - `indexes`: An array of index configurations for the table.\n * - `constraints`: An array of constraint configurations for the table.\n * - `scheduled`: The name of the reducer to be executed based on the scheduled rows in this table.\n */\nexport type TableOpts<Row extends RowObj> = {\n  name?: string;\n  public?: boolean;\n  indexes?: IndexOpts<keyof Row & string>[]; // declarative multicolumn indexes\n  constraints?: ConstraintOpts<keyof Row & string>[];\n  scheduled?: () =>\n    | ReducerExport<any, { [k: string]: RowBuilder<RowObj> }>\n    | ProcedureExport<\n        any,\n        { [k: string]: RowBuilder<RowObj> },\n        ReturnType<typeof t.unit>\n      >;\n  event?: boolean;\n};\n\n/**\n * Extracts the indices from TableOpts, defaulting to an empty array if none are provided.\n */\ntype OptsIndices<Opts extends TableOpts<any>> = Opts extends {\n  indexes: infer Ixs extends NonNullable<any[]>;\n}\n  ? Ixs\n  : CoerceArray<[]>;\n\n/**\n * Extracts the constraints from TableOpts, defaulting to an empty array if none are provided.\n */\ntype OptsConstraints<Opts extends TableOpts<any>> = Opts extends {\n  constraints: infer Constraints extends NonNullable<any[]>;\n}\n  ? Constraints\n  : CoerceArray<[]>;\n\n/**\n * Table<Row, UniqueConstraintViolation = never, AutoIncOverflow = never>\n *\n * - Row: row shape\n * - UCV: unique-constraint violation error type (never if none)\n * - AIO: auto-increment overflow error type (never if none)\n */\nexport type Table<TableDef extends UntypedTableDef> = Prettify<\n  TableMethods<TableDef> & Indexes<TableDef, TableIndexes<TableDef>>\n>;\n\nexport type ReadonlyTable<TableDef extends UntypedTableDef> = Prettify<\n  ReadonlyTableMethods<TableDef> &\n    ReadonlyIndexes<TableDef, TableIndexes<TableDef>>\n>;\n\nexport interface ReadonlyTableMethods<TableDef extends UntypedTableDef> {\n  /** Returns the number of rows in the TX state. */\n  count(): bigint;\n\n  /** Iterate over all rows in the TX state. Rust Iterator<Item=Row>  TS IterableIterator<Row>. */\n  iter(): IteratorObject<Prettify<RowType<TableDef>>, undefined>;\n  [Symbol.iterator](): IteratorObject<Prettify<RowType<TableDef>>, undefined>;\n}\n\n/**\n * A type representing the methods available on a table.\n */\nexport interface TableMethods<TableDef extends UntypedTableDef>\n  extends ReadonlyTableMethods<TableDef> {\n  /**\n   * Insert and return the inserted row (auto-increment fields filled).\n   *\n   * May throw on error:\n   * * If there are any unique or primary key columns in this table, may throw {@link errors.UniqueAlreadyExists}.\n   * * If there are any auto-incrementing columns in this table, may throw {@link errors.AutoIncOverflow}.\n   * */\n  insert(row: Prettify<RowType<TableDef>>): Prettify<RowType<TableDef>>;\n\n  /** Delete a row equal to `row`. Returns true if something was deleted. */\n  delete(row: Prettify<RowType<TableDef>>): boolean;\n}\n\n/**\n * Defines a database table with schema and options.\n *\n * @param opts - Table configuration including name, indexes, and access control\n * @param row - Product type defining the table's row structure\n * @returns Table handle for use in schema() function\n *\n * @example\n * ```ts\n * const playerTable = table(\n *   { name: 'player', public: true },\n *   {\n *     id: t.u32().primaryKey(),\n *     name: t.string().index('btree')\n *   }\n * );\n * ```\n *\n * ## Column Validation Error\n *\n * **If you see an error like \"Expected 3 arguments, but got 2\"**, this means\n * one of your columns has an invalid combination of attributes.\n *\n * Specifically, `default()` cannot be combined with:\n * - `primaryKey()`\n * - `unique()`\n * - `autoInc()`\n *\n * **Example of invalid code:**\n * ```ts\n * // ERROR: default() + primaryKey() is not allowed\n * const badTable = table(\n *   { name: 'bad' },\n *   { id: t.u64().default(0n).primaryKey() }  // <- This causes \"Expected 3 arguments\"\n * );\n * ```\n *\n * **How to fix:** Remove either `default()` or the constraint (`primaryKey`/`unique`/`autoInc`).\n */\nexport function table<Row extends RowObj, const Opts extends TableOpts<Row>>(\n  opts: Opts,\n  row: Row | RowBuilder<Row>,\n  //  INTERNAL: This parameter enforces compile-time validation of column metadata.\n  // It is never passed at runtime. If you see \"Expected 3 arguments, but got 2\",\n  // it means a column has an invalid combination (e.g., default + primaryKey).\n  // See the JSDoc above for details on how to fix this error.\n  ..._: HasInvalidColumn<Row> extends true\n    ? [\n        error: ERROR_default_cannot_be_combined_with_primaryKey_unique_or_autoInc<\n          InvalidColumnNames<Row>\n        >,\n      ]\n    : []\n): TableSchema<CoerceRow<Row>, OptsIndices<Opts>> {\n  const {\n    name,\n    public: isPublic = false,\n    indexes: userIndexes = [],\n    scheduled,\n    event: isEvent = false,\n  } = opts;\n\n  // 1. column catalogue + helpers\n  const colIds = new Map<keyof Row & string, ColId>();\n  const colNameList: string[] = [];\n\n  if (!(row instanceof RowBuilder)) {\n    row = new RowBuilder(row);\n  }\n\n  row.algebraicType.value.elements.forEach((elem, i) => {\n    colIds.set(elem.name, i);\n    colNameList.push(elem.name);\n  });\n\n  // gather primary keys, percolumn indexes, uniques, sequences\n  const pk: ColList = [];\n  const indexes: (RawIndexDefV10 & { canonicalName?: string })[] = [];\n  const constraints: RawConstraintDefV10[] = [];\n  const sequences: RawSequenceDefV10[] = [];\n\n  let scheduleAtCol: ColId | undefined;\n  const defaultValues: RawColumnDefaultValueV10[] = [];\n\n  for (const [name, builder] of Object.entries(row.row)) {\n    const meta: ColumnMetadata<any> = builder.columnMetadata;\n\n    if (meta.isPrimaryKey) {\n      pk.push(colIds.get(name)!);\n    }\n\n    const isUnique = meta.isUnique || meta.isPrimaryKey;\n\n    // implicit 1column indexes\n    if (meta.indexType || isUnique) {\n      const algo = meta.indexType ?? 'btree';\n      const id = colIds.get(name)!;\n      let algorithm: RawIndexAlgorithm;\n      switch (algo) {\n        case 'btree':\n          algorithm = RawIndexAlgorithm.BTree([id]);\n          break;\n        case 'hash':\n          algorithm = RawIndexAlgorithm.Hash([id]);\n          break;\n        case 'direct':\n          algorithm = RawIndexAlgorithm.Direct(id);\n          break;\n      }\n      indexes.push({\n        sourceName: undefined, // Unnamed indexes will be assigned a globally unique name\n        accessorName: name,\n        algorithm,\n      });\n    }\n\n    if (isUnique) {\n      constraints.push({\n        sourceName: undefined,\n        data: { tag: 'Unique', value: { columns: [colIds.get(name)!] } },\n      });\n    }\n\n    if (meta.isAutoIncrement) {\n      sequences.push({\n        sourceName: undefined,\n        start: undefined,\n        minValue: undefined,\n        maxValue: undefined,\n        column: colIds.get(name)!,\n        increment: 1n,\n      });\n    }\n\n    if (meta.defaultValue) {\n      const writer = new BinaryWriter(16);\n      builder.serialize(writer, meta.defaultValue);\n      defaultValues.push({\n        colId: colIds.get(name)!,\n        value: writer.getBuffer(),\n      });\n    }\n\n    // If this column is shaped like ScheduleAtAlgebraicType, mark it as the scheduleat column\n    if (scheduled) {\n      const algebraicType = builder.typeBuilder.algebraicType;\n      if (ScheduleAt.isScheduleAt(algebraicType)) {\n        scheduleAtCol = colIds.get(name)!;\n      }\n    }\n  }\n\n  // convert explicit multicolumn indexes coming from options.indexes\n  for (const indexOpts of userIndexes ?? []) {\n    let algorithm: RawIndexAlgorithm;\n    switch (indexOpts.algorithm) {\n      case 'btree':\n        algorithm = {\n          tag: 'BTree',\n          value: indexOpts.columns.map(c => colIds.get(c)!),\n        };\n        break;\n      case 'hash':\n        algorithm = {\n          tag: 'Hash',\n          value: indexOpts.columns.map(c => colIds.get(c)!),\n        };\n        break;\n      case 'direct':\n        algorithm = { tag: 'Direct', value: colIds.get(indexOpts.column)! };\n        break;\n    }\n    // unnamed indexes will be assigned a globally unique name\n    // The name users supply is actually the accessor name which will be used\n    // in TypeScript to access the index. This will be used verbatim.\n    // This is confusing because it is not the index name and there is\n    // no actual way for the user to set the actual index name.\n    // I think we should standardize: name and accessorName as the way to set\n    // the name and accessor name of an index across all SDKs.\n    indexes.push({\n      sourceName: undefined,\n      accessorName: indexOpts.accessor,\n      algorithm,\n      canonicalName: indexOpts.name,\n    });\n  }\n\n  // add explicit constraints from options.constraints\n  for (const constraintOpts of opts.constraints ?? []) {\n    if (constraintOpts.constraint === 'unique') {\n      const data: RawConstraintDefV10['data'] = {\n        tag: 'Unique',\n        value: { columns: constraintOpts.columns.map(c => colIds.get(c)!) },\n      };\n      constraints.push({ sourceName: constraintOpts.name, data });\n      continue;\n    }\n  }\n\n  const productType = row.algebraicType.value as RowBuilder<\n    CoerceRow<Row>\n  >['algebraicType']['value'];\n\n  const schedule =\n    scheduled && scheduleAtCol !== undefined\n      ? { scheduleAtCol, reducer: scheduled }\n      : undefined;\n\n  return {\n    rowType: row as RowBuilder<CoerceRow<Row>>,\n    tableName: name,\n    rowSpacetimeType: productType,\n    tableDef: (ctx, accName) => {\n      const tableName = name ?? accName;\n      if (row.typeName === undefined) {\n        row.typeName = toPascalCase(tableName);\n      }\n\n      // Build index source names using accName\n      for (const index of indexes) {\n        const cols =\n          index.algorithm.tag === 'Direct'\n            ? [index.algorithm.value]\n            : index.algorithm.value;\n\n        const colS = cols.map(i => colNameList[i]).join('_');\n        const sourceName =\n          (index.sourceName = `${accName}_${colS}_idx_${index.algorithm.tag.toLowerCase()}`);\n\n        const { canonicalName } = index;\n        if (canonicalName !== undefined) {\n          ctx.moduleDef.explicitNames.entries.push(\n            ExplicitNameEntry.Index({ sourceName, canonicalName })\n          );\n        }\n      }\n\n      return {\n        sourceName: accName,\n        productTypeRef: ctx.registerTypesRecursively(row).ref,\n        primaryKey: pk,\n        indexes,\n        constraints,\n        sequences,\n        tableType: { tag: 'User' },\n        tableAccess: { tag: isPublic ? 'Public' : 'Private' },\n        defaultValues,\n        isEvent,\n      };\n    },\n    idxs: {} as OptsIndices<Opts>,\n    constraints: constraints as OptsConstraints<Opts>,\n    schedule,\n  };\n}\n","import type { ProductType } from '../lib/algebraic_type';\nimport type { ReducerSchema } from '../lib/reducer_schema';\nimport type { ParamsObj } from '../lib/reducers';\nimport type { CoerceRow } from '../lib/table';\nimport { RowBuilder, type InferTypeOfRow } from '../lib/type_builders';\nimport type { CamelCase } from '../lib/type_util';\nimport { toCamelCase } from '../lib/util';\nimport type { SubscriptionEventContextInterface } from './event_context';\nimport type { UntypedRemoteModule } from './spacetime_module';\n\nexport type SubscriptionEventCallback<\n  RemoteModule extends UntypedRemoteModule,\n> = (ctx: SubscriptionEventContextInterface<RemoteModule>) => void;\n\n// Utility: detect 'any'\ntype IfAny<T, Y, N> = 0 extends 1 & T ? Y : N;\n\n// Loose shape that allows all three families even when key names are unknown\ntype ReducersViewLoose = {\n  // call: camelCase(name)\n  [k: string]: (params: any) => Promise<void>;\n};\n\nexport type ReducersView<RemoteModule> = IfAny<\n  RemoteModule,\n  ReducersViewLoose,\n  RemoteModule extends UntypedRemoteModule\n    ? // x: camelCase(name)\n      {\n        [K in RemoteModule['reducers'][number] as CamelCase<\n          K['accessorName']\n        >]: (params: InferTypeOfRow<K['params']>) => Promise<void>;\n      }\n    : never\n>;\n\nexport type ReducerEventInfo<\n  Name extends string = string,\n  Args extends object = object,\n> = {\n  name: Name;\n  args: Args;\n};\n\nexport type UntypedReducerDef = {\n  name: string;\n  accessorName: string;\n  params: CoerceRow<ParamsObj>;\n  paramsType: ProductType;\n};\n\nexport type UntypedReducersDef = {\n  reducers: readonly UntypedReducerDef[];\n};\n\nclass Reducers<ReducersDef extends UntypedReducersDef> {\n  reducersType: ReducersDef;\n\n  constructor(handles: readonly ReducerSchema<any, any>[]) {\n    this.reducersType = reducersToSchema(handles) as ReducersDef;\n  }\n}\n\n/**\n * Helper type to convert an array of TableSchema into a schema definition\n */\ntype ReducersToSchema<T extends readonly ReducerSchema<any, any>[]> = {\n  reducers: {\n    /** @type {UntypedReducerDef} */\n    readonly [i in keyof T]: {\n      name: T[i]['reducerName'];\n      accessorName: CamelCase<T[i]['accessorName']>;\n      params: T[i]['params']['row'];\n      paramsType: T[i]['paramsSpacetimeType'];\n    };\n  };\n};\n\nexport function reducersToSchema<\n  const T extends readonly ReducerSchema<any, any>[],\n>(reducers: T): ReducersToSchema<T> {\n  const mapped = reducers.map(r => {\n    const paramsRow = r.params.row;\n\n    return {\n      name: r.reducerName,\n      // Prefer the schema's own accessorName if present at runtime; otherwise derive it.\n      accessorName: r.accessorName,\n      params: paramsRow,\n      paramsType: r.paramsSpacetimeType,\n    } as const;\n  }) as {\n    readonly [I in keyof T]: {\n      name: T[I]['reducerName'];\n      accessorName: T[I]['accessorName'];\n      params: T[I]['params']['row'];\n      paramsType: T[I]['paramsSpacetimeType'];\n    };\n  };\n\n  const result = { reducers: mapped } satisfies ReducersToSchema<T>;\n  return result;\n}\n\n/**\n * Creates a schema from table definitions\n * @param handles - Array of table handles created by table() function\n * @returns ColumnBuilder representing the complete database schema\n * @example\n * ```ts\n * const s = schema({\n *   user: table({}, userType),\n *   post: table({}, postType)\n * });\n * ```\n */\nexport function reducers<const H extends readonly ReducerSchema<any, any>[]>(\n  ...handles: H\n): Reducers<ReducersToSchema<H>>;\n\n/**\n * Creates a schema from table definitions (array overload)\n * @param handles - Array of table handles created by table() function\n * @returns ColumnBuilder representing the complete database schema\n */\nexport function reducers<const H extends readonly ReducerSchema<any, any>[]>(\n  handles: H\n): Reducers<ReducersToSchema<H>>;\n\nexport function reducers<const H extends readonly ReducerSchema<any, any>[]>(\n  ...args: [H] | H\n): Reducers<ReducersToSchema<H>> {\n  const handles = (\n    args.length === 1 && Array.isArray(args[0]) ? args[0] : args\n  ) as H;\n  return new Reducers(handles);\n}\n\nexport function reducerSchema<\n  ReducerName extends string,\n  Params extends ParamsObj,\n>(name: ReducerName, params: Params): ReducerSchema<ReducerName, Params> {\n  const paramType: ProductType = {\n    elements: Object.entries(params).map(([n, c]) => ({\n      name: n,\n      algebraicType:\n        'typeBuilder' in c ? c.typeBuilder.algebraicType : c.algebraicType,\n    })),\n  };\n  return {\n    reducerName: name,\n    accessorName: toCamelCase(name),\n    params: new RowBuilder<Params>(params),\n    paramsSpacetimeType: paramType,\n    reducerDef: {\n      name,\n      params: paramType,\n      lifecycle: undefined,\n    },\n  };\n}\n","import type { ParamsObj } from '../lib/reducers';\nimport type { Infer, InferTypeOfRow, TypeBuilder } from '../lib/type_builders';\nimport type { CamelCase } from '../lib/type_util';\nimport { coerceParams, toCamelCase, type CoerceParams } from '../lib/util';\nimport type { UntypedRemoteModule } from './spacetime_module';\n\n// Utility: detect 'any'\ntype IfAny<T, Y, N> = 0 extends 1 & T ? Y : N;\n\n// Loose shape that allows all three families even when key names are unknown\ntype ProceduresViewLoose = {\n  // call: camelCase(name)\n  [k: string]: (params: any) => Promise<any>;\n};\n\nexport type ProceduresView<RemoteModule> = IfAny<\n  RemoteModule,\n  ProceduresViewLoose,\n  RemoteModule extends UntypedRemoteModule\n    ? // x: camelCase(name)\n      {\n        [K in RemoteModule['procedures'][number] as CamelCase<\n          K['accessorName']\n        >]: (\n          params: InferTypeOfRow<K['params']>\n        ) => Promise<Infer<K['returnType']>>;\n      }\n    : never\n>;\n\nexport type UntypedProcedureDef = {\n  name: string;\n  accessorName: string;\n  params: CoerceParams<ParamsObj>;\n  returnType: TypeBuilder<any, any>;\n};\n\nexport type UntypedProceduresDef = {\n  procedures: readonly UntypedProcedureDef[];\n};\n\nexport function procedures<const H extends readonly UntypedProcedureDef[]>(\n  ...handles: H\n): { procedures: H };\n\nexport function procedures<const H extends readonly UntypedProcedureDef[]>(\n  handles: H\n): { procedures: H };\n\nexport function procedures<const H extends readonly UntypedProcedureDef[]>(\n  ...args: [H] | H\n): { procedures: H } {\n  const procedures = (\n    args.length === 1 && Array.isArray(args[0]) ? args[0] : args\n  ) as H;\n  return { procedures };\n}\n\ntype ProcedureDef<\n  Name extends string,\n  Params extends ParamsObj,\n  ReturnType extends TypeBuilder<any, any>,\n> = {\n  name: Name;\n  accessorName: CamelCase<Name>;\n  params: CoerceParams<Params>;\n  returnType: ReturnType;\n};\n\nexport function procedureSchema<\n  ProcedureName extends string,\n  Params extends ParamsObj,\n  ReturnType extends TypeBuilder<any, any>,\n>(\n  name: ProcedureName,\n  params: Params,\n  returnType: ReturnType\n): ProcedureDef<ProcedureName, Params, ReturnType> {\n  return {\n    name,\n    accessorName: toCamelCase(name),\n    params: coerceParams(params),\n    returnType,\n  };\n}\n"]}