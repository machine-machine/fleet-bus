import type { ParamsObj } from '../lib/reducers';
import type { Infer, InferTypeOfRow, TypeBuilder } from '../lib/type_builders';
import type { CamelCase } from '../lib/type_util';
import { type CoerceParams } from '../lib/util';
import type { UntypedRemoteModule } from './spacetime_module';
type IfAny<T, Y, N> = 0 extends 1 & T ? Y : N;
type ProceduresViewLoose = {
    [k: string]: (params: any) => Promise<any>;
};
export type ProceduresView<RemoteModule> = IfAny<RemoteModule, ProceduresViewLoose, RemoteModule extends UntypedRemoteModule ? {
    [K in RemoteModule['procedures'][number] as CamelCase<K['accessorName']>]: (params: InferTypeOfRow<K['params']>) => Promise<Infer<K['returnType']>>;
} : never>;
export type UntypedProcedureDef = {
    name: string;
    accessorName: string;
    params: CoerceParams<ParamsObj>;
    returnType: TypeBuilder<any, any>;
};
export type UntypedProceduresDef = {
    procedures: readonly UntypedProcedureDef[];
};
export declare function procedures<const H extends readonly UntypedProcedureDef[]>(...handles: H): {
    procedures: H;
};
export declare function procedures<const H extends readonly UntypedProcedureDef[]>(handles: H): {
    procedures: H;
};
type ProcedureDef<Name extends string, Params extends ParamsObj, ReturnType extends TypeBuilder<any, any>> = {
    name: Name;
    accessorName: CamelCase<Name>;
    params: CoerceParams<Params>;
    returnType: ReturnType;
};
export declare function procedureSchema<ProcedureName extends string, Params extends ParamsObj, ReturnType extends TypeBuilder<any, any>>(name: ProcedureName, params: Params, returnType: ReturnType): ProcedureDef<ProcedureName, Params, ReturnType>;
export {};
//# sourceMappingURL=procedures.d.ts.map