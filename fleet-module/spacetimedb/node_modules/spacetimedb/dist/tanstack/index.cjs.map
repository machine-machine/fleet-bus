{"version":3,"sources":["../../src/lib/time_duration.ts","../../src/lib/timestamp.ts","../../src/lib/uuid.ts","../../src/lib/binary_reader.ts","../../src/lib/binary_writer.ts","../../src/lib/util.ts","../../src/lib/identity.ts","../../src/lib/algebraic_type.ts","../../src/lib/connection_id.ts","../../src/lib/query.ts","../../src/tanstack/SpacetimeDBQueryClient.ts","../../src/tanstack/hooks.ts","../../src/react/useSpacetimeDB.ts","../../src/sdk/connection_manager.ts","../../src/react/SpacetimeDBProvider.ts","../../src/react/useReducer.ts"],"names":["fromByteArray","body","useQuery","useSuspenseQuery","createContext","useContext","React","useRef","useEffect","useCallback"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;AAcO,IAAM,YAAA,GAAN,MAAM,aAAA,CAAa;AAAA,EACxB,wBAAA;AAAA,EAEA,OAAe,iBAAA,GAA4B,KAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAM3C,OAAO,gBAAA,GAA8C;AACnD,IAAA,OAAO,cAAc,OAAA,CAAQ;AAAA,MAC3B,QAAA,EAAU;AAAA,QACR;AAAA,UACE,IAAA,EAAM,0BAAA;AAAA,UACN,eAAe,aAAA,CAAc;AAAA;AAC/B;AACF,KACD,CAAA;AAAA,EACH;AAAA,EAEA,OAAO,eACL,aAAA,EAC4C;AAC5C,IAAA,IAAI,aAAA,CAAc,QAAQ,SAAA,EAAW;AACnC,MAAA,OAAO,KAAA;AAAA,IACT;AACA,IAAA,MAAM,QAAA,GAAW,cAAc,KAAA,CAAM,QAAA;AACrC,IAAA,IAAI,QAAA,CAAS,WAAW,CAAA,EAAG;AACzB,MAAA,OAAO,KAAA;AAAA,IACT;AACA,IAAA,MAAM,aAAA,GAAgB,SAAS,CAAC,CAAA;AAChC,IAAA,OACE,aAAA,CAAc,IAAA,KAAS,0BAAA,IACvB,aAAA,CAAc,cAAc,GAAA,KAAQ,KAAA;AAAA,EAExC;AAAA,EAEA,IAAI,MAAA,GAAiB;AACnB,IAAA,OAAO,IAAA,CAAK,wBAAA;AAAA,EACd;AAAA,EAEA,IAAI,MAAA,GAAiB;AACnB,IAAA,OAAO,MAAA,CAAO,IAAA,CAAK,MAAA,GAAS,aAAA,CAAa,iBAAiB,CAAA;AAAA,EAC5D;AAAA,EAEA,YAAY,MAAA,EAAgB;AAC1B,IAAA,IAAA,CAAK,wBAAA,GAA2B,MAAA;AAAA,EAClC;AAAA,EAEA,OAAO,WAAW,MAAA,EAA8B;AAC9C,IAAA,OAAO,IAAI,aAAA,CAAa,MAAA,CAAO,MAAM,CAAA,GAAI,cAAa,iBAAiB,CAAA;AAAA,EACzE;AAAA;AAAA,EAGA,QAAA,GAAmB;AACjB,IAAA,MAAM,SAAS,IAAA,CAAK,MAAA;AACpB,IAAA,MAAM,IAAA,GAAO,MAAA,GAAS,CAAA,GAAI,GAAA,GAAM,GAAA;AAChC,IAAA,MAAM,GAAA,GAAM,MAAA,GAAS,CAAA,GAAI,CAAC,MAAA,GAAS,MAAA;AACnC,IAAA,MAAM,OAAO,GAAA,GAAM,QAAA;AACnB,IAAA,MAAM,mBAAmB,GAAA,GAAM,QAAA;AAC/B,IAAA,OAAO,CAAA,EAAG,IAAI,CAAA,EAAG,IAAI,CAAA,CAAA,EAAI,MAAA,CAAO,gBAAgB,CAAA,CAAE,QAAA,CAAS,CAAA,EAAG,GAAG,CAAC,CAAA,CAAA;AAAA,EACpE;AACF,CAAA;;;AC1DO,IAAM,SAAA,GAAN,MAAM,UAAA,CAAU;AAAA,EACrB,qCAAA;AAAA,EAEA,OAAe,iBAAA,GAA4B,KAAA;AAAA,EAE3C,IAAI,oBAAA,GAA+B;AACjC,IAAA,OAAO,IAAA,CAAK,qCAAA;AAAA,EACd;AAAA,EAEA,YAAY,MAAA,EAAgB;AAC1B,IAAA,IAAA,CAAK,qCAAA,GAAwC,MAAA;AAAA,EAC/C;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,OAAO,gBAAA,GAA2C;AAChD,IAAA,OAAO,cAAc,OAAA,CAAQ;AAAA,MAC3B,QAAA,EAAU;AAAA,QACR;AAAA,UACE,IAAA,EAAM,uCAAA;AAAA,UACN,eAAe,aAAA,CAAc;AAAA;AAC/B;AACF,KACD,CAAA;AAAA,EACH;AAAA,EAEA,OAAO,YACL,aAAA,EACyC;AACzC,IAAA,IAAI,aAAA,CAAc,QAAQ,SAAA,EAAW;AACnC,MAAA,OAAO,KAAA;AAAA,IACT;AACA,IAAA,MAAM,QAAA,GAAW,cAAc,KAAA,CAAM,QAAA;AACrC,IAAA,IAAI,QAAA,CAAS,WAAW,CAAA,EAAG;AACzB,MAAA,OAAO,KAAA;AAAA,IACT;AACA,IAAA,MAAM,aAAA,GAAgB,SAAS,CAAC,CAAA;AAChC,IAAA,OACE,aAAA,CAAc,IAAA,KAAS,uCAAA,IACvB,aAAA,CAAc,cAAc,GAAA,KAAQ,KAAA;AAAA,EAExC;AAAA;AAAA;AAAA;AAAA,EAKA,OAAO,UAAA,GAAwB,IAAI,UAAA,CAAU,EAAE,CAAA;AAAA;AAAA;AAAA;AAAA,EAK/C,OAAO,GAAA,GAAiB;AACtB,IAAA,OAAO,UAAA,CAAU,QAAA,iBAAS,IAAI,IAAA,EAAM,CAAA;AAAA,EACtC;AAAA;AAAA,EAGA,QAAA,GAAmB;AACjB,IAAA,OAAO,KAAK,oBAAA,GAAuB,KAAA;AAAA,EACrC;AAAA;AAAA;AAAA;AAAA,EAKA,OAAO,SAAS,IAAA,EAAuB;AACrC,IAAA,MAAM,MAAA,GAAS,KAAK,OAAA,EAAQ;AAC5B,IAAA,MAAM,MAAA,GAAS,MAAA,CAAO,MAAM,CAAA,GAAI,UAAA,CAAU,iBAAA;AAC1C,IAAA,OAAO,IAAI,WAAU,MAAM,CAAA;AAAA,EAC7B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,MAAA,GAAe;AACb,IAAA,MAAM,SAAS,IAAA,CAAK,qCAAA;AACpB,IAAA,MAAM,MAAA,GAAS,SAAS,UAAA,CAAU,iBAAA;AAClC,IAAA,IACE,MAAA,GAAS,OAAO,MAAA,CAAO,gBAAgB,KACvC,MAAA,GAAS,MAAA,CAAO,MAAA,CAAO,gBAAgB,CAAA,EACvC;AACA,MAAA,MAAM,IAAI,UAAA;AAAA,QACR;AAAA,OACF;AAAA,IACF;AACA,IAAA,OAAO,IAAI,IAAA,CAAK,MAAA,CAAO,MAAM,CAAC,CAAA;AAAA,EAChC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,WAAA,GAAsB;AACpB,IAAA,MAAM,SAAS,IAAA,CAAK,qCAAA;AACpB,IAAA,MAAM,MAAA,GAAS,SAAS,UAAA,CAAU,iBAAA;AAElC,IAAA,IACE,MAAA,GAAS,OAAO,MAAA,CAAO,gBAAgB,KACvC,MAAA,GAAS,MAAA,CAAO,MAAA,CAAO,gBAAgB,CAAA,EACvC;AACA,MAAA,MAAM,IAAI,UAAA;AAAA,QACR;AAAA,OACF;AAAA,IACF;AAEA,IAAA,MAAM,IAAA,GAAO,IAAI,IAAA,CAAK,MAAA,CAAO,MAAM,CAAC,CAAA;AACpC,IAAA,MAAM,OAAA,GAAU,KAAK,WAAA,EAAY;AAGjC,IAAA,MAAM,kBAAkB,IAAA,CAAK,GAAA,CAAI,MAAA,CAAO,MAAA,GAAS,QAAQ,CAAC,CAAA;AAC1D,IAAA,MAAM,iBAAiB,MAAA,CAAO,eAAe,CAAA,CAAE,QAAA,CAAS,GAAG,GAAG,CAAA;AAG9D,IAAA,OAAO,OAAA,CAAQ,OAAA,CAAQ,WAAA,EAAa,CAAA,CAAA,EAAI,cAAc,CAAA,CAAA,CAAG,CAAA;AAAA,EAC3D;AAAA,EAEA,MAAM,KAAA,EAAgC;AACpC,IAAA,OAAO,IAAI,YAAA;AAAA,MACT,IAAA,CAAK,wCACH,KAAA,CAAM;AAAA,KACV;AAAA,EACF;AACF,CAAA;;;AClHO,IAAM,IAAA,GAAN,MAAM,KAAA,CAAK;AAAA,EAChB,QAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAaA,OAAgB,GAAA,GAAM,IAAI,KAAA,CAAK,EAAE,CAAA;AAAA,EACjC,OAAgB,eAAA,GAAkB,mCAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYlC,OAAgB,GAAA,GAAM,IAAI,KAAA,CAAK,MAAK,eAAe,CAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQnD,YAAY,CAAA,EAAW;AAErB,IAAA,IAAI,CAAA,GAAI,EAAA,IAAM,CAAA,GAAI,KAAA,CAAK,eAAA,EAAiB;AACtC,MAAA,MAAM,IAAI,MAAM,uDAAuD,CAAA;AAAA,IACzE;AACA,IAAA,IAAA,CAAK,QAAA,GAAW,CAAA;AAAA,EAClB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAsBA,OAAO,kBAAkB,KAAA,EAAyB;AAChD,IAAA,IAAI,MAAM,MAAA,KAAW,EAAA,EAAI,MAAM,IAAI,MAAM,2BAA2B,CAAA;AACpE,IAAA,MAAM,GAAA,GAAM,IAAI,UAAA,CAAW,KAAK,CAAA;AAChC,IAAA,GAAA,CAAI,CAAC,CAAA,GAAK,GAAA,CAAI,CAAC,IAAI,EAAA,GAAQ,EAAA;AAC3B,IAAA,GAAA,CAAI,CAAC,CAAA,GAAK,GAAA,CAAI,CAAC,IAAI,EAAA,GAAQ,GAAA;AAC3B,IAAA,OAAO,IAAI,KAAA,CAAK,KAAA,CAAK,aAAA,CAAc,GAAG,CAAC,CAAA;AAAA,EACzC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EA6CA,OAAO,aAAA,CACL,OAAA,EACA,GAAA,EACA,WAAA,EACM;AACN,IAAA,IAAI,WAAA,CAAY,WAAW,CAAA,EAAG;AAC5B,MAAA,MAAM,IAAI,MAAM,oDAAoD,CAAA;AAAA,IACtE;AAEA,IAAA,IAAI,OAAA,CAAQ,QAAQ,CAAA,EAAG;AACrB,MAAA,MAAM,IAAI,MAAM,qDAAqD,CAAA;AAAA,IACvE;AAEA,IAAA,IAAI,GAAA,CAAI,wCAAwC,CAAA,EAAG;AACjD,MAAA,MAAM,IAAI,MAAM,+CAA+C,CAAA;AAAA,IACjE;AAGA,IAAA,MAAM,aAAa,OAAA,CAAQ,KAAA;AAC3B,IAAA,OAAA,CAAQ,KAAA,GAAS,aAAa,CAAA,GAAK,UAAA;AAGnC,IAAA,MAAM,IAAA,GAAO,GAAA,CAAI,QAAA,EAAS,GAAI,eAAA;AAE9B,IAAA,MAAM,KAAA,GAAQ,IAAI,UAAA,CAAW,EAAE,CAAA;AAG/B,IAAA,KAAA,CAAM,CAAC,CAAA,GAAI,MAAA,CAAQ,IAAA,IAAQ,MAAO,KAAK,CAAA;AACvC,IAAA,KAAA,CAAM,CAAC,CAAA,GAAI,MAAA,CAAQ,IAAA,IAAQ,MAAO,KAAK,CAAA;AACvC,IAAA,KAAA,CAAM,CAAC,CAAA,GAAI,MAAA,CAAQ,IAAA,IAAQ,MAAO,KAAK,CAAA;AACvC,IAAA,KAAA,CAAM,CAAC,CAAA,GAAI,MAAA,CAAQ,IAAA,IAAQ,MAAO,KAAK,CAAA;AACvC,IAAA,KAAA,CAAM,CAAC,CAAA,GAAI,MAAA,CAAQ,IAAA,IAAQ,KAAM,KAAK,CAAA;AACtC,IAAA,KAAA,CAAM,CAAC,CAAA,GAAI,MAAA,CAAO,IAAA,GAAO,KAAK,CAAA;AAG9B,IAAA,KAAA,CAAM,CAAC,CAAA,GAAK,UAAA,KAAe,EAAA,GAAM,GAAA;AACjC,IAAA,KAAA,CAAM,CAAC,CAAA,GAAK,UAAA,KAAe,EAAA,GAAM,GAAA;AACjC,IAAA,KAAA,CAAM,EAAE,CAAA,GAAK,UAAA,KAAe,CAAA,GAAK,GAAA;AACjC,IAAA,KAAA,CAAM,EAAE,CAAA,GAAA,CAAM,UAAA,GAAa,GAAA,KAAS,CAAA,GAAK,GAAA;AAGzC,IAAA,KAAA,CAAM,EAAE,CAAA,IAAK,WAAA,CAAY,CAAC,CAAA,GAAI,GAAA;AAC9B,IAAA,KAAA,CAAM,EAAE,CAAA,GAAI,WAAA,CAAY,CAAC,CAAA;AACzB,IAAA,KAAA,CAAM,EAAE,CAAA,GAAI,WAAA,CAAY,CAAC,CAAA;AACzB,IAAA,KAAA,CAAM,EAAE,CAAA,GAAI,WAAA,CAAY,CAAC,CAAA;AAGzB,IAAA,KAAA,CAAM,CAAC,CAAA,GAAK,KAAA,CAAM,CAAC,IAAI,EAAA,GAAQ,GAAA;AAG/B,IAAA,KAAA,CAAM,CAAC,CAAA,GAAK,KAAA,CAAM,CAAC,IAAI,EAAA,GAAQ,GAAA;AAE/B,IAAA,OAAO,IAAI,KAAA,CAAK,KAAA,CAAK,aAAA,CAAc,KAAK,CAAC,CAAA;AAAA,EAC3C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAiBA,OAAO,MAAM,CAAA,EAAiB;AAC5B,IAAA,MAAM,GAAA,GAAM,CAAA,CAAE,OAAA,CAAQ,IAAA,EAAM,EAAE,CAAA;AAC9B,IAAA,IAAI,IAAI,MAAA,KAAW,EAAA,EAAI,MAAM,IAAI,MAAM,kBAAkB,CAAA;AAEzD,IAAA,IAAI,CAAA,GAAI,EAAA;AACR,IAAA,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,EAAA,EAAI,KAAK,CAAA,EAAG;AAC9B,MAAA,CAAA,GAAK,CAAA,IAAK,EAAA,GAAM,MAAA,CAAO,QAAA,CAAS,GAAA,CAAI,KAAA,CAAM,CAAA,EAAG,CAAA,GAAI,CAAC,CAAA,EAAG,EAAE,CAAC,CAAA;AAAA,IAC1D;AACA,IAAA,OAAO,IAAI,MAAK,CAAC,CAAA;AAAA,EACnB;AAAA;AAAA,EAGA,QAAA,GAAmB;AACjB,IAAA,MAAM,KAAA,GAAQ,KAAA,CAAK,aAAA,CAAc,IAAA,CAAK,QAAQ,CAAA;AAC9C,IAAA,MAAM,MAAM,CAAC,GAAG,KAAK,CAAA,CAAE,IAAI,CAAA,CAAA,KAAK,CAAA,CAAE,QAAA,CAAS,EAAE,EAAE,QAAA,CAAS,CAAA,EAAG,GAAG,CAAC,CAAA,CAAE,KAAK,EAAE,CAAA;AAGxE,IAAA,OACE,GAAA,CAAI,KAAA,CAAM,CAAA,EAAG,CAAC,CAAA,GACd,GAAA,GACA,GAAA,CAAI,KAAA,CAAM,CAAA,EAAG,EAAE,CAAA,GACf,GAAA,GACA,GAAA,CAAI,MAAM,EAAA,EAAI,EAAE,CAAA,GAChB,GAAA,GACA,GAAA,CAAI,KAAA,CAAM,EAAA,EAAI,EAAE,CAAA,GAChB,GAAA,GACA,GAAA,CAAI,KAAA,CAAM,EAAE,CAAA;AAAA,EAEhB;AAAA;AAAA,EAGA,QAAA,GAAmB;AACjB,IAAA,OAAO,IAAA,CAAK,QAAA;AAAA,EACd;AAAA;AAAA,EAGA,OAAA,GAAsB;AACpB,IAAA,OAAO,KAAA,CAAK,aAAA,CAAc,IAAA,CAAK,QAAQ,CAAA;AAAA,EACzC;AAAA,EAEA,OAAe,cAAc,KAAA,EAA2B;AACtD,IAAA,IAAI,MAAA,GAAS,EAAA;AACb,IAAA,KAAA,MAAW,KAAK,KAAA,EAAO,MAAA,GAAU,MAAA,IAAU,EAAA,GAAM,OAAO,CAAC,CAAA;AACzD,IAAA,OAAO,MAAA;AAAA,EACT;AAAA,EAEA,OAAe,cAAc,KAAA,EAA2B;AACtD,IAAA,MAAM,KAAA,GAAQ,IAAI,UAAA,CAAW,EAAE,CAAA;AAC/B,IAAA,KAAA,IAAS,CAAA,GAAI,EAAA,EAAI,CAAA,IAAK,CAAA,EAAG,CAAA,EAAA,EAAK;AAC5B,MAAA,KAAA,CAAM,CAAC,CAAA,GAAI,MAAA,CAAO,KAAA,GAAQ,KAAK,CAAA;AAC/B,MAAA,KAAA,KAAU,EAAA;AAAA,IACZ;AACA,IAAA,OAAO,KAAA;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,UAAA,GAA0B;AACxB,IAAA,MAAM,UAAW,IAAA,CAAK,OAAA,EAAQ,CAAE,CAAC,KAAK,CAAA,GAAK,EAAA;AAE3C,IAAA,QAAQ,OAAA;AAAS,MACf,KAAK,CAAA;AACH,QAAA,OAAO,IAAA;AAAA,MACT,KAAK,CAAA;AACH,QAAA,OAAO,IAAA;AAAA,MACT;AACE,QAAA,IAAI,IAAA,IAAQ,MAAK,GAAA,EAAK;AACpB,UAAA,OAAO,KAAA;AAAA,QACT;AACA,QAAA,IAAI,IAAA,IAAQ,MAAK,GAAA,EAAK;AACpB,UAAA,OAAO,KAAA;AAAA,QACT;AACA,QAAA,MAAM,IAAI,KAAA,CAAM,CAAA,0BAAA,EAA6B,OAAO,CAAA,CAAE,CAAA;AAAA;AAC1D,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,UAAA,GAAqB;AACnB,IAAA,MAAM,KAAA,GAAQ,KAAK,OAAA,EAAQ;AAE3B,IAAA,MAAM,IAAA,GAAO,MAAM,CAAC,CAAA;AACpB,IAAA,MAAM,IAAA,GAAO,MAAM,CAAC,CAAA;AACpB,IAAA,MAAM,IAAA,GAAO,MAAM,EAAE,CAAA;AACrB,IAAA,MAAM,GAAA,GAAM,KAAA,CAAM,EAAE,CAAA,KAAM,CAAA;AAG1B,IAAA,OAAQ,QAAQ,EAAA,GAAO,IAAA,IAAQ,EAAA,GAAO,IAAA,IAAQ,IAAK,GAAA,GAAM,CAAA;AAAA,EAC3D;AAAA,EAEA,UAAU,KAAA,EAAqB;AAC7B,IAAA,IAAI,IAAA,CAAK,QAAA,GAAW,KAAA,CAAM,QAAA,EAAU,OAAO,EAAA;AAC3C,IAAA,IAAI,IAAA,CAAK,QAAA,GAAW,KAAA,CAAM,QAAA,EAAU,OAAO,CAAA;AAE3C,IAAA,OAAO,CAAA;AAAA,EACT;AAAA,EAEA,OAAO,gBAAA,GAAsC;AAC3C,IAAA,OAAO,cAAc,OAAA,CAAQ;AAAA,MAC3B,QAAA,EAAU;AAAA,QACR;AAAA,UACE,IAAA,EAAM,UAAA;AAAA,UACN,eAAe,aAAA,CAAc;AAAA;AAC/B;AACF,KACD,CAAA;AAAA,EACH;AACF,CAAA;;;AChVA,IAAqB,eAArB,MAAkC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAShC,IAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,MAAA,GAAiB,CAAA;AAAA,EAEjB,YAAY,KAAA,EAA8B;AACxC,IAAA,IAAA,CAAK,IAAA,GACH,KAAA,YAAiB,QAAA,GACb,KAAA,GACA,IAAI,QAAA,CAAS,KAAA,CAAM,MAAA,EAAQ,KAAA,CAAM,UAAA,EAAY,KAAA,CAAM,UAAU,CAAA;AACnE,IAAA,IAAA,CAAK,MAAA,GAAS,CAAA;AAAA,EAChB;AAAA,EAEA,MAAM,IAAA,EAAgB;AACpB,IAAA,IAAA,CAAK,IAAA,GAAO,IAAA;AACZ,IAAA,IAAA,CAAK,MAAA,GAAS,CAAA;AAAA,EAChB;AAAA,EAEA,IAAI,SAAA,GAAoB;AACtB,IAAA,OAAO,IAAA,CAAK,IAAA,CAAK,UAAA,GAAa,IAAA,CAAK,MAAA;AAAA,EACrC;AAAA;AAAA,EAGA,QAAQ,CAAA,EAAiB;AACvB,IAAA,IAAI,IAAA,CAAK,MAAA,GAAS,CAAA,GAAI,IAAA,CAAK,KAAK,UAAA,EAAY;AAC1C,MAAA,MAAM,IAAI,UAAA;AAAA,QACR,iBAAiB,CAAC,CAAA,4BAAA,EAA+B,KAAK,MAAM,CAAA,WAAA,EAAc,KAAK,SAAS,CAAA,eAAA;AAAA,OAC1F;AAAA,IACF;AAAA,EACF;AAAA,EAEA,cAAA,GAA6B;AAC3B,IAAA,MAAM,MAAA,GAAS,KAAK,OAAA,EAAQ;AAC5B,IAAA,IAAA,CAAK,QAAQ,MAAM,CAAA;AACnB,IAAA,OAAO,IAAA,CAAK,UAAU,MAAM,CAAA;AAAA,EAC9B;AAAA,EAEA,QAAA,GAAoB;AAClB,IAAA,MAAM,KAAA,GAAQ,IAAA,CAAK,IAAA,CAAK,QAAA,CAAS,KAAK,MAAM,CAAA;AAC5C,IAAA,IAAA,CAAK,MAAA,IAAU,CAAA;AACf,IAAA,OAAO,KAAA,KAAU,CAAA;AAAA,EACnB;AAAA,EAEA,QAAA,GAAmB;AACjB,IAAA,MAAM,KAAA,GAAQ,IAAA,CAAK,IAAA,CAAK,QAAA,CAAS,KAAK,MAAM,CAAA;AAC5C,IAAA,IAAA,CAAK,MAAA,IAAU,CAAA;AACf,IAAA,OAAO,KAAA;AAAA,EACT;AAAA,EAEA,UAAU,MAAA,EAA4B;AAIpC,IAAA,MAAM,QAAQ,IAAI,UAAA;AAAA,MAChB,KAAK,IAAA,CAAK,MAAA;AAAA,MACV,IAAA,CAAK,IAAA,CAAK,UAAA,GAAa,IAAA,CAAK,MAAA;AAAA,MAC5B;AAAA,KACF;AACA,IAAA,IAAA,CAAK,MAAA,IAAU,MAAA;AACf,IAAA,OAAO,KAAA;AAAA,EACT;AAAA,EAEA,MAAA,GAAiB;AACf,IAAA,MAAM,KAAA,GAAQ,IAAA,CAAK,IAAA,CAAK,OAAA,CAAQ,KAAK,MAAM,CAAA;AAC3C,IAAA,IAAA,CAAK,MAAA,IAAU,CAAA;AACf,IAAA,OAAO,KAAA;AAAA,EACT;AAAA,EAEA,MAAA,GAAiB;AACf,IAAA,OAAO,KAAK,QAAA,EAAS;AAAA,EACvB;AAAA,EAEA,OAAA,GAAkB;AAChB,IAAA,MAAM,QAAQ,IAAA,CAAK,IAAA,CAAK,QAAA,CAAS,IAAA,CAAK,QAAQ,IAAI,CAAA;AAClD,IAAA,IAAA,CAAK,MAAA,IAAU,CAAA;AACf,IAAA,OAAO,KAAA;AAAA,EACT;AAAA,EAEA,OAAA,GAAkB;AAChB,IAAA,MAAM,QAAQ,IAAA,CAAK,IAAA,CAAK,SAAA,CAAU,IAAA,CAAK,QAAQ,IAAI,CAAA;AACnD,IAAA,IAAA,CAAK,MAAA,IAAU,CAAA;AACf,IAAA,OAAO,KAAA;AAAA,EACT;AAAA,EAEA,OAAA,GAAkB;AAChB,IAAA,MAAM,QAAQ,IAAA,CAAK,IAAA,CAAK,QAAA,CAAS,IAAA,CAAK,QAAQ,IAAI,CAAA;AAClD,IAAA,IAAA,CAAK,MAAA,IAAU,CAAA;AACf,IAAA,OAAO,KAAA;AAAA,EACT;AAAA,EAEA,OAAA,GAAkB;AAChB,IAAA,MAAM,QAAQ,IAAA,CAAK,IAAA,CAAK,SAAA,CAAU,IAAA,CAAK,QAAQ,IAAI,CAAA;AACnD,IAAA,IAAA,CAAK,MAAA,IAAU,CAAA;AACf,IAAA,OAAO,KAAA;AAAA,EACT;AAAA,EAEA,OAAA,GAAkB;AAChB,IAAA,MAAM,QAAQ,IAAA,CAAK,IAAA,CAAK,WAAA,CAAY,IAAA,CAAK,QAAQ,IAAI,CAAA;AACrD,IAAA,IAAA,CAAK,MAAA,IAAU,CAAA;AACf,IAAA,OAAO,KAAA;AAAA,EACT;AAAA,EAEA,OAAA,GAAkB;AAChB,IAAA,MAAM,QAAQ,IAAA,CAAK,IAAA,CAAK,YAAA,CAAa,IAAA,CAAK,QAAQ,IAAI,CAAA;AACtD,IAAA,IAAA,CAAK,MAAA,IAAU,CAAA;AACf,IAAA,OAAO,KAAA;AAAA,EACT;AAAA,EAEA,QAAA,GAAmB;AACjB,IAAA,MAAM,YAAY,IAAA,CAAK,IAAA,CAAK,YAAA,CAAa,IAAA,CAAK,QAAQ,IAAI,CAAA;AAC1D,IAAA,MAAM,YAAY,IAAA,CAAK,IAAA,CAAK,aAAa,IAAA,CAAK,MAAA,GAAS,GAAG,IAAI,CAAA;AAC9D,IAAA,IAAA,CAAK,MAAA,IAAU,EAAA;AAEf,IAAA,OAAA,CAAQ,SAAA,IAAa,MAAA,CAAO,EAAE,CAAA,IAAK,SAAA;AAAA,EACrC;AAAA,EAEA,QAAA,GAAmB;AACjB,IAAA,MAAM,YAAY,IAAA,CAAK,IAAA,CAAK,YAAA,CAAa,IAAA,CAAK,QAAQ,IAAI,CAAA;AAC1D,IAAA,MAAM,YAAY,IAAA,CAAK,IAAA,CAAK,YAAY,IAAA,CAAK,MAAA,GAAS,GAAG,IAAI,CAAA;AAC7D,IAAA,IAAA,CAAK,MAAA,IAAU,EAAA;AAEf,IAAA,OAAA,CAAQ,SAAA,IAAa,MAAA,CAAO,EAAE,CAAA,IAAK,SAAA;AAAA,EACrC;AAAA,EAEA,QAAA,GAAmB;AACjB,IAAA,MAAM,KAAK,IAAA,CAAK,IAAA,CAAK,YAAA,CAAa,IAAA,CAAK,QAAQ,IAAI,CAAA;AACnD,IAAA,MAAM,KAAK,IAAA,CAAK,IAAA,CAAK,aAAa,IAAA,CAAK,MAAA,GAAS,GAAG,IAAI,CAAA;AACvD,IAAA,MAAM,KAAK,IAAA,CAAK,IAAA,CAAK,aAAa,IAAA,CAAK,MAAA,GAAS,IAAI,IAAI,CAAA;AACxD,IAAA,MAAM,KAAK,IAAA,CAAK,IAAA,CAAK,aAAa,IAAA,CAAK,MAAA,GAAS,IAAI,IAAI,CAAA;AACxD,IAAA,IAAA,CAAK,MAAA,IAAU,EAAA;AAEf,IAAA,OAAA,CACG,EAAA,IAAM,MAAA,CAAO,CAAA,GAAI,EAAE,MACnB,EAAA,IAAM,MAAA,CAAO,CAAA,GAAI,EAAE,CAAA,CAAA,IACnB,EAAA,IAAM,MAAA,CAAO,CAAA,GAAI,EAAE,CAAA,CAAA,GACpB,EAAA;AAAA,EAEJ;AAAA,EAEA,QAAA,GAAmB;AACjB,IAAA,MAAM,KAAK,IAAA,CAAK,IAAA,CAAK,YAAA,CAAa,IAAA,CAAK,QAAQ,IAAI,CAAA;AACnD,IAAA,MAAM,KAAK,IAAA,CAAK,IAAA,CAAK,aAAa,IAAA,CAAK,MAAA,GAAS,GAAG,IAAI,CAAA;AACvD,IAAA,MAAM,KAAK,IAAA,CAAK,IAAA,CAAK,aAAa,IAAA,CAAK,MAAA,GAAS,IAAI,IAAI,CAAA;AACxD,IAAA,MAAM,KAAK,IAAA,CAAK,IAAA,CAAK,YAAY,IAAA,CAAK,MAAA,GAAS,IAAI,IAAI,CAAA;AACvD,IAAA,IAAA,CAAK,MAAA,IAAU,EAAA;AAEf,IAAA,OAAA,CACG,EAAA,IAAM,MAAA,CAAO,CAAA,GAAI,EAAE,MACnB,EAAA,IAAM,MAAA,CAAO,CAAA,GAAI,EAAE,CAAA,CAAA,IACnB,EAAA,IAAM,MAAA,CAAO,CAAA,GAAI,EAAE,CAAA,CAAA,GACpB,EAAA;AAAA,EAEJ;AAAA,EAEA,OAAA,GAAkB;AAChB,IAAA,MAAM,QAAQ,IAAA,CAAK,IAAA,CAAK,UAAA,CAAW,IAAA,CAAK,QAAQ,IAAI,CAAA;AACpD,IAAA,IAAA,CAAK,MAAA,IAAU,CAAA;AACf,IAAA,OAAO,KAAA;AAAA,EACT;AAAA,EAEA,OAAA,GAAkB;AAChB,IAAA,MAAM,QAAQ,IAAA,CAAK,IAAA,CAAK,UAAA,CAAW,IAAA,CAAK,QAAQ,IAAI,CAAA;AACpD,IAAA,IAAA,CAAK,MAAA,IAAU,CAAA;AACf,IAAA,OAAO,KAAA;AAAA,EACT;AAAA,EAEA,UAAA,GAAqB;AACnB,IAAA,MAAM,UAAA,GAAa,KAAK,cAAA,EAAe;AACvC,IAAA,OAAO,IAAI,WAAA,CAAY,OAAO,CAAA,CAAE,OAAO,UAAU,CAAA;AAAA,EACnD;AACF,CAAA;ACtLA,IAAM,4BAAA,GACJ,WAAA,CAAY,SAAA,CAAU,QAAA,IACtB,SAA6B,aAAA,EAAe;AAC1C,EAAA,IAAI,kBAAkB,MAAA,EAAW;AAC/B,IAAA,OAAO,KAAK,KAAA,EAAM;AAAA,EACpB,CAAA,MAAA,IAAW,aAAA,IAAiB,IAAA,CAAK,UAAA,EAAY;AAC3C,IAAA,OAAO,IAAA,CAAK,KAAA,CAAM,CAAA,EAAG,aAAa,CAAA;AAAA,EACpC,CAAA,MAAO;AACL,IAAA,MAAM,IAAA,GAAO,IAAI,UAAA,CAAW,aAAa,CAAA;AACzC,IAAA,IAAA,CAAK,GAAA,CAAI,IAAI,UAAA,CAAW,IAAI,CAAC,CAAA;AAC7B,IAAA,OAAO,IAAA,CAAK,MAAA;AAAA,EACd;AACF,CAAA;AAEK,IAAM,kBAAN,MAAsB;AAAA,EAC3B,MAAA;AAAA,EACA,IAAA;AAAA,EAEA,YAAY,IAAA,EAA4B;AACtC,IAAA,IAAA,CAAK,SAAS,OAAO,IAAA,KAAS,WAAW,IAAI,WAAA,CAAY,IAAI,CAAA,GAAI,IAAA;AACjE,IAAA,IAAA,CAAK,IAAA,GAAO,IAAI,QAAA,CAAS,IAAA,CAAK,MAAM,CAAA;AAAA,EACtC;AAAA,EAEA,IAAI,QAAA,GAAmB;AACrB,IAAA,OAAO,KAAK,MAAA,CAAO,UAAA;AAAA,EACrB;AAAA,EAEA,KAAK,OAAA,EAAiB;AACpB,IAAA,IAAI,OAAA,IAAW,IAAA,CAAK,MAAA,CAAO,UAAA,EAAY;AACvC,IAAA,IAAA,CAAK,MAAA,GAAS,4BAAA,CAA6B,IAAA,CAAK,IAAA,CAAK,QAAQ,OAAO,CAAA;AACpE,IAAA,IAAA,CAAK,IAAA,GAAO,IAAI,QAAA,CAAS,IAAA,CAAK,MAAM,CAAA;AAAA,EACtC;AACF,CAAA;AAEA,IAAqB,eAArB,MAAkC;AAAA,EAChC,MAAA;AAAA,EACA,MAAA,GAAiB,CAAA;AAAA,EAEjB,YAAY,IAAA,EAAgC;AAC1C,IAAA,IAAA,CAAK,SAAS,OAAO,IAAA,KAAS,WAAW,IAAI,eAAA,CAAgB,IAAI,CAAA,GAAI,IAAA;AAAA,EACvE;AAAA,EAEA,MAAM,MAAA,EAAyB;AAC7B,IAAA,IAAA,CAAK,MAAA,GAAS,MAAA;AACd,IAAA,IAAA,CAAK,MAAA,GAAS,CAAA;AAAA,EAChB;AAAA,EAEA,aAAa,kBAAA,EAAkC;AAC7C,IAAA,MAAM,WAAA,GAAc,IAAA,CAAK,MAAA,GAAS,kBAAA,GAAqB,CAAA;AACvD,IAAA,IAAI,WAAA,IAAe,IAAA,CAAK,MAAA,CAAO,QAAA,EAAU;AACzC,IAAA,IAAI,WAAA,GAAc,IAAA,CAAK,MAAA,CAAO,QAAA,GAAW,CAAA;AACzC,IAAA,IAAI,WAAA,GAAc,aAAa,WAAA,GAAc,WAAA;AAC7C,IAAA,IAAA,CAAK,MAAA,CAAO,KAAK,WAAW,CAAA;AAAA,EAC9B;AAAA,EAEA,QAAA,GAAmB;AACjB,IAAA,OAAOA,sBAAA,CAAc,IAAA,CAAK,SAAA,EAAW,CAAA;AAAA,EACvC;AAAA,EAEA,SAAA,GAAwB;AACtB,IAAA,OAAO,IAAI,UAAA,CAAW,IAAA,CAAK,OAAO,MAAA,EAAQ,CAAA,EAAG,KAAK,MAAM,CAAA;AAAA,EAC1D;AAAA,EAEA,IAAI,IAAA,GAAO;AACT,IAAA,OAAO,KAAK,MAAA,CAAO,IAAA;AAAA,EACrB;AAAA,EAEA,gBAAgB,KAAA,EAAyB;AACvC,IAAA,MAAM,SAAS,KAAA,CAAM,MAAA;AAErB,IAAA,IAAA,CAAK,YAAA,CAAa,IAAI,MAAM,CAAA;AAE5B,IAAA,IAAA,CAAK,SAAS,MAAM,CAAA;AACpB,IAAA,IAAI,UAAA,CAAW,KAAK,MAAA,CAAO,MAAA,EAAQ,KAAK,MAAM,CAAA,CAAE,IAAI,KAAK,CAAA;AACzD,IAAA,IAAA,CAAK,MAAA,IAAU,MAAA;AAAA,EACjB;AAAA,EAEA,UAAU,KAAA,EAAsB;AAC9B,IAAA,IAAA,CAAK,aAAa,CAAC,CAAA;AACnB,IAAA,IAAA,CAAK,KAAK,QAAA,CAAS,IAAA,CAAK,MAAA,EAAQ,KAAA,GAAQ,IAAI,CAAC,CAAA;AAC7C,IAAA,IAAA,CAAK,MAAA,IAAU,CAAA;AAAA,EACjB;AAAA,EAEA,UAAU,KAAA,EAAqB;AAC7B,IAAA,IAAA,CAAK,aAAa,CAAC,CAAA;AACnB,IAAA,IAAA,CAAK,IAAA,CAAK,QAAA,CAAS,IAAA,CAAK,MAAA,EAAQ,KAAK,CAAA;AACrC,IAAA,IAAA,CAAK,MAAA,IAAU,CAAA;AAAA,EACjB;AAAA,EAEA,QAAQ,KAAA,EAAqB;AAC3B,IAAA,IAAA,CAAK,aAAa,CAAC,CAAA;AACnB,IAAA,IAAA,CAAK,IAAA,CAAK,OAAA,CAAQ,IAAA,CAAK,MAAA,EAAQ,KAAK,CAAA;AACpC,IAAA,IAAA,CAAK,MAAA,IAAU,CAAA;AAAA,EACjB;AAAA,EAEA,QAAQ,KAAA,EAAqB;AAC3B,IAAA,IAAA,CAAK,aAAa,CAAC,CAAA;AACnB,IAAA,IAAA,CAAK,IAAA,CAAK,QAAA,CAAS,IAAA,CAAK,MAAA,EAAQ,KAAK,CAAA;AACrC,IAAA,IAAA,CAAK,MAAA,IAAU,CAAA;AAAA,EACjB;AAAA,EAEA,SAAS,KAAA,EAAqB;AAC5B,IAAA,IAAA,CAAK,aAAa,CAAC,CAAA;AACnB,IAAA,IAAA,CAAK,IAAA,CAAK,QAAA,CAAS,IAAA,CAAK,MAAA,EAAQ,OAAO,IAAI,CAAA;AAC3C,IAAA,IAAA,CAAK,MAAA,IAAU,CAAA;AAAA,EACjB;AAAA,EAEA,SAAS,KAAA,EAAqB;AAC5B,IAAA,IAAA,CAAK,aAAa,CAAC,CAAA;AACnB,IAAA,IAAA,CAAK,IAAA,CAAK,SAAA,CAAU,IAAA,CAAK,MAAA,EAAQ,OAAO,IAAI,CAAA;AAC5C,IAAA,IAAA,CAAK,MAAA,IAAU,CAAA;AAAA,EACjB;AAAA,EAEA,SAAS,KAAA,EAAqB;AAC5B,IAAA,IAAA,CAAK,aAAa,CAAC,CAAA;AACnB,IAAA,IAAA,CAAK,IAAA,CAAK,QAAA,CAAS,IAAA,CAAK,MAAA,EAAQ,OAAO,IAAI,CAAA;AAC3C,IAAA,IAAA,CAAK,MAAA,IAAU,CAAA;AAAA,EACjB;AAAA,EAEA,SAAS,KAAA,EAAqB;AAC5B,IAAA,IAAA,CAAK,aAAa,CAAC,CAAA;AACnB,IAAA,IAAA,CAAK,IAAA,CAAK,SAAA,CAAU,IAAA,CAAK,MAAA,EAAQ,OAAO,IAAI,CAAA;AAC5C,IAAA,IAAA,CAAK,MAAA,IAAU,CAAA;AAAA,EACjB;AAAA,EAEA,SAAS,KAAA,EAAqB;AAC5B,IAAA,IAAA,CAAK,aAAa,CAAC,CAAA;AACnB,IAAA,IAAA,CAAK,IAAA,CAAK,WAAA,CAAY,IAAA,CAAK,MAAA,EAAQ,OAAO,IAAI,CAAA;AAC9C,IAAA,IAAA,CAAK,MAAA,IAAU,CAAA;AAAA,EACjB;AAAA,EAEA,SAAS,KAAA,EAAqB;AAC5B,IAAA,IAAA,CAAK,aAAa,CAAC,CAAA;AACnB,IAAA,IAAA,CAAK,IAAA,CAAK,YAAA,CAAa,IAAA,CAAK,MAAA,EAAQ,OAAO,IAAI,CAAA;AAC/C,IAAA,IAAA,CAAK,MAAA,IAAU,CAAA;AAAA,EACjB;AAAA,EAEA,UAAU,KAAA,EAAqB;AAC7B,IAAA,IAAA,CAAK,aAAa,EAAE,CAAA;AACpB,IAAA,MAAM,SAAA,GAAY,KAAA,GAAQ,MAAA,CAAO,oBAAoB,CAAA;AACrD,IAAA,MAAM,SAAA,GAAY,KAAA,IAAS,MAAA,CAAO,EAAE,CAAA;AACpC,IAAA,IAAA,CAAK,IAAA,CAAK,YAAA,CAAa,IAAA,CAAK,MAAA,EAAQ,WAAW,IAAI,CAAA;AACnD,IAAA,IAAA,CAAK,KAAK,YAAA,CAAa,IAAA,CAAK,MAAA,GAAS,CAAA,EAAG,WAAW,IAAI,CAAA;AACvD,IAAA,IAAA,CAAK,MAAA,IAAU,EAAA;AAAA,EACjB;AAAA,EAEA,UAAU,KAAA,EAAqB;AAC7B,IAAA,IAAA,CAAK,aAAa,EAAE,CAAA;AACpB,IAAA,MAAM,SAAA,GAAY,KAAA,GAAQ,MAAA,CAAO,oBAAoB,CAAA;AACrD,IAAA,MAAM,SAAA,GAAY,KAAA,IAAS,MAAA,CAAO,EAAE,CAAA;AACpC,IAAA,IAAA,CAAK,IAAA,CAAK,WAAA,CAAY,IAAA,CAAK,MAAA,EAAQ,WAAW,IAAI,CAAA;AAClD,IAAA,IAAA,CAAK,KAAK,WAAA,CAAY,IAAA,CAAK,MAAA,GAAS,CAAA,EAAG,WAAW,IAAI,CAAA;AACtD,IAAA,IAAA,CAAK,MAAA,IAAU,EAAA;AAAA,EACjB;AAAA,EAEA,UAAU,KAAA,EAAqB;AAC7B,IAAA,IAAA,CAAK,aAAa,EAAE,CAAA;AACpB,IAAA,MAAM,WAAA,GAAc,OAAO,oBAAoB,CAAA;AAC/C,IAAA,MAAM,KAAK,KAAA,GAAQ,WAAA;AACnB,IAAA,MAAM,EAAA,GAAM,KAAA,IAAS,MAAA,CAAO,EAAA,GAAK,CAAC,CAAA,GAAK,WAAA;AACvC,IAAA,MAAM,EAAA,GAAM,KAAA,IAAS,MAAA,CAAO,EAAA,GAAK,CAAC,CAAA,GAAK,WAAA;AACvC,IAAA,MAAM,EAAA,GAAK,KAAA,IAAS,MAAA,CAAO,EAAA,GAAK,CAAC,CAAA;AACjC,IAAA,IAAA,CAAK,KAAK,YAAA,CAAa,IAAA,CAAK,SAAS,CAAA,GAAI,CAAA,EAAG,IAAI,IAAI,CAAA;AACpD,IAAA,IAAA,CAAK,KAAK,YAAA,CAAa,IAAA,CAAK,SAAS,CAAA,GAAI,CAAA,EAAG,IAAI,IAAI,CAAA;AACpD,IAAA,IAAA,CAAK,KAAK,YAAA,CAAa,IAAA,CAAK,SAAS,CAAA,GAAI,CAAA,EAAG,IAAI,IAAI,CAAA;AACpD,IAAA,IAAA,CAAK,KAAK,YAAA,CAAa,IAAA,CAAK,SAAS,CAAA,GAAI,CAAA,EAAG,IAAI,IAAI,CAAA;AACpD,IAAA,IAAA,CAAK,MAAA,IAAU,EAAA;AAAA,EACjB;AAAA,EAEA,UAAU,KAAA,EAAqB;AAC7B,IAAA,IAAA,CAAK,aAAa,EAAE,CAAA;AACpB,IAAA,MAAM,WAAA,GAAc,OAAO,oBAAoB,CAAA;AAC/C,IAAA,MAAM,KAAK,KAAA,GAAQ,WAAA;AACnB,IAAA,MAAM,EAAA,GAAM,KAAA,IAAS,MAAA,CAAO,EAAA,GAAK,CAAC,CAAA,GAAK,WAAA;AACvC,IAAA,MAAM,EAAA,GAAM,KAAA,IAAS,MAAA,CAAO,EAAA,GAAK,CAAC,CAAA,GAAK,WAAA;AACvC,IAAA,MAAM,EAAA,GAAK,KAAA,IAAS,MAAA,CAAO,EAAA,GAAK,CAAC,CAAA;AACjC,IAAA,IAAA,CAAK,KAAK,YAAA,CAAa,IAAA,CAAK,SAAS,CAAA,GAAI,CAAA,EAAG,IAAI,IAAI,CAAA;AACpD,IAAA,IAAA,CAAK,KAAK,YAAA,CAAa,IAAA,CAAK,SAAS,CAAA,GAAI,CAAA,EAAG,IAAI,IAAI,CAAA;AACpD,IAAA,IAAA,CAAK,KAAK,YAAA,CAAa,IAAA,CAAK,SAAS,CAAA,GAAI,CAAA,EAAG,IAAI,IAAI,CAAA;AACpD,IAAA,IAAA,CAAK,KAAK,WAAA,CAAY,IAAA,CAAK,SAAS,CAAA,GAAI,CAAA,EAAG,IAAI,IAAI,CAAA;AACnD,IAAA,IAAA,CAAK,MAAA,IAAU,EAAA;AAAA,EACjB;AAAA,EAEA,SAAS,KAAA,EAAqB;AAC5B,IAAA,IAAA,CAAK,aAAa,CAAC,CAAA;AACnB,IAAA,IAAA,CAAK,IAAA,CAAK,UAAA,CAAW,IAAA,CAAK,MAAA,EAAQ,OAAO,IAAI,CAAA;AAC7C,IAAA,IAAA,CAAK,MAAA,IAAU,CAAA;AAAA,EACjB;AAAA,EAEA,SAAS,KAAA,EAAqB;AAC5B,IAAA,IAAA,CAAK,aAAa,CAAC,CAAA;AACnB,IAAA,IAAA,CAAK,IAAA,CAAK,UAAA,CAAW,IAAA,CAAK,MAAA,EAAQ,OAAO,IAAI,CAAA;AAC7C,IAAA,IAAA,CAAK,MAAA,IAAU,CAAA;AAAA,EACjB;AAAA,EAEA,YAAY,KAAA,EAAqB;AAC/B,IAAA,MAAM,OAAA,GAAU,IAAI,WAAA,EAAY;AAChC,IAAA,MAAM,aAAA,GAAgB,OAAA,CAAQ,MAAA,CAAO,KAAK,CAAA;AAC1C,IAAA,IAAA,CAAK,gBAAgB,aAAa,CAAA;AAAA,EACpC;AACF,CAAA;;;AC1JO,SAAS,sBAAsB,KAAA,EAA2B;AAC/D,EAAA,OAAO,MAAM,SAAA,CAAU,GAAA,CACpB,KAAK,KAAA,CAAM,OAAA,IAAW,CAAA,CAAA,KAAA,CAAM,IAAA,GAAO,CAAA,CAAE,QAAA,CAAS,EAAE,CAAA,EAAG,KAAA,CAAM,EAAE,CAAC,CAAA,CAC5D,KAAK,EAAE,CAAA;AACZ;AAEO,SAAS,iBAAiB,KAAA,EAA2B;AAC1D,EAAA,IAAI,KAAA,CAAM,UAAU,EAAA,EAAI;AACtB,IAAA,MAAM,IAAI,KAAA,CAAM,CAAA,iCAAA,EAAoC,KAAK,CAAA,CAAE,CAAA;AAAA,EAC7D;AACA,EAAA,OAAO,IAAI,YAAA,CAAa,KAAK,CAAA,CAAE,QAAA,EAAS;AAC1C;AAEO,SAAS,iBAAiB,KAAA,EAA2B;AAC1D,EAAA,IAAI,KAAA,CAAM,UAAU,EAAA,EAAI;AACtB,IAAA,MAAM,IAAI,KAAA,CAAM,CAAA,kCAAA,EAAqC,KAAK,CAAA,CAAA,CAAG,CAAA;AAAA,EAC/D;AACA,EAAA,OAAO,IAAI,YAAA,CAAa,KAAK,CAAA,CAAE,QAAA,EAAS;AAC1C;AAEO,SAAS,sBAAsB,GAAA,EAAyB;AAC7D,EAAA,IAAI,GAAA,CAAI,UAAA,CAAW,IAAI,CAAA,EAAG;AACxB,IAAA,GAAA,GAAM,GAAA,CAAI,MAAM,CAAC,CAAA;AAAA,EACnB;AACA,EAAA,MAAM,OAAA,GAAU,GAAA,CAAI,KAAA,CAAM,SAAS,KAAK,EAAC;AACzC,EAAA,MAAM,OAAO,UAAA,CAAW,IAAA;AAAA,IACtB,QAAQ,GAAA,CAAI,CAAC,SAAiB,QAAA,CAAS,IAAA,EAAM,EAAE,CAAC;AAAA,GAClD;AACA,EAAA,OAAO,KAAK,OAAA,EAAQ;AACtB;AAEO,SAAS,gBAAgB,GAAA,EAAqB;AACnD,EAAA,OAAO,gBAAA,CAAiB,qBAAA,CAAsB,GAAG,CAAC,CAAA;AACpD;AAEO,SAAS,gBAAgB,GAAA,EAAqB;AACnD,EAAA,OAAO,gBAAA,CAAiB,qBAAA,CAAsB,GAAG,CAAC,CAAA;AACpD;AAEO,SAAS,iBAAiB,IAAA,EAA0B;AACzD,EAAA,MAAM,MAAA,GAAS,IAAI,YAAA,CAAa,EAAE,CAAA;AAClC,EAAA,MAAA,CAAO,UAAU,IAAI,CAAA;AACrB,EAAA,OAAO,OAAO,SAAA,EAAU;AAC1B;AAEO,SAAS,gBAAgB,IAAA,EAAsB;AACpD,EAAA,OAAO,qBAAA,CAAsB,gBAAA,CAAiB,IAAI,CAAC,CAAA;AACrD;AAEO,SAAS,iBAAiB,IAAA,EAA0B;AACzD,EAAA,MAAM,MAAA,GAAS,IAAI,YAAA,CAAa,EAAE,CAAA;AAClC,EAAA,MAAA,CAAO,UAAU,IAAI,CAAA;AACrB,EAAA,OAAO,OAAO,SAAA,EAAU;AAC1B;AAEO,SAAS,gBAAgB,IAAA,EAAsB;AACpD,EAAA,OAAO,qBAAA,CAAsB,gBAAA,CAAiB,IAAI,CAAC,CAAA;AACrD;AAyFO,IAAM,SAIX,MAAA,CAAO,MAAA;;;ACzLF,IAAM,QAAA,GAAN,MAAM,SAAA,CAAS;AAAA,EACpB,YAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,YAAY,IAAA,EAAuB;AAGjC,IAAA,IAAA,CAAK,eAAe,OAAO,IAAA,KAAS,QAAA,GAAW,eAAA,CAAgB,IAAI,CAAA,GAAI,IAAA;AAAA,EACzE;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,OAAO,gBAAA,GAA0C;AAC/C,IAAA,OAAO,cAAc,OAAA,CAAQ;AAAA,MAC3B,QAAA,EAAU,CAAC,EAAE,IAAA,EAAM,gBAAgB,aAAA,EAAe,aAAA,CAAc,MAAM;AAAA,KACvE,CAAA;AAAA,EACH;AAAA;AAAA;AAAA;AAAA,EAKA,QAAQ,KAAA,EAA0B;AAChC,IAAA,OAAO,IAAA,CAAK,WAAA,EAAY,KAAM,KAAA,CAAM,WAAA,EAAY;AAAA,EAClD;AAAA;AAAA;AAAA;AAAA,EAKA,OAAO,KAAA,EAA0B;AAC/B,IAAA,OAAO,IAAA,CAAK,QAAQ,KAAK,CAAA;AAAA,EAC3B;AAAA;AAAA;AAAA;AAAA,EAKA,WAAA,GAAsB;AACpB,IAAA,OAAO,eAAA,CAAgB,KAAK,YAAY,CAAA;AAAA,EAC1C;AAAA;AAAA;AAAA;AAAA,EAKA,YAAA,GAA2B;AACzB,IAAA,OAAO,gBAAA,CAAiB,KAAK,YAAY,CAAA;AAAA,EAC3C;AAAA;AAAA;AAAA;AAAA,EAKA,OAAO,WAAW,GAAA,EAAuB;AACvC,IAAA,OAAO,IAAI,UAAS,GAAG,CAAA;AAAA,EACzB;AAAA;AAAA;AAAA;AAAA,EAKA,OAAO,IAAA,GAAiB;AACtB,IAAA,OAAO,IAAI,UAAS,EAAE,CAAA;AAAA,EACxB;AAAA,EAEA,QAAA,GAAmB;AACjB,IAAA,OAAO,KAAK,WAAA,EAAY;AAAA,EAC1B;AACF,CAAA;;;ACIA,IAAM,WAAA,uBAAkB,GAAA,EAA4C;AACpE,IAAM,aAAA,uBAAoB,GAAA,EAA8C;AAGjE,IAAM,aAAA,GAAgB;AAAA,EAC3B,KAAK,CAAC,KAAA,MAA8C,EAAE,GAAA,EAAK,OAAO,KAAA,EAAM,CAAA;AAAA,EACxE,GAAA,EAAK,CAAwB,KAAA,MAAwC;AAAA,IACnE,GAAA,EAAK,KAAA;AAAA,IACL;AAAA,GACF,CAAA;AAAA,EACA,OAAA,EAAS,CACP,KAAA,MACkC;AAAA,IAClC,GAAA,EAAK,SAAA;AAAA,IACL;AAAA,GACF,CAAA;AAAA,EACA,KAAA,EAAO,CACL,KAAA,MACgC;AAAA,IAChC,GAAA,EAAK,OAAA;AAAA,IACL;AAAA,GACF,CAAA;AAAA,EACA,MAAA,EAAQ,EAAE,GAAA,EAAK,QAAA,EAAS;AAAA,EACxB,IAAA,EAAM,EAAE,GAAA,EAAK,MAAA,EAAO;AAAA,EACpB,EAAA,EAAI,EAAE,GAAA,EAAK,IAAA,EAAK;AAAA,EAChB,EAAA,EAAI,EAAE,GAAA,EAAK,IAAA,EAAK;AAAA,EAChB,GAAA,EAAK,EAAE,GAAA,EAAK,KAAA,EAAM;AAAA,EAClB,GAAA,EAAK,EAAE,GAAA,EAAK,KAAA,EAAM;AAAA,EAClB,GAAA,EAAK,EAAE,GAAA,EAAK,KAAA,EAAM;AAAA,EAClB,GAAA,EAAK,EAAE,GAAA,EAAK,KAAA,EAAM;AAAA,EAClB,GAAA,EAAK,EAAE,GAAA,EAAK,KAAA,EAAM;AAAA,EAClB,GAAA,EAAK,EAAE,GAAA,EAAK,KAAA,EAAM;AAAA,EAClB,IAAA,EAAM,EAAE,GAAA,EAAK,MAAA,EAAO;AAAA,EACpB,IAAA,EAAM,EAAE,GAAA,EAAK,MAAA,EAAO;AAAA,EACpB,IAAA,EAAM,EAAE,GAAA,EAAK,MAAA,EAAO;AAAA,EACpB,IAAA,EAAM,EAAE,GAAA,EAAK,MAAA,EAAO;AAAA,EACpB,GAAA,EAAK,EAAE,GAAA,EAAK,KAAA,EAAM;AAAA,EAClB,GAAA,EAAK,EAAE,GAAA,EAAK,KAAA,EAAM;AAAA,EAClB,cAAA,CACE,IACA,SAAA,EACiB;AACjB,IAAA,IAAI,EAAA,CAAG,QAAQ,KAAA,EAAO;AACpB,MAAA,IAAI,CAAC,SAAA;AACH,QAAA,MAAM,IAAI,MAAM,2CAA2C,CAAA;AAC7D,MAAA,OAAO,GAAG,GAAA,KAAQ,KAAA,OAAY,SAAA,CAAU,KAAA,CAAM,GAAG,KAAK,CAAA;AAAA,IACxD;AACA,IAAA,QAAQ,GAAG,GAAA;AAAK,MACd,KAAK,SAAA;AACH,QAAA,OAAO,WAAA,CAAY,cAAA,CAAe,EAAA,CAAG,KAAA,EAAO,SAAS,CAAA;AAAA,MACvD,KAAK,KAAA;AACH,QAAA,OAAO,OAAA,CAAQ,cAAA,CAAe,EAAA,CAAG,KAAA,EAAO,SAAS,CAAA;AAAA,MACnD,KAAK,OAAA;AACH,QAAA,IAAI,EAAA,CAAG,KAAA,CAAM,GAAA,KAAQ,IAAA,EAAM;AACzB,UAAA,OAAO,mBAAA;AAAA,QACT,CAAA,MAAO;AACL,UAAA,MAAM,SAAA,GAAY,aAAA,CAAc,cAAA,CAAe,EAAA,CAAG,OAAO,SAAS,CAAA;AAClE,UAAA,OAAO,CAAC,QAAQ,KAAA,KAAU;AACxB,YAAA,MAAA,CAAO,QAAA,CAAS,MAAM,MAAM,CAAA;AAC5B,YAAA,KAAA,MAAW,QAAQ,KAAA,EAAO;AACxB,cAAA,SAAA,CAAU,QAAQ,IAAI,CAAA;AAAA,YACxB;AAAA,UACF,CAAA;AAAA,QACF;AAAA,MACF;AACE,QAAA,OAAO,oBAAA,CAAqB,GAAG,GAAG,CAAA;AAAA;AACtC,EACF,CAAA;AAAA;AAAA,EAEA,cAAA,CACE,MAAA,EACA,EAAA,EACA,KAAA,EACA,SAAA,EACA;AACA,IAAA,aAAA,CAAc,cAAA,CAAe,EAAA,EAAI,SAAS,CAAA,CAAE,QAAQ,KAAK,CAAA;AAAA,EAC3D,CAAA;AAAA,EACA,gBAAA,CACE,IACA,SAAA,EACmB;AACnB,IAAA,IAAI,EAAA,CAAG,QAAQ,KAAA,EAAO;AACpB,MAAA,IAAI,CAAC,SAAA;AACH,QAAA,MAAM,IAAI,MAAM,6CAA6C,CAAA;AAC/D,MAAA,OAAO,GAAG,GAAA,KAAQ,KAAA,OAAY,SAAA,CAAU,KAAA,CAAM,GAAG,KAAK,CAAA;AAAA,IACxD;AACA,IAAA,QAAQ,GAAG,GAAA;AAAK,MACd,KAAK,SAAA;AACH,QAAA,OAAO,WAAA,CAAY,gBAAA,CAAiB,EAAA,CAAG,KAAA,EAAO,SAAS,CAAA;AAAA,MACzD,KAAK,KAAA;AACH,QAAA,OAAO,OAAA,CAAQ,gBAAA,CAAiB,EAAA,CAAG,KAAA,EAAO,SAAS,CAAA;AAAA,MACrD,KAAK,OAAA;AACH,QAAA,IAAI,EAAA,CAAG,KAAA,CAAM,GAAA,KAAQ,IAAA,EAAM;AACzB,UAAA,OAAO,qBAAA;AAAA,QACT,CAAA,MAAO;AACL,UAAA,MAAM,cAAc,aAAA,CAAc,gBAAA;AAAA,YAChC,EAAA,CAAG,KAAA;AAAA,YACH;AAAA,WACF;AACA,UAAA,OAAO,CAAA,MAAA,KAAU;AACf,YAAA,MAAM,MAAA,GAAS,OAAO,OAAA,EAAQ;AAC9B,YAAA,MAAM,MAAA,GAAgB,MAAM,MAAM,CAAA;AAClC,YAAA,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,MAAA,EAAQ,CAAA,EAAA,EAAK;AAC/B,cAAA,MAAA,CAAO,CAAC,CAAA,GAAI,WAAA,CAAY,MAAM,CAAA;AAAA,YAChC;AACA,YAAA,OAAO,MAAA;AAAA,UACT,CAAA;AAAA,QACF;AAAA,MACF;AACE,QAAA,OAAO,sBAAA,CAAuB,GAAG,GAAG,CAAA;AAAA;AACxC,EACF,CAAA;AAAA;AAAA,EAEA,gBAAA,CACE,MAAA,EACA,EAAA,EACA,SAAA,EACK;AACL,IAAA,OAAO,aAAA,CAAc,gBAAA,CAAiB,EAAA,EAAI,SAAS,EAAE,MAAM,CAAA;AAAA,EAC7D,CAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,UAAA,EAAY,SACV,EAAA,EACA,KAAA,EACqB;AACrB,IAAA,QAAQ,GAAG,GAAA;AAAK,MACd,KAAK,IAAA;AAAA,MACL,KAAK,KAAA;AAAA,MACL,KAAK,KAAA;AAAA,MACL,KAAK,KAAA;AAAA,MACL,KAAK,MAAA;AAAA,MACL,KAAK,MAAA;AAAA,MACL,KAAK,IAAA;AAAA,MACL,KAAK,KAAA;AAAA,MACL,KAAK,KAAA;AAAA,MACL,KAAK,KAAA;AAAA,MACL,KAAK,MAAA;AAAA,MACL,KAAK,MAAA;AAAA,MACL,KAAK,KAAA;AAAA,MACL,KAAK,KAAA;AAAA,MACL,KAAK,QAAA;AAAA,MACL,KAAK,MAAA;AACH,QAAA,OAAO,KAAA;AAAA,MACT,KAAK,SAAA;AACH,QAAA,OAAO,WAAA,CAAY,UAAA,CAAW,EAAA,CAAG,KAAA,EAAO,KAAK,CAAA;AAAA,MAC/C,SAAS;AAEP,QAAA,MAAM,MAAA,GAAS,IAAI,YAAA,CAAa,EAAE,CAAA;AAClC,QAAA,aAAA,CAAc,cAAA,CAAe,MAAA,EAAQ,EAAA,EAAI,KAAK,CAAA;AAC9C,QAAA,OAAO,OAAO,QAAA,EAAS;AAAA,MACzB;AAAA;AACF,EACF;AACF,CAAA;AAEA,SAAS,SACP,CAAA,EACuE;AACvE,EAAA,OAAO,QAAA,CAAS,SAAA,CAAU,IAAA,CAAK,IAAA,CAAK,CAAC,CAAA;AACvC;AAOA,IAAM,oBAAA,GAA4D;AAAA,EAChE,IAAA,EAAM,QAAA,CAAS,YAAA,CAAa,SAAA,CAAU,SAAS,CAAA;AAAA,EAC/C,EAAA,EAAI,QAAA,CAAS,YAAA,CAAa,SAAA,CAAU,OAAO,CAAA;AAAA,EAC3C,EAAA,EAAI,QAAA,CAAS,YAAA,CAAa,SAAA,CAAU,OAAO,CAAA;AAAA,EAC3C,GAAA,EAAK,QAAA,CAAS,YAAA,CAAa,SAAA,CAAU,QAAQ,CAAA;AAAA,EAC7C,GAAA,EAAK,QAAA,CAAS,YAAA,CAAa,SAAA,CAAU,QAAQ,CAAA;AAAA,EAC7C,GAAA,EAAK,QAAA,CAAS,YAAA,CAAa,SAAA,CAAU,QAAQ,CAAA;AAAA,EAC7C,GAAA,EAAK,QAAA,CAAS,YAAA,CAAa,SAAA,CAAU,QAAQ,CAAA;AAAA,EAC7C,GAAA,EAAK,QAAA,CAAS,YAAA,CAAa,SAAA,CAAU,QAAQ,CAAA;AAAA,EAC7C,GAAA,EAAK,QAAA,CAAS,YAAA,CAAa,SAAA,CAAU,QAAQ,CAAA;AAAA,EAC7C,IAAA,EAAM,QAAA,CAAS,YAAA,CAAa,SAAA,CAAU,SAAS,CAAA;AAAA,EAC/C,IAAA,EAAM,QAAA,CAAS,YAAA,CAAa,SAAA,CAAU,SAAS,CAAA;AAAA,EAC/C,IAAA,EAAM,QAAA,CAAS,YAAA,CAAa,SAAA,CAAU,SAAS,CAAA;AAAA,EAC/C,IAAA,EAAM,QAAA,CAAS,YAAA,CAAa,SAAA,CAAU,SAAS,CAAA;AAAA,EAC/C,GAAA,EAAK,QAAA,CAAS,YAAA,CAAa,SAAA,CAAU,QAAQ,CAAA;AAAA,EAC7C,GAAA,EAAK,QAAA,CAAS,YAAA,CAAa,SAAA,CAAU,QAAQ,CAAA;AAAA,EAC7C,MAAA,EAAQ,QAAA,CAAS,YAAA,CAAa,SAAA,CAAU,WAAW;AACrD,CAAA;AACA,MAAA,CAAO,OAAO,oBAAoB,CAAA;AAElC,IAAM,mBAAA,GAAsB,QAAA,CAAS,YAAA,CAAa,SAAA,CAAU,eAAe,CAAA;AAE3E,IAAM,sBAAA,GAAgE;AAAA,EACpE,IAAA,EAAM,QAAA,CAAS,YAAA,CAAa,SAAA,CAAU,QAAQ,CAAA;AAAA,EAC9C,EAAA,EAAI,QAAA,CAAS,YAAA,CAAa,SAAA,CAAU,MAAM,CAAA;AAAA,EAC1C,EAAA,EAAI,QAAA,CAAS,YAAA,CAAa,SAAA,CAAU,MAAM,CAAA;AAAA,EAC1C,GAAA,EAAK,QAAA,CAAS,YAAA,CAAa,SAAA,CAAU,OAAO,CAAA;AAAA,EAC5C,GAAA,EAAK,QAAA,CAAS,YAAA,CAAa,SAAA,CAAU,OAAO,CAAA;AAAA,EAC5C,GAAA,EAAK,QAAA,CAAS,YAAA,CAAa,SAAA,CAAU,OAAO,CAAA;AAAA,EAC5C,GAAA,EAAK,QAAA,CAAS,YAAA,CAAa,SAAA,CAAU,OAAO,CAAA;AAAA,EAC5C,GAAA,EAAK,QAAA,CAAS,YAAA,CAAa,SAAA,CAAU,OAAO,CAAA;AAAA,EAC5C,GAAA,EAAK,QAAA,CAAS,YAAA,CAAa,SAAA,CAAU,OAAO,CAAA;AAAA,EAC5C,IAAA,EAAM,QAAA,CAAS,YAAA,CAAa,SAAA,CAAU,QAAQ,CAAA;AAAA,EAC9C,IAAA,EAAM,QAAA,CAAS,YAAA,CAAa,SAAA,CAAU,QAAQ,CAAA;AAAA,EAC9C,IAAA,EAAM,QAAA,CAAS,YAAA,CAAa,SAAA,CAAU,QAAQ,CAAA;AAAA,EAC9C,IAAA,EAAM,QAAA,CAAS,YAAA,CAAa,SAAA,CAAU,QAAQ,CAAA;AAAA,EAC9C,GAAA,EAAK,QAAA,CAAS,YAAA,CAAa,SAAA,CAAU,OAAO,CAAA;AAAA,EAC5C,GAAA,EAAK,QAAA,CAAS,YAAA,CAAa,SAAA,CAAU,OAAO,CAAA;AAAA,EAC5C,MAAA,EAAQ,QAAA,CAAS,YAAA,CAAa,SAAA,CAAU,UAAU;AACpD,CAAA;AACA,MAAA,CAAO,OAAO,sBAAsB,CAAA;AAEpC,IAAM,qBAAA,GAAwB,QAAA,CAAS,YAAA,CAAa,SAAA,CAAU,cAAc,CAAA;AAI5E,IAAM,cAAA,GAAsD;AAAA,EAC1D,IAAA,EAAM,CAAA;AAAA,EACN,EAAA,EAAI,CAAA;AAAA,EACJ,EAAA,EAAI,CAAA;AAAA,EACJ,GAAA,EAAK,CAAA;AAAA,EACL,GAAA,EAAK,CAAA;AAAA,EACL,GAAA,EAAK,CAAA;AAAA,EACL,GAAA,EAAK,CAAA;AAAA,EACL,GAAA,EAAK,CAAA;AAAA,EACL,GAAA,EAAK,CAAA;AAAA,EACL,IAAA,EAAM,EAAA;AAAA,EACN,IAAA,EAAM,EAAA;AAAA,EACN,IAAA,EAAM,EAAA;AAAA,EACN,IAAA,EAAM,EAAA;AAAA,EACN,GAAA,EAAK,CAAA;AAAA,EACL,GAAA,EAAK;AACP,CAAA;AAEA,IAAM,sBAAsB,IAAI,GAAA,CAAI,MAAA,CAAO,IAAA,CAAK,cAAc,CAAC,CAAA;AAM/D,IAAM,kBAAA,GAAqB,CAAC,EAAA,KAC1B,EAAA,CAAG,QAAA,CAAS,KAAA;AAAA,EAAM,CAAC,EAAE,aAAA,OACnB,mBAAA,CAAoB,GAAA,CAAI,cAAc,GAAG;AAC3C,CAAA;AAEF,IAAM,WAAA,GAAc,CAAC,EAAA,KACnB,EAAA,CAAG,QAAA,CAAS,MAAA;AAAA,EACV,CAAC,KAAK,EAAE,aAAA,OAAoB,GAAA,GAAM,cAAA,CAAe,cAAc,GAAG,CAAA;AAAA,EAClE;AACF,CAAA;AAOF,IAAM,eAAA,GAAgD;AAAA,EACpD,IAAA,EAAM,OAAA;AAAA,EACN,EAAA,EAAI,MAAA;AAAA,EACJ,EAAA,EAAI,OAAA;AAAA,EACJ,GAAA,EAAK,OAAA;AAAA,EACL,GAAA,EAAK,QAAA;AAAA,EACL,GAAA,EAAK,OAAA;AAAA,EACL,GAAA,EAAK,QAAA;AAAA,EACL,GAAA,EAAK,UAAA;AAAA,EACL,GAAA,EAAK,WAAA;AAAA,EACL,GAAA,EAAK,SAAA;AAAA,EACL,GAAA,EAAK;AACP,CAAA;AAUA,IAAM,2BAAA,GAEF;AAAA,EACF,0BAA0B,CAAA,MAAA,KAAU,IAAI,YAAA,CAAa,MAAA,CAAO,SAAS,CAAA;AAAA,EACrE,uCAAuC,CAAA,MAAA,KACrC,IAAI,SAAA,CAAU,MAAA,CAAO,SAAS,CAAA;AAAA,EAChC,cAAc,CAAA,MAAA,KAAU,IAAI,QAAA,CAAS,MAAA,CAAO,UAAU,CAAA;AAAA,EACtD,mBAAmB,CAAA,MAAA,KAAU,IAAI,YAAA,CAAa,MAAA,CAAO,UAAU,CAAA;AAAA,EAC/D,UAAU,CAAA,MAAA,KAAU,IAAI,IAAA,CAAK,MAAA,CAAO,UAAU;AAChD,CAAA;AACA,MAAA,CAAO,OAAO,2BAA2B,CAAA;AAEzC,IAAM,gBAAA,GAAqC,OAAO,EAAC,CAAA;AAEnD,IAAM,qBAAA,GAAwB,CAAC,OAAA,KAAgC;AAC7D,EAAA,IAAI,IAAA;AACJ,EAAA,QAAQ,OAAA,CAAQ,cAAc,GAAA;AAAK,IACjC,KAAK,QAAA;AACH,MAAA,IAAA,GAAO,IAAA;AACP,MAAA;AAAA,IACF,KAAK,MAAA;AACH,MAAA,IAAA,GAAO,OAAA;AACP,MAAA;AAAA,IACF,KAAK,IAAA;AAAA,IACL,KAAK,IAAA;AAAA,IACL,KAAK,KAAA;AAAA,IACL,KAAK,KAAA;AAAA,IACL,KAAK,KAAA;AAAA,IACL,KAAK,KAAA;AACH,MAAA,IAAA,GAAO,GAAA;AACP,MAAA;AAAA,IACF,KAAK,KAAA;AAAA,IACL,KAAK,KAAA;AAAA,IACL,KAAK,MAAA;AAAA,IACL,KAAK,MAAA;AAAA,IACL,KAAK,MAAA;AAAA,IACL,KAAK,MAAA;AACH,MAAA,IAAA,GAAO,IAAA;AACP,MAAA;AAAA,IACF,KAAK,KAAA;AAAA,IACL,KAAK,KAAA;AACH,MAAA,IAAA,GAAO,KAAA;AACP,MAAA;AAAA,IACF;AACE,MAAA,IAAA,GAAO,WAAA;AAAA;AAEX,EAAA,OAAO,CAAA,EAAG,OAAA,CAAQ,IAAK,CAAA,EAAA,EAAK,IAAI,CAAA,CAAA;AAClC,CAAA;AA6BO,IAAM,WAAA,GAAc;AAAA,EACzB,cAAA,CACE,IACA,SAAA,EACiB;AACjB,IAAA,IAAI,UAAA,GAAa,WAAA,CAAY,GAAA,CAAI,EAAE,CAAA;AACnC,IAAA,IAAI,UAAA,IAAc,MAAM,OAAO,UAAA;AAE/B,IAAA,IAAI,kBAAA,CAAmB,EAAE,CAAA,EAAG;AAC1B,MAAA,MAAM,IAAA,GAAO,YAAY,EAAE,CAAA;AAC3B,MAAA,MAAMC,KAAAA,GAAO,CAAA;AAAA,oBAAA,EAEG,IAAI,CAAA;AAAA;AAAA,EAExB,GAAG,QAAA,CACF,GAAA;AAAA,QAAI,CAAC,EAAE,IAAA,EAAM,aAAA,EAAe,EAAE,GAAA,EAAI,EAAE,KACnC,GAAA,IAAO,eAAA,GACH,CAAA,QAAA,EACE,gBAAgB,GAAmB,CAAC,yBAAyB,IAAK,CAAA,EAAA,EAAK,eAAe,GAAG,CAAA,GAAI,CAAA,GAAI,MAAA,GAAS,EAAE,CAAA;AAAA,iBAAA,EACnG,eAAe,GAAG,CAAC,MAC9B,CAAA,YAAA,EAAe,GAAG,UAAU,IAAI,CAAA,EAAA;AAAA,OACtC,CACC,IAAA,CAAK,IAAI,CAAC,CAAA,CAAA;AACP,MAAA,UAAA,GAAa,QAAA,CAAS,QAAA,EAAU,OAAA,EAASA,KAAI,CAAA;AAC7C,MAAA,WAAA,CAAY,GAAA,CAAI,IAAI,UAAU,CAAA;AAC9B,MAAA,OAAO,UAAA;AAAA,IACT;AASA,IAAA,MAAM,cAA+C,EAAC;AACtD,IAAA,MAAM,IAAA,GACJ,iBAAA,GACA,EAAA,CAAG,QAAA,CACA,GAAA;AAAA,MACC,aAAW,CAAA,KAAA,EAAQ,OAAA,CAAQ,IAAK,CAAA,eAAA,EAAkB,QAAQ,IAAK,CAAA,EAAA;AAAA,KACjE,CACC,KAAK,IAAI,CAAA;AACd,IAAA,UAAA,GAAa,QAAA,CAAS,QAAA,EAAU,OAAA,EAAS,IAAI,CAAA,CAAE,IAAA;AAAA,MAC7C;AAAA,KACF;AAIA,IAAA,WAAA,CAAY,GAAA,CAAI,IAAI,UAAU,CAAA;AAC9B,IAAA,KAAA,MAAW,EAAE,IAAA,EAAM,aAAA,EAAc,IAAK,GAAG,QAAA,EAAU;AACjD,MAAA,WAAA,CAAY,IAAK,IAAI,aAAA,CAAc,cAAA;AAAA,QACjC,aAAA;AAAA,QACA;AAAA,OACF;AAAA,IACF;AACA,IAAA,MAAA,CAAO,OAAO,WAAW,CAAA;AACzB,IAAA,OAAO,UAAA;AAAA,EACT,CAAA;AAAA;AAAA,EAEA,cAAA,CACE,MAAA,EACA,EAAA,EACA,KAAA,EACA,SAAA,EACM;AACN,IAAA,WAAA,CAAY,cAAA,CAAe,EAAA,EAAI,SAAS,CAAA,CAAE,QAAQ,KAAK,CAAA;AAAA,EACzD,CAAA;AAAA,EACA,gBAAA,CACE,IACA,SAAA,EACmB;AACnB,IAAA,QAAQ,EAAA,CAAG,SAAS,MAAA;AAAQ,MAC1B,KAAK,CAAA;AACH,QAAA,OAAO,gBAAA;AAAA,MACT,KAAK,CAAA,EAAG;AACN,QAAA,MAAM,SAAA,GAAY,EAAA,CAAG,QAAA,CAAS,CAAC,CAAA,CAAE,IAAA;AACjC,QAAA,IAAI,MAAA,CAAO,6BAA6B,SAAS,CAAA;AAC/C,UAAA,OAAO,4BACL,SACF,CAAA;AAAA,MACJ;AAAA;AAGF,IAAA,IAAI,YAAA,GAAe,aAAA,CAAc,GAAA,CAAI,EAAE,CAAA;AACvC,IAAA,IAAI,YAAA,IAAgB,MAAM,OAAO,YAAA;AAEjC,IAAA,IAAI,kBAAA,CAAmB,EAAE,CAAA,EAAG;AAC1B,MAAA,MAAM,IAAA,GAAO,CAAA;AAAA,iBAAA,EAEA,GAAG,QAAA,CAAS,GAAA,CAAI,qBAAqB,CAAA,CAAE,IAAA,CAAK,IAAI,CAAC,CAAA;AAAA;AAAA,EAElE,GAAG,QAAA,CACF,GAAA;AAAA,QAAI,CAAC,EAAE,IAAA,EAAM,aAAA,EAAe,EAAE,GAAA,EAAI,EAAE,KACnC,GAAA,IAAO,eAAA,GACH,CAAA,OAAA,EACC,IAAI,CAAA,WAAA,EAAc,eAAA,CAAgB,GAAmB,CAAC,CAAA,gBAAA,EAAmB,eAAe,GAAG,CAAA,GAAI,CAAA,GAAI,MAAA,GAAS,EAAE,CAAA;AAAA,iBAAA,EACpG,eAAe,GAAG,CAAC,MAC9B,CAAA,OAAA,EAAU,IAAI,iBAAiB,GAAG,CAAA,GAAA;AAAA,OACxC,CACC,IAAA,CAAK,IAAI,CAAC;AAAA,cAAA,CAAA;AAEP,MAAA,YAAA,GAAe,QAAA,CAAS,UAAU,IAAI,CAAA;AACtC,MAAA,aAAA,CAAc,GAAA,CAAI,IAAI,YAAY,CAAA;AAClC,MAAA,OAAO,YAAA;AAAA,IACT;AASA,IAAA,MAAM,gBAAmD,EAAC;AAC1D,IAAA,YAAA,GAAe,QAAA;AAAA,MACb,QAAA;AAAA,MACA,CAAA;AAAA,iBAAA,EAEa,GAAG,QAAA,CAAS,GAAA,CAAI,qBAAqB,CAAA,CAAE,IAAA,CAAK,IAAI,CAAC,CAAA;AAAA,EAClE,EAAA,CAAG,QAAA,CAAS,GAAA,CAAI,CAAC,EAAE,IAAA,EAAK,KAAM,CAAA,OAAA,EAAU,IAAK,WAAW,IAAK,CAAA,SAAA,CAAW,CAAA,CAAE,IAAA,CAAK,IAAI,CAAC;AAAA,cAAA;AAAA,KAElF,CAAE,KAAK,aAAa,CAAA;AAIpB,IAAA,aAAA,CAAc,GAAA,CAAI,IAAI,YAAY,CAAA;AAClC,IAAA,KAAA,MAAW,EAAE,IAAA,EAAM,aAAA,EAAc,IAAK,GAAG,QAAA,EAAU;AACjD,MAAA,aAAA,CAAc,IAAK,IAAI,aAAA,CAAc,gBAAA;AAAA,QACnC,aAAA;AAAA,QACA;AAAA,OACF;AAAA,IACF;AACA,IAAA,MAAA,CAAO,OAAO,aAAa,CAAA;AAC3B,IAAA,OAAO,YAAA;AAAA,EACT,CAAA;AAAA;AAAA,EAEA,gBAAA,CACE,MAAA,EACA,EAAA,EACA,SAAA,EACK;AACL,IAAA,OAAO,WAAA,CAAY,gBAAA,CAAiB,EAAA,EAAI,SAAS,EAAE,MAAM,CAAA;AAAA,EAC3D,CAAA;AAAA,EACA,UAAA,CAAW,IAAqB,KAAA,EAAiC;AAC/D,IAAA,IAAI,EAAA,CAAG,QAAA,CAAS,MAAA,KAAW,CAAA,EAAG;AAC5B,MAAA,MAAM,SAAA,GAAY,EAAA,CAAG,QAAA,CAAS,CAAC,CAAA,CAAE,IAAA;AACjC,MAAA,IAAI,MAAA,CAAO,2BAAA,EAA6B,SAAS,CAAA,EAAG;AAClD,QAAA,OAAO,MAAM,SAAS,CAAA;AAAA,MACxB;AAAA,IACF;AAEA,IAAA,MAAM,MAAA,GAAS,IAAI,YAAA,CAAa,EAAE,CAAA;AAClC,IAAA,aAAA,CAAc,eAAe,MAAA,EAAQ,aAAA,CAAc,OAAA,CAAQ,EAAE,GAAG,KAAK,CAAA;AACrE,IAAA,OAAO,OAAO,QAAA,EAAS;AAAA,EACzB;AACF,CAAA;AA4BO,IAAM,OAAA,GAAU;AAAA,EACrB,cAAA,CAAe,IAAiB,SAAA,EAA4C;AAC1E,IAAA,IACE,EAAA,CAAG,QAAA,CAAS,MAAA,IAAU,CAAA,IACtB,GAAG,QAAA,CAAS,CAAC,CAAA,CAAE,IAAA,KAAS,UACxB,EAAA,CAAG,QAAA,CAAS,CAAC,CAAA,CAAE,SAAS,MAAA,EACxB;AACA,MAAA,MAAM,YAAY,aAAA,CAAc,cAAA;AAAA,QAC9B,EAAA,CAAG,QAAA,CAAS,CAAC,CAAA,CAAE,aAAA;AAAA,QACf;AAAA,OACF;AACA,MAAA,OAAO,CAAC,QAAQ,KAAA,KAAU;AACxB,QAAA,IAAI,KAAA,KAAU,IAAA,IAAQ,KAAA,KAAU,MAAA,EAAW;AACzC,UAAA,MAAA,CAAO,UAAU,CAAC,CAAA;AAClB,UAAA,SAAA,CAAU,QAAQ,KAAK,CAAA;AAAA,QACzB,CAAA,MAAO;AACL,UAAA,MAAA,CAAO,UAAU,CAAC,CAAA;AAAA,QACpB;AAAA,MACF,CAAA;AAAA,IACF,WACE,EAAA,CAAG,QAAA,CAAS,MAAA,IAAU,CAAA,IACtB,GAAG,QAAA,CAAS,CAAC,CAAA,CAAE,IAAA,KAAS,QACxB,EAAA,CAAG,QAAA,CAAS,CAAC,CAAA,CAAE,SAAS,KAAA,EACxB;AACA,MAAA,MAAM,cAAc,aAAA,CAAc,cAAA;AAAA,QAChC,EAAA,CAAG,QAAA,CAAS,CAAC,CAAA,CAAE,aAAA;AAAA,QACf;AAAA,OACF;AACA,MAAA,MAAM,eAAe,aAAA,CAAc,cAAA;AAAA,QACjC,EAAA,CAAG,QAAA,CAAS,CAAC,CAAA,CAAE,aAAA;AAAA,QACf;AAAA,OACF;AAEA,MAAA,OAAO,CAAC,QAAQ,KAAA,KAAU;AACxB,QAAA,IAAI,QAAQ,KAAA,EAAO;AACjB,UAAA,MAAA,CAAO,QAAQ,CAAC,CAAA;AAChB,UAAA,WAAA,CAAY,MAAA,EAAQ,MAAM,EAAE,CAAA;AAAA,QAC9B,CAAA,MAAA,IAAW,SAAS,KAAA,EAAO;AACzB,UAAA,MAAA,CAAO,QAAQ,CAAC,CAAA;AAChB,UAAA,YAAA,CAAa,MAAA,EAAQ,MAAM,GAAG,CAAA;AAAA,QAChC,CAAA,MAAO;AACL,UAAA,MAAM,IAAI,SAAA;AAAA,YACR;AAAA,WACF;AAAA,QACF;AAAA,MACF,CAAA;AAAA,IACF,CAAA,MAAO;AACL,MAAA,IAAI,UAAA,GAAa,WAAA,CAAY,GAAA,CAAI,EAAE,CAAA;AACnC,MAAA,IAAI,UAAA,IAAc,MAAM,OAAO,UAAA;AAE/B,MAAA,MAAM,cAA+C,EAAC;AAEtD,MAAA,MAAM,IAAA,GAAO,CAAA;AAAA,EAEjB,GAAG,QAAA,CACF,GAAA;AAAA,QACC,CAAC,EAAE,IAAA,EAAK,EAAG,MAAM,CAAA,OAAA,EACZ,IAAA,CAAK,SAAA,CAAU,IAAK,CAAC,CAAA;AAAA,qBAAA,EACP,CAAC,CAAA;AAAA,gBAAA,EACN,IAAK,CAAA,sBAAA;AAAA,OACrB,CACC,IAAA,CAAK,IAAI,CAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,CAAA;AAQP,MAAA,UAAA,GAAa,QAAA,CAAS,QAAA,EAAU,OAAA,EAAS,IAAI,CAAA,CAAE,IAAA;AAAA,QAC7C;AAAA,OACF;AAKA,MAAA,WAAA,CAAY,GAAA,CAAI,IAAI,UAAU,CAAA;AAE9B,MAAA,KAAA,MAAW,EAAE,IAAA,EAAM,aAAA,EAAc,IAAK,GAAG,QAAA,EAAU;AACjD,QAAA,WAAA,CAAY,IAAK,IAAI,aAAA,CAAc,cAAA;AAAA,UACjC,aAAA;AAAA,UACA;AAAA,SACF;AAAA,MACF;AACA,MAAA,MAAA,CAAO,OAAO,WAAW,CAAA;AACzB,MAAA,OAAO,UAAA;AAAA,IACT;AAAA,EACF,CAAA;AAAA;AAAA,EAEA,cAAA,CACE,MAAA,EACA,EAAA,EACA,KAAA,EACA,SAAA,EACM;AACN,IAAA,OAAA,CAAQ,cAAA,CAAe,EAAA,EAAI,SAAS,CAAA,CAAE,QAAQ,KAAK,CAAA;AAAA,EACrD,CAAA;AAAA,EACA,gBAAA,CACE,IACA,SAAA,EACmB;AASnB,IAAA,IACE,EAAA,CAAG,QAAA,CAAS,MAAA,IAAU,CAAA,IACtB,GAAG,QAAA,CAAS,CAAC,CAAA,CAAE,IAAA,KAAS,UACxB,EAAA,CAAG,QAAA,CAAS,CAAC,CAAA,CAAE,SAAS,MAAA,EACxB;AACA,MAAA,MAAM,cAAc,aAAA,CAAc,gBAAA;AAAA,QAChC,EAAA,CAAG,QAAA,CAAS,CAAC,CAAA,CAAE,aAAA;AAAA,QACf;AAAA,OACF;AACA,MAAA,OAAO,CAAA,MAAA,KAAU;AACf,QAAA,MAAM,GAAA,GAAM,OAAO,MAAA,EAAO;AAC1B,QAAA,IAAI,QAAQ,CAAA,EAAG;AACb,UAAA,OAAO,YAAY,MAAM,CAAA;AAAA,QAC3B,CAAA,MAAA,IAAW,QAAQ,CAAA,EAAG;AACpB,UAAA,OAAO,MAAA;AAAA,QACT,CAAA,MAAO;AACL,UAAA,MAAM,mDAAmD,GAAG,CAAA,IAAA,CAAA;AAAA,QAC9D;AAAA,MACF,CAAA;AAAA,IACF,WACE,EAAA,CAAG,QAAA,CAAS,MAAA,IAAU,CAAA,IACtB,GAAG,QAAA,CAAS,CAAC,CAAA,CAAE,IAAA,KAAS,QACxB,EAAA,CAAG,QAAA,CAAS,CAAC,CAAA,CAAE,SAAS,KAAA,EACxB;AACA,MAAA,MAAM,gBAAgB,aAAA,CAAc,gBAAA;AAAA,QAClC,EAAA,CAAG,QAAA,CAAS,CAAC,CAAA,CAAE,aAAA;AAAA,QACf;AAAA,OACF;AACA,MAAA,MAAM,iBAAiB,aAAA,CAAc,gBAAA;AAAA,QACnC,EAAA,CAAG,QAAA,CAAS,CAAC,CAAA,CAAE,aAAA;AAAA,QACf;AAAA,OACF;AACA,MAAA,OAAO,CAAA,MAAA,KAAU;AACf,QAAA,MAAM,GAAA,GAAM,OAAO,QAAA,EAAS;AAC5B,QAAA,IAAI,QAAQ,CAAA,EAAG;AACb,UAAA,OAAO,EAAE,EAAA,EAAI,aAAA,CAAc,MAAM,CAAA,EAAE;AAAA,QACrC,CAAA,MAAA,IAAW,QAAQ,CAAA,EAAG;AACpB,UAAA,OAAO,EAAE,GAAA,EAAK,cAAA,CAAe,MAAM,CAAA,EAAE;AAAA,QACvC,CAAA,MAAO;AACL,UAAA,MAAM,kDAAkD,GAAG,CAAA,IAAA,CAAA;AAAA,QAC7D;AAAA,MACF,CAAA;AAAA,IACF,CAAA,MAAO;AACL,MAAA,IAAI,YAAA,GAAe,aAAA,CAAc,GAAA,CAAI,EAAE,CAAA;AACvC,MAAA,IAAI,YAAA,IAAgB,MAAM,OAAO,YAAA;AACjC,MAAA,MAAM,gBAAmD,EAAC;AAC1D,MAAA,YAAA,GAAe,QAAA;AAAA,QACb,QAAA;AAAA,QACA,CAAA;AAAA,EAA+B,GAAG,QAAA,CAC/B,GAAA;AAAA,UACC,CAAC,EAAE,IAAA,EAAK,EAAG,CAAA,KACT,CAAA,KAAA,EAAQ,CAAC,CAAA,gBAAA,EAAmB,IAAA,CAAK,SAAA,CAAU,IAAK,CAAC,iBAAiB,IAAK,CAAA,WAAA;AAAA,SAC3E,CACC,IAAA,CAAK,IAAI,CAAC,CAAA,EAAA;AAAA,OACf,CAAE,KAAK,aAAa,CAAA;AAIpB,MAAA,aAAA,CAAc,GAAA,CAAI,IAAI,YAAY,CAAA;AAClC,MAAA,KAAA,MAAW,EAAE,IAAA,EAAM,aAAA,EAAc,IAAK,GAAG,QAAA,EAAU;AACjD,QAAA,aAAA,CAAc,IAAK,IAAI,aAAA,CAAc,gBAAA;AAAA,UACnC,aAAA;AAAA,UACA;AAAA,SACF;AAAA,MACF;AACA,MAAA,MAAA,CAAO,OAAO,aAAa,CAAA;AAC3B,MAAA,OAAO,YAAA;AAAA,IACT;AAAA,EACF,CAAA;AAAA;AAAA,EAEA,gBAAA,CACE,MAAA,EACA,EAAA,EACA,SAAA,EACK;AACL,IAAA,OAAO,OAAA,CAAQ,gBAAA,CAAiB,EAAA,EAAI,SAAS,EAAE,MAAM,CAAA;AAAA,EACvD;AACF,CAAA;;;AC/xBO,IAAM,YAAA,GAAN,MAAM,aAAA,CAAa;AAAA,EACxB,iBAAA;AAAA;AAAA;AAAA;AAAA,EAKA,YAAY,IAAA,EAAc;AACxB,IAAA,IAAA,CAAK,iBAAA,GAAoB,IAAA;AAAA,EAC3B;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,OAAO,gBAAA,GAA8C;AACnD,IAAA,OAAO,cAAc,OAAA,CAAQ;AAAA,MAC3B,QAAA,EAAU;AAAA,QACR,EAAE,IAAA,EAAM,mBAAA,EAAqB,aAAA,EAAe,cAAc,IAAA;AAAK;AACjE,KACD,CAAA;AAAA,EACH;AAAA,EAEA,MAAA,GAAkB;AAChB,IAAA,OAAO,IAAA,CAAK,iBAAA,KAAsB,MAAA,CAAO,CAAC,CAAA;AAAA,EAC5C;AAAA,EAEA,OAAO,WAAW,IAAA,EAAyC;AACzD,IAAA,IAAI,IAAA,CAAK,QAAO,EAAG;AACjB,MAAA,OAAO,IAAA;AAAA,IACT,CAAA,MAAO;AACL,MAAA,OAAO,IAAA;AAAA,IACT;AAAA,EACF;AAAA,EAEA,OAAO,MAAA,GAAuB;AAC5B,IAAA,SAAS,QAAA,GAAmB;AAC1B,MAAA,OAAO,IAAA,CAAK,KAAA,CAAM,IAAA,CAAK,MAAA,KAAW,GAAI,CAAA;AAAA,IACxC;AACA,IAAA,IAAI,MAAA,GAAS,OAAO,CAAC,CAAA;AACrB,IAAA,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,EAAA,EAAI,CAAA,EAAA,EAAK;AAC3B,MAAA,MAAA,GAAU,UAAU,MAAA,CAAO,CAAC,CAAA,GAAK,MAAA,CAAO,UAAU,CAAA;AAAA,IACpD;AACA,IAAA,OAAO,IAAI,cAAa,MAAM,CAAA;AAAA,EAChC;AAAA;AAAA;AAAA;AAAA,EAKA,QAAQ,KAAA,EAA8B;AACpC,IAAA,OAAO,IAAA,CAAK,qBAAqB,KAAA,CAAM,iBAAA;AAAA,EACzC;AAAA;AAAA;AAAA;AAAA,EAKA,OAAO,KAAA,EAA8B;AACnC,IAAA,OAAO,IAAA,CAAK,QAAQ,KAAK,CAAA;AAAA,EAC3B;AAAA;AAAA;AAAA;AAAA,EAKA,WAAA,GAAsB;AACpB,IAAA,OAAO,eAAA,CAAgB,KAAK,iBAAiB,CAAA;AAAA,EAC/C;AAAA;AAAA;AAAA;AAAA,EAKA,YAAA,GAA2B;AACzB,IAAA,OAAO,gBAAA,CAAiB,KAAK,iBAAiB,CAAA;AAAA,EAChD;AAAA;AAAA;AAAA;AAAA,EAKA,OAAO,WAAW,GAAA,EAA2B;AAC3C,IAAA,OAAO,IAAI,aAAA,CAAa,eAAA,CAAgB,GAAG,CAAC,CAAA;AAAA,EAC9C;AAAA,EAEA,OAAO,iBAAiB,GAAA,EAAkC;AACxD,IAAA,MAAM,IAAA,GAAO,aAAA,CAAa,UAAA,CAAW,GAAG,CAAA;AACxC,IAAA,IAAI,IAAA,CAAK,QAAO,EAAG;AACjB,MAAA,OAAO,IAAA;AAAA,IACT,CAAA,MAAO;AACL,MAAA,OAAO,IAAA;AAAA,IACT;AAAA,EACF;AACF,CAAA;ACwsBA,SAAS,cACP,IAAA,EAC2C;AAC3C,EAAA,OAAQ,KAA4B,IAAA,KAAS,SAAA;AAC/C;AAKO,SAAS,mBAAA,CACd,MACA,GAAA,EACS;AACT,EAAA,OAAO,YAAA,CAAa,IAAA,CAAK,IAAA,EAAM,GAAG,CAAA;AACpC;AAEA,SAAS,YAAA,CACP,MACA,GAAA,EACS;AACT,EAAA,QAAQ,KAAK,IAAA;AAAM,IACjB,KAAK,IAAA;AACH,MAAA,OAAO,YAAA,CAAa,KAAK,IAAA,EAAM,GAAG,MAAM,YAAA,CAAa,IAAA,CAAK,OAAO,GAAG,CAAA;AAAA,IACtE,KAAK,IAAA;AACH,MAAA,OAAO,YAAA,CAAa,KAAK,IAAA,EAAM,GAAG,MAAM,YAAA,CAAa,IAAA,CAAK,OAAO,GAAG,CAAA;AAAA,IACtE,KAAK,IAAA;AACH,MAAA,OAAO,YAAA,CAAa,KAAK,IAAA,EAAM,GAAG,IAAI,YAAA,CAAa,IAAA,CAAK,OAAO,GAAG,CAAA;AAAA,IACpE,KAAK,KAAA;AACH,MAAA,OAAO,YAAA,CAAa,KAAK,IAAA,EAAM,GAAG,KAAK,YAAA,CAAa,IAAA,CAAK,OAAO,GAAG,CAAA;AAAA,IACrE,KAAK,IAAA;AACH,MAAA,OAAO,YAAA,CAAa,KAAK,IAAA,EAAM,GAAG,IAAI,YAAA,CAAa,IAAA,CAAK,OAAO,GAAG,CAAA;AAAA,IACpE,KAAK,KAAA;AACH,MAAA,OAAO,YAAA,CAAa,KAAK,IAAA,EAAM,GAAG,KAAK,YAAA,CAAa,IAAA,CAAK,OAAO,GAAG,CAAA;AAAA,IACrE,KAAK,KAAA;AACH,MAAA,OAAO,KAAK,OAAA,CAAQ,KAAA,CAAM,OAAK,YAAA,CAAa,CAAA,EAAG,GAAG,CAAC,CAAA;AAAA,IACrD,KAAK,IAAA;AACH,MAAA,OAAO,KAAK,OAAA,CAAQ,IAAA,CAAK,OAAK,YAAA,CAAa,CAAA,EAAG,GAAG,CAAC,CAAA;AAAA,IACpD,KAAK,KAAA;AACH,MAAA,OAAO,CAAC,YAAA,CAAa,IAAA,CAAK,MAAA,EAAQ,GAAG,CAAA;AAAA;AAE3C;AAEA,SAAS,YAAA,CACP,MACA,GAAA,EACK;AACL,EAAA,IAAI,aAAA,CAAc,IAAI,CAAA,EAAG;AACvB,IAAA,OAAO,iBAAA,CAAkB,KAAK,KAAK,CAAA;AAAA,EACrC;AACA,EAAA,OAAO,iBAAA,CAAkB,GAAA,CAAI,IAAA,CAAK,MAAM,CAAC,CAAA;AAC3C;AAUA,SAAS,sBAAsB,KAAA,EAA8C;AAC3E,EAAA,OACE,CAAC,CAAC,KAAA,IACF,OAAO,UAAU,QAAA,IACjB,OAAQ,MAAoC,WAAA,KAAgB,UAAA;AAEhE;AAKA,SAAS,gBAAgB,KAAA,EAAwC;AAC/D,EAAA,IAAI,CAAC,KAAA,IAAS,OAAO,KAAA,KAAU,UAAU,OAAO,KAAA;AAEhD,EAAA,IAAI,KAAA,YAAiB,WAAW,OAAO,IAAA;AAEvC,EAAA,MAAM,MAAA,GAAU,MACd,uCACF,CAAA;AACA,EAAA,OAAO,OAAO,MAAA,KAAW,QAAA;AAC3B;AAGO,SAAS,kBAAkB,KAAA,EAAiB;AAEjD,EAAA,IAAI,qBAAA,CAAsB,KAAK,CAAA,EAAG;AAChC,IAAA,OAAO,MAAM,WAAA,EAAY;AAAA,EAC3B;AACA,EAAA,IAAI,eAAA,CAAgB,KAAK,CAAA,EAAG;AAC1B,IAAA,OAAO,KAAA,CAAM,qCAAA;AAAA,EACf;AACA,EAAA,OAAO,KAAA;AACT;AAeO,SAAS,qBAAqB,KAAA,EAAoB;AACvD,EAAA,IAAI,KAAA,CAAM,KAAA,EAAO,OAAO,KAAA,CAAM,KAAA,CAAM,YAAA;AACpC,EAAA,IAAI,KAAA,CAAM,YAAA,EAAc,OAAO,KAAA,CAAM,YAAA;AACrC,EAAA,IAAI,KAAA,CAAM,WAAA,EAAa,OAAO,KAAA,CAAM,YAAY,KAAA,CAAM,YAAA;AACtD,EAAA,MAAM,IAAI,MAAM,yCAAyC,CAAA;AAC3D;AAKO,SAAS,oBAAoB,KAAA,EAA0C;AAC5E,EAAA,IAAI,KAAA,CAAM,WAAA,EAAa,OAAO,KAAA,CAAM,WAAA;AACpC,EAAA,OAAO,MAAA;AACT;;;ACv5BA,IAAM,aAAA,uBAAoB,GAAA,EAGxB;AAsBK,SAAS,iBACd,WAAA,EAC0D;AAC1D,EAAA,IAAI,gBAAgB,MAAA,EAAQ;AAC1B,IAAA,OAAO;AAAA,MACL,QAAA,EAAU,CAAC,aAAA,EAAe,EAAA,EAAI,MAAM,CAAA;AAAA,MACpC,SAAA,EAAW,QAAA;AAAA,MACX,OAAA,EAAS;AAAA,KACX;AAAA,EACF;AAEA,EAAA,MAAM,KAAA,GAAQ,WAAA;AACd,EAAA,MAAM,YAAA,GAAe,qBAAqB,KAAK,CAAA;AAC/C,EAAA,MAAM,SAAA,GAAY,oBAAoB,KAAK,CAAA;AAC3C,EAAA,MAAM,QAAA,GAAW,MAAM,KAAA,EAAM;AAE7B,EAAA,aAAA,CAAc,GAAA,CAAI,QAAA,EAAU,EAAE,YAAA,EAAc,WAAW,CAAA;AAEvD,EAAA,OAAO;AAAA,IACL,QAAA,EAAU,CAAC,aAAA,EAAe,YAAA,EAAc,QAAQ,CAAA;AAAA,IAChD,SAAA,EAAW;AAAA,GACb;AACF;AAiBO,IAAM,yBAAN,MAA6B;AAAA,EAC1B,UAAA,GAAyC,IAAA;AAAA,EACzC,WAAA,GAAkC,IAAA;AAAA,EAClC,aAAA,uBAAoB,GAAA,EAA+B;AAAA,EACnD,cAAA,uBAAqB,GAAA,EAO3B;AAAA,EACM,gBAAA,GAAwC,IAAA;AAAA;AAAA,EAGhD,cAAc,UAAA,EAAuC;AACnD,IAAA,IAAA,CAAK,UAAA,GAAa,UAAA;AAClB,IAAA,IAAA,CAAK,qBAAA,EAAsB;AAAA,EAC7B;AAAA,EAEA,QAAQ,WAAA,EAAgC;AACtC,IAAA,IAAA,CAAK,WAAA,GAAc,WAAA;AAEnB,IAAA,IAAA,CAAK,mBAAmB,WAAA,CACrB,aAAA,EAAc,CACd,SAAA,CAAU,CAAC,KAAA,KAAe;AACzB,MAAA,IACE,KAAA,CAAM,SAAS,SAAA,IACf,KAAA,CAAM,MAAM,QAAA,CAAS,CAAC,MAAM,aAAA,EAC5B;AACA,QAAA,MAAM,MAAA,GAAS,IAAA,CAAK,SAAA,CAAU,KAAA,CAAM,MAAM,QAAQ,CAAA;AAClD,QAAA,MAAM,GAAA,GAAM,IAAA,CAAK,aAAA,CAAc,GAAA,CAAI,MAAM,CAAA;AACzC,QAAA,IAAI,GAAA,EAAK;AACP,UAAA,GAAA,CAAI,WAAA,EAAY;AAChB,UAAA,IAAA,CAAK,aAAA,CAAc,OAAO,MAAM,CAAA;AAAA,QAClC;AAAA,MACF;AAAA,IACF,CAAC,CAAA;AAAA,EACL;AAAA,EAEA,UAA0C,OAAO;AAAA,IAC/C;AAAA,GACF,KAEM;AACJ,IAAA,MAAM,MAAA,GAAS,IAAA,CAAK,SAAA,CAAU,QAAQ,CAAA;AACtC,IAAA,MAAM,CAAC,MAAA,EAAQ,YAAA,EAAc,QAAQ,CAAA,GAAI,QAAA;AAMzC,IAAA,IAAI,WAAW,aAAA,EAAe;AAC5B,MAAA,MAAM,IAAI,KAAA;AAAA,QACR,oEAAoE,MAAM,CAAA;AAAA,OAC5E;AAAA,IACF;AAEA,IAAA,MAAM,UAAA,GAAa,aAAA,CAAc,GAAA,CAAI,QAAQ,CAAA;AAC7C,IAAA,MAAM,YAAY,UAAA,EAAY,SAAA;AAE9B,IAAA,MAAM,WAAA,GAAc,IAAA,CAAK,aAAA,CAAc,GAAA,CAAI,MAAM,CAAA;AACjD,IAAA,IAAI,aAAa,OAAA,EAAS;AACxB,MAAA,OAAO,IAAA,CAAK,YAAA,CAAa,WAAA,CAAY,aAAA,EAAe,SAAS,CAAA;AAAA,IAC/D;AAGA,IAAA,IAAI,CAAC,KAAK,UAAA,EAAY;AACpB,MAAA,OAAO,IAAI,QAAe,CAAA,OAAA,KAAW;AACnC,QAAA,MAAM,UAAU,IAAA,CAAK,cAAA,CAAe,GAAA,CAAI,MAAM,KAAK,EAAC;AACpD,QAAA,OAAA,CAAQ,IAAA,CAAK,EAAE,OAAA,EAAS,QAAA,EAAU,WAAW,CAAA;AAC7C,QAAA,IAAA,CAAK,cAAA,CAAe,GAAA,CAAI,MAAA,EAAQ,OAAO,CAAA;AAAA,MACzC,CAAC,CAAA;AAAA,IACH;AAEA,IAAA,OAAO,IAAA,CAAK,iBAAA,CAAkB,QAAA,EAAU,YAAA,EAAc,UAAU,SAAS,CAAA;AAAA,EAC3E,CAAA;AAAA,EAEQ,YAAA,CACN,eACA,SAAA,EACO;AACP,IAAA,MAAM,OAAA,GAAU,KAAA,CAAM,IAAA,CAAK,aAAA,CAAc,MAAM,CAAA;AAC/C,IAAA,IAAI,SAAA,EAAW;AACb,MAAA,OAAO,OAAA,CAAQ,MAAA;AAAA,QAAO,CAAA,GAAA,KACpB,mBAAA,CAAoB,SAAA,EAAW,GAA0B;AAAA,OAC3D;AAAA,IACF;AACA,IAAA,OAAO,OAAA;AAAA,EACT;AAAA,EAEQ,iBAAA,CACN,QAAA,EACA,YAAA,EACA,QAAA,EACA,SAAA,EACgB;AAChB,IAAA,IAAI,CAAC,KAAK,UAAA,EAAY;AACpB,MAAA,OAAO,OAAA,CAAQ,OAAA,CAAQ,EAAE,CAAA;AAAA,IAC3B;AAEA,IAAA,MAAM,MAAA,GAAS,IAAA,CAAK,SAAA,CAAU,QAAQ,CAAA;AACtC,IAAA,MAAM,EAAA,GAAK,KAAK,UAAA,CAAW,EAAA;AAE3B,IAAA,MAAM,aAAA,GAAgB,GAAG,YAAY,CAAA;AAErC,IAAA,IAAI,CAAC,aAAA,EAAe;AAClB,MAAA,OAAA,CAAQ,IAAA,CAAK,CAAA,+BAAA,EAAkC,YAAY,CAAA,WAAA,CAAa,CAAA;AACxE,MAAA,OAAO,OAAA,CAAQ,OAAA,CAAQ,EAAE,CAAA;AAAA,IAC3B;AAGA,IAAA,MAAM,WAAA,GAAc,IAAA,CAAK,aAAA,CAAc,GAAA,CAAI,MAAM,CAAA;AACjD,IAAA,IAAI,WAAA,EAAa;AACf,MAAA,IAAI,YAAY,OAAA,EAAS;AACvB,QAAA,OAAO,OAAA,CAAQ,OAAA;AAAA,UACb,IAAA,CAAK,YAAA,CAAa,WAAA,CAAY,aAAA,EAAe,SAAS;AAAA,SACxD;AAAA,MACF;AACA,MAAA,OAAO,IAAI,QAAQ,CAAA,OAAA,KAAW;AAC5B,QAAA,MAAM,UAAU,IAAA,CAAK,cAAA,CAAe,GAAA,CAAI,MAAM,KAAK,EAAC;AACpD,QAAA,OAAA,CAAQ,IAAA,CAAK,EAAE,OAAA,EAAS,QAAA,EAAU,WAAW,CAAA;AAC7C,QAAA,IAAA,CAAK,cAAA,CAAe,GAAA,CAAI,MAAA,EAAQ,OAAO,CAAA;AAAA,MACzC,CAAC,CAAA;AAAA,IACH;AAEA,IAAA,OAAO,IAAI,QAAe,CAAA,OAAA,KAAW;AACnC,MAAA,MAAM,cAAc,MAAM;AACxB,QAAA,IAAI,CAAC,IAAA,CAAK,WAAA,EAAa,OAAO,EAAC;AAC/B,QAAA,MAAM,IAAA,GAAO,IAAA,CAAK,YAAA,CAAa,aAAA,EAAe,SAAS,CAAA;AACvD,QAAA,IAAA,CAAK,WAAA,CAAY,YAAA,CAAa,QAAA,EAAU,IAAI,CAAA;AAC5C,QAAA,OAAO,IAAA;AAAA,MACT,CAAA;AAEA,MAAA,MAAM,SAAS,IAAA,CAAK,UAAA,CAAY,mBAAA,EAAoB,CACjD,UAAU,MAAM;AACf,QAAA,MAAM,GAAA,GAAM,IAAA,CAAK,aAAA,CAAc,GAAA,CAAI,MAAM,CAAA;AACzC,QAAA,IAAI,GAAA,EAAK;AACP,UAAA,GAAA,CAAI,OAAA,GAAU,IAAA;AAAA,QAChB;AAEA,QAAA,MAAM,OAAO,WAAA,EAAY;AACzB,QAAA,OAAA,CAAQ,IAAI,CAAA;AAEZ,QAAA,MAAM,OAAA,GAAU,IAAA,CAAK,cAAA,CAAe,GAAA,CAAI,MAAM,CAAA;AAC9C,QAAA,IAAI,OAAA,EAAS;AACX,UAAA,KAAA,MAAW,KAAK,OAAA,EAAS;AACvB,YAAA,CAAA,CAAE,QAAQ,IAAI,CAAA;AAAA,UAChB;AACA,UAAA,IAAA,CAAK,cAAA,CAAe,OAAO,MAAM,CAAA;AAAA,QACnC;AAAA,MACF,CAAC,CAAA,CACA,SAAA,CAAU,QAAQ,CAAA;AAGrB,MAAA,MAAM,gBAAgB,MAAM;AAC1B,QAAA,MAAM,GAAA,GAAM,IAAA,CAAK,aAAA,CAAc,GAAA,CAAI,MAAM,CAAA;AACzC,QAAA,IAAI,KAAK,OAAA,EAAS;AAChB,UAAA,WAAA,EAAY;AAAA,QACd;AAAA,MACF,CAAA;AAEA,MAAA,aAAA,CAAc,SAAS,aAAa,CAAA;AACpC,MAAA,aAAA,CAAc,SAAS,aAAa,CAAA;AACpC,MAAA,aAAA,CAAc,WAAW,aAAa,CAAA;AAEtC,MAAA,IAAA,CAAK,aAAA,CAAc,IAAI,MAAA,EAAQ;AAAA,QAC7B,aAAa,MAAM;AACjB,UAAA,MAAA,CAAO,WAAA,EAAY;AACnB,UAAA,aAAA,CAAc,eAAe,aAAa,CAAA;AAC1C,UAAA,aAAA,CAAc,eAAe,aAAa,CAAA;AAC1C,UAAA,aAAA,CAAc,iBAAiB,aAAa,CAAA;AAAA,QAC9C,CAAA;AAAA,QACA,aAAA;AAAA,QACA,OAAA,EAAS;AAAA,OACV,CAAA;AAAA,IACH,CAAC,CAAA;AAAA,EACH;AAAA,EAEQ,qBAAA,GAA8B;AACpC,IAAA,IAAI,CAAC,KAAK,UAAA,EAAY;AAEtB,IAAA,MAAM,iBAAiB,KAAA,CAAM,IAAA,CAAK,IAAA,CAAK,cAAA,CAAe,SAAS,CAAA;AAC/D,IAAA,IAAA,CAAK,eAAe,KAAA,EAAM;AAE1B,IAAA,KAAA,MAAW,CAAC,MAAA,EAAQ,OAAO,CAAA,IAAK,cAAA,EAAgB;AAC9C,MAAA,MAAM,QAAA,GAAW,IAAA,CAAK,KAAA,CAAM,MAAM,CAAA;AAClC,MAAA,MAAM,GAAG,YAAY,CAAA,GAAI,QAAA;AAEzB,MAAA,IAAI,OAAA,CAAQ,SAAS,CAAA,EAAG;AACtB,QAAA,MAAM,KAAA,GAAQ,QAAQ,CAAC,CAAA;AACvB,QAAA,IAAA,CAAK,iBAAA;AAAA,UACH,QAAA;AAAA,UACA,YAAA;AAAA,UACA,KAAA,CAAM,QAAA;AAAA,UACN,KAAA,CAAM;AAAA,SACR,CACG,KAAK,CAAA,IAAA,KAAQ;AACZ,UAAA,KAAA,MAAW,KAAK,OAAA,EAAS;AACvB,YAAA,CAAA,CAAE,QAAQ,IAAI,CAAA;AAAA,UAChB;AAAA,QACF,CAAC,CAAA,CACA,KAAA,CAAM,MAAM;AACX,UAAA,KAAA,MAAW,KAAK,OAAA,EAAS;AACvB,YAAA,CAAA,CAAE,OAAA,CAAQ,EAAE,CAAA;AAAA,UACd;AAAA,QACF,CAAC,CAAA;AAAA,MACL;AAAA,IACF;AAAA,EACF;AAAA;AAAA,EAGA,UAAA,GAAmB;AACjB,IAAA,IAAI,KAAK,gBAAA,EAAkB;AACzB,MAAA,IAAA,CAAK,gBAAA,EAAiB;AACtB,MAAA,IAAA,CAAK,gBAAA,GAAmB,IAAA;AAAA,IAC1B;AAEA,IAAA,KAAA,MAAW,GAAA,IAAO,IAAA,CAAK,aAAA,CAAc,MAAA,EAAO,EAAG;AAC7C,MAAA,GAAA,CAAI,WAAA,EAAY;AAAA,IAClB;AACA,IAAA,IAAA,CAAK,cAAc,KAAA,EAAM;AACzB,IAAA,IAAA,CAAK,eAAe,KAAA,EAAM;AAC1B,IAAA,IAAA,CAAK,UAAA,GAAa,IAAA;AAAA,EACpB;AACF;ACjRO,SAAS,mBAAA,CACd,aAGA,OAAA,EAS8C;AAC9C,EAAA,MAAM,eACJ,WAAA,KAAgB,MAAA,GACZ,iBAAiB,MAAM,CAAA,GACvB,iBAAiB,WAAW,CAAA;AAElC,EAAA,MAAM,QAAQC,mBAAA,CAAS;AAAA,IACrB,GAAG,YAAA;AAAA,IACH,GAAG;AAAA,GAC2C,CAAA;AAEhD,EAAA,OAAO,CAAC,KAAA,CAAM,IAAA,IAAQ,EAAC,EAAG,KAAA,CAAM,WAAW,KAAK,CAAA;AAClD;AAMO,SAAS,2BAAA,CACd,OACA,OAAA,EASsD;AACtD,EAAA,MAAM,YAAA,GAAe,iBAAiB,KAAK,CAAA;AAE3C,EAAA,MAAM,IAAIC,2BAAA,CAAiB;AAAA,IACzB,GAAG,YAAA;AAAA,IACH,GAAG;AAAA,GACmD,CAAA;AAExD,EAAA,OAAO,CAAC,CAAA,CAAE,IAAA,EAAM,KAAA,EAAO,CAAC,CAAA;AAC1B;AC9EO,IAAM,kBAAA,GAAqBC,mBAAA;AAAA,EAChC;AACF,CAAA;AAIO,SAAS,cAAA,GAAkC;AAChD,EAAA,MAAM,OAAA,GAAUC,iBAAW,kBAAkB,CAAA;AAC7C,EAAA,IAAI,CAAC,OAAA,EAAS;AACZ,IAAA,MAAM,IAAI,KAAA;AAAA,MACR;AAAA,KACF;AAAA,EACF;AACA,EAAA,OAAO,OAAA;AACT;;;AC0CA,SAAS,YAAA,GAAgC;AACvC,EAAA,OAAO;AAAA,IACL,QAAA,EAAU,KAAA;AAAA,IACV,QAAA,EAAU,MAAA;AAAA,IACV,KAAA,EAAO,MAAA;AAAA,IACP,YAAA,EAAc,aAAa,MAAA,EAAO;AAAA,IAClC,eAAA,EAAiB;AAAA,GACnB;AACF;AAMA,IAAM,qBAAA,GAAN,MAAM,sBAAA,CAAsB;AAAA,EAC1B,YAAA,uBAAmB,GAAA,EAA+B;AAAA;AAAA,EAGlD,OAAO,MAAA,CAAO,GAAA,EAAa,UAAA,EAA4B;AACrD,IAAA,OAAO,CAAA,EAAG,GAAG,CAAA,EAAA,EAAK,UAAU,CAAA,CAAA;AAAA,EAC9B;AAAA;AAAA,EAGA,MAAA,CAAO,KAAa,UAAA,EAA4B;AAC9C,IAAA,OAAO,sBAAA,CAAsB,MAAA,CAAO,GAAA,EAAK,UAAU,CAAA;AAAA,EACrD;AAAA,EAEA,aAAa,GAAA,EAAgC;AAC3C,IAAA,MAAM,QAAA,GAAW,IAAA,CAAK,YAAA,CAAa,GAAA,CAAI,GAAG,CAAA;AAC1C,IAAA,IAAI,QAAA,EAAU;AACZ,MAAA,OAAO,QAAA;AAAA,IACT;AACA,IAAA,MAAM,OAAA,GAA6B;AAAA,MACjC,UAAA,EAAY,MAAA;AAAA,MACZ,QAAA,EAAU,CAAA;AAAA,MACV,OAAO,YAAA,EAAa;AAAA,MACpB,SAAA,sBAAe,GAAA,EAAI;AAAA,MACnB,cAAA,EAAgB;AAAA,KAClB;AACA,IAAA,IAAA,CAAK,YAAA,CAAa,GAAA,CAAI,GAAA,EAAK,OAAO,CAAA;AAClC,IAAA,OAAO,OAAA;AAAA,EACT;AAAA,EAEA,QAAQ,OAAA,EAAkC;AACxC,IAAA,KAAA,MAAW,QAAA,IAAY,QAAQ,SAAA,EAAW;AACxC,MAAA,QAAA,EAAS;AAAA,IACX;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,MAAA,CACE,KACA,OAAA,EACG;AACH,IAAA,MAAM,OAAA,GAAU,IAAA,CAAK,YAAA,CAAa,GAAG,CAAA;AACrC,IAAA,IAAI,QAAQ,cAAA,EAAgB;AAC1B,MAAA,YAAA,CAAa,QAAQ,cAAc,CAAA;AACnC,MAAA,OAAA,CAAQ,cAAA,GAAiB,IAAA;AAAA,IAC3B;AACA,IAAA,OAAA,CAAQ,QAAA,IAAY,CAAA;AACpB,IAAA,IAAI,QAAQ,UAAA,EAAY;AACtB,MAAA,OAAO,OAAA,CAAQ,UAAA;AAAA,IACjB;AAEA,IAAA,MAAM,UAAA,GAAa,QAAQ,KAAA,EAAM;AACjC,IAAA,OAAA,CAAQ,UAAA,GAAa,UAAA;AAErB,IAAA,MAAM,WAAA,GAAc,CAAC,OAAA,KAAsC;AACzD,MAAA,OAAA,CAAQ,QAAQ,EAAE,GAAG,OAAA,CAAQ,KAAA,EAAO,GAAG,OAAA,EAAQ;AAC/C,MAAA,IAAA,CAAK,QAAQ,OAAO,CAAA;AAAA,IACtB,CAAA;AAEA,IAAA,WAAA,CAAY;AAAA,MACV,UAAU,UAAA,CAAW,QAAA;AAAA,MACrB,UAAU,UAAA,CAAW,QAAA;AAAA,MACrB,OAAO,UAAA,CAAW,KAAA;AAAA,MAClB,cAAc,UAAA,CAAW,YAAA;AAAA,MACzB,eAAA,EAAiB;AAAA,KAClB,CAAA;AAED,IAAA,OAAA,CAAQ,YAAY,CAAA,IAAA,KAAQ;AAC1B,MAAA,WAAA,CAAY;AAAA,QACV,UAAU,IAAA,CAAK,QAAA;AAAA,QACf,UAAU,IAAA,CAAK,QAAA;AAAA,QACf,OAAO,IAAA,CAAK,KAAA;AAAA,QACZ,cAAc,IAAA,CAAK,YAAA;AAAA,QACnB,eAAA,EAAiB;AAAA,OAClB,CAAA;AAAA,IACH,CAAA;AAEA,IAAA,OAAA,CAAQ,YAAA,GAAe,CAAC,GAAA,EAAK,KAAA,KAAU;AACrC,MAAA,WAAA,CAAY;AAAA,QACV,UAAU,GAAA,CAAI,QAAA;AAAA,QACd,iBAAiB,KAAA,IAAS;AAAA,OAC3B,CAAA;AAAA,IACH,CAAA;AAEA,IAAA,OAAA,CAAQ,cAAA,GAAiB,CAAC,GAAA,EAAK,KAAA,KAAU;AACvC,MAAA,WAAA,CAAY;AAAA,QACV,UAAU,GAAA,CAAI,QAAA;AAAA,QACd,eAAA,EAAiB;AAAA,OAClB,CAAA;AAAA,IACH,CAAA;AAEA,IAAA,OAAA,CAAQ,SAAA,CAAU,QAAQ,SAAS,CAAA;AACnC,IAAA,OAAA,CAAQ,YAAA,CAAa,QAAQ,YAAY,CAAA;AACzC,IAAA,OAAA,CAAQ,cAAA,CAAe,QAAQ,cAAc,CAAA;AAE7C,IAAA,OAAO,UAAA;AAAA,EACT;AAAA,EAEA,QAAQ,GAAA,EAAmB;AACzB,IAAA,MAAM,OAAA,GAAU,IAAA,CAAK,YAAA,CAAa,GAAA,CAAI,GAAG,CAAA;AACzC,IAAA,IAAI,CAAC,OAAA,EAAS;AACZ,MAAA;AAAA,IACF;AAEA,IAAA,OAAA,CAAQ,QAAA,IAAY,CAAA;AACpB,IAAA,IAAI,OAAA,CAAQ,QAAA,GAAW,CAAA,IAAK,OAAA,CAAQ,cAAA,EAAgB;AAClD,MAAA;AAAA,IACF;AAEA,IAAA,OAAA,CAAQ,cAAA,GAAiB,WAAW,MAAM;AACxC,MAAA,OAAA,CAAQ,cAAA,GAAiB,IAAA;AACzB,MAAA,IAAI,OAAA,CAAQ,WAAW,CAAA,EAAG;AACxB,QAAA;AAAA,MACF;AACA,MAAA,IAAI,QAAQ,UAAA,EAAY;AACtB,QAAA,IAAI,QAAQ,SAAA,EAAW;AACrB,UAAA,OAAA,CAAQ,UAAA,CAAW,eAAA,CAAgB,OAAA,CAAQ,SAAgB,CAAA;AAAA,QAC7D;AACA,QAAA,IAAI,QAAQ,YAAA,EAAc;AACxB,UAAA,OAAA,CAAQ,UAAA,CAAW,kBAAA,CAAmB,OAAA,CAAQ,YAAmB,CAAA;AAAA,QACnE;AACA,QAAA,IAAI,QAAQ,cAAA,EAAgB;AAC1B,UAAA,OAAA,CAAQ,UAAA,CAAW,oBAAA;AAAA,YACjB,OAAA,CAAQ;AAAA,WACV;AAAA,QACF;AACA,QAAA,OAAA,CAAQ,WAAW,UAAA,EAAW;AAAA,MAChC;AACA,MAAA,IAAA,CAAK,YAAA,CAAa,OAAO,GAAG,CAAA;AAAA,IAC9B,GAAG,CAAC,CAAA;AAAA,EACN;AAAA,EAEA,SAAA,CAAU,KAAa,QAAA,EAAgC;AACrD,IAAA,MAAM,OAAA,GAAU,IAAA,CAAK,YAAA,CAAa,GAAG,CAAA;AACrC,IAAA,OAAA,CAAQ,SAAA,CAAU,IAAI,QAAQ,CAAA;AAC9B,IAAA,OAAO,MAAM;AACX,MAAA,OAAA,CAAQ,SAAA,CAAU,OAAO,QAAQ,CAAA;AACjC,MAAA,IACE,OAAA,CAAQ,YAAY,CAAA,IACpB,OAAA,CAAQ,UAAU,IAAA,KAAS,CAAA,IAC3B,CAAC,OAAA,CAAQ,UAAA,EACT;AACA,QAAA,IAAA,CAAK,YAAA,CAAa,OAAO,GAAG,CAAA;AAAA,MAC9B;AAAA,IACF,CAAA;AAAA,EACF;AAAA,EAEA,YAAY,GAAA,EAA0C;AACpD,IAAA,OAAO,IAAA,CAAK,YAAA,CAAa,GAAA,CAAI,GAAG,CAAA,EAAG,KAAA;AAAA,EACrC;AAAA,EAEA,cAA+C,GAAA,EAAuB;AACpE,IAAA,OAAQ,IAAA,CAAK,YAAA,CAAa,GAAA,CAAI,GAAG,GAAG,UAAA,IAAgC,IAAA;AAAA,EACtE;AACF,CAAA;AAEO,IAAM,iBAAA,GAAoB,IAAI,qBAAA,EAAsB;;;ACxNpD,SAAS,mBAAA,CAEd;AAAA,EACA,iBAAA;AAAA,EACA;AACF,CAAA,EAA8D;AAC5D,EAAA,MAAM,GAAA,GAAM,kBAAkB,MAAA,EAAO;AACrC,EAAA,MAAM,UAAA,GAAa,kBAAkB,aAAA,EAAc;AACnD,EAAA,MAAM,GAAA,GAAYC,gBAAA,CAAA,OAAA;AAAA,IAChB,MAAM,iBAAA,CAAkB,MAAA,CAAO,GAAA,EAAK,UAAU,CAAA;AAAA,IAC9C,CAAC,KAAK,UAAU;AAAA,GAClB;AAEA,EAAA,MAAM,mBAAyBA,gBAAA,CAAA,MAAA,CAA+B;AAAA,IAC5D,QAAA,EAAU,KAAA;AAAA,IACV,QAAA,EAAU,MAAA;AAAA,IACV,KAAA,EAAO,MAAA;AAAA,IACP,YAAA,EAAc,aAAa,MAAA,EAAO;AAAA,IAClC,eAAA,EAAiB;AAAA,GAClB,CAAA;AAED,EAAA,MAAM,SAAA,GAAkBA,gBAAA,CAAA,WAAA;AAAA,IACtB,CAAC,aAAA,KACC,iBAAA,CAAkB,SAAA,CAAU,KAAK,aAAa,CAAA;AAAA,IAChD,CAAC,GAAG;AAAA,GACN;AACA,EAAA,MAAM,WAAA,GAAoBA,gBAAA,CAAA,WAAA;AAAA,IACxB,MAAM,iBAAA,CAAkB,WAAA,CAAY,GAAG,KAAK,gBAAA,CAAiB,OAAA;AAAA,IAC7D,CAAC,GAAG;AAAA,GACN;AACA,EAAA,MAAM,iBAAA,GAA0BA,gBAAA,CAAA,WAAA;AAAA,IAC9B,MAAM,gBAAA,CAAiB,OAAA;AAAA,IACvB;AAAC,GACH;AAEA,EAAA,MAAM,KAAA,GAAcA,gBAAA,CAAA,oBAAA;AAAA,IAClB,SAAA;AAAA,IACA,WAAA;AAAA,IACA;AAAA,GACF;AAEA,EAAA,MAAM,aAAA,GAAsBA,gBAAA,CAAA,WAAA;AAAA,IAC1B,MAAM,iBAAA,CAAkB,aAAA,CAA4B,GAAG,CAAA;AAAA,IACvD,CAAC,GAAG;AAAA,GACN;AAEA,EAAA,MAAM,YAAA,GAAqBA,gBAAA,CAAA,OAAA;AAAA,IACzB,OAAO,EAAE,GAAG,KAAA,EAAO,aAAA,EAAc,CAAA;AAAA,IACjC,CAAC,OAAO,aAAa;AAAA,GACvB;AAEA,EAAMA,2BAAU,MAAM;AACpB,IAAA,iBAAA,CAAkB,MAAA,CAAO,KAAK,iBAAiB,CAAA;AAC/C,IAAA,OAAO,MAAM;AACX,MAAA,iBAAA,CAAkB,QAAQ,GAAG,CAAA;AAAA,IAC/B,CAAA;AAAA,EACF,CAAA,EAAG,CAAC,GAAA,EAAK,iBAAiB,CAAC,CAAA;AAE3B,EAAA,OAAaA,gBAAA,CAAA,aAAA;AAAA,IACX,kBAAA,CAAmB,QAAA;AAAA,IACnB,EAAE,OAAO,YAAA,EAAa;AAAA,IACtB;AAAA,GACF;AACF;AC9EO,SAAS,WACd,UAAA,EACsD;AACtD,EAAA,MAAM,EAAE,aAAA,EAAe,QAAA,EAAS,GAAI,cAAA,EAAe;AACnD,EAAA,MAAM,cAAc,UAAA,CAAW,YAAA;AAG/B,EAAA,MAAM,QAAA,GAAWC,YAAAA,CAMf,EAAE,CAAA;AAGJ,EAAAC,gBAAU,MAAM;AACd,IAAA,MAAM,OAAO,aAAA,EAAc;AAC3B,IAAA,IAAI,CAAC,IAAA,EAAM;AACT,MAAA;AAAA,IACF;AACA,IAAA,MAAM,EAAA,GAAM,IAAA,CAAK,QAAA,CAAiB,WAAW,CAAA;AAG7C,IAAA,IAAI,QAAA,CAAS,QAAQ,MAAA,EAAQ;AAC3B,MAAA,MAAM,OAAA,GAAU,QAAA,CAAS,OAAA,CAAQ,MAAA,CAAO,CAAC,CAAA;AACzC,MAAA,KAAA,MAAW,QAAQ,OAAA,EAAS;AAC1B,QAAA,EAAA,CAAG,GAAG,KAAK,MAAM,CAAA,CAAE,KAAK,IAAA,CAAK,OAAA,EAAS,KAAK,MAAM,CAAA;AAAA,MACnD;AAAA,IACF;AAAA,EACF,CAAA,EAAG,CAAC,aAAA,EAAe,WAAA,EAAa,QAAQ,CAAC,CAAA;AAEzC,EAAA,OAAOC,iBAAAA;AAAA,IACL,IAAI,MAAA,KAAmC;AACrC,MAAA,MAAM,OAAO,aAAA,EAAc;AAC3B,MAAA,IAAI,CAAC,IAAA,EAAM;AACT,QAAA,OAAO,IAAI,OAAA,CAAc,CAAC,OAAA,EAAS,MAAA,KAAW;AAC5C,UAAA,QAAA,CAAS,QAAQ,IAAA,CAAK,EAAE,MAAA,EAAQ,OAAA,EAAS,QAAQ,CAAA;AAAA,QACnD,CAAC,CAAA;AAAA,MACH;AACA,MAAA,MAAM,EAAA,GAAM,IAAA,CAAK,QAAA,CAAiB,WAAW,CAAA;AAG7C,MAAA,OAAO,EAAA,CAAG,GAAG,MAAM,CAAA;AAAA,IACrB,CAAA;AAAA,IACA,CAAC,eAAe,WAAW;AAAA,GAC7B;AACF","file":"index.cjs","sourcesContent":["import { AlgebraicType } from './algebraic_type';\n\nexport type TimeDurationAlgebraicType = {\n  tag: 'Product';\n  value: {\n    elements: [\n      { name: '__time_duration_micros__'; algebraicType: { tag: 'I64' } },\n    ];\n  };\n};\n\n/**\n * A difference between two points in time, represented as a number of microseconds.\n */\nexport class TimeDuration {\n  __time_duration_micros__: bigint;\n\n  private static MICROS_PER_MILLIS: bigint = 1000n;\n\n  /**\n   * Get the algebraic type representation of the {@link TimeDuration} type.\n   * @returns The algebraic type representation of the type.\n   */\n  static getAlgebraicType(): TimeDurationAlgebraicType {\n    return AlgebraicType.Product({\n      elements: [\n        {\n          name: '__time_duration_micros__',\n          algebraicType: AlgebraicType.I64,\n        },\n      ],\n    });\n  }\n\n  static isTimeDuration(\n    algebraicType: AlgebraicType\n  ): algebraicType is TimeDurationAlgebraicType {\n    if (algebraicType.tag !== 'Product') {\n      return false;\n    }\n    const elements = algebraicType.value.elements;\n    if (elements.length !== 1) {\n      return false;\n    }\n    const microsElement = elements[0];\n    return (\n      microsElement.name === '__time_duration_micros__' &&\n      microsElement.algebraicType.tag === 'I64'\n    );\n  }\n\n  get micros(): bigint {\n    return this.__time_duration_micros__;\n  }\n\n  get millis(): number {\n    return Number(this.micros / TimeDuration.MICROS_PER_MILLIS);\n  }\n\n  constructor(micros: bigint) {\n    this.__time_duration_micros__ = micros;\n  }\n\n  static fromMillis(millis: number): TimeDuration {\n    return new TimeDuration(BigInt(millis) * TimeDuration.MICROS_PER_MILLIS);\n  }\n\n  /** This outputs the same string format that we use in the host and in Rust modules */\n  toString(): string {\n    const micros = this.micros;\n    const sign = micros < 0 ? '-' : '+';\n    const pos = micros < 0 ? -micros : micros;\n    const secs = pos / 1_000_000n;\n    const micros_remaining = pos % 1_000_000n;\n    return `${sign}${secs}.${String(micros_remaining).padStart(6, '0')}`;\n  }\n}\n","import { AlgebraicType } from './algebraic_type';\nimport { TimeDuration } from './time_duration';\n\nexport type TimestampAlgebraicType = {\n  tag: 'Product';\n  value: {\n    elements: [\n      {\n        name: '__timestamp_micros_since_unix_epoch__';\n        algebraicType: { tag: 'I64' };\n      },\n    ];\n  };\n};\n\n/**\n * A point in time, represented as a number of microseconds since the Unix epoch.\n */\nexport class Timestamp {\n  __timestamp_micros_since_unix_epoch__: bigint;\n\n  private static MICROS_PER_MILLIS: bigint = 1000n;\n\n  get microsSinceUnixEpoch(): bigint {\n    return this.__timestamp_micros_since_unix_epoch__;\n  }\n\n  constructor(micros: bigint) {\n    this.__timestamp_micros_since_unix_epoch__ = micros;\n  }\n\n  /**\n   * Get the algebraic type representation of the {@link Timestamp} type.\n   * @returns The algebraic type representation of the type.\n   */\n  static getAlgebraicType(): TimestampAlgebraicType {\n    return AlgebraicType.Product({\n      elements: [\n        {\n          name: '__timestamp_micros_since_unix_epoch__',\n          algebraicType: AlgebraicType.I64,\n        },\n      ],\n    });\n  }\n\n  static isTimestamp(\n    algebraicType: AlgebraicType\n  ): algebraicType is TimestampAlgebraicType {\n    if (algebraicType.tag !== 'Product') {\n      return false;\n    }\n    const elements = algebraicType.value.elements;\n    if (elements.length !== 1) {\n      return false;\n    }\n    const microsElement = elements[0];\n    return (\n      microsElement.name === '__timestamp_micros_since_unix_epoch__' &&\n      microsElement.algebraicType.tag === 'I64'\n    );\n  }\n\n  /**\n   * The Unix epoch, the midnight at the beginning of January 1, 1970, UTC.\n   */\n  static UNIX_EPOCH: Timestamp = new Timestamp(0n);\n\n  /**\n   * Get a `Timestamp` representing the execution environment's belief of the current moment in time.\n   */\n  static now(): Timestamp {\n    return Timestamp.fromDate(new Date());\n  }\n\n  /** Convert to milliseconds since Unix epoch. */\n  toMillis(): bigint {\n    return this.microsSinceUnixEpoch / 1000n;\n  }\n\n  /**\n   * Get a `Timestamp` representing the same point in time as `date`.\n   */\n  static fromDate(date: Date): Timestamp {\n    const millis = date.getTime();\n    const micros = BigInt(millis) * Timestamp.MICROS_PER_MILLIS;\n    return new Timestamp(micros);\n  }\n\n  /**\n   * Get a `Date` representing approximately the same point in time as `this`.\n   *\n   * This method truncates to millisecond precision,\n   * and throws `RangeError` if the `Timestamp` is outside the range representable as a `Date`.\n   */\n  toDate(): Date {\n    const micros = this.__timestamp_micros_since_unix_epoch__;\n    const millis = micros / Timestamp.MICROS_PER_MILLIS;\n    if (\n      millis > BigInt(Number.MAX_SAFE_INTEGER) ||\n      millis < BigInt(Number.MIN_SAFE_INTEGER)\n    ) {\n      throw new RangeError(\n        \"Timestamp is outside of the representable range of JS's Date\"\n      );\n    }\n    return new Date(Number(millis));\n  }\n\n  /**\n   * Get an ISO 8601 / RFC 3339 formatted string representation of this timestamp with microsecond precision.\n   *\n   * This method preserves the full microsecond precision of the timestamp,\n   * and throws `RangeError` if the `Timestamp` is outside the range representable in ISO format.\n   *\n   * @returns ISO 8601 formatted string with microsecond precision (e.g., '2025-02-17T10:30:45.123456Z')\n   */\n  toISOString(): string {\n    const micros = this.__timestamp_micros_since_unix_epoch__;\n    const millis = micros / Timestamp.MICROS_PER_MILLIS;\n\n    if (\n      millis > BigInt(Number.MAX_SAFE_INTEGER) ||\n      millis < BigInt(Number.MIN_SAFE_INTEGER)\n    ) {\n      throw new RangeError(\n        'Timestamp is outside of the representable range for ISO string formatting'\n      );\n    }\n\n    const date = new Date(Number(millis));\n    const isoBase = date.toISOString(); // Format: '2025-02-17T10:30:45.123Z'\n\n    // Extract the full 6 decimal places of microseconds\n    const microsRemainder = Math.abs(Number(micros % 1000000n));\n    const fractionalPart = String(microsRemainder).padStart(6, '0');\n\n    // Replace the 3-digit millisecond part with the full 6-digit microsecond part\n    return isoBase.replace(/\\.\\d{3}Z$/, `.${fractionalPart}Z`);\n  }\n\n  since(other: Timestamp): TimeDuration {\n    return new TimeDuration(\n      this.__timestamp_micros_since_unix_epoch__ -\n        other.__timestamp_micros_since_unix_epoch__\n    );\n  }\n}\n","import { Timestamp } from './timestamp';\nimport { AlgebraicType } from './algebraic_type.ts';\n\nexport type UuidAlgebraicType = {\n  tag: 'Product';\n  value: {\n    elements: [\n      {\n        name: '__uuid__';\n        algebraicType: { tag: 'U128' };\n      },\n    ];\n  };\n};\n\n/**\n * Supported UUID versions.\n *\n * - `Nil`  The \"Nil\" UUID (all zeros)\n * - `V4`   Version 4: random\n * - `V7`   Version 7: timestamp + counter + random\n * - `Max`  The \"Max\" UUID (all ones)\n */\ntype UuidVersion = 'Nil' | 'V4' | 'V7' | 'Max';\n\n/**\n * A universally unique identifier (UUID).\n *\n * Supports UUID `Nil`, `Max`, `V4` (random), and `V7`\n * (timestamp + counter + random).\n *\n * Internally represented as an unsigned 128-bit between 0 and `MAX_UUID_BIGINT`.\n */\nexport class Uuid {\n  __uuid__: bigint;\n\n  /**\n   * The nil UUID (all zeros).\n   *\n   * @example\n   * ```ts\n   * const uuid = Uuid.NIL;\n   * console.assert(\n   *   uuid.toString() === \"00000000-0000-0000-0000-000000000000\"\n   * );\n   * ```\n   */\n  static readonly NIL = new Uuid(0n);\n  static readonly MAX_UUID_BIGINT = 0xffffffffffffffffffffffffffffffffn;\n  /**\n   * The max UUID (all ones).\n   *\n   * @example\n   * ```ts\n   * const uuid = Uuid.MAX;\n   * console.assert(\n   *   uuid.toString() === \"ffffffff-ffff-ffff-ffff-ffffffffffff\"\n   * );\n   * ```\n   */\n  static readonly MAX = new Uuid(Uuid.MAX_UUID_BIGINT);\n\n  /**\n   * Create a UUID from a raw 128-bit value.\n   *\n   * @param u - Unsigned 128-bit integer\n   * @throws {Error} If the value is outside the valid UUID range\n   */\n  constructor(u: bigint) {\n    // Must fit in exactly 16 bytes\n    if (u < 0n || u > Uuid.MAX_UUID_BIGINT) {\n      throw new Error('Invalid UUID: must be between 0 and `MAX_UUID_BIGINT`');\n    }\n    this.__uuid__ = u;\n  }\n\n  /**\n   * Create a UUID `v4` from explicit random bytes.\n   *\n   * This method assumes the bytes are already sufficiently random.\n   * It only sets the appropriate bits for the UUID version and variant.\n   *\n   * @param bytes - Exactly 16 random bytes\n   * @returns A UUID `v4`\n   * @throws {Error} If `bytes.length !== 16`\n   *\n   * @example\n   * ```ts\n   * const randomBytes = new Uint8Array(16);\n   * const uuid = Uuid.fromRandomBytesV4(randomBytes);\n   *\n   * console.assert(\n   *   uuid.toString() === \"00000000-0000-4000-8000-000000000000\"\n   * );\n   * ```\n   */\n  static fromRandomBytesV4(bytes: Uint8Array): Uuid {\n    if (bytes.length !== 16) throw new Error('UUID v4 requires 16 bytes');\n    const arr = new Uint8Array(bytes);\n    arr[6] = (arr[6] & 0x0f) | 0x40; // version 4\n    arr[8] = (arr[8] & 0x3f) | 0x80; // variant\n    return new Uuid(Uuid.bytesToBigInt(arr));\n  }\n\n  /**\n   * Generate a UUID `v7` using a monotonic counter from `0` to `2^31 - 1`,\n   * a timestamp, and 4 random bytes.\n   *\n   * The counter wraps around on overflow.\n   *\n   * The UUID `v7` is structured as follows:\n   *\n   * ```ascii\n   * \n   * | B0  | B1  | B2  | B3  | B4  | B5              |         B6        |\n   * \n   * |                 unix_ts_ms                    |      version 7    |\n   * \n   * \n   * | B7           | B8      | B9  | B10 | B11  | B12 | B13 | B14 | B15 |\n   * \n   * | counter_high | variant |    counter_low   |        random         |\n   * \n   * ```\n   *\n   * @param counter - Mutable monotonic counter (31-bit)\n   * @param now - Timestamp since the Unix epoch\n   * @param randomBytes - Exactly 4 random bytes\n   * @returns A UUID `v7`\n   *\n   * @throws {Error} If the `counter` is negative\n   * @throws {Error} If the `timestamp` is before the Unix epoch\n   * @throws {Error} If `randomBytes.length !== 4`\n   *\n   * @example\n   * ```ts\n   * const now = Timestamp.fromMillis(1_686_000_000_000n);\n   * const counter = { value: 1 };\n   * const randomBytes = new Uint8Array(4);\n   *\n   * const uuid = Uuid.fromCounterV7(counter, now, randomBytes);\n   *\n   * console.assert(\n   *   uuid.toString() === \"0000647e-5180-7000-8000-000200000000\"\n   * );\n   * ```\n   */\n  static fromCounterV7(\n    counter: { value: number },\n    now: Timestamp,\n    randomBytes: Uint8Array\n  ): Uuid {\n    if (randomBytes.length !== 4) {\n      throw new Error('`fromCounterV7` requires `randomBytes.length == 4`');\n    }\n\n    if (counter.value < 0) {\n      throw new Error('`fromCounterV7` uuid `counter` must be non-negative');\n    }\n\n    if (now.__timestamp_micros_since_unix_epoch__ < 0) {\n      throw new Error('`fromCounterV7` `timestamp` before unix epoch');\n    }\n\n    // 31-bit monotonic counter with wraparound\n    const counterVal = counter.value;\n    counter.value = (counterVal + 1) & 0x7fff_ffff;\n\n    // 48-bit unix timestamp (ms)\n    const tsMs = now.toMillis() & 0xffff_ffff_ffffn;\n\n    const bytes = new Uint8Array(16);\n\n    // unix_ts_ms (48 bits)\n    bytes[0] = Number((tsMs >> 40n) & 0xffn);\n    bytes[1] = Number((tsMs >> 32n) & 0xffn);\n    bytes[2] = Number((tsMs >> 24n) & 0xffn);\n    bytes[3] = Number((tsMs >> 16n) & 0xffn);\n    bytes[4] = Number((tsMs >> 8n) & 0xffn);\n    bytes[5] = Number(tsMs & 0xffn);\n\n    // Counter bits (31 bits total)\n    bytes[7] = (counterVal >>> 23) & 0xff;\n    bytes[9] = (counterVal >>> 15) & 0xff;\n    bytes[10] = (counterVal >>> 7) & 0xff;\n    bytes[11] = ((counterVal & 0x7f) << 1) & 0xff;\n\n    // Random bytes\n    bytes[12] |= randomBytes[0] & 0x7f;\n    bytes[13] = randomBytes[1];\n    bytes[14] = randomBytes[2];\n    bytes[15] = randomBytes[3];\n\n    // Version 7\n    bytes[6] = (bytes[6] & 0x0f) | 0x70;\n\n    // Variant RFC4122\n    bytes[8] = (bytes[8] & 0x3f) | 0x80;\n\n    return new Uuid(Uuid.bytesToBigInt(bytes));\n  }\n\n  /**\n   * Parse a UUID from a string representation.\n   *\n   * @param s - UUID string\n   * @returns Parsed UUID\n   * @throws {Error} If the string is not a valid UUID\n   *\n   * @example\n   * ```ts\n   * const s = \"01888d6e-5c00-7000-8000-000000000000\";\n   * const uuid = Uuid.parse(s);\n   *\n   * console.assert(uuid.toString() === s);\n   * ```\n   */\n  static parse(s: string): Uuid {\n    const hex = s.replace(/-/g, '');\n    if (hex.length !== 32) throw new Error('Invalid hex UUID');\n\n    let v = 0n;\n    for (let i = 0; i < 32; i += 2) {\n      v = (v << 8n) | BigInt(parseInt(hex.slice(i, i + 2), 16));\n    }\n    return new Uuid(v);\n  }\n\n  /** Convert to string (hyphenated form). */\n  toString(): string {\n    const bytes = Uuid.bigIntToBytes(this.__uuid__);\n    const hex = [...bytes].map(b => b.toString(16).padStart(2, '0')).join('');\n\n    // Format as 8-4-4-4-12\n    return (\n      hex.slice(0, 8) +\n      '-' +\n      hex.slice(8, 12) +\n      '-' +\n      hex.slice(12, 16) +\n      '-' +\n      hex.slice(16, 20) +\n      '-' +\n      hex.slice(20)\n    );\n  }\n\n  /** Convert to bigint (u128). */\n  asBigInt(): bigint {\n    return this.__uuid__;\n  }\n\n  /** Return a `Uint8Array` of 16 bytes. */\n  toBytes(): Uint8Array {\n    return Uuid.bigIntToBytes(this.__uuid__);\n  }\n\n  private static bytesToBigInt(bytes: Uint8Array): bigint {\n    let result = 0n;\n    for (const b of bytes) result = (result << 8n) | BigInt(b);\n    return result;\n  }\n\n  private static bigIntToBytes(value: bigint): Uint8Array {\n    const bytes = new Uint8Array(16);\n    for (let i = 15; i >= 0; i--) {\n      bytes[i] = Number(value & 0xffn);\n      value >>= 8n;\n    }\n    return bytes;\n  }\n\n  /**\n   * Returns the version of this UUID.\n   *\n   * This represents the algorithm used to generate the value.\n   *\n   * @returns A `UuidVersion`\n   * @throws {Error} If the version field is not recognized\n   */\n  getVersion(): UuidVersion {\n    const version = (this.toBytes()[6] >> 4) & 0x0f;\n\n    switch (version) {\n      case 4:\n        return 'V4';\n      case 7:\n        return 'V7';\n      default:\n        if (this == Uuid.NIL) {\n          return 'Nil';\n        }\n        if (this == Uuid.MAX) {\n          return 'Max';\n        }\n        throw new Error(`Unsupported UUID version: ${version}`);\n    }\n  }\n\n  /**\n   * Extract the monotonic counter from a UUIDv7.\n   *\n   * Intended for testing and diagnostics.\n   * Behavior is undefined if called on a non-V7 UUID.\n   *\n   * @returns 31-bit counter value\n   */\n  getCounter(): number {\n    const bytes = this.toBytes(); // big-endian, 16 bytes\n\n    const high = bytes[7]; // bits 30..23\n    const mid1 = bytes[9]; // bits 22..15\n    const mid2 = bytes[10]; // bits 14..7\n    const low = bytes[11] >>> 1; // bits 6..0\n\n    // reconstruct 31-bit counter\n    return (high << 23) | (mid1 << 15) | (mid2 << 7) | low | 0; // force 32-bit int\n  }\n\n  compareTo(other: Uuid): number {\n    if (this.__uuid__ < other.__uuid__) return -1;\n    if (this.__uuid__ > other.__uuid__) return 1;\n\n    return 0;\n  }\n\n  static getAlgebraicType(): UuidAlgebraicType {\n    return AlgebraicType.Product({\n      elements: [\n        {\n          name: '__uuid__',\n          algebraicType: AlgebraicType.U128,\n        },\n      ],\n    });\n  }\n}\n","export default class BinaryReader {\n  /**\n   * The DataView used to read values from the binary data.\n   *\n   * Note: The DataView's `byteOffset` is relative to the beginning of the\n   * underlying ArrayBuffer, not the start of the provided Uint8Array input.\n   * This `BinaryReader`'s `#offset` field is used to track the current read position\n   * relative to the start of the provided Uint8Array input.\n   */\n  view: DataView;\n\n  /**\n   * Represents the offset (in bytes) relative to the start of the DataView\n   * and provided Uint8Array input.\n   *\n   * Note: This is *not* the absolute byte offset within the underlying ArrayBuffer.\n   */\n  offset: number = 0;\n\n  constructor(input: Uint8Array | DataView) {\n    this.view =\n      input instanceof DataView\n        ? input\n        : new DataView(input.buffer, input.byteOffset, input.byteLength);\n    this.offset = 0;\n  }\n\n  reset(view: DataView) {\n    this.view = view;\n    this.offset = 0;\n  }\n\n  get remaining(): number {\n    return this.view.byteLength - this.offset;\n  }\n\n  /** Ensure we have at least `n` bytes left to read */\n  #ensure(n: number): void {\n    if (this.offset + n > this.view.byteLength) {\n      throw new RangeError(\n        `Tried to read ${n} byte(s) at relative offset ${this.offset}, but only ${this.remaining} byte(s) remain`\n      );\n    }\n  }\n\n  readUInt8Array(): Uint8Array {\n    const length = this.readU32();\n    this.#ensure(length);\n    return this.readBytes(length);\n  }\n\n  readBool(): boolean {\n    const value = this.view.getUint8(this.offset);\n    this.offset += 1;\n    return value !== 0;\n  }\n\n  readByte(): number {\n    const value = this.view.getUint8(this.offset);\n    this.offset += 1;\n    return value;\n  }\n\n  readBytes(length: number): Uint8Array {\n    // Create a Uint8Array view over the DataView's buffer at the current offset\n    // The #view.buffer is the whole ArrayBuffer, so we need to account for the\n    // #view's starting position in that buffer (#view.byteOffset) and the current #offset\n    const array = new Uint8Array(\n      this.view.buffer,\n      this.view.byteOffset + this.offset,\n      length\n    );\n    this.offset += length;\n    return array;\n  }\n\n  readI8(): number {\n    const value = this.view.getInt8(this.offset);\n    this.offset += 1;\n    return value;\n  }\n\n  readU8(): number {\n    return this.readByte();\n  }\n\n  readI16(): number {\n    const value = this.view.getInt16(this.offset, true);\n    this.offset += 2;\n    return value;\n  }\n\n  readU16(): number {\n    const value = this.view.getUint16(this.offset, true);\n    this.offset += 2;\n    return value;\n  }\n\n  readI32(): number {\n    const value = this.view.getInt32(this.offset, true);\n    this.offset += 4;\n    return value;\n  }\n\n  readU32(): number {\n    const value = this.view.getUint32(this.offset, true);\n    this.offset += 4;\n    return value;\n  }\n\n  readI64(): bigint {\n    const value = this.view.getBigInt64(this.offset, true);\n    this.offset += 8;\n    return value;\n  }\n\n  readU64(): bigint {\n    const value = this.view.getBigUint64(this.offset, true);\n    this.offset += 8;\n    return value;\n  }\n\n  readU128(): bigint {\n    const lowerPart = this.view.getBigUint64(this.offset, true);\n    const upperPart = this.view.getBigUint64(this.offset + 8, true);\n    this.offset += 16;\n\n    return (upperPart << BigInt(64)) + lowerPart;\n  }\n\n  readI128(): bigint {\n    const lowerPart = this.view.getBigUint64(this.offset, true);\n    const upperPart = this.view.getBigInt64(this.offset + 8, true);\n    this.offset += 16;\n\n    return (upperPart << BigInt(64)) + lowerPart;\n  }\n\n  readU256(): bigint {\n    const p0 = this.view.getBigUint64(this.offset, true);\n    const p1 = this.view.getBigUint64(this.offset + 8, true);\n    const p2 = this.view.getBigUint64(this.offset + 16, true);\n    const p3 = this.view.getBigUint64(this.offset + 24, true);\n    this.offset += 32;\n\n    return (\n      (p3 << BigInt(3 * 64)) +\n      (p2 << BigInt(2 * 64)) +\n      (p1 << BigInt(1 * 64)) +\n      p0\n    );\n  }\n\n  readI256(): bigint {\n    const p0 = this.view.getBigUint64(this.offset, true);\n    const p1 = this.view.getBigUint64(this.offset + 8, true);\n    const p2 = this.view.getBigUint64(this.offset + 16, true);\n    const p3 = this.view.getBigInt64(this.offset + 24, true);\n    this.offset += 32;\n\n    return (\n      (p3 << BigInt(3 * 64)) +\n      (p2 << BigInt(2 * 64)) +\n      (p1 << BigInt(1 * 64)) +\n      p0\n    );\n  }\n\n  readF32(): number {\n    const value = this.view.getFloat32(this.offset, true);\n    this.offset += 4;\n    return value;\n  }\n\n  readF64(): number {\n    const value = this.view.getFloat64(this.offset, true);\n    this.offset += 8;\n    return value;\n  }\n\n  readString(): string {\n    const uint8Array = this.readUInt8Array();\n    return new TextDecoder('utf-8').decode(uint8Array);\n  }\n}\n","import { fromByteArray } from 'base64-js';\n\nconst ArrayBufferPrototypeTransfer =\n  ArrayBuffer.prototype.transfer ??\n  function (this: ArrayBuffer, newByteLength) {\n    if (newByteLength === undefined) {\n      return this.slice();\n    } else if (newByteLength <= this.byteLength) {\n      return this.slice(0, newByteLength);\n    } else {\n      const copy = new Uint8Array(newByteLength);\n      copy.set(new Uint8Array(this));\n      return copy.buffer;\n    }\n  };\n\nexport class ResizableBuffer {\n  buffer: ArrayBuffer;\n  view: DataView;\n\n  constructor(init: number | ArrayBuffer) {\n    this.buffer = typeof init === 'number' ? new ArrayBuffer(init) : init;\n    this.view = new DataView(this.buffer);\n  }\n\n  get capacity(): number {\n    return this.buffer.byteLength;\n  }\n\n  grow(newSize: number) {\n    if (newSize <= this.buffer.byteLength) return;\n    this.buffer = ArrayBufferPrototypeTransfer.call(this.buffer, newSize);\n    this.view = new DataView(this.buffer);\n  }\n}\n\nexport default class BinaryWriter {\n  buffer: ResizableBuffer;\n  offset: number = 0;\n\n  constructor(init: number | ResizableBuffer) {\n    this.buffer = typeof init === 'number' ? new ResizableBuffer(init) : init;\n  }\n\n  reset(buffer: ResizableBuffer) {\n    this.buffer = buffer;\n    this.offset = 0;\n  }\n\n  expandBuffer(additionalCapacity: number): void {\n    const minCapacity = this.offset + additionalCapacity + 1;\n    if (minCapacity <= this.buffer.capacity) return;\n    let newCapacity = this.buffer.capacity * 2;\n    if (newCapacity < minCapacity) newCapacity = minCapacity;\n    this.buffer.grow(newCapacity);\n  }\n\n  toBase64(): string {\n    return fromByteArray(this.getBuffer());\n  }\n\n  getBuffer(): Uint8Array {\n    return new Uint8Array(this.buffer.buffer, 0, this.offset);\n  }\n\n  get view() {\n    return this.buffer.view;\n  }\n\n  writeUInt8Array(value: Uint8Array): void {\n    const length = value.length;\n\n    this.expandBuffer(4 + length);\n\n    this.writeU32(length);\n    new Uint8Array(this.buffer.buffer, this.offset).set(value);\n    this.offset += length;\n  }\n\n  writeBool(value: boolean): void {\n    this.expandBuffer(1);\n    this.view.setUint8(this.offset, value ? 1 : 0);\n    this.offset += 1;\n  }\n\n  writeByte(value: number): void {\n    this.expandBuffer(1);\n    this.view.setUint8(this.offset, value);\n    this.offset += 1;\n  }\n\n  writeI8(value: number): void {\n    this.expandBuffer(1);\n    this.view.setInt8(this.offset, value);\n    this.offset += 1;\n  }\n\n  writeU8(value: number): void {\n    this.expandBuffer(1);\n    this.view.setUint8(this.offset, value);\n    this.offset += 1;\n  }\n\n  writeI16(value: number): void {\n    this.expandBuffer(2);\n    this.view.setInt16(this.offset, value, true);\n    this.offset += 2;\n  }\n\n  writeU16(value: number): void {\n    this.expandBuffer(2);\n    this.view.setUint16(this.offset, value, true);\n    this.offset += 2;\n  }\n\n  writeI32(value: number): void {\n    this.expandBuffer(4);\n    this.view.setInt32(this.offset, value, true);\n    this.offset += 4;\n  }\n\n  writeU32(value: number): void {\n    this.expandBuffer(4);\n    this.view.setUint32(this.offset, value, true);\n    this.offset += 4;\n  }\n\n  writeI64(value: bigint): void {\n    this.expandBuffer(8);\n    this.view.setBigInt64(this.offset, value, true);\n    this.offset += 8;\n  }\n\n  writeU64(value: bigint): void {\n    this.expandBuffer(8);\n    this.view.setBigUint64(this.offset, value, true);\n    this.offset += 8;\n  }\n\n  writeU128(value: bigint): void {\n    this.expandBuffer(16);\n    const lowerPart = value & BigInt('0xFFFFFFFFFFFFFFFF');\n    const upperPart = value >> BigInt(64);\n    this.view.setBigUint64(this.offset, lowerPart, true);\n    this.view.setBigUint64(this.offset + 8, upperPart, true);\n    this.offset += 16;\n  }\n\n  writeI128(value: bigint): void {\n    this.expandBuffer(16);\n    const lowerPart = value & BigInt('0xFFFFFFFFFFFFFFFF');\n    const upperPart = value >> BigInt(64);\n    this.view.setBigInt64(this.offset, lowerPart, true);\n    this.view.setBigInt64(this.offset + 8, upperPart, true);\n    this.offset += 16;\n  }\n\n  writeU256(value: bigint): void {\n    this.expandBuffer(32);\n    const low_64_mask = BigInt('0xFFFFFFFFFFFFFFFF');\n    const p0 = value & low_64_mask;\n    const p1 = (value >> BigInt(64 * 1)) & low_64_mask;\n    const p2 = (value >> BigInt(64 * 2)) & low_64_mask;\n    const p3 = value >> BigInt(64 * 3);\n    this.view.setBigUint64(this.offset + 8 * 0, p0, true);\n    this.view.setBigUint64(this.offset + 8 * 1, p1, true);\n    this.view.setBigUint64(this.offset + 8 * 2, p2, true);\n    this.view.setBigUint64(this.offset + 8 * 3, p3, true);\n    this.offset += 32;\n  }\n\n  writeI256(value: bigint): void {\n    this.expandBuffer(32);\n    const low_64_mask = BigInt('0xFFFFFFFFFFFFFFFF');\n    const p0 = value & low_64_mask;\n    const p1 = (value >> BigInt(64 * 1)) & low_64_mask;\n    const p2 = (value >> BigInt(64 * 2)) & low_64_mask;\n    const p3 = value >> BigInt(64 * 3);\n    this.view.setBigUint64(this.offset + 8 * 0, p0, true);\n    this.view.setBigUint64(this.offset + 8 * 1, p1, true);\n    this.view.setBigUint64(this.offset + 8 * 2, p2, true);\n    this.view.setBigInt64(this.offset + 8 * 3, p3, true);\n    this.offset += 32;\n  }\n\n  writeF32(value: number): void {\n    this.expandBuffer(4);\n    this.view.setFloat32(this.offset, value, true);\n    this.offset += 4;\n  }\n\n  writeF64(value: number): void {\n    this.expandBuffer(8);\n    this.view.setFloat64(this.offset, value, true);\n    this.offset += 8;\n  }\n\n  writeString(value: string): void {\n    const encoder = new TextEncoder();\n    const encodedString = encoder.encode(value);\n    this.writeUInt8Array(encodedString);\n  }\n}\n","import BinaryReader from './binary_reader';\nimport BinaryWriter from './binary_writer';\nimport type { CamelCase, SnakeCase } from './type_util';\n\n/**\n * Converts a string to PascalCase (UpperCamelCase).\n * @param str The string to convert\n * @returns The converted string\n */\nexport function toPascalCase(s: string): string {\n  const str = s.replace(/([-_][a-z])/gi, $1 => {\n    return $1.toUpperCase().replace('-', '').replace('_', '');\n  });\n\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\n\nexport function deepEqual(obj1: any, obj2: any): boolean {\n  // If both are strictly equal (covers primitives and reference equality), return true\n  if (obj1 === obj2) return true;\n\n  // If either is a primitive type or one is null, return false since we already checked for strict equality\n  if (\n    typeof obj1 !== 'object' ||\n    obj1 === null ||\n    typeof obj2 !== 'object' ||\n    obj2 === null\n  ) {\n    return false;\n  }\n\n  // Get keys of both objects\n  const keys1 = Object.keys(obj1);\n  const keys2 = Object.keys(obj2);\n\n  // If number of keys is different, return false\n  if (keys1.length !== keys2.length) return false;\n\n  // Check all keys and compare values recursively\n  for (const key of keys1) {\n    if (!keys2.includes(key) || !deepEqual(obj1[key], obj2[key])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexport function uint8ArrayToHexString(array: Uint8Array): string {\n  return Array.prototype.map\n    .call(array.reverse(), x => ('00' + x.toString(16)).slice(-2))\n    .join('');\n}\n\nexport function uint8ArrayToU128(array: Uint8Array): bigint {\n  if (array.length != 16) {\n    throw new Error(`Uint8Array is not 16 bytes long: ${array}`);\n  }\n  return new BinaryReader(array).readU128();\n}\n\nexport function uint8ArrayToU256(array: Uint8Array): bigint {\n  if (array.length != 32) {\n    throw new Error(`Uint8Array is not 32 bytes long: [${array}]`);\n  }\n  return new BinaryReader(array).readU256();\n}\n\nexport function hexStringToUint8Array(str: string): Uint8Array {\n  if (str.startsWith('0x')) {\n    str = str.slice(2);\n  }\n  const matches = str.match(/.{1,2}/g) || [];\n  const data = Uint8Array.from(\n    matches.map((byte: string) => parseInt(byte, 16))\n  );\n  return data.reverse();\n}\n\nexport function hexStringToU128(str: string): bigint {\n  return uint8ArrayToU128(hexStringToUint8Array(str));\n}\n\nexport function hexStringToU256(str: string): bigint {\n  return uint8ArrayToU256(hexStringToUint8Array(str));\n}\n\nexport function u128ToUint8Array(data: bigint): Uint8Array {\n  const writer = new BinaryWriter(16);\n  writer.writeU128(data);\n  return writer.getBuffer();\n}\n\nexport function u128ToHexString(data: bigint): string {\n  return uint8ArrayToHexString(u128ToUint8Array(data));\n}\n\nexport function u256ToUint8Array(data: bigint): Uint8Array {\n  const writer = new BinaryWriter(32);\n  writer.writeU256(data);\n  return writer.getBuffer();\n}\n\nexport function u256ToHexString(data: bigint): string {\n  return uint8ArrayToHexString(u256ToUint8Array(data));\n}\n\n/**\n * Type safe conversion from a string like \"some_identifier-name\" to \"someIdentifierName\".\n * @param str The string to convert\n * @returns The converted string\n */\nexport function toCamelCase<T extends string>(str: T): CamelCase<T> {\n  return str\n    .replace(/[-_]+/g, '_') // collapse runs to a single separator (no backtracking issue)\n    .replace(/_([a-zA-Z0-9])/g, (_, c) => c.toUpperCase()) as CamelCase<T>;\n}\n\n/** Type safe conversion from a string like \"some_Identifier-name\" to \"some_identifier_name\".\n * @param str The string to convert\n * @returns The converted string\n */\nexport function toSnakeCase<T extends string>(str: T): SnakeCase<T> {\n  return str\n    .replace(/([A-Z])/g, '_$1') // insert underscores before capitals\n    .replace(/[-\\s]+/g, '_') // replace spaces and dashes with underscores\n    .toLowerCase() as SnakeCase<T>;\n}\n\nimport type { AlgebraicType } from './algebraic_type';\nimport type { Typespace } from './autogen/types';\nimport type { ColumnBuilder, TypeBuilder } from './type_builders';\nimport type { ParamsObj } from './reducers';\n\nexport function bsatnBaseSize(typespace: Typespace, ty: AlgebraicType): number {\n  const assumedArrayLength = 4;\n  while (ty.tag === 'Ref') ty = typespace.types[ty.value];\n  if (ty.tag === 'Product') {\n    let sum = 0;\n    for (const { algebraicType: elem } of ty.value.elements) {\n      sum += bsatnBaseSize(typespace, elem);\n    }\n    return sum;\n  } else if (ty.tag === 'Sum') {\n    let min = Infinity;\n    for (const { algebraicType: vari } of ty.value.variants) {\n      const vSize = bsatnBaseSize(typespace, vari);\n      if (vSize < min) min = vSize;\n    }\n    if (min === Infinity) min = 0;\n    return 4 + min;\n  } else if (ty.tag == 'Array') {\n    return 4 + assumedArrayLength * bsatnBaseSize(typespace, ty.value);\n  }\n  return {\n    String: 4 + assumedArrayLength,\n    Sum: 1,\n    Bool: 1,\n    I8: 1,\n    U8: 1,\n    I16: 2,\n    U16: 2,\n    I32: 4,\n    U32: 4,\n    F32: 4,\n    I64: 8,\n    U64: 8,\n    F64: 8,\n    I128: 16,\n    U128: 16,\n    I256: 32,\n    U256: 32,\n  }[ty.tag];\n}\n\nexport type CoerceTypeBuilder<\n  Col extends TypeBuilder<any, any> | ColumnBuilder<any, any, any>,\n> = Col extends ColumnBuilder<any, any> ? Col['typeBuilder'] : Col;\n\nexport type CoerceParams<Params extends ParamsObj> = {\n  [k in keyof Params & string]: CoerceTypeBuilder<Params[k]>;\n};\n\nexport function coerceParams<Params extends ParamsObj>(\n  params: Params\n): CoerceParams<Params> {\n  return Object.fromEntries(\n    Object.entries(params).map(([n, c]) => [\n      n,\n      'typeBuilder' in c ? c.typeBuilder : c,\n    ])\n  ) as CoerceParams<Params>;\n}\n\nexport const hasOwn: <K extends PropertyKey>(\n  o: object,\n  k: K\n) => o is K extends PropertyKey ? { [k in K]: unknown } : never =\n  Object.hasOwn as any;\n","import { AlgebraicType } from './algebraic_type';\nimport { hexStringToU256, u256ToHexString, u256ToUint8Array } from './util';\n\nexport type IdentityAlgebraicType = {\n  tag: 'Product';\n  value: {\n    elements: [{ name: '__identity__'; algebraicType: { tag: 'U256' } }];\n  };\n};\n\n/**\n * A unique identifier for a user connected to a database.\n */\nexport class Identity {\n  __identity__: bigint;\n\n  /**\n   * Creates a new `Identity`.\n   *\n   * `data` can be a hexadecimal string or a `bigint`.\n   */\n  constructor(data: string | bigint) {\n    // we get a JSON with __identity__ when getting a token with a JSON API\n    // and an bigint when using BSATN\n    this.__identity__ = typeof data === 'string' ? hexStringToU256(data) : data;\n  }\n\n  /**\n   * Get the algebraic type representation of the {@link Identity} type.\n   * @returns The algebraic type representation of the type.\n   */\n  static getAlgebraicType(): IdentityAlgebraicType {\n    return AlgebraicType.Product({\n      elements: [{ name: '__identity__', algebraicType: AlgebraicType.U256 }],\n    });\n  }\n\n  /**\n   * Check if two identities are equal.\n   */\n  isEqual(other: Identity): boolean {\n    return this.toHexString() === other.toHexString();\n  }\n\n  /**\n   * Check if two identities are equal.\n   */\n  equals(other: Identity): boolean {\n    return this.isEqual(other);\n  }\n\n  /**\n   * Print the identity as a hexadecimal string.\n   */\n  toHexString(): string {\n    return u256ToHexString(this.__identity__);\n  }\n\n  /**\n   * Convert the address to a Uint8Array.\n   */\n  toUint8Array(): Uint8Array {\n    return u256ToUint8Array(this.__identity__);\n  }\n\n  /**\n   * Parse an Identity from a hexadecimal string.\n   */\n  static fromString(str: string): Identity {\n    return new Identity(str);\n  }\n\n  /**\n   * Zero identity (0x0000000000000000000000000000000000000000000000000000000000000000)\n   */\n  static zero(): Identity {\n    return new Identity(0n);\n  }\n\n  toString(): string {\n    return this.toHexString();\n  }\n}\n","import { TimeDuration } from './time_duration';\nimport { Timestamp } from './timestamp';\nimport { Uuid } from './uuid';\nimport { ConnectionId } from './connection_id';\nimport BinaryReader from './binary_reader';\nimport BinaryWriter from './binary_writer';\nimport { Identity } from './identity';\nimport * as AlgebraicTypeVariants from './algebraic_type_variants';\nimport { hasOwn } from './util';\n\ntype TypespaceType = {\n  types: AlgebraicTypeType[];\n};\n\nexport type ProductTypeType = {\n  elements: ProductTypeElement[];\n};\n\n/**\n * A factor / element of a product type.\n *\n * An element consist of an optional name and a type.\n *\n * NOTE: Each element has an implicit element tag based on its order.\n * Uniquely identifies an element similarly to protobuf tags.\n */\nexport type ProductTypeElement = {\n  name: string | undefined;\n  algebraicType: AlgebraicTypeType;\n};\n\nexport type SumTypeType = {\n  variants: SumTypeVariant[];\n};\n\n/**\n * A variant of a sum type.\n *\n * NOTE: Each element has an implicit element tag based on its order.\n * Uniquely identifies an element similarly to protobuf tags.\n */\nexport type SumTypeVariant = {\n  name: string | undefined;\n  algebraicType: AlgebraicTypeType;\n};\n\nexport type AlgebraicTypeType =\n  | AlgebraicTypeVariants.Ref\n  | AlgebraicTypeVariants.Sum\n  | AlgebraicTypeVariants.Product\n  | AlgebraicTypeVariants.Array\n  | AlgebraicTypeVariants.String\n  | AlgebraicTypeVariants.Bool\n  | AlgebraicTypeVariants.I8\n  | AlgebraicTypeVariants.U8\n  | AlgebraicTypeVariants.I16\n  | AlgebraicTypeVariants.U16\n  | AlgebraicTypeVariants.I32\n  | AlgebraicTypeVariants.U32\n  | AlgebraicTypeVariants.I64\n  | AlgebraicTypeVariants.U64\n  | AlgebraicTypeVariants.I128\n  | AlgebraicTypeVariants.U128\n  | AlgebraicTypeVariants.I256\n  | AlgebraicTypeVariants.U256\n  | AlgebraicTypeVariants.F32\n  | AlgebraicTypeVariants.F64;\n\nexport type AlgebraicType = AlgebraicTypeType;\n\n/**\n * The variant types of the Algebraic Type tagged union.\n */\nexport { AlgebraicTypeVariants };\n\nexport type Serializer<T> = (writer: BinaryWriter, value: T) => void;\n\nexport type Deserializer<T> = (reader: BinaryReader) => T;\n\n// Caches to prevent `makeSerializer`/`makeDeserializer` from recursing\n// infinitely when called on recursive types.\n//\n// We check for recursion in `{Product,Sum}Type.make{Deser,Ser}ializer` rather\n// than in `AlgebraciType.make{Deser,Ser}ializer` because we need to store the\n// [de]serializer in the cache before recursing into its fields/variants, and\n// we wouldn't be able to do that in the `AlgebraicType` functions.\nconst SERIALIZERS = new Map<ProductType | SumType, Serializer<any>>();\nconst DESERIALIZERS = new Map<ProductType | SumType, Deserializer<any>>();\n\n// A value with helper functions to construct the type.\nexport const AlgebraicType = {\n  Ref: (value: number): AlgebraicTypeVariants.Ref => ({ tag: 'Ref', value }),\n  Sum: <T extends SumTypeType>(value: T): { tag: 'Sum'; value: T } => ({\n    tag: 'Sum',\n    value,\n  }),\n  Product: <T extends ProductTypeType>(\n    value: T\n  ): { tag: 'Product'; value: T } => ({\n    tag: 'Product',\n    value,\n  }),\n  Array: <T extends AlgebraicTypeType>(\n    value: T\n  ): { tag: 'Array'; value: T } => ({\n    tag: 'Array',\n    value,\n  }),\n  String: { tag: 'String' } as const,\n  Bool: { tag: 'Bool' } as const,\n  I8: { tag: 'I8' } as const,\n  U8: { tag: 'U8' } as const,\n  I16: { tag: 'I16' } as const,\n  U16: { tag: 'U16' } as const,\n  I32: { tag: 'I32' } as const,\n  U32: { tag: 'U32' } as const,\n  I64: { tag: 'I64' } as const,\n  U64: { tag: 'U64' } as const,\n  I128: { tag: 'I128' } as const,\n  U128: { tag: 'U128' } as const,\n  I256: { tag: 'I256' } as const,\n  U256: { tag: 'U256' } as const,\n  F32: { tag: 'F32' } as const,\n  F64: { tag: 'F64' } as const,\n  makeSerializer(\n    ty: AlgebraicTypeType,\n    typespace?: TypespaceType\n  ): Serializer<any> {\n    if (ty.tag === 'Ref') {\n      if (!typespace)\n        throw new Error('cannot serialize refs without a typespace');\n      while (ty.tag === 'Ref') ty = typespace.types[ty.value];\n    }\n    switch (ty.tag) {\n      case 'Product':\n        return ProductType.makeSerializer(ty.value, typespace);\n      case 'Sum':\n        return SumType.makeSerializer(ty.value, typespace);\n      case 'Array':\n        if (ty.value.tag === 'U8') {\n          return serializeUint8Array;\n        } else {\n          const serialize = AlgebraicType.makeSerializer(ty.value, typespace);\n          return (writer, value) => {\n            writer.writeU32(value.length);\n            for (const elem of value) {\n              serialize(writer, elem);\n            }\n          };\n        }\n      default:\n        return primitiveSerializers[ty.tag];\n    }\n  },\n  /** @deprecated Use `makeSerializer` instead. */\n  serializeValue(\n    writer: BinaryWriter,\n    ty: AlgebraicTypeType,\n    value: any,\n    typespace?: TypespaceType\n  ) {\n    AlgebraicType.makeSerializer(ty, typespace)(writer, value);\n  },\n  makeDeserializer(\n    ty: AlgebraicTypeType,\n    typespace?: TypespaceType\n  ): Deserializer<any> {\n    if (ty.tag === 'Ref') {\n      if (!typespace)\n        throw new Error('cannot deserialize refs without a typespace');\n      while (ty.tag === 'Ref') ty = typespace.types[ty.value];\n    }\n    switch (ty.tag) {\n      case 'Product':\n        return ProductType.makeDeserializer(ty.value, typespace);\n      case 'Sum':\n        return SumType.makeDeserializer(ty.value, typespace);\n      case 'Array':\n        if (ty.value.tag === 'U8') {\n          return deserializeUint8Array;\n        } else {\n          const deserialize = AlgebraicType.makeDeserializer(\n            ty.value,\n            typespace\n          );\n          return reader => {\n            const length = reader.readU32();\n            const result: any[] = Array(length);\n            for (let i = 0; i < length; i++) {\n              result[i] = deserialize(reader);\n            }\n            return result;\n          };\n        }\n      default:\n        return primitiveDeserializers[ty.tag];\n    }\n  },\n  /** @deprecated Use `makeDeserializer` instead. */\n  deserializeValue(\n    reader: BinaryReader,\n    ty: AlgebraicTypeType,\n    typespace?: TypespaceType\n  ): any {\n    return AlgebraicType.makeDeserializer(ty, typespace)(reader);\n  },\n  /**\n   * Convert a value of the algebraic type into something that can be used as a key in a map.\n   * There are no guarantees about being able to order it.\n   * This is only guaranteed to be comparable to other values of the same type.\n   * @param value A value of the algebraic type\n   * @returns Something that can be used as a key in a map.\n   */\n  intoMapKey: function (\n    ty: AlgebraicTypeType,\n    value: any\n  ): ComparablePrimitive {\n    switch (ty.tag) {\n      case 'U8':\n      case 'U16':\n      case 'U32':\n      case 'U64':\n      case 'U128':\n      case 'U256':\n      case 'I8':\n      case 'I16':\n      case 'I32':\n      case 'I64':\n      case 'I128':\n      case 'I256':\n      case 'F32':\n      case 'F64':\n      case 'String':\n      case 'Bool':\n        return value;\n      case 'Product':\n        return ProductType.intoMapKey(ty.value, value);\n      default: {\n        // The fallback is to serialize and base64 encode the bytes.\n        const writer = new BinaryWriter(10);\n        AlgebraicType.serializeValue(writer, ty, value);\n        return writer.toBase64();\n      }\n    }\n  },\n};\n\nfunction bindCall<F extends (this: any, ...args: any[]) => any>(\n  f: F\n): (recv: ThisParameterType<F>, ...args: Parameters<F>) => ReturnType<F> {\n  return Function.prototype.call.bind(f);\n}\n\ntype Primitives = Exclude<\n  AlgebraicType['tag'],\n  'Ref' | 'Sum' | 'Product' | 'Array'\n>;\n\nconst primitiveSerializers: Record<Primitives, Serializer<any>> = {\n  Bool: bindCall(BinaryWriter.prototype.writeBool),\n  I8: bindCall(BinaryWriter.prototype.writeI8),\n  U8: bindCall(BinaryWriter.prototype.writeU8),\n  I16: bindCall(BinaryWriter.prototype.writeI16),\n  U16: bindCall(BinaryWriter.prototype.writeU16),\n  I32: bindCall(BinaryWriter.prototype.writeI32),\n  U32: bindCall(BinaryWriter.prototype.writeU32),\n  I64: bindCall(BinaryWriter.prototype.writeI64),\n  U64: bindCall(BinaryWriter.prototype.writeU64),\n  I128: bindCall(BinaryWriter.prototype.writeI128),\n  U128: bindCall(BinaryWriter.prototype.writeU128),\n  I256: bindCall(BinaryWriter.prototype.writeI256),\n  U256: bindCall(BinaryWriter.prototype.writeU256),\n  F32: bindCall(BinaryWriter.prototype.writeF32),\n  F64: bindCall(BinaryWriter.prototype.writeF64),\n  String: bindCall(BinaryWriter.prototype.writeString),\n};\nObject.freeze(primitiveSerializers);\n\nconst serializeUint8Array = bindCall(BinaryWriter.prototype.writeUInt8Array);\n\nconst primitiveDeserializers: Record<Primitives, Deserializer<any>> = {\n  Bool: bindCall(BinaryReader.prototype.readBool),\n  I8: bindCall(BinaryReader.prototype.readI8),\n  U8: bindCall(BinaryReader.prototype.readU8),\n  I16: bindCall(BinaryReader.prototype.readI16),\n  U16: bindCall(BinaryReader.prototype.readU16),\n  I32: bindCall(BinaryReader.prototype.readI32),\n  U32: bindCall(BinaryReader.prototype.readU32),\n  I64: bindCall(BinaryReader.prototype.readI64),\n  U64: bindCall(BinaryReader.prototype.readU64),\n  I128: bindCall(BinaryReader.prototype.readI128),\n  U128: bindCall(BinaryReader.prototype.readU128),\n  I256: bindCall(BinaryReader.prototype.readI256),\n  U256: bindCall(BinaryReader.prototype.readU256),\n  F32: bindCall(BinaryReader.prototype.readF32),\n  F64: bindCall(BinaryReader.prototype.readF64),\n  String: bindCall(BinaryReader.prototype.readString),\n};\nObject.freeze(primitiveDeserializers);\n\nconst deserializeUint8Array = bindCall(BinaryReader.prototype.readUInt8Array);\n\ntype FixedSizePrimitives = Exclude<Primitives, 'String'>;\n\nconst primitiveSizes: Record<FixedSizePrimitives, number> = {\n  Bool: 1,\n  I8: 1,\n  U8: 1,\n  I16: 2,\n  U16: 2,\n  I32: 4,\n  U32: 4,\n  I64: 8,\n  U64: 8,\n  I128: 16,\n  U128: 16,\n  I256: 32,\n  U256: 32,\n  F32: 4,\n  F64: 8,\n};\n\nconst fixedSizePrimitives = new Set(Object.keys(primitiveSizes));\n\ntype FixedSizeProductType = {\n  elements: { name: string; algebraicType: { tag: FixedSizePrimitives } }[];\n};\n\nconst isFixedSizeProduct = (ty: ProductType): ty is FixedSizeProductType =>\n  ty.elements.every(({ algebraicType }) =>\n    fixedSizePrimitives.has(algebraicType.tag)\n  );\n\nconst productSize = (ty: FixedSizeProductType): number =>\n  ty.elements.reduce(\n    (acc, { algebraicType }) => acc + primitiveSizes[algebraicType.tag],\n    0\n  );\n\ntype JSPrimitives = Exclude<\n  FixedSizePrimitives,\n  'I128' | 'U128' | 'I256' | 'U256'\n>;\n\nconst primitiveJSName: Record<JSPrimitives, string> = {\n  Bool: 'Uint8',\n  I8: 'Int8',\n  U8: 'Uint8',\n  I16: 'Int16',\n  U16: 'Uint16',\n  I32: 'Int32',\n  U32: 'Uint32',\n  I64: 'BigInt64',\n  U64: 'BigUint64',\n  F32: 'Float32',\n  F64: 'Float64',\n};\n\ntype SpecialProducts = {\n  __time_duration_micros__: TimeDuration;\n  __timestamp_micros_since_unix_epoch__: Timestamp;\n  __identity__: Identity;\n  __connection_id__: ConnectionId;\n  __uuid__: Uuid;\n};\n\nconst specialProductDeserializers: {\n  [k in keyof SpecialProducts]: Deserializer<SpecialProducts[k]>;\n} = {\n  __time_duration_micros__: reader => new TimeDuration(reader.readI64()),\n  __timestamp_micros_since_unix_epoch__: reader =>\n    new Timestamp(reader.readI64()),\n  __identity__: reader => new Identity(reader.readU256()),\n  __connection_id__: reader => new ConnectionId(reader.readU128()),\n  __uuid__: reader => new Uuid(reader.readU128()),\n};\nObject.freeze(specialProductDeserializers);\n\nconst unitDeserializer: Deserializer<{}> = () => ({});\n\nconst getElementInitializer = (element: ProductTypeElement) => {\n  let init: string;\n  switch (element.algebraicType.tag) {\n    case 'String':\n      init = \"''\";\n      break;\n    case 'Bool':\n      init = 'false';\n      break;\n    case 'I8':\n    case 'U8':\n    case 'I16':\n    case 'U16':\n    case 'I32':\n    case 'U32':\n      init = '0';\n      break;\n    case 'I64':\n    case 'U64':\n    case 'I128':\n    case 'U128':\n    case 'I256':\n    case 'U256':\n      init = '0n';\n      break;\n    case 'F32':\n    case 'F64':\n      init = '0.0';\n      break;\n    default:\n      init = 'undefined';\n  }\n  return `${element.name!}: ${init}`;\n};\n\n/**\n * A structural product type  of the factors given by `elements`.\n *\n * This is also known as `struct` and `tuple` in many languages,\n * but note that unlike most languages, products in SATs are *[structural]* and not nominal.\n * When checking whether two nominal types are the same,\n * their names and/or declaration sites (e.g., module / namespace) are considered.\n * Meanwhile, a structural type system would only check the structure of the type itself,\n * e.g., the names of its fields and their types in the case of a record.\n * The name \"product\" comes from category theory.\n *\n * See also: https://ncatlab.org/nlab/show/product+type.\n *\n * These structures are known as product types because the number of possible values in product\n * ```ignore\n * { N_0: T_0, N_1: T_1, ..., N_n: T_n }\n * ```\n * is:\n * ```ignore\n *  (i  0..n). values(T_i)\n * ```\n * so for example, `values({ A: U64, B: Bool }) = values(U64) * values(Bool)`.\n *\n * [structural]: https://en.wikipedia.org/wiki/Structural_type_system\n */\nexport type ProductType = ProductTypeType;\n\nexport const ProductType = {\n  makeSerializer(\n    ty: ProductTypeType,\n    typespace?: TypespaceType\n  ): Serializer<any> {\n    let serializer = SERIALIZERS.get(ty);\n    if (serializer != null) return serializer;\n\n    if (isFixedSizeProduct(ty)) {\n      const size = productSize(ty);\n      const body = `\\\n\"use strict\";\nwriter.expandBuffer(${size});\nconst view = writer.view;\n${ty.elements\n  .map(({ name, algebraicType: { tag } }) =>\n    tag in primitiveJSName\n      ? `\\\nview.set${primitiveJSName[tag as JSPrimitives]}(writer.offset, value.${name!}, ${primitiveSizes[tag] > 1 ? 'true' : ''});\nwriter.offset += ${primitiveSizes[tag]};`\n      : `writer.write${tag}(value.${name});`\n  )\n  .join('\\n')}`;\n      serializer = Function('writer', 'value', body) as Serializer<any>;\n      SERIALIZERS.set(ty, serializer);\n      return serializer;\n    }\n\n    // Because V8 forces us to generate our code as a string, rather than a proper syntax tree,\n    // we can't have our `body` close over values.\n    // Instead, we construct an object with the values we'd otherwise \"close over\" in `serializers`,\n    // and use `Function.prototype.bind` to pass it as the `this` argument.\n    //\n    // We populate `serializers` after constructing this type's `serializer`\n    // so that it can close over itself, in the case that `ty` is recursive.\n    const serializers: Record<string, Serializer<any>> = {};\n    const body =\n      '\"use strict\";\\n' +\n      ty.elements\n        .map(\n          element => `this.${element.name!}(writer, value.${element.name!});`\n        )\n        .join('\\n');\n    serializer = Function('writer', 'value', body).bind(\n      serializers\n    ) as Serializer<any>;\n    // In case `ty` is recursive, we cache the function *before* before computing\n    // `serializers`, so that a recursive `makeSerializer` with the same `ty` has\n    // an exit condition.\n    SERIALIZERS.set(ty, serializer);\n    for (const { name, algebraicType } of ty.elements) {\n      serializers[name!] = AlgebraicType.makeSerializer(\n        algebraicType,\n        typespace\n      );\n    }\n    Object.freeze(serializers);\n    return serializer;\n  },\n  /** @deprecated Use `makeSerializer` instead. */\n  serializeValue(\n    writer: BinaryWriter,\n    ty: ProductTypeType,\n    value: any,\n    typespace?: TypespaceType\n  ): void {\n    ProductType.makeSerializer(ty, typespace)(writer, value);\n  },\n  makeDeserializer(\n    ty: ProductTypeType,\n    typespace?: TypespaceType\n  ): Deserializer<any> {\n    switch (ty.elements.length) {\n      case 0:\n        return unitDeserializer;\n      case 1: {\n        const fieldName = ty.elements[0].name!;\n        if (hasOwn(specialProductDeserializers, fieldName))\n          return specialProductDeserializers[\n            fieldName as keyof SpecialProducts\n          ];\n      }\n    }\n\n    let deserializer = DESERIALIZERS.get(ty);\n    if (deserializer != null) return deserializer;\n\n    if (isFixedSizeProduct(ty)) {\n      const body = `\\\n\"use strict\";\nconst result = { ${ty.elements.map(getElementInitializer).join(', ')} };\nconst view = reader.view;\n${ty.elements\n  .map(({ name, algebraicType: { tag } }) =>\n    tag in primitiveJSName\n      ? `\\\nresult.${name} = view.get${primitiveJSName[tag as JSPrimitives]}(reader.offset, ${primitiveSizes[tag] > 1 ? 'true' : ''});\nreader.offset += ${primitiveSizes[tag]};`\n      : `result.${name} = reader.read${tag}();`\n  )\n  .join('\\n')}\nreturn result;`;\n      deserializer = Function('reader', body) as Deserializer<any>;\n      DESERIALIZERS.set(ty, deserializer);\n      return deserializer;\n    }\n\n    // Because V8 forces us to generate our code as a string, rather than a proper syntax tree,\n    // we can't have our `body` close over values.\n    // Instead, we construct an object with the values we'd otherwise \"close over\" in `deserializers`,\n    // and use `Function.prototype.bind` to pass it as the `this` argument.\n    //\n    // We populate `deserializers` after constructing this type's `deserializer`\n    // so that it can close over itself, in the case that `ty` is recursive.\n    const deserializers: Record<string, Deserializer<any>> = {};\n    deserializer = Function(\n      'reader',\n      `\\\n\"use strict\";\nconst result = { ${ty.elements.map(getElementInitializer).join(', ')} };\n${ty.elements.map(({ name }) => `result.${name!} = this.${name!}(reader);`).join('\\n')}\nreturn result;`\n    ).bind(deserializers) as Deserializer<any>;\n    // In case `ty` is recursive, we cache the function *before* before computing\n    // `deserializers`, so that a recursive `makeDeserializer` with the same `ty` has\n    // an exit condition.\n    DESERIALIZERS.set(ty, deserializer);\n    for (const { name, algebraicType } of ty.elements) {\n      deserializers[name!] = AlgebraicType.makeDeserializer(\n        algebraicType,\n        typespace\n      );\n    }\n    Object.freeze(deserializers);\n    return deserializer;\n  },\n  /** @deprecated Use `makeDeserializer` instead. */\n  deserializeValue(\n    reader: BinaryReader,\n    ty: ProductTypeType,\n    typespace?: TypespaceType\n  ): any {\n    return ProductType.makeDeserializer(ty, typespace)(reader);\n  },\n  intoMapKey(ty: ProductTypeType, value: any): ComparablePrimitive {\n    if (ty.elements.length === 1) {\n      const fieldName = ty.elements[0].name!;\n      if (hasOwn(specialProductDeserializers, fieldName)) {\n        return value[fieldName];\n      }\n    }\n    // The fallback is to serialize and base64 encode the bytes.\n    const writer = new BinaryWriter(10);\n    AlgebraicType.serializeValue(writer, AlgebraicType.Product(ty), value);\n    return writer.toBase64();\n  },\n};\n\nexport type SumType = SumTypeType;\n\n/**\n * Unlike most languages, sums in SATS are *[structural]* and not nominal.\n * When checking whether two nominal types are the same,\n * their names and/or declaration sites (e.g., module / namespace) are considered.\n * Meanwhile, a structural type system would only check the structure of the type itself,\n * e.g., the names of its variants and their inner data types in the case of a sum.\n *\n * This is also known as a discriminated union (implementation) or disjoint union.\n * Another name is [coproduct (category theory)](https://ncatlab.org/nlab/show/coproduct).\n *\n * These structures are known as sum types because the number of possible values a sum\n * ```ignore\n * { N_0(T_0), N_1(T_1), ..., N_n(T_n) }\n * ```\n * is:\n * ```ignore\n *  (i  0..n). values(T_i)\n * ```\n * so for example, `values({ A(U64), B(Bool) }) = values(U64) + values(Bool)`.\n *\n * See also: https://ncatlab.org/nlab/show/sum+type.\n *\n * [structural]: https://en.wikipedia.org/wiki/Structural_type_system\n */\nexport const SumType = {\n  makeSerializer(ty: SumTypeType, typespace?: TypespaceType): Serializer<any> {\n    if (\n      ty.variants.length == 2 &&\n      ty.variants[0].name === 'some' &&\n      ty.variants[1].name === 'none'\n    ) {\n      const serialize = AlgebraicType.makeSerializer(\n        ty.variants[0].algebraicType,\n        typespace\n      );\n      return (writer, value) => {\n        if (value !== null && value !== undefined) {\n          writer.writeByte(0);\n          serialize(writer, value);\n        } else {\n          writer.writeByte(1);\n        }\n      };\n    } else if (\n      ty.variants.length == 2 &&\n      ty.variants[0].name === 'ok' &&\n      ty.variants[1].name === 'err'\n    ) {\n      const serializeOk = AlgebraicType.makeSerializer(\n        ty.variants[0].algebraicType,\n        typespace\n      );\n      const serializeErr = AlgebraicType.makeSerializer(\n        ty.variants[0].algebraicType,\n        typespace\n      );\n\n      return (writer, value) => {\n        if ('ok' in value) {\n          writer.writeU8(0);\n          serializeOk(writer, value.ok);\n        } else if ('err' in value) {\n          writer.writeU8(1);\n          serializeErr(writer, value.err);\n        } else {\n          throw new TypeError(\n            'could not serialize result: object had neither a `ok` nor an `err` field'\n          );\n        }\n      };\n    } else {\n      let serializer = SERIALIZERS.get(ty);\n      if (serializer != null) return serializer;\n\n      const serializers: Record<string, Serializer<any>> = {};\n\n      const body = `\\\nswitch (value.tag) {\n${ty.variants\n  .map(\n    ({ name }, i) => `\\\n  case ${JSON.stringify(name!)}:\n    writer.writeByte(${i});\n    return this.${name!}(writer, value.value);`\n  )\n  .join('\\n')}\n  default:\n    throw new TypeError(\n      \\`Could not serialize sum type; unknown tag \\${value.tag}\\`\n    )\n}\n`;\n\n      serializer = Function('writer', 'value', body).bind(\n        serializers\n      ) as Serializer<any>;\n\n      // In case `ty` is recursive, we cache the function *before* before computing\n      // `variants`, so that a recursive `makeSerializer` with the same `ty` has\n      // an exit condition.\n      SERIALIZERS.set(ty, serializer);\n\n      for (const { name, algebraicType } of ty.variants) {\n        serializers[name!] = AlgebraicType.makeSerializer(\n          algebraicType,\n          typespace\n        );\n      }\n      Object.freeze(serializers);\n      return serializer;\n    }\n  },\n  /** @deprecated Use `makeSerializer` instead. */\n  serializeValue(\n    writer: BinaryWriter,\n    ty: SumTypeType,\n    value: any,\n    typespace?: TypespaceType\n  ): void {\n    SumType.makeSerializer(ty, typespace)(writer, value);\n  },\n  makeDeserializer(\n    ty: SumTypeType,\n    typespace?: TypespaceType\n  ): Deserializer<any> {\n    // In TypeScript we handle Option values as a special case\n    // we don't represent the some and none variants, but instead\n    // we represent the value directly.\n    //\n    // For these special cases, we don't do dynamic codegen, since that has the\n    // most benefit in cases where the object has a different shape. Since\n    // option/result always have the same number of variants, there's not as\n    // much benefit for the amount of work.\n    if (\n      ty.variants.length == 2 &&\n      ty.variants[0].name === 'some' &&\n      ty.variants[1].name === 'none'\n    ) {\n      const deserialize = AlgebraicType.makeDeserializer(\n        ty.variants[0].algebraicType,\n        typespace\n      );\n      return reader => {\n        const tag = reader.readU8();\n        if (tag === 0) {\n          return deserialize(reader);\n        } else if (tag === 1) {\n          return undefined;\n        } else {\n          throw `Can't deserialize an option type, couldn't find ${tag} tag`;\n        }\n      };\n    } else if (\n      ty.variants.length == 2 &&\n      ty.variants[0].name === 'ok' &&\n      ty.variants[1].name === 'err'\n    ) {\n      const deserializeOk = AlgebraicType.makeDeserializer(\n        ty.variants[0].algebraicType,\n        typespace\n      );\n      const deserializeErr = AlgebraicType.makeDeserializer(\n        ty.variants[1].algebraicType,\n        typespace\n      );\n      return reader => {\n        const tag = reader.readByte();\n        if (tag === 0) {\n          return { ok: deserializeOk(reader) };\n        } else if (tag === 1) {\n          return { err: deserializeErr(reader) };\n        } else {\n          throw `Can't deserialize a result type, couldn't find ${tag} tag`;\n        }\n      };\n    } else {\n      let deserializer = DESERIALIZERS.get(ty);\n      if (deserializer != null) return deserializer;\n      const deserializers: Record<string, Deserializer<any>> = {};\n      deserializer = Function(\n        'reader',\n        `switch (reader.readU8()) {\\n${ty.variants\n          .map(\n            ({ name }, i) =>\n              `case ${i}: return { tag: ${JSON.stringify(name!)}, value: this.${name!}(reader) };`\n          )\n          .join('\\n')} }`\n      ).bind(deserializers) as Deserializer<any>;\n      // In case `ty` is recursive, we cache the function *before* before computing\n      // `deserializers`, so that a recursive `makeDeserializer` with the same `ty` has\n      // an exit condition.\n      DESERIALIZERS.set(ty, deserializer);\n      for (const { name, algebraicType } of ty.variants) {\n        deserializers[name!] = AlgebraicType.makeDeserializer(\n          algebraicType,\n          typespace\n        );\n      }\n      Object.freeze(deserializers);\n      return deserializer;\n    }\n  },\n  /** @deprecated Use `makeDeserializer` instead. */\n  deserializeValue(\n    reader: BinaryReader,\n    ty: SumTypeType,\n    typespace?: TypespaceType\n  ): any {\n    return SumType.makeDeserializer(ty, typespace)(reader);\n  },\n};\n\nexport type ComparablePrimitive = number | string | boolean | bigint;\n","import { AlgebraicType } from './algebraic_type';\nimport { hexStringToU128, u128ToHexString, u128ToUint8Array } from './util';\n\nexport type ConnectionIdAlgebraicType = {\n  tag: 'Product';\n  value: {\n    elements: [{ name: '__connection_id__'; algebraicType: { tag: 'U128' } }];\n  };\n};\n\n/**\n * A unique identifier for a client connected to a database.\n */\nexport class ConnectionId {\n  __connection_id__: bigint;\n\n  /**\n   * Creates a new `ConnectionId`.\n   */\n  constructor(data: bigint) {\n    this.__connection_id__ = data;\n  }\n\n  /**\n   * Get the algebraic type representation of the {@link ConnectionId} type.\n   * @returns The algebraic type representation of the type.\n   */\n  static getAlgebraicType(): ConnectionIdAlgebraicType {\n    return AlgebraicType.Product({\n      elements: [\n        { name: '__connection_id__', algebraicType: AlgebraicType.U128 },\n      ],\n    });\n  }\n\n  isZero(): boolean {\n    return this.__connection_id__ === BigInt(0);\n  }\n\n  static nullIfZero(addr: ConnectionId): ConnectionId | null {\n    if (addr.isZero()) {\n      return null;\n    } else {\n      return addr;\n    }\n  }\n\n  static random(): ConnectionId {\n    function randomU8(): number {\n      return Math.floor(Math.random() * 0xff);\n    }\n    let result = BigInt(0);\n    for (let i = 0; i < 16; i++) {\n      result = (result << BigInt(8)) | BigInt(randomU8());\n    }\n    return new ConnectionId(result);\n  }\n\n  /**\n   * Compare two connection IDs for equality.\n   */\n  isEqual(other: ConnectionId): boolean {\n    return this.__connection_id__ == other.__connection_id__;\n  }\n\n  /**\n   * Check if two connection IDs are equal.\n   */\n  equals(other: ConnectionId): boolean {\n    return this.isEqual(other);\n  }\n\n  /**\n   * Print the connection ID as a hexadecimal string.\n   */\n  toHexString(): string {\n    return u128ToHexString(this.__connection_id__);\n  }\n\n  /**\n   * Convert the connection ID to a Uint8Array.\n   */\n  toUint8Array(): Uint8Array {\n    return u128ToUint8Array(this.__connection_id__);\n  }\n\n  /**\n   * Parse a connection ID from a hexadecimal string.\n   */\n  static fromString(str: string): ConnectionId {\n    return new ConnectionId(hexStringToU128(str));\n  }\n\n  static fromStringOrNull(str: string): ConnectionId | null {\n    const addr = ConnectionId.fromString(str);\n    if (addr.isZero()) {\n      return null;\n    } else {\n      return addr;\n    }\n  }\n}\n","import { ConnectionId } from './connection_id';\nimport { Identity } from './identity';\nimport type { ColumnIndex, IndexColumns, IndexOpts } from './indexes';\nimport type { UntypedSchemaDef } from './schema';\nimport type { UntypedTableSchema } from './table_schema';\nimport { Timestamp } from './timestamp';\nimport type {\n  ColumnBuilder,\n  ColumnMetadata,\n  RowBuilder,\n  TypeBuilder,\n} from './type_builders';\nimport type { Values } from './type_util';\n\n/**\n * Helper to get the set of table names.\n */\nexport type TableNames<SchemaDef extends UntypedSchemaDef> = Values<\n  SchemaDef['tables']\n>['accessorName'] &\n  string;\n\n/** helper: pick the table def object from the schema by its name */\nexport type TableDefByName<\n  SchemaDef extends UntypedSchemaDef,\n  Name extends TableNames<SchemaDef>,\n> = Extract<Values<SchemaDef['tables']>, { accessorName: Name }>;\n\n// internal only  NOT exported.\n// This is how we make sure queries are only created with our helpers.\nconst QueryBrand = Symbol('QueryBrand');\n\nexport interface TableTypedQuery<TableDef extends TypedTableDef> {\n  readonly [QueryBrand]: true;\n  readonly __table?: TableDef;\n}\n\nexport interface RowTypedQuery<Row, ST> {\n  readonly [QueryBrand]: true;\n  // Phantom type to track the row type.\n  readonly __row?: Row;\n  readonly __algebraicType?: ST;\n}\n\nexport type Query<TableDef extends TypedTableDef> = RowTypedQuery<\n  RowType<TableDef>,\n  TableDef['rowType']\n>;\n\nexport const isRowTypedQuery = (val: unknown): val is RowTypedQuery<any, any> =>\n  !!val && typeof val === 'object' && QueryBrand in (val as object);\n\nexport const isTypedQuery = (val: unknown): val is TableTypedQuery<any> =>\n  !!val && typeof val === 'object' && QueryBrand in (val as object);\n\nexport function toSql(q: Query<any>): string {\n  return (q as unknown as { toSql(): string }).toSql();\n}\n\n// A query builder with a single table.\ntype From<TableDef extends TypedTableDef> = RowTypedQuery<\n  RowType<TableDef>,\n  TableDef['rowType']\n> &\n  Readonly<{\n    toSql(): string;\n    where(\n      predicate: (row: RowExpr<TableDef>) => BooleanExpr<TableDef>\n    ): From<TableDef>;\n    rightSemijoin<RightTable extends TypedTableDef>(\n      other: TableRef<RightTable>,\n      on: (\n        left: IndexedRowExpr<TableDef>,\n        right: IndexedRowExpr<RightTable>\n      ) => BooleanExpr<TableDef | RightTable>\n    ): SemijoinBuilder<RightTable>;\n    leftSemijoin<RightTable extends TypedTableDef>(\n      other: TableRef<RightTable>,\n      on: (\n        left: IndexedRowExpr<TableDef>,\n        right: IndexedRowExpr<RightTable>\n      ) => BooleanExpr<TableDef | RightTable>\n    ): SemijoinBuilder<TableDef>;\n    /** @deprecated No longer needed  builder is already a valid query. */\n    build(): Query<TableDef>;\n  }>;\n\n// A query builder with a semijoin.\ntype SemijoinBuilder<TableDef extends TypedTableDef> = RowTypedQuery<\n  RowType<TableDef>,\n  TableDef['rowType']\n> &\n  Readonly<{\n    toSql(): string;\n    where(\n      predicate: (row: RowExpr<TableDef>) => BooleanExpr<TableDef>\n    ): SemijoinBuilder<TableDef>;\n    /** @deprecated No longer needed  builder is already a valid query. */\n    build(): Query<TableDef>;\n  }>;\n\nclass SemijoinImpl<TableDef extends TypedTableDef>\n  implements SemijoinBuilder<TableDef>, TableTypedQuery<TableDef>\n{\n  readonly [QueryBrand] = true;\n  readonly type = 'semijoin' as const;\n  constructor(\n    readonly sourceQuery: FromBuilder<TableDef>,\n    readonly filterQuery: FromBuilder<any>,\n    readonly joinCondition: BooleanExpr<any>\n  ) {\n    if (sourceQuery.table.sourceName === filterQuery.table.sourceName) {\n      // TODO: Handle aliasing properly instead of just forbidding it.\n      throw new Error('Cannot semijoin a table to itself');\n    }\n  }\n\n  build(): Query<TableDef> {\n    return this as Query<TableDef>;\n  }\n\n  where(\n    predicate: (row: RowExpr<TableDef>) => BooleanExpr<TableDef>\n  ): SemijoinImpl<TableDef> {\n    const nextSourceQuery = this.sourceQuery.where(predicate);\n    return new SemijoinImpl<TableDef>(\n      nextSourceQuery,\n      this.filterQuery,\n      this.joinCondition\n    );\n  }\n\n  toSql(): string {\n    const left = this.filterQuery;\n    const right = this.sourceQuery;\n    const leftTable = quoteIdentifier(left.table.sourceName);\n    const rightTable = quoteIdentifier(right.table.sourceName);\n    let sql = `SELECT ${rightTable}.* FROM ${leftTable} JOIN ${rightTable} ON ${booleanExprToSql(this.joinCondition)}`;\n\n    const clauses: string[] = [];\n    if (left.whereClause) {\n      clauses.push(booleanExprToSql(left.whereClause));\n    }\n    if (right.whereClause) {\n      clauses.push(booleanExprToSql(right.whereClause));\n    }\n\n    if (clauses.length > 0) {\n      const whereSql =\n        clauses.length === 1\n          ? clauses[0]\n          : clauses.map(wrapInParens).join(' AND ');\n      sql += ` WHERE ${whereSql}`;\n    }\n\n    return sql;\n  }\n}\n\nclass FromBuilder<TableDef extends TypedTableDef>\n  implements From<TableDef>, TableTypedQuery<TableDef>\n{\n  readonly [QueryBrand] = true;\n  constructor(\n    readonly table: TableRef<TableDef>,\n    readonly whereClause?: BooleanExpr<TableDef>\n  ) {}\n\n  where(\n    predicate: (row: RowExpr<TableDef>) => BooleanExpr<TableDef>\n  ): FromBuilder<TableDef> {\n    const newCondition = predicate(this.table.cols);\n    const nextWhere = this.whereClause\n      ? this.whereClause.and(newCondition)\n      : newCondition;\n    return new FromBuilder<TableDef>(this.table, nextWhere);\n  }\n\n  rightSemijoin<OtherTable extends TypedTableDef>(\n    right: TableRef<OtherTable>,\n    on: (\n      left: IndexedRowExpr<TableDef>,\n      right: IndexedRowExpr<OtherTable>\n    ) => BooleanExpr<TableDef | OtherTable>\n  ): SemijoinBuilder<OtherTable> {\n    const sourceQuery = new FromBuilder(right);\n    const joinCondition = on(\n      this.table.indexedCols,\n      right.indexedCols\n    ) as BooleanExpr<any>;\n    return new SemijoinImpl<OtherTable>(sourceQuery, this, joinCondition);\n  }\n\n  leftSemijoin<OtherTable extends TypedTableDef>(\n    right: TableRef<OtherTable>,\n    on: (\n      left: IndexedRowExpr<TableDef>,\n      right: IndexedRowExpr<OtherTable>\n    ) => BooleanExpr<TableDef | OtherTable>\n  ): SemijoinBuilder<TableDef> {\n    const filterQuery = new FromBuilder(right);\n    const joinCondition = on(\n      this.table.indexedCols,\n      right.indexedCols\n    ) as BooleanExpr<any>;\n    return new SemijoinImpl<TableDef>(this, filterQuery, joinCondition);\n  }\n\n  toSql(): string {\n    return renderSelectSqlWithJoins(this.table, this.whereClause);\n  }\n\n  build(): Query<TableDef> {\n    return this as Query<TableDef>;\n  }\n}\n\nexport type QueryBuilder<SchemaDef extends UntypedSchemaDef> = {\n  readonly [Tbl in Values<\n    SchemaDef['tables']\n  > as Tbl['accessorName']]: TableRef<Tbl> & From<Tbl>;\n} & {};\n\n/**\n * A runtime reference to a table. This materializes the RowExpr for us.\n * TODO: Maybe add the full SchemaDef to the type signature depending on how joins will work.\n */\nexport type TableRef<TableDef extends TypedTableDef> = Readonly<{\n  type: 'table';\n  sourceName: TableDef['sourceName'];\n  accessorName: string;\n  cols: RowExpr<TableDef>;\n  indexedCols: IndexedRowExpr<TableDef>;\n  tableDef: TableDef;\n  // Delegated UntypedTableDef properties for compatibility.\n  columns: TableDef['columns'];\n  indexes: TableDef['indexes'];\n  rowType: TableDef['rowType'];\n  constraints: any;\n}>;\n\nclass TableRefImpl<TableDef extends TypedTableDef>\n  implements TableRef<TableDef>, From<TableDef>\n{\n  readonly [QueryBrand] = true;\n  readonly type = 'table' as const;\n  sourceName: string;\n  accessorName: string;\n  cols: RowExpr<TableDef>;\n  indexedCols: IndexedRowExpr<TableDef>;\n  tableDef: TableDef;\n  // Delegate UntypedTableDef properties from tableDef so this can be used as a table def.\n  get columns() {\n    return this.tableDef.columns;\n  }\n  get indexes() {\n    return this.tableDef.indexes;\n  }\n  get rowType() {\n    return this.tableDef.rowType;\n  }\n  get constraints() {\n    return (this.tableDef as any).constraints;\n  }\n  constructor(tableDef: TableDef) {\n    this.sourceName = tableDef.sourceName;\n    this.accessorName = tableDef.accessorName;\n    this.cols = createRowExpr(tableDef);\n    // this.indexedCols = createIndexedRowExpr(tableDef, this.cols);\n    // TODO: we could create an indexedRowExpr to avoid having the extra columns.\n    // Right now, the objects we pass will actually have all the columns, but the\n    // type system will consider it an error.\n    this.indexedCols = this.cols;\n    this.tableDef = tableDef;\n    Object.freeze(this);\n  }\n\n  asFrom(): FromBuilder<TableDef> {\n    return new FromBuilder<TableDef>(this);\n  }\n\n  rightSemijoin<RightTable extends TypedTableDef>(\n    other: TableRef<RightTable>,\n    on: (\n      left: IndexedRowExpr<TableDef>,\n      right: IndexedRowExpr<RightTable>\n    ) => EqExpr<TableDef | RightTable>\n  ): SemijoinBuilder<RightTable> {\n    return this.asFrom().rightSemijoin(other, on);\n  }\n\n  leftSemijoin<RightTable extends TypedTableDef>(\n    other: TableRef<RightTable>,\n    on: (\n      left: IndexedRowExpr<TableDef>,\n      right: IndexedRowExpr<RightTable>\n    ) => EqExpr<TableDef | RightTable>\n  ): SemijoinBuilder<TableDef> {\n    return this.asFrom().leftSemijoin(other, on);\n  }\n\n  build(): Query<TableDef> {\n    return this.asFrom().build();\n  }\n\n  toSql(): string {\n    return this.asFrom().toSql();\n  }\n\n  where(\n    predicate: (row: RowExpr<TableDef>) => BooleanExpr<TableDef>\n  ): FromBuilder<TableDef> {\n    return this.asFrom().where(predicate);\n  }\n}\n\nexport function createTableRefFromDef<TableDef extends TypedTableDef>(\n  tableDef: TableDef\n): TableRef<TableDef> {\n  return new TableRefImpl<TableDef>(tableDef);\n}\n\nexport function makeQueryBuilder<SchemaDef extends UntypedSchemaDef>(\n  schema: SchemaDef\n): QueryBuilder<SchemaDef> {\n  const qb = Object.create(null) as QueryBuilder<SchemaDef>;\n  for (const table of Object.values(schema.tables)) {\n    const ref = createTableRefFromDef(\n      table as TableDefByName<SchemaDef, TableNames<SchemaDef>>\n    );\n    (qb as Record<string, TableRef<any>>)[table.accessorName] = ref;\n  }\n  return Object.freeze(qb) as QueryBuilder<SchemaDef>;\n}\n\nfunction createRowExpr<TableDef extends TypedTableDef>(\n  tableDef: TableDef\n): RowExpr<TableDef> {\n  const row: Record<string, ColumnExpr<TableDef, any>> = {};\n  for (const columnName of Object.keys(tableDef.columns) as Array<\n    keyof TableDef['columns'] & string\n  >) {\n    const columnBuilder = tableDef.columns[columnName];\n    const column = new ColumnExpression<TableDef, typeof columnName>(\n      tableDef.sourceName,\n      columnName,\n      columnBuilder.typeBuilder.algebraicType as InferSpacetimeTypeOfColumn<\n        TableDef,\n        typeof columnName\n      >\n    );\n    row[columnName] = Object.freeze(column);\n  }\n  return Object.freeze(row) as RowExpr<TableDef>;\n}\n\nfunction renderSelectSqlWithJoins<Table extends TypedTableDef>(\n  table: TableRef<Table>,\n  where?: BooleanExpr<Table>,\n  extraClauses: readonly string[] = []\n): string {\n  const quotedTable = quoteIdentifier(table.sourceName);\n  const sql = `SELECT * FROM ${quotedTable}`;\n  const clauses: string[] = [];\n  if (where) clauses.push(booleanExprToSql(where));\n  clauses.push(...extraClauses);\n  if (clauses.length === 0) return sql;\n  const whereSql =\n    clauses.length === 1 ? clauses[0] : clauses.map(wrapInParens).join(' AND ');\n  return `${sql} WHERE ${whereSql}`;\n}\n\n// TODO: Just use UntypedTableDef if they end up being the same.\nexport type TypedTableDef<\n  Columns extends Record<\n    string,\n    ColumnBuilder<any, any, ColumnMetadata<any>>\n  > = Record<string, ColumnBuilder<any, any, ColumnMetadata<any>>>,\n> = {\n  sourceName: string;\n  accessorName: string;\n  columns: Columns;\n  indexes: readonly IndexOpts<any>[];\n  rowType: RowBuilder<Columns>['algebraicType']['value'];\n};\n\nexport type TableSchemaAsTableDef<TSchema extends UntypedTableSchema> = {\n  name: TSchema['tableName'];\n  columns: TSchema['rowType']['row'];\n  indexes: TSchema['idxs'];\n};\n\ntype RowType<TableDef extends TypedTableDef> = {\n  [K in keyof TableDef['columns']]: TableDef['columns'][K] extends ColumnBuilder<\n    infer T,\n    any,\n    any\n  >\n    ? T\n    : never;\n};\n\n// TODO: Consider making a smaller version of these types that doesn't expose the internals.\n// Restricting it later should not break anyone in practice.\nexport type ColumnExpr<\n  TableDef extends TypedTableDef,\n  ColumnName extends ColumnNames<TableDef>,\n> = ColumnExpression<TableDef, ColumnName>;\n\ntype ColumnSpacetimeType<Col extends ColumnExpr<any, any>> =\n  Col extends ColumnExpr<infer T, infer N>\n    ? InferSpacetimeTypeOfColumn<T, N>\n    : never;\n\n// TODO: This checks that they match, but we also need to make sure that they are comparable types,\n// since you can use product types at all.\ntype ColumnSameSpacetime<\n  ThisTable extends TypedTableDef,\n  ThisCol extends ColumnNames<ThisTable>,\n  OtherCol extends ColumnExpr<any, any>,\n> = [InferSpacetimeTypeOfColumn<ThisTable, ThisCol>] extends [\n  ColumnSpacetimeType<OtherCol>,\n]\n  ? [ColumnSpacetimeType<OtherCol>] extends [\n      InferSpacetimeTypeOfColumn<ThisTable, ThisCol>,\n    ]\n    ? OtherCol\n    : never\n  : never;\n\n// Helper to get the table back from a column.\ntype ExtractTable<Col extends ColumnExpr<any, any>> =\n  Col extends ColumnExpr<infer T, any> ? T : never;\n\nexport class ColumnExpression<\n  TableDef extends TypedTableDef,\n  ColumnName extends ColumnNames<TableDef>,\n> {\n  readonly type = 'column' as const;\n  readonly column: ColumnName;\n  readonly table: TableDef['sourceName'];\n  // phantom: actual runtime value is undefined\n  readonly tsValueType?: RowType<TableDef>[ColumnName];\n  readonly spacetimeType: InferSpacetimeTypeOfColumn<TableDef, ColumnName>;\n\n  constructor(\n    table: TableDef['sourceName'],\n    column: ColumnName,\n    spacetimeType: InferSpacetimeTypeOfColumn<TableDef, ColumnName>\n  ) {\n    this.table = table;\n    this.column = column;\n    this.spacetimeType = spacetimeType;\n  }\n\n  eq(\n    literal: LiteralValue & RowType<TableDef>[ColumnName]\n  ): BooleanExpr<TableDef>;\n  eq<OtherCol extends ColumnExpr<any, any>>(\n    value: ColumnSameSpacetime<TableDef, ColumnName, OtherCol>\n  ): BooleanExpr<TableDef | ExtractTable<OtherCol>>;\n\n  eq(x: any): any {\n    return new BooleanExpr({\n      type: 'eq',\n      left: this as unknown as ValueExpr<TableDef, any>,\n      right: normalizeValue(x) as ValueExpr<TableDef, any>,\n    });\n  }\n\n  ne(\n    literal: LiteralValue & RowType<TableDef>[ColumnName]\n  ): BooleanExpr<TableDef>;\n  ne<OtherCol extends ColumnExpr<any, any>>(\n    value: ColumnSameSpacetime<TableDef, ColumnName, OtherCol>\n  ): BooleanExpr<TableDef | ExtractTable<OtherCol>>;\n\n  ne(x: any): any {\n    return new BooleanExpr({\n      type: 'ne',\n      left: this as unknown as ValueExpr<TableDef, any>,\n      right: normalizeValue(x) as ValueExpr<TableDef, any>,\n    });\n  }\n\n  lt(\n    literal: LiteralValue & RowType<TableDef>[ColumnName]\n  ): BooleanExpr<TableDef>;\n  lt<OtherCol extends ColumnExpr<any, any>>(\n    value: ColumnSameSpacetime<TableDef, ColumnName, OtherCol>\n  ): BooleanExpr<TableDef | ExtractTable<OtherCol>>;\n\n  lt(x: any): any {\n    return new BooleanExpr({\n      type: 'lt',\n      left: this as unknown as ValueExpr<TableDef, any>,\n      right: normalizeValue(x) as ValueExpr<TableDef, any>,\n    });\n  }\n\n  lte(\n    literal: LiteralValue & RowType<TableDef>[ColumnName]\n  ): BooleanExpr<TableDef>;\n  lte<OtherCol extends ColumnExpr<any, any>>(\n    value: ColumnSameSpacetime<TableDef, ColumnName, OtherCol>\n  ): BooleanExpr<TableDef | ExtractTable<OtherCol>>;\n\n  lte(x: any): any {\n    return new BooleanExpr({\n      type: 'lte',\n      left: this as unknown as ValueExpr<TableDef, any>,\n      right: normalizeValue(x) as ValueExpr<TableDef, any>,\n    });\n  }\n\n  gt(\n    literal: LiteralValue & RowType<TableDef>[ColumnName]\n  ): BooleanExpr<TableDef>;\n  gt<OtherCol extends ColumnExpr<any, any>>(\n    value: ColumnSameSpacetime<TableDef, ColumnName, OtherCol>\n  ): BooleanExpr<TableDef | ExtractTable<OtherCol>>;\n\n  gt(x: any): any {\n    return new BooleanExpr({\n      type: 'gt',\n      left: this as unknown as ValueExpr<TableDef, any>,\n      right: normalizeValue(x) as ValueExpr<TableDef, any>,\n    });\n  }\n\n  gte(\n    literal: LiteralValue & RowType<TableDef>[ColumnName]\n  ): BooleanExpr<TableDef>;\n  gte<OtherCol extends ColumnExpr<any, any>>(\n    value: ColumnSameSpacetime<TableDef, ColumnName, OtherCol>\n  ): BooleanExpr<TableDef | ExtractTable<OtherCol>>;\n\n  gte(x: any): any {\n    return new BooleanExpr({\n      type: 'gte',\n      left: this as unknown as ValueExpr<TableDef, any>,\n      right: normalizeValue(x) as ValueExpr<TableDef, any>,\n    });\n  }\n}\n\n/**\n * Helper to get the spacetime type of a column.\n */\ntype InferSpacetimeTypeOfColumn<\n  TableDef extends TypedTableDef,\n  ColumnName extends ColumnNames<TableDef>,\n> =\n  TableDef['columns'][ColumnName]['typeBuilder'] extends TypeBuilder<\n    any,\n    infer U\n  >\n    ? U\n    : never;\n\ntype ColumnNames<TableDef extends TypedTableDef> = keyof RowType<TableDef> &\n  string;\n\n// For composite indexes, we only consider it as an index over the first column in the index.\ntype FirstIndexColumn<I extends IndexOpts<any>> =\n  IndexColumns<I> extends readonly [infer Head extends string, ...infer _Rest]\n    ? Head\n    : never;\n\n// Columns that are indexed by something in the indexes: [...] part.\ntype ExplicitIndexedColumns<TableDef extends TypedTableDef> =\n  TableDef['indexes'][number] extends infer I\n    ? I extends IndexOpts<ColumnNames<TableDef>>\n      ? FirstIndexColumn<I> & ColumnNames<TableDef>\n      : never\n    : never;\n\n// Columns with an index defined on the column definition.\ntype MetadataIndexedColumns<TableDef extends TypedTableDef> = {\n  [K in ColumnNames<TableDef>]: ColumnIndex<\n    K,\n    TableDef['columns'][K]['columnMetadata']\n  > extends never\n    ? never\n    : K;\n}[ColumnNames<TableDef>];\n\nexport type IndexedColumnNames<TableDef extends TypedTableDef> =\n  | ExplicitIndexedColumns<TableDef>\n  | MetadataIndexedColumns<TableDef>;\n\nexport type IndexedRowExpr<TableDef extends TypedTableDef> = Readonly<{\n  readonly [C in IndexedColumnNames<TableDef>]: ColumnExpr<TableDef, C>;\n}>;\n\n/**\n * Acts as a row when writing filters for queries. It is a way to get column references.\n */\nexport type RowExpr<TableDef extends TypedTableDef> = Readonly<{\n  readonly [C in ColumnNames<TableDef>]: ColumnExpr<TableDef, C>;\n}>;\n\n/**\n * Union of ColumnExprs from Table whose spacetimeType is compatible with Value\n * (produces a union of ColumnExpr<Table, C> for matching columns).\n */\nexport type ColumnExprForValue<Table extends TypedTableDef, Value> = {\n  [C in ColumnNames<Table>]: InferSpacetimeTypeOfColumn<Table, C> extends Value\n    ? ColumnExpr<Table, C>\n    : never;\n}[ColumnNames<Table>];\n\ntype LiteralValue =\n  | string\n  | number\n  | bigint\n  | boolean\n  | Identity\n  | Timestamp\n  | ConnectionId;\n\ntype ValueLike = LiteralValue | ColumnExpr<any, any> | LiteralExpr<any>;\ntype ValueInput<TableDef extends TypedTableDef> =\n  | ValueLike\n  | ValueExpr<TableDef, any>;\n\nexport type ValueExpr<TableDef extends TypedTableDef, Value> =\n  | LiteralExpr<Value & LiteralValue>\n  | ColumnExprForValue<TableDef, Value>;\n\ntype LiteralExpr<Value> = {\n  type: 'literal';\n  value: Value;\n};\n\nexport function literal<Value extends LiteralValue>(\n  value: Value\n): ValueExpr<never, Value> {\n  return { type: 'literal', value };\n}\n\n// This is here to take literal values and wrap them in an AST node.\nfunction normalizeValue(val: ValueInput<any>): ValueExpr<any, any> {\n  if ((val as LiteralExpr<any>).type === 'literal')\n    return val as LiteralExpr<any>;\n  if (\n    typeof val === 'object' &&\n    val != null &&\n    'type' in (val as any) &&\n    (val as any).type === 'column'\n  ) {\n    return val as ColumnExpr<any, any>;\n  }\n  return literal(val as LiteralValue);\n}\n\ntype EqExpr<Table extends TypedTableDef = any> = BooleanExpr<Table>;\n\ntype BooleanExprData<Table extends TypedTableDef> = (\n  | {\n      type: 'eq' | 'ne' | 'gt' | 'lt' | 'gte' | 'lte';\n      left: ValueExpr<Table, any>;\n      right: ValueExpr<Table, any>;\n    }\n  | {\n      type: 'and';\n      clauses: readonly [\n        BooleanExprData<Table>,\n        BooleanExprData<Table>,\n        ...BooleanExprData<Table>[],\n      ];\n    }\n  | {\n      type: 'or';\n      clauses: readonly [\n        BooleanExprData<Table>,\n        BooleanExprData<Table>,\n        ...BooleanExprData<Table>[],\n      ];\n    }\n  | {\n      type: 'not';\n      clause: BooleanExprData<Table>;\n    }\n) & {\n  _tableType?: Table;\n};\n\nexport class BooleanExpr<Table extends TypedTableDef> {\n  constructor(readonly data: BooleanExprData<Table>) {}\n\n  and(other: BooleanExpr<Table>): BooleanExpr<Table> {\n    return new BooleanExpr({ type: 'and', clauses: [this.data, other.data] });\n  }\n\n  or(other: BooleanExpr<Table>): BooleanExpr<Table> {\n    return new BooleanExpr({ type: 'or', clauses: [this.data, other.data] });\n  }\n\n  not(): BooleanExpr<Table> {\n    return new BooleanExpr({ type: 'not', clause: this.data });\n  }\n}\n\nexport function not<T extends TypedTableDef>(\n  clause: BooleanExpr<T>\n): BooleanExpr<T> {\n  return new BooleanExpr({ type: 'not', clause: clause.data });\n}\n\nexport function and<T extends TypedTableDef>(\n  ...clauses: readonly [BooleanExpr<T>, BooleanExpr<T>, ...BooleanExpr<T>[]]\n): BooleanExpr<T> {\n  return new BooleanExpr({\n    type: 'and',\n    clauses: clauses.map(c => c.data) as [\n      BooleanExprData<T>,\n      BooleanExprData<T>,\n      ...BooleanExprData<T>[],\n    ],\n  });\n}\n\nexport function or<T extends TypedTableDef>(\n  ...clauses: readonly [BooleanExpr<T>, BooleanExpr<T>, ...BooleanExpr<T>[]]\n): BooleanExpr<T> {\n  return new BooleanExpr({\n    type: 'or',\n    clauses: clauses.map(c => c.data) as [\n      BooleanExprData<T>,\n      BooleanExprData<T>,\n      ...BooleanExprData<T>[],\n    ],\n  });\n}\n\nfunction booleanExprToSql<Table extends TypedTableDef>(\n  expr: BooleanExpr<Table> | BooleanExprData<Table>,\n  tableAlias?: string\n): string {\n  const data = expr instanceof BooleanExpr ? expr.data : expr;\n  switch (data.type) {\n    case 'eq':\n      return `${valueExprToSql(data.left, tableAlias)} = ${valueExprToSql(data.right, tableAlias)}`;\n    case 'ne':\n      return `${valueExprToSql(data.left, tableAlias)} <> ${valueExprToSql(data.right, tableAlias)}`;\n    case 'gt':\n      return `${valueExprToSql(data.left, tableAlias)} > ${valueExprToSql(data.right, tableAlias)}`;\n    case 'gte':\n      return `${valueExprToSql(data.left, tableAlias)} >= ${valueExprToSql(data.right, tableAlias)}`;\n    case 'lt':\n      return `${valueExprToSql(data.left, tableAlias)} < ${valueExprToSql(data.right, tableAlias)}`;\n    case 'lte':\n      return `${valueExprToSql(data.left, tableAlias)} <= ${valueExprToSql(data.right, tableAlias)}`;\n    case 'and':\n      return data.clauses\n        .map(c => booleanExprToSql(c, tableAlias))\n        .map(wrapInParens)\n        .join(' AND ');\n    case 'or':\n      return data.clauses\n        .map(c => booleanExprToSql(c, tableAlias))\n        .map(wrapInParens)\n        .join(' OR ');\n    case 'not':\n      return `NOT ${wrapInParens(booleanExprToSql(data.clause, tableAlias))}`;\n  }\n}\n\nfunction wrapInParens(sql: string): string {\n  return `(${sql})`;\n}\n\nfunction valueExprToSql<Table extends TypedTableDef>(\n  expr: ValueExpr<Table, any>,\n  tableAlias?: string\n): string {\n  if (isLiteralExpr(expr)) {\n    return literalValueToSql(expr.value);\n  }\n  const table = tableAlias ?? expr.table;\n  return `${quoteIdentifier(table)}.${quoteIdentifier(expr.column)}`;\n}\n\nfunction literalValueToSql(value: unknown): string {\n  if (value === null || value === undefined) {\n    return 'NULL';\n  }\n  if (value instanceof Identity || value instanceof ConnectionId) {\n    // We use this hex string syntax.\n    return `0x${value.toHexString()}`;\n  }\n  if (value instanceof Timestamp) {\n    return `'${value.toISOString()}'`;\n  }\n  switch (typeof value) {\n    case 'number':\n    case 'bigint':\n      return String(value);\n    case 'boolean':\n      return value ? 'TRUE' : 'FALSE';\n    case 'string':\n      return `'${value.replace(/'/g, \"''\")}'`;\n    default:\n      // It might be safer to error here?\n      return `'${JSON.stringify(value).replace(/'/g, \"''\")}'`;\n  }\n}\n\nfunction quoteIdentifier(name: string): string {\n  return `\"${name.replace(/\"/g, '\"\"')}\"`;\n}\n\nfunction isLiteralExpr<Value>(\n  expr: ValueExpr<any, Value>\n): expr is LiteralExpr<Value & LiteralValue> {\n  return (expr as LiteralExpr<Value>).type === 'literal';\n}\n\n/**\n * Evaluate a BooleanExpr against a row at runtime for client-side filtering.\n */\nexport function evaluateBooleanExpr(\n  expr: BooleanExpr<any>,\n  row: Record<string, any>\n): boolean {\n  return evaluateData(expr.data, row);\n}\n\nfunction evaluateData(\n  data: BooleanExprData<any>,\n  row: Record<string, any>\n): boolean {\n  switch (data.type) {\n    case 'eq':\n      return resolveValue(data.left, row) === resolveValue(data.right, row);\n    case 'ne':\n      return resolveValue(data.left, row) !== resolveValue(data.right, row);\n    case 'gt':\n      return resolveValue(data.left, row) > resolveValue(data.right, row);\n    case 'gte':\n      return resolveValue(data.left, row) >= resolveValue(data.right, row);\n    case 'lt':\n      return resolveValue(data.left, row) < resolveValue(data.right, row);\n    case 'lte':\n      return resolveValue(data.left, row) <= resolveValue(data.right, row);\n    case 'and':\n      return data.clauses.every(c => evaluateData(c, row));\n    case 'or':\n      return data.clauses.some(c => evaluateData(c, row));\n    case 'not':\n      return !evaluateData(data.clause, row);\n  }\n}\n\nfunction resolveValue(\n  expr: ValueExpr<any, any>,\n  row: Record<string, any>\n): any {\n  if (isLiteralExpr(expr)) {\n    return toComparableValue(expr.value);\n  }\n  return toComparableValue(row[expr.column]);\n}\n\ntype TimestampLike = {\n  __timestamp_micros_since_unix_epoch__: bigint;\n};\n\ntype HexSerializableLike = {\n  toHexString: () => string;\n};\n\nfunction isHexSerializableLike(value: unknown): value is HexSerializableLike {\n  return (\n    !!value &&\n    typeof value === 'object' &&\n    typeof (value as { toHexString?: unknown }).toHexString === 'function'\n  );\n}\n\n// Check if this value is a Timestamp-like object. This is here because\n// running locally can end up with different versions of the Timestamp class,\n// which breaks the simple instanceof version.\nfunction isTimestampLike(value: unknown): value is TimestampLike {\n  if (!value || typeof value !== 'object') return false;\n\n  if (value instanceof Timestamp) return true;\n\n  const micros = (value as Record<string, unknown>)[\n    '__timestamp_micros_since_unix_epoch__'\n  ];\n  return typeof micros === 'bigint';\n}\n\n// Exported for tests.\nexport function toComparableValue(value: any): any {\n  // Handle `ConnectionId` and `Identity`.\n  if (isHexSerializableLike(value)) {\n    return value.toHexString();\n  }\n  if (isTimestampLike(value)) {\n    return value.__timestamp_micros_since_unix_epoch__;\n  }\n  return value;\n}\n\n/**\n * Extract the table name from a query builder expression.\n */\nexport function getQueryTableName(query: any): string {\n  if (query.table) return query.table.name; // FromBuilder\n  if (query.name) return query.name; // TableRefImpl\n  if (query.sourceQuery) return query.sourceQuery.table.name; // SemijoinImpl (source table)\n  throw new Error('Cannot extract table name from query');\n}\n\n/**\n * Extract the accessor name from a query builder expression.\n */\nexport function getQueryAccessorName(query: any): string {\n  if (query.table) return query.table.accessorName; // FromBuilder\n  if (query.accessorName) return query.accessorName; // TableRefImpl\n  if (query.sourceQuery) return query.sourceQuery.table.accessorName; // SemijoinImpl\n  throw new Error('Cannot extract accessor name from query');\n}\n\n/**\n * Extract the BooleanExpr from a query builder, if any.\n */\nexport function getQueryWhereClause(query: any): BooleanExpr<any> | undefined {\n  if (query.whereClause) return query.whereClause; // FromBuilder\n  return undefined; // TableRefImpl has no where clause\n}\n\n// TODO: Fix this.\nfunction _createIndexedRowExpr<TableDef extends TypedTableDef>(\n  tableDef: TableDef,\n  cols: RowExpr<TableDef>\n): IndexedRowExpr<TableDef> {\n  const indexed = new Set<ColumnNames<TableDef>>();\n  for (const idx of tableDef.indexes) {\n    if ('columns' in idx) {\n      const [first] = idx.columns;\n      if (first) indexed.add(first);\n    } else if ('column' in idx) {\n      indexed.add(idx.column);\n    }\n  }\n  const pickedEntries = [...indexed].map(name => [name, cols[name]]);\n  return Object.freeze(\n    Object.fromEntries(pickedEntries)\n  ) as IndexedRowExpr<TableDef>;\n}\n","import type {\n  QueryClient,\n  QueryKey,\n  QueryFunction,\n} from '@tanstack/react-query';\nimport {\n  type BooleanExpr,\n  evaluateBooleanExpr,\n  getQueryAccessorName,\n  getQueryWhereClause,\n} from '../lib/query';\n\ntype QueryInput = { toSql(): string } & Record<string, any>;\n\nconst queryRegistry = new Map<\n  string,\n  { accessorName: string; whereExpr?: BooleanExpr<any> }\n>();\n\nexport interface SpacetimeDBQueryOptions {\n  queryKey: readonly ['spacetimedb', string, string];\n  staleTime: number;\n}\n\nexport interface SpacetimeDBQueryOptionsSkipped\n  extends SpacetimeDBQueryOptions {\n  enabled: false;\n}\n\n// creates query options for useQuery/useSuspenseQuery.\n// useQuery(spacetimeDBQuery(tables.person));\n// useQuery(spacetimeDBQuery(tables.user.where(r => r.online.eq(true))));\n// useQuery(spacetimeDBQuery(condition ? tables.user : 'skip'));\nexport function spacetimeDBQuery(\n  queryOrSkip: 'skip'\n): SpacetimeDBQueryOptionsSkipped;\n\nexport function spacetimeDBQuery(query: QueryInput): SpacetimeDBQueryOptions;\n\nexport function spacetimeDBQuery(\n  queryOrSkip: QueryInput | 'skip'\n): SpacetimeDBQueryOptions | SpacetimeDBQueryOptionsSkipped {\n  if (queryOrSkip === 'skip') {\n    return {\n      queryKey: ['spacetimedb', '', 'skip'] as const,\n      staleTime: Infinity,\n      enabled: false,\n    };\n  }\n\n  const query = queryOrSkip;\n  const accessorName = getQueryAccessorName(query);\n  const whereExpr = getQueryWhereClause(query);\n  const querySql = query.toSql();\n\n  queryRegistry.set(querySql, { accessorName, whereExpr });\n\n  return {\n    queryKey: ['spacetimedb', accessorName, querySql] as const,\n    staleTime: Infinity,\n  };\n}\n\ninterface SpacetimeConnection {\n  db: Record<string, any>;\n  subscriptionBuilder: () => {\n    onApplied: (cb: () => void) => any;\n    subscribe: (query: string) => { unsubscribe: () => void };\n  };\n}\n\ninterface SubscriptionState {\n  unsubscribe: () => void;\n  tableInstance: any;\n  applied: boolean;\n}\n\n// push updates to cache via setQueryData when SpacetimeDB data changes\nexport class SpacetimeDBQueryClient {\n  private connection: SpacetimeConnection | null = null;\n  private queryClient: QueryClient | null = null;\n  private subscriptions = new Map<string, SubscriptionState>();\n  private pendingQueries = new Map<\n    string,\n    Array<{\n      resolve: (data: any[]) => void;\n      querySql: string;\n      whereExpr?: BooleanExpr<any>;\n    }>\n  >();\n  private cacheUnsubscribe: (() => void) | null = null;\n\n  // set connection, called on onConnect callback\n  setConnection(connection: SpacetimeConnection): void {\n    this.connection = connection;\n    this.processPendingQueries();\n  }\n\n  connect(queryClient: QueryClient): void {\n    this.queryClient = queryClient;\n\n    this.cacheUnsubscribe = queryClient\n      .getQueryCache()\n      .subscribe((event: any) => {\n        if (\n          event.type === 'removed' &&\n          event.query.queryKey[0] === 'spacetimedb'\n        ) {\n          const keyStr = JSON.stringify(event.query.queryKey);\n          const sub = this.subscriptions.get(keyStr);\n          if (sub) {\n            sub.unsubscribe();\n            this.subscriptions.delete(keyStr);\n          }\n        }\n      });\n  }\n\n  queryFn: QueryFunction<any[], QueryKey> = async ({\n    queryKey,\n  }: {\n    queryKey: QueryKey;\n  }) => {\n    const keyStr = JSON.stringify(queryKey);\n    const [prefix, accessorName, querySql] = queryKey as [\n      string,\n      string,\n      string,\n    ];\n\n    if (prefix !== 'spacetimedb') {\n      throw new Error(\n        `SpacetimeDBQueryClient can only handle spacetimedb queries, got: ${prefix}`\n      );\n    }\n\n    const registered = queryRegistry.get(querySql);\n    const whereExpr = registered?.whereExpr;\n\n    const existingSub = this.subscriptions.get(keyStr);\n    if (existingSub?.applied) {\n      return this.getTableData(existingSub.tableInstance, whereExpr);\n    }\n\n    // queue query if connection not ready yet\n    if (!this.connection) {\n      return new Promise<any[]>(resolve => {\n        const pending = this.pendingQueries.get(keyStr) || [];\n        pending.push({ resolve, querySql, whereExpr });\n        this.pendingQueries.set(keyStr, pending);\n      });\n    }\n\n    return this.setupSubscription(queryKey, accessorName, querySql, whereExpr);\n  };\n\n  private getTableData(\n    tableInstance: any,\n    whereExpr?: BooleanExpr<any>\n  ): any[] {\n    const allRows = Array.from(tableInstance.iter());\n    if (whereExpr) {\n      return allRows.filter(row =>\n        evaluateBooleanExpr(whereExpr, row as Record<string, any>)\n      );\n    }\n    return allRows;\n  }\n\n  private setupSubscription(\n    queryKey: QueryKey,\n    accessorName: string,\n    querySql: string,\n    whereExpr?: BooleanExpr<any>\n  ): Promise<any[]> {\n    if (!this.connection) {\n      return Promise.resolve([]);\n    }\n\n    const keyStr = JSON.stringify(queryKey);\n    const db = this.connection.db;\n\n    const tableInstance = db[accessorName];\n\n    if (!tableInstance) {\n      console.warn(`SpacetimeDBQueryClient: table \"${accessorName}\" not found`);\n      return Promise.resolve([]);\n    }\n\n    // return existing data if already subscribed\n    const existingSub = this.subscriptions.get(keyStr);\n    if (existingSub) {\n      if (existingSub.applied) {\n        return Promise.resolve(\n          this.getTableData(existingSub.tableInstance, whereExpr)\n        );\n      }\n      return new Promise(resolve => {\n        const pending = this.pendingQueries.get(keyStr) || [];\n        pending.push({ resolve, querySql, whereExpr });\n        this.pendingQueries.set(keyStr, pending);\n      });\n    }\n\n    return new Promise<any[]>(resolve => {\n      const updateCache = () => {\n        if (!this.queryClient) return [];\n        const data = this.getTableData(tableInstance, whereExpr);\n        this.queryClient.setQueryData(queryKey, data);\n        return data;\n      };\n\n      const handle = this.connection!.subscriptionBuilder()\n        .onApplied(() => {\n          const sub = this.subscriptions.get(keyStr);\n          if (sub) {\n            sub.applied = true;\n          }\n\n          const data = updateCache();\n          resolve(data);\n\n          const pending = this.pendingQueries.get(keyStr);\n          if (pending) {\n            for (const p of pending) {\n              p.resolve(data);\n            }\n            this.pendingQueries.delete(keyStr);\n          }\n        })\n        .subscribe(querySql);\n\n      // push updates to cache when data changes\n      const onTableChange = () => {\n        const sub = this.subscriptions.get(keyStr);\n        if (sub?.applied) {\n          updateCache();\n        }\n      };\n\n      tableInstance.onInsert(onTableChange);\n      tableInstance.onDelete(onTableChange);\n      tableInstance.onUpdate?.(onTableChange);\n\n      this.subscriptions.set(keyStr, {\n        unsubscribe: () => {\n          handle.unsubscribe();\n          tableInstance.removeOnInsert(onTableChange);\n          tableInstance.removeOnDelete(onTableChange);\n          tableInstance.removeOnUpdate?.(onTableChange);\n        },\n        tableInstance,\n        applied: false,\n      });\n    });\n  }\n\n  private processPendingQueries(): void {\n    if (!this.connection) return;\n\n    const pendingEntries = Array.from(this.pendingQueries.entries());\n    this.pendingQueries.clear();\n\n    for (const [keyStr, pending] of pendingEntries) {\n      const queryKey = JSON.parse(keyStr) as QueryKey;\n      const [, accessorName] = queryKey as [string, string, string];\n\n      if (pending.length > 0) {\n        const first = pending[0];\n        this.setupSubscription(\n          queryKey,\n          accessorName,\n          first.querySql,\n          first.whereExpr\n        )\n          .then(data => {\n            for (const p of pending) {\n              p.resolve(data);\n            }\n          })\n          .catch(() => {\n            for (const p of pending) {\n              p.resolve([]);\n            }\n          });\n      }\n    }\n  }\n\n  // clean up all subscriptions and disconnect\n  disconnect(): void {\n    if (this.cacheUnsubscribe) {\n      this.cacheUnsubscribe();\n      this.cacheUnsubscribe = null;\n    }\n\n    for (const sub of this.subscriptions.values()) {\n      sub.unsubscribe();\n    }\n    this.subscriptions.clear();\n    this.pendingQueries.clear();\n    this.connection = null;\n  }\n}\n","import { useQuery, useSuspenseQuery } from '@tanstack/react-query';\nimport type {\n  UseQueryOptions,\n  UseQueryResult,\n  UseSuspenseQueryOptions,\n  UseSuspenseQueryResult,\n} from '@tanstack/react-query';\nimport type { UntypedTableDef, RowType } from '../lib/table';\nimport { spacetimeDBQuery } from './SpacetimeDBQueryClient';\n\nexport type UseSpacetimeDBQueryResult<T> = [\n  T[],\n  boolean,\n  UseQueryResult<T[], Error>,\n];\n\nexport type UseSpacetimeDBSuspenseQueryResult<T> = [\n  T[],\n  false,\n  UseSuspenseQueryResult<T[], Error>,\n];\n\n// Wraps TanStack Query useQuery and returns [data, loading, query]\n// pass 'skip' as the second argument to set enabled: false, disabling the query\n// until a condition is met\n//\n// Usage:\n//   useSpacetimeDBQuery(tables.person)\n//   useSpacetimeDBQuery(tables.user.where(r => r.online.eq(true)))\n//   useSpacetimeDBQuery(condition ? tables.user : 'skip')\nexport function useSpacetimeDBQuery<TableDef extends UntypedTableDef>(\n  queryOrSkip: ({ toSql(): string } & Record<string, any>) | 'skip',\n  // any useQuery option (e.g. enabled, refetchInterval, select, placeholderData),\n  // except queryKey, queryFn, and meta (managed internally)\n  options?: Omit<\n    UseQueryOptions<\n      RowType<TableDef>[],\n      Error,\n      RowType<TableDef>[],\n      readonly ['spacetimedb', string, string]\n    >,\n    'queryKey' | 'queryFn' | 'meta'\n  >\n): UseSpacetimeDBQueryResult<RowType<TableDef>> {\n  const queryOptions =\n    queryOrSkip === 'skip'\n      ? spacetimeDBQuery('skip')\n      : spacetimeDBQuery(queryOrSkip);\n\n  const query = useQuery({\n    ...queryOptions,\n    ...options,\n  } as UseQueryOptions<RowType<TableDef>[], Error>);\n\n  return [query.data ?? [], query.isPending, query];\n}\n\n// Suspense version of useSpacetimeDBQuery, returns [data, false, query] tuple (loading = false)\n// Instead of returning a loading boolean, this hook suspends the component\n// until data is ready, a parent <Suspense fallback={}> handles the loading UI.\n// does not support 'skip' because useSuspenseQuery must always resolve\nexport function useSpacetimeDBSuspenseQuery<TableDef extends UntypedTableDef>(\n  query: { toSql(): string } & Record<string, any>,\n  options?: Omit<\n    UseSuspenseQueryOptions<\n      RowType<TableDef>[],\n      Error,\n      RowType<TableDef>[],\n      readonly ['spacetimedb', string, string]\n    >,\n    'queryKey' | 'queryFn' | 'meta'\n  >\n): UseSpacetimeDBSuspenseQueryResult<RowType<TableDef>> {\n  const queryOptions = spacetimeDBQuery(query);\n\n  const q = useSuspenseQuery({\n    ...queryOptions,\n    ...options,\n  } as UseSuspenseQueryOptions<RowType<TableDef>[], Error>);\n\n  return [q.data, false, q];\n}\n","import { createContext, useContext } from 'react';\nimport type { ConnectionState } from './connection_state';\n\nexport const SpacetimeDBContext = createContext<ConnectionState | undefined>(\n  undefined\n);\n\n// Throws an error if used outside of a SpacetimeDBProvider\n// Error is caught by other hooks like useTable so they can provide better error messages\nexport function useSpacetimeDB(): ConnectionState {\n  const context = useContext(SpacetimeDBContext) as ConnectionState | undefined;\n  if (!context) {\n    throw new Error(\n      'useSpacetimeDB must be used within a SpacetimeDBProvider component. Did you forget to add a `SpacetimeDBProvider` to your component tree?'\n    );\n  }\n  return context;\n}\n","/**\n * ConnectionManager - A reference-counted connection manager for SpacetimeDB.\n *\n * This module implements a TanStack Query-style pattern for managing WebSocket\n * connections in React applications. It solves the React StrictMode double-mount\n * problem by using reference counting and deferred cleanup.\n *\n * ## How it works:\n *\n * 1. **Reference Counting**: Each `retain()` increments a counter, `release()` decrements it.\n *    The connection is only closed when the count reaches zero.\n *\n * 2. **Deferred Cleanup**: When refCount hits zero, cleanup is scheduled via `setTimeout(0)`.\n *    This allows React StrictMode's rapid unmountremount cycle to cancel the cleanup.\n *\n * 3. **useSyncExternalStore Integration**: The `subscribe()` and `getSnapshot()` methods\n *    are designed to work with React's `useSyncExternalStore` hook for tear-free reads.\n *\n * ## StrictMode Lifecycle:\n *\n * ```\n * Mount    retain()   refCount: 01, connection created\n * Unmount  release()  refCount: 10, cleanup SCHEDULED (not executed)\n * Remount  retain()   refCount: 01, cleanup CANCELLED\n * Result: Single WebSocket survives \n * ```\n *\n * @module connection_manager\n */\nimport type {\n  DbConnectionBuilder,\n  DbConnectionImpl,\n  ErrorContextInterface,\n} from './db_connection_impl';\nimport type { Identity } from '../lib/identity';\nimport { ConnectionId } from '../lib/connection_id';\n\n/** Represents the current state of a managed connection. */\nexport type ConnectionState = {\n  isActive: boolean;\n  identity?: Identity;\n  token?: string;\n  connectionId: ConnectionId;\n  connectionError?: Error;\n};\n\ntype Listener = () => void;\n\ntype ManagedConnection = {\n  connection?: DbConnectionImpl<any>;\n  refCount: number;\n  state: ConnectionState;\n  listeners: Set<Listener>;\n  pendingRelease: ReturnType<typeof setTimeout> | null;\n  onConnect?: (conn: DbConnectionImpl<any>) => void;\n  onDisconnect?: (ctx: ErrorContextInterface<any>, error?: Error) => void;\n  onConnectError?: (ctx: ErrorContextInterface<any>, error: Error) => void;\n};\n\nfunction defaultState(): ConnectionState {\n  return {\n    isActive: false,\n    identity: undefined,\n    token: undefined,\n    connectionId: ConnectionId.random(),\n    connectionError: undefined,\n  };\n}\n\n/**\n * Singleton manager for SpacetimeDB connections.\n * Use the exported `ConnectionManager` instance rather than instantiating directly.\n */\nclass ConnectionManagerImpl {\n  #connections = new Map<string, ManagedConnection>();\n\n  /** Generates a unique key for a connection based on URI and module name. */\n  static getKey(uri: string, moduleName: string): string {\n    return `${uri}::${moduleName}`;\n  }\n\n  /** Instance method wrapper for getKey. */\n  getKey(uri: string, moduleName: string): string {\n    return ConnectionManagerImpl.getKey(uri, moduleName);\n  }\n\n  #ensureEntry(key: string): ManagedConnection {\n    const existing = this.#connections.get(key);\n    if (existing) {\n      return existing;\n    }\n    const managed: ManagedConnection = {\n      connection: undefined,\n      refCount: 0,\n      state: defaultState(),\n      listeners: new Set(),\n      pendingRelease: null,\n    };\n    this.#connections.set(key, managed);\n    return managed;\n  }\n\n  #notify(managed: ManagedConnection): void {\n    for (const listener of managed.listeners) {\n      listener();\n    }\n  }\n\n  /**\n   * Retains a connection, incrementing its reference count.\n   * Creates the connection on first call; returns existing connection on subsequent calls.\n   * Cancels any pending release if the connection was about to be cleaned up.\n   *\n   * @param key - Unique identifier for the connection (use getKey to generate)\n   * @param builder - Connection builder to create the connection if needed\n   * @returns The managed connection instance\n   */\n  retain<T extends DbConnectionImpl<any>>(\n    key: string,\n    builder: DbConnectionBuilder<T>\n  ): T {\n    const managed = this.#ensureEntry(key);\n    if (managed.pendingRelease) {\n      clearTimeout(managed.pendingRelease);\n      managed.pendingRelease = null;\n    }\n    managed.refCount += 1;\n    if (managed.connection) {\n      return managed.connection as T;\n    }\n\n    const connection = builder.build();\n    managed.connection = connection;\n\n    const updateState = (updates: Partial<ConnectionState>) => {\n      managed.state = { ...managed.state, ...updates };\n      this.#notify(managed);\n    };\n\n    updateState({\n      isActive: connection.isActive,\n      identity: connection.identity,\n      token: connection.token,\n      connectionId: connection.connectionId,\n      connectionError: undefined,\n    });\n\n    managed.onConnect = conn => {\n      updateState({\n        isActive: conn.isActive,\n        identity: conn.identity,\n        token: conn.token,\n        connectionId: conn.connectionId,\n        connectionError: undefined,\n      });\n    };\n\n    managed.onDisconnect = (ctx, error) => {\n      updateState({\n        isActive: ctx.isActive,\n        connectionError: error ?? undefined,\n      });\n    };\n\n    managed.onConnectError = (ctx, error) => {\n      updateState({\n        isActive: ctx.isActive,\n        connectionError: error,\n      });\n    };\n\n    builder.onConnect(managed.onConnect);\n    builder.onDisconnect(managed.onDisconnect);\n    builder.onConnectError(managed.onConnectError);\n\n    return connection as T;\n  }\n\n  release(key: string): void {\n    const managed = this.#connections.get(key);\n    if (!managed) {\n      return;\n    }\n\n    managed.refCount -= 1;\n    if (managed.refCount > 0 || managed.pendingRelease) {\n      return;\n    }\n\n    managed.pendingRelease = setTimeout(() => {\n      managed.pendingRelease = null;\n      if (managed.refCount > 0) {\n        return;\n      }\n      if (managed.connection) {\n        if (managed.onConnect) {\n          managed.connection.removeOnConnect(managed.onConnect as any);\n        }\n        if (managed.onDisconnect) {\n          managed.connection.removeOnDisconnect(managed.onDisconnect as any);\n        }\n        if (managed.onConnectError) {\n          managed.connection.removeOnConnectError(\n            managed.onConnectError as any\n          );\n        }\n        managed.connection.disconnect();\n      }\n      this.#connections.delete(key);\n    }, 0);\n  }\n\n  subscribe(key: string, listener: Listener): () => void {\n    const managed = this.#ensureEntry(key);\n    managed.listeners.add(listener);\n    return () => {\n      managed.listeners.delete(listener);\n      if (\n        managed.refCount <= 0 &&\n        managed.listeners.size === 0 &&\n        !managed.connection\n      ) {\n        this.#connections.delete(key);\n      }\n    };\n  }\n\n  getSnapshot(key: string): ConnectionState | undefined {\n    return this.#connections.get(key)?.state;\n  }\n\n  getConnection<T extends DbConnectionImpl<any>>(key: string): T | null {\n    return (this.#connections.get(key)?.connection as T | undefined) ?? null;\n  }\n}\n\nexport const ConnectionManager = new ConnectionManagerImpl();\n","import {\n  DbConnectionBuilder,\n  type DbConnectionImpl,\n} from '../sdk/db_connection_impl';\nimport * as React from 'react';\nimport { SpacetimeDBContext } from './useSpacetimeDB';\nimport type { ConnectionState } from './connection_state';\nimport { ConnectionId } from '../lib/connection_id';\nimport {\n  ConnectionManager,\n  type ConnectionState as ManagerConnectionState,\n} from '../sdk/connection_manager';\n\nexport interface SpacetimeDBProviderProps<\n  DbConnection extends DbConnectionImpl<any>,\n> {\n  connectionBuilder: DbConnectionBuilder<DbConnection>;\n  children?: React.ReactNode;\n}\n\nexport function SpacetimeDBProvider<\n  DbConnection extends DbConnectionImpl<any>,\n>({\n  connectionBuilder,\n  children,\n}: SpacetimeDBProviderProps<DbConnection>): React.JSX.Element {\n  const uri = connectionBuilder.getUri();\n  const moduleName = connectionBuilder.getModuleName();\n  const key = React.useMemo(\n    () => ConnectionManager.getKey(uri, moduleName),\n    [uri, moduleName]\n  );\n\n  const fallbackStateRef = React.useRef<ManagerConnectionState>({\n    isActive: false,\n    identity: undefined,\n    token: undefined,\n    connectionId: ConnectionId.random(),\n    connectionError: undefined,\n  });\n\n  const subscribe = React.useCallback(\n    (onStoreChange: () => void) =>\n      ConnectionManager.subscribe(key, onStoreChange),\n    [key]\n  );\n  const getSnapshot = React.useCallback(\n    () => ConnectionManager.getSnapshot(key) ?? fallbackStateRef.current,\n    [key]\n  );\n  const getServerSnapshot = React.useCallback(\n    () => fallbackStateRef.current,\n    []\n  );\n\n  const state = React.useSyncExternalStore(\n    subscribe,\n    getSnapshot,\n    getServerSnapshot\n  );\n\n  const getConnection = React.useCallback(\n    () => ConnectionManager.getConnection<DbConnection>(key),\n    [key]\n  );\n\n  const contextValue = React.useMemo<ConnectionState>(\n    () => ({ ...state, getConnection }),\n    [state, getConnection]\n  );\n\n  React.useEffect(() => {\n    ConnectionManager.retain(key, connectionBuilder);\n    return () => {\n      ConnectionManager.release(key);\n    };\n  }, [key, connectionBuilder]);\n\n  return React.createElement(\n    SpacetimeDBContext.Provider,\n    { value: contextValue },\n    children\n  );\n}\n","import { useCallback, useEffect, useRef } from 'react';\nimport type { UntypedReducerDef } from '../sdk/reducers';\nimport { useSpacetimeDB } from './useSpacetimeDB';\nimport type { ParamsType } from '../sdk';\n\nexport function useReducer<ReducerDef extends UntypedReducerDef>(\n  reducerDef: ReducerDef\n): (...params: ParamsType<ReducerDef>) => Promise<void> {\n  const { getConnection, isActive } = useSpacetimeDB();\n  const reducerName = reducerDef.accessorName;\n\n  // Holds calls made before the connection exists\n  const queueRef = useRef<\n    {\n      params: ParamsType<ReducerDef>;\n      resolve: () => void;\n      reject: (err: unknown) => void;\n    }[]\n  >([]);\n\n  // Flush when we finally have a connection\n  useEffect(() => {\n    const conn = getConnection();\n    if (!conn) {\n      return;\n    }\n    const fn = (conn.reducers as any)[reducerName] as (\n      ...p: ParamsType<ReducerDef>\n    ) => Promise<void>;\n    if (queueRef.current.length) {\n      const pending = queueRef.current.splice(0);\n      for (const item of pending) {\n        fn(...item.params).then(item.resolve, item.reject);\n      }\n    }\n  }, [getConnection, reducerName, isActive]);\n\n  return useCallback(\n    (...params: ParamsType<ReducerDef>) => {\n      const conn = getConnection();\n      if (!conn) {\n        return new Promise<void>((resolve, reject) => {\n          queueRef.current.push({ params, resolve, reject });\n        });\n      }\n      const fn = (conn.reducers as any)[reducerName] as (\n        ...p: ParamsType<ReducerDef>\n      ) => Promise<void>;\n      return fn(...params);\n    },\n    [getConnection, reducerName]\n  );\n}\n"]}