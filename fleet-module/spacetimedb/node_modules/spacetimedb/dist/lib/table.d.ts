import type { ProcedureExport, ReducerExport, t } from '../server';
import { RawTableDefV10 } from './autogen/types';
import type { AllUnique, ConstraintOpts } from './constraints';
import type { ColumnIndex, IndexColumns, Indexes, IndexOpts, ReadonlyIndexes } from './indexes';
import type { TableSchema } from './table_schema';
import { RowBuilder, type ColumnBuilder, type ColumnMetadata, type InferTypeOfRow, type RowObj, type TypeBuilder } from './type_builders';
import type { InvalidColumnMetadata, Prettify, ValidateColumnMetadata } from './type_util';
export type AlgebraicTypeRef = number;
/**
 * Check if any column in the row has invalid metadata.
 */
type HasInvalidColumn<Row extends RowObj> = (<G>() => G extends Row ? 1 : 2) extends <G>() => G extends RowObj ? 1 : 2 ? false : {
    [K in keyof Row]: Row[K] extends ColumnBuilder<any, any, infer M> ? ValidateColumnMetadata<M> extends InvalidColumnMetadata<any> ? true : false : false;
}[keyof Row] extends false ? false : true;
/**
 * Extract the names of columns that have invalid metadata.
 */
type InvalidColumnNames<Row extends RowObj> = {
    [K in keyof Row]: Row[K] extends ColumnBuilder<any, any, infer M> ? ValidateColumnMetadata<M> extends InvalidColumnMetadata<any> ? K & string : never : never;
}[keyof Row];
/**
 * A descriptive error type that surfaces the validation error.
 * The type name itself contains the error message for better CLI output.
 */
type ERROR_default_cannot_be_combined_with_primaryKey_unique_or_autoInc<InvalidColumns extends string> = {
    _invalidColumns: InvalidColumns;
    _fix: 'Remove either default() or the constraint (primaryKey/unique/autoInc) from these columns';
};
/**
 * A helper type to extract the row type from a TableDef
 */
export type RowType<TableDef extends Pick<UntypedTableDef, 'columns'>> = InferTypeOfRow<TableDef['columns']>;
/**
 * Coerces a column which may be a TypeBuilder or ColumnBuilder into a ColumnBuilder
 */
export type CoerceColumn<Col extends TypeBuilder<any, any> | ColumnBuilder<any, any, any>> = Col extends TypeBuilder<infer T, infer U> ? ColumnBuilder<T, U, ColumnMetadata<any>> : Col;
/**
 * Coerces a RowObj where TypeBuilders are replaced with ColumnBuilders
 */
export type CoerceRow<Row extends RowObj> = {
    [k in keyof Row & string]: CoerceColumn<Row[k]>;
};
/**
 * Helper type to coerce an array of IndexOpts
 */
type CoerceArray<X extends IndexOpts<any>[]> = X;
/**
 * An untyped representation of a table's schema.
 */
export type UntypedTableDef = {
    sourceName: string;
    accessorName: string;
    columns: Record<string, ColumnBuilder<any, any, ColumnMetadata<any>>>;
    rowType: RowBuilder<RowObj>['algebraicType']['value'];
    indexes: readonly IndexOpts<any>[];
    constraints: readonly ConstraintOpts<any>[];
    tableDef: RawTableDefV10;
    isEvent?: boolean;
};
/**
 * A type representing the indexes defined on a table.
 */
export type TableIndexes<TableDef extends UntypedTableDef> = {
    [K in keyof TableDef['columns'] & string as ColumnIndex<K, TableDef['columns'][K]['columnMetadata']> extends never ? never : K]: ColumnIndex<K, TableDef['columns'][K]['columnMetadata']>;
} & {
    [I in TableDef['indexes'][number] as I['accessor'] & {}]: TableIndexFromDef<TableDef, I>;
};
type TableIndexFromDef<TableDef extends UntypedTableDef, I extends IndexOpts<keyof TableDef['columns'] & string>> = NormalizeIndexColumns<TableDef, I> extends infer Cols extends ReadonlyArray<keyof TableDef['columns'] & string> ? {
    name: I['accessor'];
    unique: AllUnique<TableDef, Cols>;
    algorithm: Lowercase<I['algorithm']>;
    columns: Cols;
} : never;
type NormalizeIndexColumns<TableDef extends UntypedTableDef, I extends IndexOpts<keyof TableDef['columns'] & string>> = IndexColumns<I> extends ReadonlyArray<keyof TableDef['columns'] & string> ? IndexColumns<I> : never;
/**
 * Options for configuring a database table.
 * - `name`: The name of the table.
 * - `public`: Whether the table is publicly accessible. Defaults to `false`.
 * - `indexes`: An array of index configurations for the table.
 * - `constraints`: An array of constraint configurations for the table.
 * - `scheduled`: The name of the reducer to be executed based on the scheduled rows in this table.
 */
export type TableOpts<Row extends RowObj> = {
    name?: string;
    public?: boolean;
    indexes?: IndexOpts<keyof Row & string>[];
    constraints?: ConstraintOpts<keyof Row & string>[];
    scheduled?: () => ReducerExport<any, {
        [k: string]: RowBuilder<RowObj>;
    }> | ProcedureExport<any, {
        [k: string]: RowBuilder<RowObj>;
    }, ReturnType<typeof t.unit>>;
    event?: boolean;
};
/**
 * Extracts the indices from TableOpts, defaulting to an empty array if none are provided.
 */
type OptsIndices<Opts extends TableOpts<any>> = Opts extends {
    indexes: infer Ixs extends NonNullable<any[]>;
} ? Ixs : CoerceArray<[]>;
/**
 * Table<Row, UniqueConstraintViolation = never, AutoIncOverflow = never>
 *
 * - Row: row shape
 * - UCV: unique-constraint violation error type (never if none)
 * - AIO: auto-increment overflow error type (never if none)
 */
export type Table<TableDef extends UntypedTableDef> = Prettify<TableMethods<TableDef> & Indexes<TableDef, TableIndexes<TableDef>>>;
export type ReadonlyTable<TableDef extends UntypedTableDef> = Prettify<ReadonlyTableMethods<TableDef> & ReadonlyIndexes<TableDef, TableIndexes<TableDef>>>;
export interface ReadonlyTableMethods<TableDef extends UntypedTableDef> {
    /** Returns the number of rows in the TX state. */
    count(): bigint;
    /** Iterate over all rows in the TX state. Rust Iterator<Item=Row> â†’ TS IterableIterator<Row>. */
    iter(): IteratorObject<Prettify<RowType<TableDef>>, undefined>;
    [Symbol.iterator](): IteratorObject<Prettify<RowType<TableDef>>, undefined>;
}
/**
 * A type representing the methods available on a table.
 */
export interface TableMethods<TableDef extends UntypedTableDef> extends ReadonlyTableMethods<TableDef> {
    /**
     * Insert and return the inserted row (auto-increment fields filled).
     *
     * May throw on error:
     * * If there are any unique or primary key columns in this table, may throw {@link errors.UniqueAlreadyExists}.
     * * If there are any auto-incrementing columns in this table, may throw {@link errors.AutoIncOverflow}.
     * */
    insert(row: Prettify<RowType<TableDef>>): Prettify<RowType<TableDef>>;
    /** Delete a row equal to `row`. Returns true if something was deleted. */
    delete(row: Prettify<RowType<TableDef>>): boolean;
}
/**
 * Defines a database table with schema and options.
 *
 * @param opts - Table configuration including name, indexes, and access control
 * @param row - Product type defining the table's row structure
 * @returns Table handle for use in schema() function
 *
 * @example
 * ```ts
 * const playerTable = table(
 *   { name: 'player', public: true },
 *   {
 *     id: t.u32().primaryKey(),
 *     name: t.string().index('btree')
 *   }
 * );
 * ```
 *
 * ## Column Validation Error
 *
 * **If you see an error like "Expected 3 arguments, but got 2"**, this means
 * one of your columns has an invalid combination of attributes.
 *
 * Specifically, `default()` cannot be combined with:
 * - `primaryKey()`
 * - `unique()`
 * - `autoInc()`
 *
 * **Example of invalid code:**
 * ```ts
 * // ERROR: default() + primaryKey() is not allowed
 * const badTable = table(
 *   { name: 'bad' },
 *   { id: t.u64().default(0n).primaryKey() }  // <- This causes "Expected 3 arguments"
 * );
 * ```
 *
 * **How to fix:** Remove either `default()` or the constraint (`primaryKey`/`unique`/`autoInc`).
 */
export declare function table<Row extends RowObj, const Opts extends TableOpts<Row>>(opts: Opts, row: Row | RowBuilder<Row>, ..._: HasInvalidColumn<Row> extends true ? [
    error: ERROR_default_cannot_be_combined_with_primaryKey_unique_or_autoInc<InvalidColumnNames<Row>>
] : []): TableSchema<CoerceRow<Row>, OptsIndices<Opts>>;
export {};
//# sourceMappingURL=table.d.ts.map