import type { RowType, UntypedTableDef } from './table';
import { Uuid } from './uuid';
export type Value = string | number | boolean | Uuid;
export type Expr<Column extends string> = {
    type: 'eq';
    key: Column;
    value: Value;
} | {
    type: 'and';
    children: Expr<Column>[];
} | {
    type: 'or';
    children: Expr<Column>[];
};
export declare const eq: <Column extends string>(key: Column, value: Value) => Expr<Column>;
export declare const and: <Column extends string>(...children: Expr<Column>[]) => Expr<Column>;
export declare const or: <Column extends string>(...children: Expr<Column>[]) => Expr<Column>;
export declare const isEq: <Column extends string>(e: Expr<Column>) => e is Extract<Expr<Column>, {
    type: "eq";
}>;
export declare const isAnd: <Column extends string>(e: Expr<Column>) => e is Extract<Expr<Column>, {
    type: "and";
}>;
export declare const isOr: <Column extends string>(e: Expr<Column>) => e is Extract<Expr<Column>, {
    type: "or";
}>;
export declare function evaluate<Column extends string>(expr: Expr<Column>, row: Record<Column, any>): boolean;
export declare function toString<TableDef extends UntypedTableDef>(tableDef: TableDef, expr: Expr<ColumnsFromRow<RowType<TableDef>>>): string;
/**
 * This is just the identity function to make things look like SQL.
 * @param expr
 * @returns
 */
export declare function where<Column extends string>(expr: Expr<Column>): Expr<Column>;
type MembershipChange = 'enter' | 'leave' | 'stayIn' | 'stayOut';
export declare function classifyMembership<Col extends string, R extends Record<string, unknown>>(where: Expr<Col> | undefined, oldRow: R, newRow: R): MembershipChange;
/**
 * Extracts the column names from a RowType whose values are of type Value.
 * Note that this will exclude columns that are of type object, array, etc.
 */
export type ColumnsFromRow<R> = {
    [K in keyof R]-?: R[K] extends Value | undefined ? K : never;
}[keyof R] & string;
export {};
//# sourceMappingURL=filter.d.ts.map