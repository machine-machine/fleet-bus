import { ConnectionId } from './connection_id';
import { Identity } from './identity';
import type { ColumnIndex, IndexColumns, IndexOpts } from './indexes';
import type { UntypedSchemaDef } from './schema';
import type { UntypedTableSchema } from './table_schema';
import { Timestamp } from './timestamp';
import type { ColumnBuilder, ColumnMetadata, RowBuilder, TypeBuilder } from './type_builders';
import type { Values } from './type_util';
/**
 * Helper to get the set of table names.
 */
export type TableNames<SchemaDef extends UntypedSchemaDef> = Values<SchemaDef['tables']>['accessorName'] & string;
/** helper: pick the table def object from the schema by its name */
export type TableDefByName<SchemaDef extends UntypedSchemaDef, Name extends TableNames<SchemaDef>> = Extract<Values<SchemaDef['tables']>, {
    accessorName: Name;
}>;
declare const QueryBrand: unique symbol;
export interface TableTypedQuery<TableDef extends TypedTableDef> {
    readonly [QueryBrand]: true;
    readonly __table?: TableDef;
}
export interface RowTypedQuery<Row, ST> {
    readonly [QueryBrand]: true;
    readonly __row?: Row;
    readonly __algebraicType?: ST;
}
export type Query<TableDef extends TypedTableDef> = RowTypedQuery<RowType<TableDef>, TableDef['rowType']>;
export declare const isRowTypedQuery: (val: unknown) => val is RowTypedQuery<any, any>;
export declare const isTypedQuery: (val: unknown) => val is TableTypedQuery<any>;
export declare function toSql(q: Query<any>): string;
type From<TableDef extends TypedTableDef> = RowTypedQuery<RowType<TableDef>, TableDef['rowType']> & Readonly<{
    toSql(): string;
    where(predicate: (row: RowExpr<TableDef>) => BooleanExpr<TableDef>): From<TableDef>;
    rightSemijoin<RightTable extends TypedTableDef>(other: TableRef<RightTable>, on: (left: IndexedRowExpr<TableDef>, right: IndexedRowExpr<RightTable>) => BooleanExpr<TableDef | RightTable>): SemijoinBuilder<RightTable>;
    leftSemijoin<RightTable extends TypedTableDef>(other: TableRef<RightTable>, on: (left: IndexedRowExpr<TableDef>, right: IndexedRowExpr<RightTable>) => BooleanExpr<TableDef | RightTable>): SemijoinBuilder<TableDef>;
    /** @deprecated No longer needed — builder is already a valid query. */
    build(): Query<TableDef>;
}>;
type SemijoinBuilder<TableDef extends TypedTableDef> = RowTypedQuery<RowType<TableDef>, TableDef['rowType']> & Readonly<{
    toSql(): string;
    where(predicate: (row: RowExpr<TableDef>) => BooleanExpr<TableDef>): SemijoinBuilder<TableDef>;
    /** @deprecated No longer needed — builder is already a valid query. */
    build(): Query<TableDef>;
}>;
export type QueryBuilder<SchemaDef extends UntypedSchemaDef> = {
    readonly [Tbl in Values<SchemaDef['tables']> as Tbl['accessorName']]: TableRef<Tbl> & From<Tbl>;
} & {};
/**
 * A runtime reference to a table. This materializes the RowExpr for us.
 * TODO: Maybe add the full SchemaDef to the type signature depending on how joins will work.
 */
export type TableRef<TableDef extends TypedTableDef> = Readonly<{
    type: 'table';
    sourceName: TableDef['sourceName'];
    accessorName: string;
    cols: RowExpr<TableDef>;
    indexedCols: IndexedRowExpr<TableDef>;
    tableDef: TableDef;
    columns: TableDef['columns'];
    indexes: TableDef['indexes'];
    rowType: TableDef['rowType'];
    constraints: any;
}>;
export declare function createTableRefFromDef<TableDef extends TypedTableDef>(tableDef: TableDef): TableRef<TableDef>;
export declare function makeQueryBuilder<SchemaDef extends UntypedSchemaDef>(schema: SchemaDef): QueryBuilder<SchemaDef>;
export type TypedTableDef<Columns extends Record<string, ColumnBuilder<any, any, ColumnMetadata<any>>> = Record<string, ColumnBuilder<any, any, ColumnMetadata<any>>>> = {
    sourceName: string;
    accessorName: string;
    columns: Columns;
    indexes: readonly IndexOpts<any>[];
    rowType: RowBuilder<Columns>['algebraicType']['value'];
};
export type TableSchemaAsTableDef<TSchema extends UntypedTableSchema> = {
    name: TSchema['tableName'];
    columns: TSchema['rowType']['row'];
    indexes: TSchema['idxs'];
};
type RowType<TableDef extends TypedTableDef> = {
    [K in keyof TableDef['columns']]: TableDef['columns'][K] extends ColumnBuilder<infer T, any, any> ? T : never;
};
export type ColumnExpr<TableDef extends TypedTableDef, ColumnName extends ColumnNames<TableDef>> = ColumnExpression<TableDef, ColumnName>;
type ColumnSpacetimeType<Col extends ColumnExpr<any, any>> = Col extends ColumnExpr<infer T, infer N> ? InferSpacetimeTypeOfColumn<T, N> : never;
type ColumnSameSpacetime<ThisTable extends TypedTableDef, ThisCol extends ColumnNames<ThisTable>, OtherCol extends ColumnExpr<any, any>> = [InferSpacetimeTypeOfColumn<ThisTable, ThisCol>] extends [
    ColumnSpacetimeType<OtherCol>
] ? [ColumnSpacetimeType<OtherCol>] extends [
    InferSpacetimeTypeOfColumn<ThisTable, ThisCol>
] ? OtherCol : never : never;
type ExtractTable<Col extends ColumnExpr<any, any>> = Col extends ColumnExpr<infer T, any> ? T : never;
export declare class ColumnExpression<TableDef extends TypedTableDef, ColumnName extends ColumnNames<TableDef>> {
    readonly type: "column";
    readonly column: ColumnName;
    readonly table: TableDef['sourceName'];
    readonly tsValueType?: RowType<TableDef>[ColumnName];
    readonly spacetimeType: InferSpacetimeTypeOfColumn<TableDef, ColumnName>;
    constructor(table: TableDef['sourceName'], column: ColumnName, spacetimeType: InferSpacetimeTypeOfColumn<TableDef, ColumnName>);
    eq(literal: LiteralValue & RowType<TableDef>[ColumnName]): BooleanExpr<TableDef>;
    eq<OtherCol extends ColumnExpr<any, any>>(value: ColumnSameSpacetime<TableDef, ColumnName, OtherCol>): BooleanExpr<TableDef | ExtractTable<OtherCol>>;
    ne(literal: LiteralValue & RowType<TableDef>[ColumnName]): BooleanExpr<TableDef>;
    ne<OtherCol extends ColumnExpr<any, any>>(value: ColumnSameSpacetime<TableDef, ColumnName, OtherCol>): BooleanExpr<TableDef | ExtractTable<OtherCol>>;
    lt(literal: LiteralValue & RowType<TableDef>[ColumnName]): BooleanExpr<TableDef>;
    lt<OtherCol extends ColumnExpr<any, any>>(value: ColumnSameSpacetime<TableDef, ColumnName, OtherCol>): BooleanExpr<TableDef | ExtractTable<OtherCol>>;
    lte(literal: LiteralValue & RowType<TableDef>[ColumnName]): BooleanExpr<TableDef>;
    lte<OtherCol extends ColumnExpr<any, any>>(value: ColumnSameSpacetime<TableDef, ColumnName, OtherCol>): BooleanExpr<TableDef | ExtractTable<OtherCol>>;
    gt(literal: LiteralValue & RowType<TableDef>[ColumnName]): BooleanExpr<TableDef>;
    gt<OtherCol extends ColumnExpr<any, any>>(value: ColumnSameSpacetime<TableDef, ColumnName, OtherCol>): BooleanExpr<TableDef | ExtractTable<OtherCol>>;
    gte(literal: LiteralValue & RowType<TableDef>[ColumnName]): BooleanExpr<TableDef>;
    gte<OtherCol extends ColumnExpr<any, any>>(value: ColumnSameSpacetime<TableDef, ColumnName, OtherCol>): BooleanExpr<TableDef | ExtractTable<OtherCol>>;
}
/**
 * Helper to get the spacetime type of a column.
 */
type InferSpacetimeTypeOfColumn<TableDef extends TypedTableDef, ColumnName extends ColumnNames<TableDef>> = TableDef['columns'][ColumnName]['typeBuilder'] extends TypeBuilder<any, infer U> ? U : never;
type ColumnNames<TableDef extends TypedTableDef> = keyof RowType<TableDef> & string;
type FirstIndexColumn<I extends IndexOpts<any>> = IndexColumns<I> extends readonly [infer Head extends string, ...infer _Rest] ? Head : never;
type ExplicitIndexedColumns<TableDef extends TypedTableDef> = TableDef['indexes'][number] extends infer I ? I extends IndexOpts<ColumnNames<TableDef>> ? FirstIndexColumn<I> & ColumnNames<TableDef> : never : never;
type MetadataIndexedColumns<TableDef extends TypedTableDef> = {
    [K in ColumnNames<TableDef>]: ColumnIndex<K, TableDef['columns'][K]['columnMetadata']> extends never ? never : K;
}[ColumnNames<TableDef>];
export type IndexedColumnNames<TableDef extends TypedTableDef> = ExplicitIndexedColumns<TableDef> | MetadataIndexedColumns<TableDef>;
export type IndexedRowExpr<TableDef extends TypedTableDef> = Readonly<{
    readonly [C in IndexedColumnNames<TableDef>]: ColumnExpr<TableDef, C>;
}>;
/**
 * Acts as a row when writing filters for queries. It is a way to get column references.
 */
export type RowExpr<TableDef extends TypedTableDef> = Readonly<{
    readonly [C in ColumnNames<TableDef>]: ColumnExpr<TableDef, C>;
}>;
/**
 * Union of ColumnExprs from Table whose spacetimeType is compatible with Value
 * (produces a union of ColumnExpr<Table, C> for matching columns).
 */
export type ColumnExprForValue<Table extends TypedTableDef, Value> = {
    [C in ColumnNames<Table>]: InferSpacetimeTypeOfColumn<Table, C> extends Value ? ColumnExpr<Table, C> : never;
}[ColumnNames<Table>];
type LiteralValue = string | number | bigint | boolean | Identity | Timestamp | ConnectionId;
export type ValueExpr<TableDef extends TypedTableDef, Value> = LiteralExpr<Value & LiteralValue> | ColumnExprForValue<TableDef, Value>;
type LiteralExpr<Value> = {
    type: 'literal';
    value: Value;
};
export declare function literal<Value extends LiteralValue>(value: Value): ValueExpr<never, Value>;
type BooleanExprData<Table extends TypedTableDef> = ({
    type: 'eq' | 'ne' | 'gt' | 'lt' | 'gte' | 'lte';
    left: ValueExpr<Table, any>;
    right: ValueExpr<Table, any>;
} | {
    type: 'and';
    clauses: readonly [
        BooleanExprData<Table>,
        BooleanExprData<Table>,
        ...BooleanExprData<Table>[]
    ];
} | {
    type: 'or';
    clauses: readonly [
        BooleanExprData<Table>,
        BooleanExprData<Table>,
        ...BooleanExprData<Table>[]
    ];
} | {
    type: 'not';
    clause: BooleanExprData<Table>;
}) & {
    _tableType?: Table;
};
export declare class BooleanExpr<Table extends TypedTableDef> {
    readonly data: BooleanExprData<Table>;
    constructor(data: BooleanExprData<Table>);
    and(other: BooleanExpr<Table>): BooleanExpr<Table>;
    or(other: BooleanExpr<Table>): BooleanExpr<Table>;
    not(): BooleanExpr<Table>;
}
export declare function not<T extends TypedTableDef>(clause: BooleanExpr<T>): BooleanExpr<T>;
export declare function and<T extends TypedTableDef>(...clauses: readonly [BooleanExpr<T>, BooleanExpr<T>, ...BooleanExpr<T>[]]): BooleanExpr<T>;
export declare function or<T extends TypedTableDef>(...clauses: readonly [BooleanExpr<T>, BooleanExpr<T>, ...BooleanExpr<T>[]]): BooleanExpr<T>;
/**
 * Evaluate a BooleanExpr against a row at runtime for client-side filtering.
 */
export declare function evaluateBooleanExpr(expr: BooleanExpr<any>, row: Record<string, any>): boolean;
export declare function toComparableValue(value: any): any;
/**
 * Extract the table name from a query builder expression.
 */
export declare function getQueryTableName(query: any): string;
/**
 * Extract the accessor name from a query builder expression.
 */
export declare function getQueryAccessorName(query: any): string;
/**
 * Extract the BooleanExpr from a query builder, if any.
 */
export declare function getQueryWhereClause(query: any): BooleanExpr<any> | undefined;
export {};
//# sourceMappingURL=query.d.ts.map