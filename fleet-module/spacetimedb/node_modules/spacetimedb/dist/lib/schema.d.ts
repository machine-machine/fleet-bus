import { AlgebraicType, type AlgebraicTypeType } from './algebraic_type';
import type { CaseConversionPolicy, RawModuleDefV10, RawModuleDefV10Section, RawScopedTypeNameV10, RawTableDefV10 } from './autogen/types';
import type { UntypedTableDef } from './table';
import type { UntypedTableSchema } from './table_schema';
import { ProductBuilder, RefBuilder, RowBuilder, SumBuilder, TypeBuilder, type Infer, type InferSpacetimeTypeOfTypeBuilder } from './type_builders';
import type { Values } from './type_util';
export type TableNamesOf<S extends UntypedSchemaDef> = Values<S['tables']>['accessorName'];
/**
 * An untyped representation of the database schema.
 */
export type UntypedSchemaDef = {
    tables: Record<string, UntypedTableDef>;
};
/**
 * Helper type to convert an array of TableSchema into a schema definition
 */
export interface TablesToSchema<T extends Record<string, UntypedTableSchema>> extends UntypedSchemaDef {
    tables: {
        readonly [AccName in keyof T & string]: TableToSchema<AccName, T[AccName]>;
    };
}
export interface TableToSchema<AccName extends string, T extends UntypedTableSchema> extends UntypedTableDef {
    accessorName: AccName;
    columns: T['rowType']['row'];
    rowType: T['rowSpacetimeType'];
    indexes: T['idxs'];
    constraints: T['constraints'];
}
export declare function tablesToSchema<const T extends Record<string, UntypedTableSchema>>(ctx: ModuleContext, tables: T): TablesToSchema<T>;
export declare function tableToSchema<AccName extends string, const T extends UntypedTableSchema>(accName: AccName, schema: T, tableDef: RawTableDefV10): TableToSchema<AccName, T>;
export type ModuleDef = {
    [S in RawModuleDefV10Section as Uncapitalize<S['tag']>]: S['value'];
};
export declare class ModuleContext {
    #private;
    get moduleDef(): ModuleDef;
    rawModuleDefV10(): RawModuleDefV10;
    /**
     * Set the case conversion policy for this module.
     * Called by the settings mechanism.
     */
    setCaseConversionPolicy(policy: CaseConversionPolicy): void;
    get typespace(): {
        readonly types: ({
            tag: "Ref";
            value: number;
        } | {
            tag: "Sum";
            value: import("./algebraic_type").SumTypeType;
        } | {
            tag: "Product";
            value: import("./algebraic_type").ProductTypeType;
        } | {
            tag: "Array";
            value: AlgebraicTypeType;
        } | {
            tag: "String";
        } | {
            tag: "Bool";
        } | {
            tag: "I8";
        } | {
            tag: "U8";
        } | {
            tag: "I16";
        } | {
            tag: "U16";
        } | {
            tag: "I32";
        } | {
            tag: "U32";
        } | {
            tag: "I64";
        } | {
            tag: "U64";
        } | {
            tag: "I128";
        } | {
            tag: "U128";
        } | {
            tag: "I256";
        } | {
            tag: "U256";
        } | {
            tag: "F32";
        } | {
            tag: "F64";
        })[];
    };
    /**
     * Resolves the actual type of a TypeBuilder by following its references until it reaches a non-ref type.
     * @param typespace The typespace to resolve types against.
     * @param typeBuilder The TypeBuilder to resolve.
     * @returns The resolved algebraic type.
     */
    resolveType<AT extends AlgebraicTypeType>(typeBuilder: RefBuilder<any, AT>): AT;
    /**
     * Adds a type to the module definition's typespace as a `Ref` if it is a named compound type (Product or Sum).
     * Otherwise, returns the type as is.
     * @param name
     * @param ty
     * @returns
     */
    registerTypesRecursively<T extends TypeBuilder<any, AlgebraicType>>(typeBuilder: T): T extends SumBuilder<any> | ProductBuilder<any> | RowBuilder<any> ? RefBuilder<Infer<T>, InferSpacetimeTypeOfTypeBuilder<T>> : T;
}
export declare function splitName(name: string): RawScopedTypeNameV10;
//# sourceMappingURL=schema.d.ts.map