import { type AlgebraicTypeVariants, type Deserializer, type Serializer } from '../lib/algebraic_type';
import type { Identity } from '../lib/identity';
import type { OptionAlgebraicType } from '../lib/option';
import type { ParamsObj } from '../lib/reducers';
import { type UntypedSchemaDef } from '../lib/schema';
import { type Infer, type InferSpacetimeTypeOfTypeBuilder, type InferTypeOfRow, type TypeBuilder } from '../lib/type_builders';
import type { ReadonlyDbView } from './db_view';
import { type QueryBuilder, type RowTypedQuery } from './query';
import { type ModuleExport, type SchemaInner } from './schema';
export type ViewExport<ViewFn> = ViewFn & ModuleExport;
export declare function makeViewExport<S extends UntypedSchemaDef, Params extends ParamsObj, Ret extends ViewReturnTypeBuilder, F extends ViewFn<S, Params, Ret>>(ctx: SchemaInner, opts: ViewOpts, params: Params, ret: Ret, fn: F): ViewExport<F>;
export declare function makeAnonViewExport<S extends UntypedSchemaDef, Params extends ParamsObj, Ret extends ViewReturnTypeBuilder, F extends AnonymousViewFn<S, Params, Ret>>(ctx: SchemaInner, opts: ViewOpts, params: Params, ret: Ret, fn: F): ViewExport<F>;
export type ViewCtx<S extends UntypedSchemaDef> = Readonly<{
    sender: Identity;
    db: ReadonlyDbView<S>;
    from: QueryBuilder<S>;
}>;
export type AnonymousViewCtx<S extends UntypedSchemaDef> = Readonly<{
    db: ReadonlyDbView<S>;
    from: QueryBuilder<S>;
}>;
export type ViewOpts = {
    name?: string;
    public: true;
};
type FlattenedArray<T> = T extends readonly (infer E)[] ? E : never;
export type ViewFn<S extends UntypedSchemaDef, Params extends ParamsObj, Ret extends ViewReturnTypeBuilder> = ((ctx: ViewCtx<S>, params: InferTypeOfRow<Params>) => Infer<Ret>) | ((ctx: ViewCtx<S>, params: InferTypeOfRow<Params>) => RowTypedQuery<FlattenedArray<Infer<Ret>>, ExtractArrayProduct<Ret>>);
export type AnonymousViewFn<S extends UntypedSchemaDef, Params extends ParamsObj, Ret extends ViewReturnTypeBuilder> = ((ctx: AnonymousViewCtx<S>, params: InferTypeOfRow<Params>) => Infer<Ret>) | ((ctx: AnonymousViewCtx<S>, params: InferTypeOfRow<Params>) => RowTypedQuery<FlattenedArray<Infer<Ret>>, ExtractArrayProduct<Ret>>);
export type ViewReturnTypeBuilder = TypeBuilder<readonly object[], {
    tag: 'Array';
    value: AlgebraicTypeVariants.Product;
}> | TypeBuilder<object | undefined, OptionAlgebraicType<AlgebraicTypeVariants.Product>>;
export declare function registerView<S extends UntypedSchemaDef, const Anonymous extends boolean, Params extends ParamsObj, Ret extends ViewReturnTypeBuilder>(ctx: SchemaInner, opts: ViewOpts, exportName: string, anon: Anonymous, params: Params, ret: Ret, fn: Anonymous extends true ? AnonymousViewFn<S, Params, Ret> : ViewFn<S, Params, Ret>): void;
type ViewInfo<F> = {
    fn: F;
    deserializeParams: Deserializer<any>;
    serializeReturn: Serializer<any>;
    returnTypeBaseSize: number;
};
export type Views = ViewInfo<ViewFn<any, any, any>>[];
export type AnonViews = ViewInfo<AnonymousViewFn<any, any, any>>[];
type ExtractArrayProduct<T extends TypeBuilder<any, any>> = InferSpacetimeTypeOfTypeBuilder<T> extends {
    tag: 'Array';
    value: infer V;
} ? V extends {
    tag: 'Product';
    value: infer P;
} ? P : never : never;
export {};
//# sourceMappingURL=views.d.ts.map