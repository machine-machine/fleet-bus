{"version":3,"sources":["../../../../node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js","../../../../node_modules/.pnpm/statuses@2.0.2/node_modules/statuses/codes.json","../../../../node_modules/.pnpm/statuses@2.0.2/node_modules/statuses/index.js","../../src/util-stub.ts","../../../../node_modules/.pnpm/object-inspect@1.13.4/node_modules/object-inspect/util.inspect.js","../../../../node_modules/.pnpm/object-inspect@1.13.4/node_modules/object-inspect/index.js","../../src/lib/time_duration.ts","../../src/lib/timestamp.ts","../../src/lib/uuid.ts","../../src/lib/binary_reader.ts","../../src/lib/binary_writer.ts","../../src/lib/util.ts","../../src/lib/connection_id.ts","../../src/lib/identity.ts","../../src/lib/algebraic_type.ts","../../src/lib/option.ts","../../src/lib/result.ts","../../src/lib/schedule_at.ts","../../src/lib/type_util.ts","../../src/lib/type_builders.ts","../../src/lib/autogen/types.ts","../../src/lib/schema.ts","../../src/server/http_internal.ts","../../src/server/range.ts","../../src/lib/table.ts","../../src/lib/query.ts","../../src/server/views.ts","../../src/lib/errors.ts","../../src/server/errors.ts","../../../../node_modules/.pnpm/pure-rand@7.0.1/node_modules/pure-rand/lib/esm/distribution/UnsafeUniformBigIntDistribution.js","../../../../node_modules/.pnpm/pure-rand@7.0.1/node_modules/pure-rand/lib/esm/distribution/internals/UnsafeUniformIntDistributionInternal.js","../../../../node_modules/.pnpm/pure-rand@7.0.1/node_modules/pure-rand/lib/esm/distribution/internals/ArrayInt64.js","../../../../node_modules/.pnpm/pure-rand@7.0.1/node_modules/pure-rand/lib/esm/distribution/internals/UnsafeUniformArrayIntDistributionInternal.js","../../../../node_modules/.pnpm/pure-rand@7.0.1/node_modules/pure-rand/lib/esm/distribution/UnsafeUniformIntDistribution.js","../../../../node_modules/.pnpm/pure-rand@7.0.1/node_modules/pure-rand/lib/esm/generator/XoroShiro.js","../../src/server/rng.ts","../../src/server/runtime.ts","../../src/server/procedures.ts","../../src/server/reducers.ts","../../src/server/schema.ts","../../src/server/console.ts","../../src/server/polyfills.ts"],"names":["fromByteArray","len","i","len2","status","codes","inspect","hasOwn","body","t","name","variants","isUnit","AlgebraicType","SumType","ProductType","schema","table","ctx","ret","XoroShiro128Plus","freeze","v","console"],"mappings":"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","file":"index.mjs","sourcesContent":["'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n","{\n  \"100\": \"Continue\",\n  \"101\": \"Switching Protocols\",\n  \"102\": \"Processing\",\n  \"103\": \"Early Hints\",\n  \"200\": \"OK\",\n  \"201\": \"Created\",\n  \"202\": \"Accepted\",\n  \"203\": \"Non-Authoritative Information\",\n  \"204\": \"No Content\",\n  \"205\": \"Reset Content\",\n  \"206\": \"Partial Content\",\n  \"207\": \"Multi-Status\",\n  \"208\": \"Already Reported\",\n  \"226\": \"IM Used\",\n  \"300\": \"Multiple Choices\",\n  \"301\": \"Moved Permanently\",\n  \"302\": \"Found\",\n  \"303\": \"See Other\",\n  \"304\": \"Not Modified\",\n  \"305\": \"Use Proxy\",\n  \"307\": \"Temporary Redirect\",\n  \"308\": \"Permanent Redirect\",\n  \"400\": \"Bad Request\",\n  \"401\": \"Unauthorized\",\n  \"402\": \"Payment Required\",\n  \"403\": \"Forbidden\",\n  \"404\": \"Not Found\",\n  \"405\": \"Method Not Allowed\",\n  \"406\": \"Not Acceptable\",\n  \"407\": \"Proxy Authentication Required\",\n  \"408\": \"Request Timeout\",\n  \"409\": \"Conflict\",\n  \"410\": \"Gone\",\n  \"411\": \"Length Required\",\n  \"412\": \"Precondition Failed\",\n  \"413\": \"Payload Too Large\",\n  \"414\": \"URI Too Long\",\n  \"415\": \"Unsupported Media Type\",\n  \"416\": \"Range Not Satisfiable\",\n  \"417\": \"Expectation Failed\",\n  \"418\": \"I'm a Teapot\",\n  \"421\": \"Misdirected Request\",\n  \"422\": \"Unprocessable Entity\",\n  \"423\": \"Locked\",\n  \"424\": \"Failed Dependency\",\n  \"425\": \"Too Early\",\n  \"426\": \"Upgrade Required\",\n  \"428\": \"Precondition Required\",\n  \"429\": \"Too Many Requests\",\n  \"431\": \"Request Header Fields Too Large\",\n  \"451\": \"Unavailable For Legal Reasons\",\n  \"500\": \"Internal Server Error\",\n  \"501\": \"Not Implemented\",\n  \"502\": \"Bad Gateway\",\n  \"503\": \"Service Unavailable\",\n  \"504\": \"Gateway Timeout\",\n  \"505\": \"HTTP Version Not Supported\",\n  \"506\": \"Variant Also Negotiates\",\n  \"507\": \"Insufficient Storage\",\n  \"508\": \"Loop Detected\",\n  \"509\": \"Bandwidth Limit Exceeded\",\n  \"510\": \"Not Extended\",\n  \"511\": \"Network Authentication Required\"\n}\n","/*!\n * statuses\n * Copyright(c) 2014 Jonathan Ong\n * Copyright(c) 2016 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar codes = require('./codes.json')\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = status\n\n// status code to message map\nstatus.message = codes\n\n// status message (lower-case) to code map\nstatus.code = createMessageToStatusCodeMap(codes)\n\n// array of status codes\nstatus.codes = createStatusCodeList(codes)\n\n// status codes for redirects\nstatus.redirect = {\n  300: true,\n  301: true,\n  302: true,\n  303: true,\n  305: true,\n  307: true,\n  308: true\n}\n\n// status codes for empty bodies\nstatus.empty = {\n  204: true,\n  205: true,\n  304: true\n}\n\n// status codes for when you should retry the request\nstatus.retry = {\n  502: true,\n  503: true,\n  504: true\n}\n\n/**\n * Create a map of message to status code.\n * @private\n */\n\nfunction createMessageToStatusCodeMap (codes) {\n  var map = {}\n\n  Object.keys(codes).forEach(function forEachCode (code) {\n    var message = codes[code]\n    var status = Number(code)\n\n    // populate map\n    map[message.toLowerCase()] = status\n  })\n\n  return map\n}\n\n/**\n * Create a list of all status codes.\n * @private\n */\n\nfunction createStatusCodeList (codes) {\n  return Object.keys(codes).map(function mapCode (code) {\n    return Number(code)\n  })\n}\n\n/**\n * Get the status code for given message.\n * @private\n */\n\nfunction getStatusCode (message) {\n  var msg = message.toLowerCase()\n\n  if (!Object.prototype.hasOwnProperty.call(status.code, msg)) {\n    throw new Error('invalid status message: \"' + message + '\"')\n  }\n\n  return status.code[msg]\n}\n\n/**\n * Get the status message for given code.\n * @private\n */\n\nfunction getStatusMessage (code) {\n  if (!Object.prototype.hasOwnProperty.call(status.message, code)) {\n    throw new Error('invalid status code: ' + code)\n  }\n\n  return status.message[code]\n}\n\n/**\n * Get the status code.\n *\n * Given a number, this will throw if it is not a known status\n * code, otherwise the code will be returned. Given a string,\n * the string will be parsed for a number and return the code\n * if valid, otherwise will lookup the code assuming this is\n * the status message.\n *\n * @param {string|number} code\n * @returns {number}\n * @public\n */\n\nfunction status (code) {\n  if (typeof code === 'number') {\n    return getStatusMessage(code)\n  }\n\n  if (typeof code !== 'string') {\n    throw new TypeError('code must be a number or string')\n  }\n\n  // '403'\n  var n = parseInt(code, 10)\n  if (!isNaN(n)) {\n    return getStatusMessage(n)\n  }\n\n  return getStatusCode(code)\n}\n","export const inspect = {};\n","module.exports = require('util').inspect;\n","var hasMap = typeof Map === 'function' && Map.prototype;\nvar mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, 'size') : null;\nvar mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === 'function' ? mapSizeDescriptor.get : null;\nvar mapForEach = hasMap && Map.prototype.forEach;\nvar hasSet = typeof Set === 'function' && Set.prototype;\nvar setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, 'size') : null;\nvar setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === 'function' ? setSizeDescriptor.get : null;\nvar setForEach = hasSet && Set.prototype.forEach;\nvar hasWeakMap = typeof WeakMap === 'function' && WeakMap.prototype;\nvar weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;\nvar hasWeakSet = typeof WeakSet === 'function' && WeakSet.prototype;\nvar weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;\nvar hasWeakRef = typeof WeakRef === 'function' && WeakRef.prototype;\nvar weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;\nvar booleanValueOf = Boolean.prototype.valueOf;\nvar objectToString = Object.prototype.toString;\nvar functionToString = Function.prototype.toString;\nvar $match = String.prototype.match;\nvar $slice = String.prototype.slice;\nvar $replace = String.prototype.replace;\nvar $toUpperCase = String.prototype.toUpperCase;\nvar $toLowerCase = String.prototype.toLowerCase;\nvar $test = RegExp.prototype.test;\nvar $concat = Array.prototype.concat;\nvar $join = Array.prototype.join;\nvar $arrSlice = Array.prototype.slice;\nvar $floor = Math.floor;\nvar bigIntValueOf = typeof BigInt === 'function' ? BigInt.prototype.valueOf : null;\nvar gOPS = Object.getOwnPropertySymbols;\nvar symToString = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? Symbol.prototype.toString : null;\nvar hasShammedSymbols = typeof Symbol === 'function' && typeof Symbol.iterator === 'object';\n// ie, `has-tostringtag/shams\nvar toStringTag = typeof Symbol === 'function' && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? 'object' : 'symbol')\n    ? Symbol.toStringTag\n    : null;\nvar isEnumerable = Object.prototype.propertyIsEnumerable;\n\nvar gPO = (typeof Reflect === 'function' ? Reflect.getPrototypeOf : Object.getPrototypeOf) || (\n    [].__proto__ === Array.prototype // eslint-disable-line no-proto\n        ? function (O) {\n            return O.__proto__; // eslint-disable-line no-proto\n        }\n        : null\n);\n\nfunction addNumericSeparator(num, str) {\n    if (\n        num === Infinity\n        || num === -Infinity\n        || num !== num\n        || (num && num > -1000 && num < 1000)\n        || $test.call(/e/, str)\n    ) {\n        return str;\n    }\n    var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;\n    if (typeof num === 'number') {\n        var int = num < 0 ? -$floor(-num) : $floor(num); // trunc(num)\n        if (int !== num) {\n            var intStr = String(int);\n            var dec = $slice.call(str, intStr.length + 1);\n            return $replace.call(intStr, sepRegex, '$&_') + '.' + $replace.call($replace.call(dec, /([0-9]{3})/g, '$&_'), /_$/, '');\n        }\n    }\n    return $replace.call(str, sepRegex, '$&_');\n}\n\nvar utilInspect = require('./util.inspect');\nvar inspectCustom = utilInspect.custom;\nvar inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;\n\nvar quotes = {\n    __proto__: null,\n    'double': '\"',\n    single: \"'\"\n};\nvar quoteREs = {\n    __proto__: null,\n    'double': /([\"\\\\])/g,\n    single: /(['\\\\])/g\n};\n\nmodule.exports = function inspect_(obj, options, depth, seen) {\n    var opts = options || {};\n\n    if (has(opts, 'quoteStyle') && !has(quotes, opts.quoteStyle)) {\n        throw new TypeError('option \"quoteStyle\" must be \"single\" or \"double\"');\n    }\n    if (\n        has(opts, 'maxStringLength') && (typeof opts.maxStringLength === 'number'\n            ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity\n            : opts.maxStringLength !== null\n        )\n    ) {\n        throw new TypeError('option \"maxStringLength\", if provided, must be a positive integer, Infinity, or `null`');\n    }\n    var customInspect = has(opts, 'customInspect') ? opts.customInspect : true;\n    if (typeof customInspect !== 'boolean' && customInspect !== 'symbol') {\n        throw new TypeError('option \"customInspect\", if provided, must be `true`, `false`, or `\\'symbol\\'`');\n    }\n\n    if (\n        has(opts, 'indent')\n        && opts.indent !== null\n        && opts.indent !== '\\t'\n        && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)\n    ) {\n        throw new TypeError('option \"indent\" must be \"\\\\t\", an integer > 0, or `null`');\n    }\n    if (has(opts, 'numericSeparator') && typeof opts.numericSeparator !== 'boolean') {\n        throw new TypeError('option \"numericSeparator\", if provided, must be `true` or `false`');\n    }\n    var numericSeparator = opts.numericSeparator;\n\n    if (typeof obj === 'undefined') {\n        return 'undefined';\n    }\n    if (obj === null) {\n        return 'null';\n    }\n    if (typeof obj === 'boolean') {\n        return obj ? 'true' : 'false';\n    }\n\n    if (typeof obj === 'string') {\n        return inspectString(obj, opts);\n    }\n    if (typeof obj === 'number') {\n        if (obj === 0) {\n            return Infinity / obj > 0 ? '0' : '-0';\n        }\n        var str = String(obj);\n        return numericSeparator ? addNumericSeparator(obj, str) : str;\n    }\n    if (typeof obj === 'bigint') {\n        var bigIntStr = String(obj) + 'n';\n        return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;\n    }\n\n    var maxDepth = typeof opts.depth === 'undefined' ? 5 : opts.depth;\n    if (typeof depth === 'undefined') { depth = 0; }\n    if (depth >= maxDepth && maxDepth > 0 && typeof obj === 'object') {\n        return isArray(obj) ? '[Array]' : '[Object]';\n    }\n\n    var indent = getIndent(opts, depth);\n\n    if (typeof seen === 'undefined') {\n        seen = [];\n    } else if (indexOf(seen, obj) >= 0) {\n        return '[Circular]';\n    }\n\n    function inspect(value, from, noIndent) {\n        if (from) {\n            seen = $arrSlice.call(seen);\n            seen.push(from);\n        }\n        if (noIndent) {\n            var newOpts = {\n                depth: opts.depth\n            };\n            if (has(opts, 'quoteStyle')) {\n                newOpts.quoteStyle = opts.quoteStyle;\n            }\n            return inspect_(value, newOpts, depth + 1, seen);\n        }\n        return inspect_(value, opts, depth + 1, seen);\n    }\n\n    if (typeof obj === 'function' && !isRegExp(obj)) { // in older engines, regexes are callable\n        var name = nameOf(obj);\n        var keys = arrObjKeys(obj, inspect);\n        return '[Function' + (name ? ': ' + name : ' (anonymous)') + ']' + (keys.length > 0 ? ' { ' + $join.call(keys, ', ') + ' }' : '');\n    }\n    if (isSymbol(obj)) {\n        var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\\(.*\\))_[^)]*$/, '$1') : symToString.call(obj);\n        return typeof obj === 'object' && !hasShammedSymbols ? markBoxed(symString) : symString;\n    }\n    if (isElement(obj)) {\n        var s = '<' + $toLowerCase.call(String(obj.nodeName));\n        var attrs = obj.attributes || [];\n        for (var i = 0; i < attrs.length; i++) {\n            s += ' ' + attrs[i].name + '=' + wrapQuotes(quote(attrs[i].value), 'double', opts);\n        }\n        s += '>';\n        if (obj.childNodes && obj.childNodes.length) { s += '...'; }\n        s += '</' + $toLowerCase.call(String(obj.nodeName)) + '>';\n        return s;\n    }\n    if (isArray(obj)) {\n        if (obj.length === 0) { return '[]'; }\n        var xs = arrObjKeys(obj, inspect);\n        if (indent && !singleLineValues(xs)) {\n            return '[' + indentedJoin(xs, indent) + ']';\n        }\n        return '[ ' + $join.call(xs, ', ') + ' ]';\n    }\n    if (isError(obj)) {\n        var parts = arrObjKeys(obj, inspect);\n        if (!('cause' in Error.prototype) && 'cause' in obj && !isEnumerable.call(obj, 'cause')) {\n            return '{ [' + String(obj) + '] ' + $join.call($concat.call('[cause]: ' + inspect(obj.cause), parts), ', ') + ' }';\n        }\n        if (parts.length === 0) { return '[' + String(obj) + ']'; }\n        return '{ [' + String(obj) + '] ' + $join.call(parts, ', ') + ' }';\n    }\n    if (typeof obj === 'object' && customInspect) {\n        if (inspectSymbol && typeof obj[inspectSymbol] === 'function' && utilInspect) {\n            return utilInspect(obj, { depth: maxDepth - depth });\n        } else if (customInspect !== 'symbol' && typeof obj.inspect === 'function') {\n            return obj.inspect();\n        }\n    }\n    if (isMap(obj)) {\n        var mapParts = [];\n        if (mapForEach) {\n            mapForEach.call(obj, function (value, key) {\n                mapParts.push(inspect(key, obj, true) + ' => ' + inspect(value, obj));\n            });\n        }\n        return collectionOf('Map', mapSize.call(obj), mapParts, indent);\n    }\n    if (isSet(obj)) {\n        var setParts = [];\n        if (setForEach) {\n            setForEach.call(obj, function (value) {\n                setParts.push(inspect(value, obj));\n            });\n        }\n        return collectionOf('Set', setSize.call(obj), setParts, indent);\n    }\n    if (isWeakMap(obj)) {\n        return weakCollectionOf('WeakMap');\n    }\n    if (isWeakSet(obj)) {\n        return weakCollectionOf('WeakSet');\n    }\n    if (isWeakRef(obj)) {\n        return weakCollectionOf('WeakRef');\n    }\n    if (isNumber(obj)) {\n        return markBoxed(inspect(Number(obj)));\n    }\n    if (isBigInt(obj)) {\n        return markBoxed(inspect(bigIntValueOf.call(obj)));\n    }\n    if (isBoolean(obj)) {\n        return markBoxed(booleanValueOf.call(obj));\n    }\n    if (isString(obj)) {\n        return markBoxed(inspect(String(obj)));\n    }\n    // note: in IE 8, sometimes `global !== window` but both are the prototypes of each other\n    /* eslint-env browser */\n    if (typeof window !== 'undefined' && obj === window) {\n        return '{ [object Window] }';\n    }\n    if (\n        (typeof globalThis !== 'undefined' && obj === globalThis)\n        || (typeof global !== 'undefined' && obj === global)\n    ) {\n        return '{ [object globalThis] }';\n    }\n    if (!isDate(obj) && !isRegExp(obj)) {\n        var ys = arrObjKeys(obj, inspect);\n        var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;\n        var protoTag = obj instanceof Object ? '' : 'null prototype';\n        var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? 'Object' : '';\n        var constructorTag = isPlainObject || typeof obj.constructor !== 'function' ? '' : obj.constructor.name ? obj.constructor.name + ' ' : '';\n        var tag = constructorTag + (stringTag || protoTag ? '[' + $join.call($concat.call([], stringTag || [], protoTag || []), ': ') + '] ' : '');\n        if (ys.length === 0) { return tag + '{}'; }\n        if (indent) {\n            return tag + '{' + indentedJoin(ys, indent) + '}';\n        }\n        return tag + '{ ' + $join.call(ys, ', ') + ' }';\n    }\n    return String(obj);\n};\n\nfunction wrapQuotes(s, defaultStyle, opts) {\n    var style = opts.quoteStyle || defaultStyle;\n    var quoteChar = quotes[style];\n    return quoteChar + s + quoteChar;\n}\n\nfunction quote(s) {\n    return $replace.call(String(s), /\"/g, '&quot;');\n}\n\nfunction canTrustToString(obj) {\n    return !toStringTag || !(typeof obj === 'object' && (toStringTag in obj || typeof obj[toStringTag] !== 'undefined'));\n}\nfunction isArray(obj) { return toStr(obj) === '[object Array]' && canTrustToString(obj); }\nfunction isDate(obj) { return toStr(obj) === '[object Date]' && canTrustToString(obj); }\nfunction isRegExp(obj) { return toStr(obj) === '[object RegExp]' && canTrustToString(obj); }\nfunction isError(obj) { return toStr(obj) === '[object Error]' && canTrustToString(obj); }\nfunction isString(obj) { return toStr(obj) === '[object String]' && canTrustToString(obj); }\nfunction isNumber(obj) { return toStr(obj) === '[object Number]' && canTrustToString(obj); }\nfunction isBoolean(obj) { return toStr(obj) === '[object Boolean]' && canTrustToString(obj); }\n\n// Symbol and BigInt do have Symbol.toStringTag by spec, so that can't be used to eliminate false positives\nfunction isSymbol(obj) {\n    if (hasShammedSymbols) {\n        return obj && typeof obj === 'object' && obj instanceof Symbol;\n    }\n    if (typeof obj === 'symbol') {\n        return true;\n    }\n    if (!obj || typeof obj !== 'object' || !symToString) {\n        return false;\n    }\n    try {\n        symToString.call(obj);\n        return true;\n    } catch (e) {}\n    return false;\n}\n\nfunction isBigInt(obj) {\n    if (!obj || typeof obj !== 'object' || !bigIntValueOf) {\n        return false;\n    }\n    try {\n        bigIntValueOf.call(obj);\n        return true;\n    } catch (e) {}\n    return false;\n}\n\nvar hasOwn = Object.prototype.hasOwnProperty || function (key) { return key in this; };\nfunction has(obj, key) {\n    return hasOwn.call(obj, key);\n}\n\nfunction toStr(obj) {\n    return objectToString.call(obj);\n}\n\nfunction nameOf(f) {\n    if (f.name) { return f.name; }\n    var m = $match.call(functionToString.call(f), /^function\\s*([\\w$]+)/);\n    if (m) { return m[1]; }\n    return null;\n}\n\nfunction indexOf(xs, x) {\n    if (xs.indexOf) { return xs.indexOf(x); }\n    for (var i = 0, l = xs.length; i < l; i++) {\n        if (xs[i] === x) { return i; }\n    }\n    return -1;\n}\n\nfunction isMap(x) {\n    if (!mapSize || !x || typeof x !== 'object') {\n        return false;\n    }\n    try {\n        mapSize.call(x);\n        try {\n            setSize.call(x);\n        } catch (s) {\n            return true;\n        }\n        return x instanceof Map; // core-js workaround, pre-v2.5.0\n    } catch (e) {}\n    return false;\n}\n\nfunction isWeakMap(x) {\n    if (!weakMapHas || !x || typeof x !== 'object') {\n        return false;\n    }\n    try {\n        weakMapHas.call(x, weakMapHas);\n        try {\n            weakSetHas.call(x, weakSetHas);\n        } catch (s) {\n            return true;\n        }\n        return x instanceof WeakMap; // core-js workaround, pre-v2.5.0\n    } catch (e) {}\n    return false;\n}\n\nfunction isWeakRef(x) {\n    if (!weakRefDeref || !x || typeof x !== 'object') {\n        return false;\n    }\n    try {\n        weakRefDeref.call(x);\n        return true;\n    } catch (e) {}\n    return false;\n}\n\nfunction isSet(x) {\n    if (!setSize || !x || typeof x !== 'object') {\n        return false;\n    }\n    try {\n        setSize.call(x);\n        try {\n            mapSize.call(x);\n        } catch (m) {\n            return true;\n        }\n        return x instanceof Set; // core-js workaround, pre-v2.5.0\n    } catch (e) {}\n    return false;\n}\n\nfunction isWeakSet(x) {\n    if (!weakSetHas || !x || typeof x !== 'object') {\n        return false;\n    }\n    try {\n        weakSetHas.call(x, weakSetHas);\n        try {\n            weakMapHas.call(x, weakMapHas);\n        } catch (s) {\n            return true;\n        }\n        return x instanceof WeakSet; // core-js workaround, pre-v2.5.0\n    } catch (e) {}\n    return false;\n}\n\nfunction isElement(x) {\n    if (!x || typeof x !== 'object') { return false; }\n    if (typeof HTMLElement !== 'undefined' && x instanceof HTMLElement) {\n        return true;\n    }\n    return typeof x.nodeName === 'string' && typeof x.getAttribute === 'function';\n}\n\nfunction inspectString(str, opts) {\n    if (str.length > opts.maxStringLength) {\n        var remaining = str.length - opts.maxStringLength;\n        var trailer = '... ' + remaining + ' more character' + (remaining > 1 ? 's' : '');\n        return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;\n    }\n    var quoteRE = quoteREs[opts.quoteStyle || 'single'];\n    quoteRE.lastIndex = 0;\n    // eslint-disable-next-line no-control-regex\n    var s = $replace.call($replace.call(str, quoteRE, '\\\\$1'), /[\\x00-\\x1f]/g, lowbyte);\n    return wrapQuotes(s, 'single', opts);\n}\n\nfunction lowbyte(c) {\n    var n = c.charCodeAt(0);\n    var x = {\n        8: 'b',\n        9: 't',\n        10: 'n',\n        12: 'f',\n        13: 'r'\n    }[n];\n    if (x) { return '\\\\' + x; }\n    return '\\\\x' + (n < 0x10 ? '0' : '') + $toUpperCase.call(n.toString(16));\n}\n\nfunction markBoxed(str) {\n    return 'Object(' + str + ')';\n}\n\nfunction weakCollectionOf(type) {\n    return type + ' { ? }';\n}\n\nfunction collectionOf(type, size, entries, indent) {\n    var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ', ');\n    return type + ' (' + size + ') {' + joinedEntries + '}';\n}\n\nfunction singleLineValues(xs) {\n    for (var i = 0; i < xs.length; i++) {\n        if (indexOf(xs[i], '\\n') >= 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction getIndent(opts, depth) {\n    var baseIndent;\n    if (opts.indent === '\\t') {\n        baseIndent = '\\t';\n    } else if (typeof opts.indent === 'number' && opts.indent > 0) {\n        baseIndent = $join.call(Array(opts.indent + 1), ' ');\n    } else {\n        return null;\n    }\n    return {\n        base: baseIndent,\n        prev: $join.call(Array(depth + 1), baseIndent)\n    };\n}\n\nfunction indentedJoin(xs, indent) {\n    if (xs.length === 0) { return ''; }\n    var lineJoiner = '\\n' + indent.prev + indent.base;\n    return lineJoiner + $join.call(xs, ',' + lineJoiner) + '\\n' + indent.prev;\n}\n\nfunction arrObjKeys(obj, inspect) {\n    var isArr = isArray(obj);\n    var xs = [];\n    if (isArr) {\n        xs.length = obj.length;\n        for (var i = 0; i < obj.length; i++) {\n            xs[i] = has(obj, i) ? inspect(obj[i], obj) : '';\n        }\n    }\n    var syms = typeof gOPS === 'function' ? gOPS(obj) : [];\n    var symMap;\n    if (hasShammedSymbols) {\n        symMap = {};\n        for (var k = 0; k < syms.length; k++) {\n            symMap['$' + syms[k]] = syms[k];\n        }\n    }\n\n    for (var key in obj) { // eslint-disable-line no-restricted-syntax\n        if (!has(obj, key)) { continue; } // eslint-disable-line no-restricted-syntax, no-continue\n        if (isArr && String(Number(key)) === key && key < obj.length) { continue; } // eslint-disable-line no-restricted-syntax, no-continue\n        if (hasShammedSymbols && symMap['$' + key] instanceof Symbol) {\n            // this is to prevent shammed Symbols, which are stored as strings, from being included in the string key section\n            continue; // eslint-disable-line no-restricted-syntax, no-continue\n        } else if ($test.call(/[^\\w$]/, key)) {\n            xs.push(inspect(key, obj) + ': ' + inspect(obj[key], obj));\n        } else {\n            xs.push(key + ': ' + inspect(obj[key], obj));\n        }\n    }\n    if (typeof gOPS === 'function') {\n        for (var j = 0; j < syms.length; j++) {\n            if (isEnumerable.call(obj, syms[j])) {\n                xs.push('[' + inspect(syms[j]) + ']: ' + inspect(obj[syms[j]], obj));\n            }\n        }\n    }\n    return xs;\n}\n","import { AlgebraicType } from './algebraic_type';\n\nexport type TimeDurationAlgebraicType = {\n  tag: 'Product';\n  value: {\n    elements: [\n      { name: '__time_duration_micros__'; algebraicType: { tag: 'I64' } },\n    ];\n  };\n};\n\n/**\n * A difference between two points in time, represented as a number of microseconds.\n */\nexport class TimeDuration {\n  __time_duration_micros__: bigint;\n\n  private static MICROS_PER_MILLIS: bigint = 1000n;\n\n  /**\n   * Get the algebraic type representation of the {@link TimeDuration} type.\n   * @returns The algebraic type representation of the type.\n   */\n  static getAlgebraicType(): TimeDurationAlgebraicType {\n    return AlgebraicType.Product({\n      elements: [\n        {\n          name: '__time_duration_micros__',\n          algebraicType: AlgebraicType.I64,\n        },\n      ],\n    });\n  }\n\n  static isTimeDuration(\n    algebraicType: AlgebraicType\n  ): algebraicType is TimeDurationAlgebraicType {\n    if (algebraicType.tag !== 'Product') {\n      return false;\n    }\n    const elements = algebraicType.value.elements;\n    if (elements.length !== 1) {\n      return false;\n    }\n    const microsElement = elements[0];\n    return (\n      microsElement.name === '__time_duration_micros__' &&\n      microsElement.algebraicType.tag === 'I64'\n    );\n  }\n\n  get micros(): bigint {\n    return this.__time_duration_micros__;\n  }\n\n  get millis(): number {\n    return Number(this.micros / TimeDuration.MICROS_PER_MILLIS);\n  }\n\n  constructor(micros: bigint) {\n    this.__time_duration_micros__ = micros;\n  }\n\n  static fromMillis(millis: number): TimeDuration {\n    return new TimeDuration(BigInt(millis) * TimeDuration.MICROS_PER_MILLIS);\n  }\n\n  /** This outputs the same string format that we use in the host and in Rust modules */\n  toString(): string {\n    const micros = this.micros;\n    const sign = micros < 0 ? '-' : '+';\n    const pos = micros < 0 ? -micros : micros;\n    const secs = pos / 1_000_000n;\n    const micros_remaining = pos % 1_000_000n;\n    return `${sign}${secs}.${String(micros_remaining).padStart(6, '0')}`;\n  }\n}\n","import { AlgebraicType } from './algebraic_type';\nimport { TimeDuration } from './time_duration';\n\nexport type TimestampAlgebraicType = {\n  tag: 'Product';\n  value: {\n    elements: [\n      {\n        name: '__timestamp_micros_since_unix_epoch__';\n        algebraicType: { tag: 'I64' };\n      },\n    ];\n  };\n};\n\n/**\n * A point in time, represented as a number of microseconds since the Unix epoch.\n */\nexport class Timestamp {\n  __timestamp_micros_since_unix_epoch__: bigint;\n\n  private static MICROS_PER_MILLIS: bigint = 1000n;\n\n  get microsSinceUnixEpoch(): bigint {\n    return this.__timestamp_micros_since_unix_epoch__;\n  }\n\n  constructor(micros: bigint) {\n    this.__timestamp_micros_since_unix_epoch__ = micros;\n  }\n\n  /**\n   * Get the algebraic type representation of the {@link Timestamp} type.\n   * @returns The algebraic type representation of the type.\n   */\n  static getAlgebraicType(): TimestampAlgebraicType {\n    return AlgebraicType.Product({\n      elements: [\n        {\n          name: '__timestamp_micros_since_unix_epoch__',\n          algebraicType: AlgebraicType.I64,\n        },\n      ],\n    });\n  }\n\n  static isTimestamp(\n    algebraicType: AlgebraicType\n  ): algebraicType is TimestampAlgebraicType {\n    if (algebraicType.tag !== 'Product') {\n      return false;\n    }\n    const elements = algebraicType.value.elements;\n    if (elements.length !== 1) {\n      return false;\n    }\n    const microsElement = elements[0];\n    return (\n      microsElement.name === '__timestamp_micros_since_unix_epoch__' &&\n      microsElement.algebraicType.tag === 'I64'\n    );\n  }\n\n  /**\n   * The Unix epoch, the midnight at the beginning of January 1, 1970, UTC.\n   */\n  static UNIX_EPOCH: Timestamp = new Timestamp(0n);\n\n  /**\n   * Get a `Timestamp` representing the execution environment's belief of the current moment in time.\n   */\n  static now(): Timestamp {\n    return Timestamp.fromDate(new Date());\n  }\n\n  /** Convert to milliseconds since Unix epoch. */\n  toMillis(): bigint {\n    return this.microsSinceUnixEpoch / 1000n;\n  }\n\n  /**\n   * Get a `Timestamp` representing the same point in time as `date`.\n   */\n  static fromDate(date: Date): Timestamp {\n    const millis = date.getTime();\n    const micros = BigInt(millis) * Timestamp.MICROS_PER_MILLIS;\n    return new Timestamp(micros);\n  }\n\n  /**\n   * Get a `Date` representing approximately the same point in time as `this`.\n   *\n   * This method truncates to millisecond precision,\n   * and throws `RangeError` if the `Timestamp` is outside the range representable as a `Date`.\n   */\n  toDate(): Date {\n    const micros = this.__timestamp_micros_since_unix_epoch__;\n    const millis = micros / Timestamp.MICROS_PER_MILLIS;\n    if (\n      millis > BigInt(Number.MAX_SAFE_INTEGER) ||\n      millis < BigInt(Number.MIN_SAFE_INTEGER)\n    ) {\n      throw new RangeError(\n        \"Timestamp is outside of the representable range of JS's Date\"\n      );\n    }\n    return new Date(Number(millis));\n  }\n\n  /**\n   * Get an ISO 8601 / RFC 3339 formatted string representation of this timestamp with microsecond precision.\n   *\n   * This method preserves the full microsecond precision of the timestamp,\n   * and throws `RangeError` if the `Timestamp` is outside the range representable in ISO format.\n   *\n   * @returns ISO 8601 formatted string with microsecond precision (e.g., '2025-02-17T10:30:45.123456Z')\n   */\n  toISOString(): string {\n    const micros = this.__timestamp_micros_since_unix_epoch__;\n    const millis = micros / Timestamp.MICROS_PER_MILLIS;\n\n    if (\n      millis > BigInt(Number.MAX_SAFE_INTEGER) ||\n      millis < BigInt(Number.MIN_SAFE_INTEGER)\n    ) {\n      throw new RangeError(\n        'Timestamp is outside of the representable range for ISO string formatting'\n      );\n    }\n\n    const date = new Date(Number(millis));\n    const isoBase = date.toISOString(); // Format: '2025-02-17T10:30:45.123Z'\n\n    // Extract the full 6 decimal places of microseconds\n    const microsRemainder = Math.abs(Number(micros % 1000000n));\n    const fractionalPart = String(microsRemainder).padStart(6, '0');\n\n    // Replace the 3-digit millisecond part with the full 6-digit microsecond part\n    return isoBase.replace(/\\.\\d{3}Z$/, `.${fractionalPart}Z`);\n  }\n\n  since(other: Timestamp): TimeDuration {\n    return new TimeDuration(\n      this.__timestamp_micros_since_unix_epoch__ -\n        other.__timestamp_micros_since_unix_epoch__\n    );\n  }\n}\n","import { Timestamp } from './timestamp';\nimport { AlgebraicType } from './algebraic_type.ts';\n\nexport type UuidAlgebraicType = {\n  tag: 'Product';\n  value: {\n    elements: [\n      {\n        name: '__uuid__';\n        algebraicType: { tag: 'U128' };\n      },\n    ];\n  };\n};\n\n/**\n * Supported UUID versions.\n *\n * - `Nil`  The \"Nil\" UUID (all zeros)\n * - `V4`   Version 4: random\n * - `V7`   Version 7: timestamp + counter + random\n * - `Max`  The \"Max\" UUID (all ones)\n */\ntype UuidVersion = 'Nil' | 'V4' | 'V7' | 'Max';\n\n/**\n * A universally unique identifier (UUID).\n *\n * Supports UUID `Nil`, `Max`, `V4` (random), and `V7`\n * (timestamp + counter + random).\n *\n * Internally represented as an unsigned 128-bit between 0 and `MAX_UUID_BIGINT`.\n */\nexport class Uuid {\n  __uuid__: bigint;\n\n  /**\n   * The nil UUID (all zeros).\n   *\n   * @example\n   * ```ts\n   * const uuid = Uuid.NIL;\n   * console.assert(\n   *   uuid.toString() === \"00000000-0000-0000-0000-000000000000\"\n   * );\n   * ```\n   */\n  static readonly NIL = new Uuid(0n);\n  static readonly MAX_UUID_BIGINT = 0xffffffffffffffffffffffffffffffffn;\n  /**\n   * The max UUID (all ones).\n   *\n   * @example\n   * ```ts\n   * const uuid = Uuid.MAX;\n   * console.assert(\n   *   uuid.toString() === \"ffffffff-ffff-ffff-ffff-ffffffffffff\"\n   * );\n   * ```\n   */\n  static readonly MAX = new Uuid(Uuid.MAX_UUID_BIGINT);\n\n  /**\n   * Create a UUID from a raw 128-bit value.\n   *\n   * @param u - Unsigned 128-bit integer\n   * @throws {Error} If the value is outside the valid UUID range\n   */\n  constructor(u: bigint) {\n    // Must fit in exactly 16 bytes\n    if (u < 0n || u > Uuid.MAX_UUID_BIGINT) {\n      throw new Error('Invalid UUID: must be between 0 and `MAX_UUID_BIGINT`');\n    }\n    this.__uuid__ = u;\n  }\n\n  /**\n   * Create a UUID `v4` from explicit random bytes.\n   *\n   * This method assumes the bytes are already sufficiently random.\n   * It only sets the appropriate bits for the UUID version and variant.\n   *\n   * @param bytes - Exactly 16 random bytes\n   * @returns A UUID `v4`\n   * @throws {Error} If `bytes.length !== 16`\n   *\n   * @example\n   * ```ts\n   * const randomBytes = new Uint8Array(16);\n   * const uuid = Uuid.fromRandomBytesV4(randomBytes);\n   *\n   * console.assert(\n   *   uuid.toString() === \"00000000-0000-4000-8000-000000000000\"\n   * );\n   * ```\n   */\n  static fromRandomBytesV4(bytes: Uint8Array): Uuid {\n    if (bytes.length !== 16) throw new Error('UUID v4 requires 16 bytes');\n    const arr = new Uint8Array(bytes);\n    arr[6] = (arr[6] & 0x0f) | 0x40; // version 4\n    arr[8] = (arr[8] & 0x3f) | 0x80; // variant\n    return new Uuid(Uuid.bytesToBigInt(arr));\n  }\n\n  /**\n   * Generate a UUID `v7` using a monotonic counter from `0` to `2^31 - 1`,\n   * a timestamp, and 4 random bytes.\n   *\n   * The counter wraps around on overflow.\n   *\n   * The UUID `v7` is structured as follows:\n   *\n   * ```ascii\n   * \n   * | B0  | B1  | B2  | B3  | B4  | B5              |         B6        |\n   * \n   * |                 unix_ts_ms                    |      version 7    |\n   * \n   * \n   * | B7           | B8      | B9  | B10 | B11  | B12 | B13 | B14 | B15 |\n   * \n   * | counter_high | variant |    counter_low   |        random         |\n   * \n   * ```\n   *\n   * @param counter - Mutable monotonic counter (31-bit)\n   * @param now - Timestamp since the Unix epoch\n   * @param randomBytes - Exactly 4 random bytes\n   * @returns A UUID `v7`\n   *\n   * @throws {Error} If the `counter` is negative\n   * @throws {Error} If the `timestamp` is before the Unix epoch\n   * @throws {Error} If `randomBytes.length !== 4`\n   *\n   * @example\n   * ```ts\n   * const now = Timestamp.fromMillis(1_686_000_000_000n);\n   * const counter = { value: 1 };\n   * const randomBytes = new Uint8Array(4);\n   *\n   * const uuid = Uuid.fromCounterV7(counter, now, randomBytes);\n   *\n   * console.assert(\n   *   uuid.toString() === \"0000647e-5180-7000-8000-000200000000\"\n   * );\n   * ```\n   */\n  static fromCounterV7(\n    counter: { value: number },\n    now: Timestamp,\n    randomBytes: Uint8Array\n  ): Uuid {\n    if (randomBytes.length !== 4) {\n      throw new Error('`fromCounterV7` requires `randomBytes.length == 4`');\n    }\n\n    if (counter.value < 0) {\n      throw new Error('`fromCounterV7` uuid `counter` must be non-negative');\n    }\n\n    if (now.__timestamp_micros_since_unix_epoch__ < 0) {\n      throw new Error('`fromCounterV7` `timestamp` before unix epoch');\n    }\n\n    // 31-bit monotonic counter with wraparound\n    const counterVal = counter.value;\n    counter.value = (counterVal + 1) & 0x7fff_ffff;\n\n    // 48-bit unix timestamp (ms)\n    const tsMs = now.toMillis() & 0xffff_ffff_ffffn;\n\n    const bytes = new Uint8Array(16);\n\n    // unix_ts_ms (48 bits)\n    bytes[0] = Number((tsMs >> 40n) & 0xffn);\n    bytes[1] = Number((tsMs >> 32n) & 0xffn);\n    bytes[2] = Number((tsMs >> 24n) & 0xffn);\n    bytes[3] = Number((tsMs >> 16n) & 0xffn);\n    bytes[4] = Number((tsMs >> 8n) & 0xffn);\n    bytes[5] = Number(tsMs & 0xffn);\n\n    // Counter bits (31 bits total)\n    bytes[7] = (counterVal >>> 23) & 0xff;\n    bytes[9] = (counterVal >>> 15) & 0xff;\n    bytes[10] = (counterVal >>> 7) & 0xff;\n    bytes[11] = ((counterVal & 0x7f) << 1) & 0xff;\n\n    // Random bytes\n    bytes[12] |= randomBytes[0] & 0x7f;\n    bytes[13] = randomBytes[1];\n    bytes[14] = randomBytes[2];\n    bytes[15] = randomBytes[3];\n\n    // Version 7\n    bytes[6] = (bytes[6] & 0x0f) | 0x70;\n\n    // Variant RFC4122\n    bytes[8] = (bytes[8] & 0x3f) | 0x80;\n\n    return new Uuid(Uuid.bytesToBigInt(bytes));\n  }\n\n  /**\n   * Parse a UUID from a string representation.\n   *\n   * @param s - UUID string\n   * @returns Parsed UUID\n   * @throws {Error} If the string is not a valid UUID\n   *\n   * @example\n   * ```ts\n   * const s = \"01888d6e-5c00-7000-8000-000000000000\";\n   * const uuid = Uuid.parse(s);\n   *\n   * console.assert(uuid.toString() === s);\n   * ```\n   */\n  static parse(s: string): Uuid {\n    const hex = s.replace(/-/g, '');\n    if (hex.length !== 32) throw new Error('Invalid hex UUID');\n\n    let v = 0n;\n    for (let i = 0; i < 32; i += 2) {\n      v = (v << 8n) | BigInt(parseInt(hex.slice(i, i + 2), 16));\n    }\n    return new Uuid(v);\n  }\n\n  /** Convert to string (hyphenated form). */\n  toString(): string {\n    const bytes = Uuid.bigIntToBytes(this.__uuid__);\n    const hex = [...bytes].map(b => b.toString(16).padStart(2, '0')).join('');\n\n    // Format as 8-4-4-4-12\n    return (\n      hex.slice(0, 8) +\n      '-' +\n      hex.slice(8, 12) +\n      '-' +\n      hex.slice(12, 16) +\n      '-' +\n      hex.slice(16, 20) +\n      '-' +\n      hex.slice(20)\n    );\n  }\n\n  /** Convert to bigint (u128). */\n  asBigInt(): bigint {\n    return this.__uuid__;\n  }\n\n  /** Return a `Uint8Array` of 16 bytes. */\n  toBytes(): Uint8Array {\n    return Uuid.bigIntToBytes(this.__uuid__);\n  }\n\n  private static bytesToBigInt(bytes: Uint8Array): bigint {\n    let result = 0n;\n    for (const b of bytes) result = (result << 8n) | BigInt(b);\n    return result;\n  }\n\n  private static bigIntToBytes(value: bigint): Uint8Array {\n    const bytes = new Uint8Array(16);\n    for (let i = 15; i >= 0; i--) {\n      bytes[i] = Number(value & 0xffn);\n      value >>= 8n;\n    }\n    return bytes;\n  }\n\n  /**\n   * Returns the version of this UUID.\n   *\n   * This represents the algorithm used to generate the value.\n   *\n   * @returns A `UuidVersion`\n   * @throws {Error} If the version field is not recognized\n   */\n  getVersion(): UuidVersion {\n    const version = (this.toBytes()[6] >> 4) & 0x0f;\n\n    switch (version) {\n      case 4:\n        return 'V4';\n      case 7:\n        return 'V7';\n      default:\n        if (this == Uuid.NIL) {\n          return 'Nil';\n        }\n        if (this == Uuid.MAX) {\n          return 'Max';\n        }\n        throw new Error(`Unsupported UUID version: ${version}`);\n    }\n  }\n\n  /**\n   * Extract the monotonic counter from a UUIDv7.\n   *\n   * Intended for testing and diagnostics.\n   * Behavior is undefined if called on a non-V7 UUID.\n   *\n   * @returns 31-bit counter value\n   */\n  getCounter(): number {\n    const bytes = this.toBytes(); // big-endian, 16 bytes\n\n    const high = bytes[7]; // bits 30..23\n    const mid1 = bytes[9]; // bits 22..15\n    const mid2 = bytes[10]; // bits 14..7\n    const low = bytes[11] >>> 1; // bits 6..0\n\n    // reconstruct 31-bit counter\n    return (high << 23) | (mid1 << 15) | (mid2 << 7) | low | 0; // force 32-bit int\n  }\n\n  compareTo(other: Uuid): number {\n    if (this.__uuid__ < other.__uuid__) return -1;\n    if (this.__uuid__ > other.__uuid__) return 1;\n\n    return 0;\n  }\n\n  static getAlgebraicType(): UuidAlgebraicType {\n    return AlgebraicType.Product({\n      elements: [\n        {\n          name: '__uuid__',\n          algebraicType: AlgebraicType.U128,\n        },\n      ],\n    });\n  }\n}\n","export default class BinaryReader {\n  /**\n   * The DataView used to read values from the binary data.\n   *\n   * Note: The DataView's `byteOffset` is relative to the beginning of the\n   * underlying ArrayBuffer, not the start of the provided Uint8Array input.\n   * This `BinaryReader`'s `#offset` field is used to track the current read position\n   * relative to the start of the provided Uint8Array input.\n   */\n  view: DataView;\n\n  /**\n   * Represents the offset (in bytes) relative to the start of the DataView\n   * and provided Uint8Array input.\n   *\n   * Note: This is *not* the absolute byte offset within the underlying ArrayBuffer.\n   */\n  offset: number = 0;\n\n  constructor(input: Uint8Array | DataView) {\n    this.view =\n      input instanceof DataView\n        ? input\n        : new DataView(input.buffer, input.byteOffset, input.byteLength);\n    this.offset = 0;\n  }\n\n  reset(view: DataView) {\n    this.view = view;\n    this.offset = 0;\n  }\n\n  get remaining(): number {\n    return this.view.byteLength - this.offset;\n  }\n\n  /** Ensure we have at least `n` bytes left to read */\n  #ensure(n: number): void {\n    if (this.offset + n > this.view.byteLength) {\n      throw new RangeError(\n        `Tried to read ${n} byte(s) at relative offset ${this.offset}, but only ${this.remaining} byte(s) remain`\n      );\n    }\n  }\n\n  readUInt8Array(): Uint8Array {\n    const length = this.readU32();\n    this.#ensure(length);\n    return this.readBytes(length);\n  }\n\n  readBool(): boolean {\n    const value = this.view.getUint8(this.offset);\n    this.offset += 1;\n    return value !== 0;\n  }\n\n  readByte(): number {\n    const value = this.view.getUint8(this.offset);\n    this.offset += 1;\n    return value;\n  }\n\n  readBytes(length: number): Uint8Array {\n    // Create a Uint8Array view over the DataView's buffer at the current offset\n    // The #view.buffer is the whole ArrayBuffer, so we need to account for the\n    // #view's starting position in that buffer (#view.byteOffset) and the current #offset\n    const array = new Uint8Array(\n      this.view.buffer,\n      this.view.byteOffset + this.offset,\n      length\n    );\n    this.offset += length;\n    return array;\n  }\n\n  readI8(): number {\n    const value = this.view.getInt8(this.offset);\n    this.offset += 1;\n    return value;\n  }\n\n  readU8(): number {\n    return this.readByte();\n  }\n\n  readI16(): number {\n    const value = this.view.getInt16(this.offset, true);\n    this.offset += 2;\n    return value;\n  }\n\n  readU16(): number {\n    const value = this.view.getUint16(this.offset, true);\n    this.offset += 2;\n    return value;\n  }\n\n  readI32(): number {\n    const value = this.view.getInt32(this.offset, true);\n    this.offset += 4;\n    return value;\n  }\n\n  readU32(): number {\n    const value = this.view.getUint32(this.offset, true);\n    this.offset += 4;\n    return value;\n  }\n\n  readI64(): bigint {\n    const value = this.view.getBigInt64(this.offset, true);\n    this.offset += 8;\n    return value;\n  }\n\n  readU64(): bigint {\n    const value = this.view.getBigUint64(this.offset, true);\n    this.offset += 8;\n    return value;\n  }\n\n  readU128(): bigint {\n    const lowerPart = this.view.getBigUint64(this.offset, true);\n    const upperPart = this.view.getBigUint64(this.offset + 8, true);\n    this.offset += 16;\n\n    return (upperPart << BigInt(64)) + lowerPart;\n  }\n\n  readI128(): bigint {\n    const lowerPart = this.view.getBigUint64(this.offset, true);\n    const upperPart = this.view.getBigInt64(this.offset + 8, true);\n    this.offset += 16;\n\n    return (upperPart << BigInt(64)) + lowerPart;\n  }\n\n  readU256(): bigint {\n    const p0 = this.view.getBigUint64(this.offset, true);\n    const p1 = this.view.getBigUint64(this.offset + 8, true);\n    const p2 = this.view.getBigUint64(this.offset + 16, true);\n    const p3 = this.view.getBigUint64(this.offset + 24, true);\n    this.offset += 32;\n\n    return (\n      (p3 << BigInt(3 * 64)) +\n      (p2 << BigInt(2 * 64)) +\n      (p1 << BigInt(1 * 64)) +\n      p0\n    );\n  }\n\n  readI256(): bigint {\n    const p0 = this.view.getBigUint64(this.offset, true);\n    const p1 = this.view.getBigUint64(this.offset + 8, true);\n    const p2 = this.view.getBigUint64(this.offset + 16, true);\n    const p3 = this.view.getBigInt64(this.offset + 24, true);\n    this.offset += 32;\n\n    return (\n      (p3 << BigInt(3 * 64)) +\n      (p2 << BigInt(2 * 64)) +\n      (p1 << BigInt(1 * 64)) +\n      p0\n    );\n  }\n\n  readF32(): number {\n    const value = this.view.getFloat32(this.offset, true);\n    this.offset += 4;\n    return value;\n  }\n\n  readF64(): number {\n    const value = this.view.getFloat64(this.offset, true);\n    this.offset += 8;\n    return value;\n  }\n\n  readString(): string {\n    const uint8Array = this.readUInt8Array();\n    return new TextDecoder('utf-8').decode(uint8Array);\n  }\n}\n","import { fromByteArray } from 'base64-js';\n\nconst ArrayBufferPrototypeTransfer =\n  ArrayBuffer.prototype.transfer ??\n  function (this: ArrayBuffer, newByteLength) {\n    if (newByteLength === undefined) {\n      return this.slice();\n    } else if (newByteLength <= this.byteLength) {\n      return this.slice(0, newByteLength);\n    } else {\n      const copy = new Uint8Array(newByteLength);\n      copy.set(new Uint8Array(this));\n      return copy.buffer;\n    }\n  };\n\nexport class ResizableBuffer {\n  buffer: ArrayBuffer;\n  view: DataView;\n\n  constructor(init: number | ArrayBuffer) {\n    this.buffer = typeof init === 'number' ? new ArrayBuffer(init) : init;\n    this.view = new DataView(this.buffer);\n  }\n\n  get capacity(): number {\n    return this.buffer.byteLength;\n  }\n\n  grow(newSize: number) {\n    if (newSize <= this.buffer.byteLength) return;\n    this.buffer = ArrayBufferPrototypeTransfer.call(this.buffer, newSize);\n    this.view = new DataView(this.buffer);\n  }\n}\n\nexport default class BinaryWriter {\n  buffer: ResizableBuffer;\n  offset: number = 0;\n\n  constructor(init: number | ResizableBuffer) {\n    this.buffer = typeof init === 'number' ? new ResizableBuffer(init) : init;\n  }\n\n  reset(buffer: ResizableBuffer) {\n    this.buffer = buffer;\n    this.offset = 0;\n  }\n\n  expandBuffer(additionalCapacity: number): void {\n    const minCapacity = this.offset + additionalCapacity + 1;\n    if (minCapacity <= this.buffer.capacity) return;\n    let newCapacity = this.buffer.capacity * 2;\n    if (newCapacity < minCapacity) newCapacity = minCapacity;\n    this.buffer.grow(newCapacity);\n  }\n\n  toBase64(): string {\n    return fromByteArray(this.getBuffer());\n  }\n\n  getBuffer(): Uint8Array {\n    return new Uint8Array(this.buffer.buffer, 0, this.offset);\n  }\n\n  get view() {\n    return this.buffer.view;\n  }\n\n  writeUInt8Array(value: Uint8Array): void {\n    const length = value.length;\n\n    this.expandBuffer(4 + length);\n\n    this.writeU32(length);\n    new Uint8Array(this.buffer.buffer, this.offset).set(value);\n    this.offset += length;\n  }\n\n  writeBool(value: boolean): void {\n    this.expandBuffer(1);\n    this.view.setUint8(this.offset, value ? 1 : 0);\n    this.offset += 1;\n  }\n\n  writeByte(value: number): void {\n    this.expandBuffer(1);\n    this.view.setUint8(this.offset, value);\n    this.offset += 1;\n  }\n\n  writeI8(value: number): void {\n    this.expandBuffer(1);\n    this.view.setInt8(this.offset, value);\n    this.offset += 1;\n  }\n\n  writeU8(value: number): void {\n    this.expandBuffer(1);\n    this.view.setUint8(this.offset, value);\n    this.offset += 1;\n  }\n\n  writeI16(value: number): void {\n    this.expandBuffer(2);\n    this.view.setInt16(this.offset, value, true);\n    this.offset += 2;\n  }\n\n  writeU16(value: number): void {\n    this.expandBuffer(2);\n    this.view.setUint16(this.offset, value, true);\n    this.offset += 2;\n  }\n\n  writeI32(value: number): void {\n    this.expandBuffer(4);\n    this.view.setInt32(this.offset, value, true);\n    this.offset += 4;\n  }\n\n  writeU32(value: number): void {\n    this.expandBuffer(4);\n    this.view.setUint32(this.offset, value, true);\n    this.offset += 4;\n  }\n\n  writeI64(value: bigint): void {\n    this.expandBuffer(8);\n    this.view.setBigInt64(this.offset, value, true);\n    this.offset += 8;\n  }\n\n  writeU64(value: bigint): void {\n    this.expandBuffer(8);\n    this.view.setBigUint64(this.offset, value, true);\n    this.offset += 8;\n  }\n\n  writeU128(value: bigint): void {\n    this.expandBuffer(16);\n    const lowerPart = value & BigInt('0xFFFFFFFFFFFFFFFF');\n    const upperPart = value >> BigInt(64);\n    this.view.setBigUint64(this.offset, lowerPart, true);\n    this.view.setBigUint64(this.offset + 8, upperPart, true);\n    this.offset += 16;\n  }\n\n  writeI128(value: bigint): void {\n    this.expandBuffer(16);\n    const lowerPart = value & BigInt('0xFFFFFFFFFFFFFFFF');\n    const upperPart = value >> BigInt(64);\n    this.view.setBigInt64(this.offset, lowerPart, true);\n    this.view.setBigInt64(this.offset + 8, upperPart, true);\n    this.offset += 16;\n  }\n\n  writeU256(value: bigint): void {\n    this.expandBuffer(32);\n    const low_64_mask = BigInt('0xFFFFFFFFFFFFFFFF');\n    const p0 = value & low_64_mask;\n    const p1 = (value >> BigInt(64 * 1)) & low_64_mask;\n    const p2 = (value >> BigInt(64 * 2)) & low_64_mask;\n    const p3 = value >> BigInt(64 * 3);\n    this.view.setBigUint64(this.offset + 8 * 0, p0, true);\n    this.view.setBigUint64(this.offset + 8 * 1, p1, true);\n    this.view.setBigUint64(this.offset + 8 * 2, p2, true);\n    this.view.setBigUint64(this.offset + 8 * 3, p3, true);\n    this.offset += 32;\n  }\n\n  writeI256(value: bigint): void {\n    this.expandBuffer(32);\n    const low_64_mask = BigInt('0xFFFFFFFFFFFFFFFF');\n    const p0 = value & low_64_mask;\n    const p1 = (value >> BigInt(64 * 1)) & low_64_mask;\n    const p2 = (value >> BigInt(64 * 2)) & low_64_mask;\n    const p3 = value >> BigInt(64 * 3);\n    this.view.setBigUint64(this.offset + 8 * 0, p0, true);\n    this.view.setBigUint64(this.offset + 8 * 1, p1, true);\n    this.view.setBigUint64(this.offset + 8 * 2, p2, true);\n    this.view.setBigInt64(this.offset + 8 * 3, p3, true);\n    this.offset += 32;\n  }\n\n  writeF32(value: number): void {\n    this.expandBuffer(4);\n    this.view.setFloat32(this.offset, value, true);\n    this.offset += 4;\n  }\n\n  writeF64(value: number): void {\n    this.expandBuffer(8);\n    this.view.setFloat64(this.offset, value, true);\n    this.offset += 8;\n  }\n\n  writeString(value: string): void {\n    const encoder = new TextEncoder();\n    const encodedString = encoder.encode(value);\n    this.writeUInt8Array(encodedString);\n  }\n}\n","import BinaryReader from './binary_reader';\nimport BinaryWriter from './binary_writer';\nimport type { CamelCase, SnakeCase } from './type_util';\n\n/**\n * Converts a string to PascalCase (UpperCamelCase).\n * @param str The string to convert\n * @returns The converted string\n */\nexport function toPascalCase(s: string): string {\n  const str = s.replace(/([-_][a-z])/gi, $1 => {\n    return $1.toUpperCase().replace('-', '').replace('_', '');\n  });\n\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\n\nexport function deepEqual(obj1: any, obj2: any): boolean {\n  // If both are strictly equal (covers primitives and reference equality), return true\n  if (obj1 === obj2) return true;\n\n  // If either is a primitive type or one is null, return false since we already checked for strict equality\n  if (\n    typeof obj1 !== 'object' ||\n    obj1 === null ||\n    typeof obj2 !== 'object' ||\n    obj2 === null\n  ) {\n    return false;\n  }\n\n  // Get keys of both objects\n  const keys1 = Object.keys(obj1);\n  const keys2 = Object.keys(obj2);\n\n  // If number of keys is different, return false\n  if (keys1.length !== keys2.length) return false;\n\n  // Check all keys and compare values recursively\n  for (const key of keys1) {\n    if (!keys2.includes(key) || !deepEqual(obj1[key], obj2[key])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexport function uint8ArrayToHexString(array: Uint8Array): string {\n  return Array.prototype.map\n    .call(array.reverse(), x => ('00' + x.toString(16)).slice(-2))\n    .join('');\n}\n\nexport function uint8ArrayToU128(array: Uint8Array): bigint {\n  if (array.length != 16) {\n    throw new Error(`Uint8Array is not 16 bytes long: ${array}`);\n  }\n  return new BinaryReader(array).readU128();\n}\n\nexport function uint8ArrayToU256(array: Uint8Array): bigint {\n  if (array.length != 32) {\n    throw new Error(`Uint8Array is not 32 bytes long: [${array}]`);\n  }\n  return new BinaryReader(array).readU256();\n}\n\nexport function hexStringToUint8Array(str: string): Uint8Array {\n  if (str.startsWith('0x')) {\n    str = str.slice(2);\n  }\n  const matches = str.match(/.{1,2}/g) || [];\n  const data = Uint8Array.from(\n    matches.map((byte: string) => parseInt(byte, 16))\n  );\n  return data.reverse();\n}\n\nexport function hexStringToU128(str: string): bigint {\n  return uint8ArrayToU128(hexStringToUint8Array(str));\n}\n\nexport function hexStringToU256(str: string): bigint {\n  return uint8ArrayToU256(hexStringToUint8Array(str));\n}\n\nexport function u128ToUint8Array(data: bigint): Uint8Array {\n  const writer = new BinaryWriter(16);\n  writer.writeU128(data);\n  return writer.getBuffer();\n}\n\nexport function u128ToHexString(data: bigint): string {\n  return uint8ArrayToHexString(u128ToUint8Array(data));\n}\n\nexport function u256ToUint8Array(data: bigint): Uint8Array {\n  const writer = new BinaryWriter(32);\n  writer.writeU256(data);\n  return writer.getBuffer();\n}\n\nexport function u256ToHexString(data: bigint): string {\n  return uint8ArrayToHexString(u256ToUint8Array(data));\n}\n\n/**\n * Type safe conversion from a string like \"some_identifier-name\" to \"someIdentifierName\".\n * @param str The string to convert\n * @returns The converted string\n */\nexport function toCamelCase<T extends string>(str: T): CamelCase<T> {\n  return str\n    .replace(/[-_]+/g, '_') // collapse runs to a single separator (no backtracking issue)\n    .replace(/_([a-zA-Z0-9])/g, (_, c) => c.toUpperCase()) as CamelCase<T>;\n}\n\n/** Type safe conversion from a string like \"some_Identifier-name\" to \"some_identifier_name\".\n * @param str The string to convert\n * @returns The converted string\n */\nexport function toSnakeCase<T extends string>(str: T): SnakeCase<T> {\n  return str\n    .replace(/([A-Z])/g, '_$1') // insert underscores before capitals\n    .replace(/[-\\s]+/g, '_') // replace spaces and dashes with underscores\n    .toLowerCase() as SnakeCase<T>;\n}\n\nimport type { AlgebraicType } from './algebraic_type';\nimport type { Typespace } from './autogen/types';\nimport type { ColumnBuilder, TypeBuilder } from './type_builders';\nimport type { ParamsObj } from './reducers';\n\nexport function bsatnBaseSize(typespace: Typespace, ty: AlgebraicType): number {\n  const assumedArrayLength = 4;\n  while (ty.tag === 'Ref') ty = typespace.types[ty.value];\n  if (ty.tag === 'Product') {\n    let sum = 0;\n    for (const { algebraicType: elem } of ty.value.elements) {\n      sum += bsatnBaseSize(typespace, elem);\n    }\n    return sum;\n  } else if (ty.tag === 'Sum') {\n    let min = Infinity;\n    for (const { algebraicType: vari } of ty.value.variants) {\n      const vSize = bsatnBaseSize(typespace, vari);\n      if (vSize < min) min = vSize;\n    }\n    if (min === Infinity) min = 0;\n    return 4 + min;\n  } else if (ty.tag == 'Array') {\n    return 4 + assumedArrayLength * bsatnBaseSize(typespace, ty.value);\n  }\n  return {\n    String: 4 + assumedArrayLength,\n    Sum: 1,\n    Bool: 1,\n    I8: 1,\n    U8: 1,\n    I16: 2,\n    U16: 2,\n    I32: 4,\n    U32: 4,\n    F32: 4,\n    I64: 8,\n    U64: 8,\n    F64: 8,\n    I128: 16,\n    U128: 16,\n    I256: 32,\n    U256: 32,\n  }[ty.tag];\n}\n\nexport type CoerceTypeBuilder<\n  Col extends TypeBuilder<any, any> | ColumnBuilder<any, any, any>,\n> = Col extends ColumnBuilder<any, any> ? Col['typeBuilder'] : Col;\n\nexport type CoerceParams<Params extends ParamsObj> = {\n  [k in keyof Params & string]: CoerceTypeBuilder<Params[k]>;\n};\n\nexport function coerceParams<Params extends ParamsObj>(\n  params: Params\n): CoerceParams<Params> {\n  return Object.fromEntries(\n    Object.entries(params).map(([n, c]) => [\n      n,\n      'typeBuilder' in c ? c.typeBuilder : c,\n    ])\n  ) as CoerceParams<Params>;\n}\n\nexport const hasOwn: <K extends PropertyKey>(\n  o: object,\n  k: K\n) => o is K extends PropertyKey ? { [k in K]: unknown } : never =\n  Object.hasOwn as any;\n","import { AlgebraicType } from './algebraic_type';\nimport { hexStringToU128, u128ToHexString, u128ToUint8Array } from './util';\n\nexport type ConnectionIdAlgebraicType = {\n  tag: 'Product';\n  value: {\n    elements: [{ name: '__connection_id__'; algebraicType: { tag: 'U128' } }];\n  };\n};\n\n/**\n * A unique identifier for a client connected to a database.\n */\nexport class ConnectionId {\n  __connection_id__: bigint;\n\n  /**\n   * Creates a new `ConnectionId`.\n   */\n  constructor(data: bigint) {\n    this.__connection_id__ = data;\n  }\n\n  /**\n   * Get the algebraic type representation of the {@link ConnectionId} type.\n   * @returns The algebraic type representation of the type.\n   */\n  static getAlgebraicType(): ConnectionIdAlgebraicType {\n    return AlgebraicType.Product({\n      elements: [\n        { name: '__connection_id__', algebraicType: AlgebraicType.U128 },\n      ],\n    });\n  }\n\n  isZero(): boolean {\n    return this.__connection_id__ === BigInt(0);\n  }\n\n  static nullIfZero(addr: ConnectionId): ConnectionId | null {\n    if (addr.isZero()) {\n      return null;\n    } else {\n      return addr;\n    }\n  }\n\n  static random(): ConnectionId {\n    function randomU8(): number {\n      return Math.floor(Math.random() * 0xff);\n    }\n    let result = BigInt(0);\n    for (let i = 0; i < 16; i++) {\n      result = (result << BigInt(8)) | BigInt(randomU8());\n    }\n    return new ConnectionId(result);\n  }\n\n  /**\n   * Compare two connection IDs for equality.\n   */\n  isEqual(other: ConnectionId): boolean {\n    return this.__connection_id__ == other.__connection_id__;\n  }\n\n  /**\n   * Check if two connection IDs are equal.\n   */\n  equals(other: ConnectionId): boolean {\n    return this.isEqual(other);\n  }\n\n  /**\n   * Print the connection ID as a hexadecimal string.\n   */\n  toHexString(): string {\n    return u128ToHexString(this.__connection_id__);\n  }\n\n  /**\n   * Convert the connection ID to a Uint8Array.\n   */\n  toUint8Array(): Uint8Array {\n    return u128ToUint8Array(this.__connection_id__);\n  }\n\n  /**\n   * Parse a connection ID from a hexadecimal string.\n   */\n  static fromString(str: string): ConnectionId {\n    return new ConnectionId(hexStringToU128(str));\n  }\n\n  static fromStringOrNull(str: string): ConnectionId | null {\n    const addr = ConnectionId.fromString(str);\n    if (addr.isZero()) {\n      return null;\n    } else {\n      return addr;\n    }\n  }\n}\n","import { AlgebraicType } from './algebraic_type';\nimport { hexStringToU256, u256ToHexString, u256ToUint8Array } from './util';\n\nexport type IdentityAlgebraicType = {\n  tag: 'Product';\n  value: {\n    elements: [{ name: '__identity__'; algebraicType: { tag: 'U256' } }];\n  };\n};\n\n/**\n * A unique identifier for a user connected to a database.\n */\nexport class Identity {\n  __identity__: bigint;\n\n  /**\n   * Creates a new `Identity`.\n   *\n   * `data` can be a hexadecimal string or a `bigint`.\n   */\n  constructor(data: string | bigint) {\n    // we get a JSON with __identity__ when getting a token with a JSON API\n    // and an bigint when using BSATN\n    this.__identity__ = typeof data === 'string' ? hexStringToU256(data) : data;\n  }\n\n  /**\n   * Get the algebraic type representation of the {@link Identity} type.\n   * @returns The algebraic type representation of the type.\n   */\n  static getAlgebraicType(): IdentityAlgebraicType {\n    return AlgebraicType.Product({\n      elements: [{ name: '__identity__', algebraicType: AlgebraicType.U256 }],\n    });\n  }\n\n  /**\n   * Check if two identities are equal.\n   */\n  isEqual(other: Identity): boolean {\n    return this.toHexString() === other.toHexString();\n  }\n\n  /**\n   * Check if two identities are equal.\n   */\n  equals(other: Identity): boolean {\n    return this.isEqual(other);\n  }\n\n  /**\n   * Print the identity as a hexadecimal string.\n   */\n  toHexString(): string {\n    return u256ToHexString(this.__identity__);\n  }\n\n  /**\n   * Convert the address to a Uint8Array.\n   */\n  toUint8Array(): Uint8Array {\n    return u256ToUint8Array(this.__identity__);\n  }\n\n  /**\n   * Parse an Identity from a hexadecimal string.\n   */\n  static fromString(str: string): Identity {\n    return new Identity(str);\n  }\n\n  /**\n   * Zero identity (0x0000000000000000000000000000000000000000000000000000000000000000)\n   */\n  static zero(): Identity {\n    return new Identity(0n);\n  }\n\n  toString(): string {\n    return this.toHexString();\n  }\n}\n","import { TimeDuration } from './time_duration';\nimport { Timestamp } from './timestamp';\nimport { Uuid } from './uuid';\nimport { ConnectionId } from './connection_id';\nimport BinaryReader from './binary_reader';\nimport BinaryWriter from './binary_writer';\nimport { Identity } from './identity';\nimport * as AlgebraicTypeVariants from './algebraic_type_variants';\nimport { hasOwn } from './util';\n\ntype TypespaceType = {\n  types: AlgebraicTypeType[];\n};\n\nexport type ProductTypeType = {\n  elements: ProductTypeElement[];\n};\n\n/**\n * A factor / element of a product type.\n *\n * An element consist of an optional name and a type.\n *\n * NOTE: Each element has an implicit element tag based on its order.\n * Uniquely identifies an element similarly to protobuf tags.\n */\nexport type ProductTypeElement = {\n  name: string | undefined;\n  algebraicType: AlgebraicTypeType;\n};\n\nexport type SumTypeType = {\n  variants: SumTypeVariant[];\n};\n\n/**\n * A variant of a sum type.\n *\n * NOTE: Each element has an implicit element tag based on its order.\n * Uniquely identifies an element similarly to protobuf tags.\n */\nexport type SumTypeVariant = {\n  name: string | undefined;\n  algebraicType: AlgebraicTypeType;\n};\n\nexport type AlgebraicTypeType =\n  | AlgebraicTypeVariants.Ref\n  | AlgebraicTypeVariants.Sum\n  | AlgebraicTypeVariants.Product\n  | AlgebraicTypeVariants.Array\n  | AlgebraicTypeVariants.String\n  | AlgebraicTypeVariants.Bool\n  | AlgebraicTypeVariants.I8\n  | AlgebraicTypeVariants.U8\n  | AlgebraicTypeVariants.I16\n  | AlgebraicTypeVariants.U16\n  | AlgebraicTypeVariants.I32\n  | AlgebraicTypeVariants.U32\n  | AlgebraicTypeVariants.I64\n  | AlgebraicTypeVariants.U64\n  | AlgebraicTypeVariants.I128\n  | AlgebraicTypeVariants.U128\n  | AlgebraicTypeVariants.I256\n  | AlgebraicTypeVariants.U256\n  | AlgebraicTypeVariants.F32\n  | AlgebraicTypeVariants.F64;\n\nexport type AlgebraicType = AlgebraicTypeType;\n\n/**\n * The variant types of the Algebraic Type tagged union.\n */\nexport { AlgebraicTypeVariants };\n\nexport type Serializer<T> = (writer: BinaryWriter, value: T) => void;\n\nexport type Deserializer<T> = (reader: BinaryReader) => T;\n\n// Caches to prevent `makeSerializer`/`makeDeserializer` from recursing\n// infinitely when called on recursive types.\n//\n// We check for recursion in `{Product,Sum}Type.make{Deser,Ser}ializer` rather\n// than in `AlgebraciType.make{Deser,Ser}ializer` because we need to store the\n// [de]serializer in the cache before recursing into its fields/variants, and\n// we wouldn't be able to do that in the `AlgebraicType` functions.\nconst SERIALIZERS = new Map<ProductType | SumType, Serializer<any>>();\nconst DESERIALIZERS = new Map<ProductType | SumType, Deserializer<any>>();\n\n// A value with helper functions to construct the type.\nexport const AlgebraicType = {\n  Ref: (value: number): AlgebraicTypeVariants.Ref => ({ tag: 'Ref', value }),\n  Sum: <T extends SumTypeType>(value: T): { tag: 'Sum'; value: T } => ({\n    tag: 'Sum',\n    value,\n  }),\n  Product: <T extends ProductTypeType>(\n    value: T\n  ): { tag: 'Product'; value: T } => ({\n    tag: 'Product',\n    value,\n  }),\n  Array: <T extends AlgebraicTypeType>(\n    value: T\n  ): { tag: 'Array'; value: T } => ({\n    tag: 'Array',\n    value,\n  }),\n  String: { tag: 'String' } as const,\n  Bool: { tag: 'Bool' } as const,\n  I8: { tag: 'I8' } as const,\n  U8: { tag: 'U8' } as const,\n  I16: { tag: 'I16' } as const,\n  U16: { tag: 'U16' } as const,\n  I32: { tag: 'I32' } as const,\n  U32: { tag: 'U32' } as const,\n  I64: { tag: 'I64' } as const,\n  U64: { tag: 'U64' } as const,\n  I128: { tag: 'I128' } as const,\n  U128: { tag: 'U128' } as const,\n  I256: { tag: 'I256' } as const,\n  U256: { tag: 'U256' } as const,\n  F32: { tag: 'F32' } as const,\n  F64: { tag: 'F64' } as const,\n  makeSerializer(\n    ty: AlgebraicTypeType,\n    typespace?: TypespaceType\n  ): Serializer<any> {\n    if (ty.tag === 'Ref') {\n      if (!typespace)\n        throw new Error('cannot serialize refs without a typespace');\n      while (ty.tag === 'Ref') ty = typespace.types[ty.value];\n    }\n    switch (ty.tag) {\n      case 'Product':\n        return ProductType.makeSerializer(ty.value, typespace);\n      case 'Sum':\n        return SumType.makeSerializer(ty.value, typespace);\n      case 'Array':\n        if (ty.value.tag === 'U8') {\n          return serializeUint8Array;\n        } else {\n          const serialize = AlgebraicType.makeSerializer(ty.value, typespace);\n          return (writer, value) => {\n            writer.writeU32(value.length);\n            for (const elem of value) {\n              serialize(writer, elem);\n            }\n          };\n        }\n      default:\n        return primitiveSerializers[ty.tag];\n    }\n  },\n  /** @deprecated Use `makeSerializer` instead. */\n  serializeValue(\n    writer: BinaryWriter,\n    ty: AlgebraicTypeType,\n    value: any,\n    typespace?: TypespaceType\n  ) {\n    AlgebraicType.makeSerializer(ty, typespace)(writer, value);\n  },\n  makeDeserializer(\n    ty: AlgebraicTypeType,\n    typespace?: TypespaceType\n  ): Deserializer<any> {\n    if (ty.tag === 'Ref') {\n      if (!typespace)\n        throw new Error('cannot deserialize refs without a typespace');\n      while (ty.tag === 'Ref') ty = typespace.types[ty.value];\n    }\n    switch (ty.tag) {\n      case 'Product':\n        return ProductType.makeDeserializer(ty.value, typespace);\n      case 'Sum':\n        return SumType.makeDeserializer(ty.value, typespace);\n      case 'Array':\n        if (ty.value.tag === 'U8') {\n          return deserializeUint8Array;\n        } else {\n          const deserialize = AlgebraicType.makeDeserializer(\n            ty.value,\n            typespace\n          );\n          return reader => {\n            const length = reader.readU32();\n            const result: any[] = Array(length);\n            for (let i = 0; i < length; i++) {\n              result[i] = deserialize(reader);\n            }\n            return result;\n          };\n        }\n      default:\n        return primitiveDeserializers[ty.tag];\n    }\n  },\n  /** @deprecated Use `makeDeserializer` instead. */\n  deserializeValue(\n    reader: BinaryReader,\n    ty: AlgebraicTypeType,\n    typespace?: TypespaceType\n  ): any {\n    return AlgebraicType.makeDeserializer(ty, typespace)(reader);\n  },\n  /**\n   * Convert a value of the algebraic type into something that can be used as a key in a map.\n   * There are no guarantees about being able to order it.\n   * This is only guaranteed to be comparable to other values of the same type.\n   * @param value A value of the algebraic type\n   * @returns Something that can be used as a key in a map.\n   */\n  intoMapKey: function (\n    ty: AlgebraicTypeType,\n    value: any\n  ): ComparablePrimitive {\n    switch (ty.tag) {\n      case 'U8':\n      case 'U16':\n      case 'U32':\n      case 'U64':\n      case 'U128':\n      case 'U256':\n      case 'I8':\n      case 'I16':\n      case 'I32':\n      case 'I64':\n      case 'I128':\n      case 'I256':\n      case 'F32':\n      case 'F64':\n      case 'String':\n      case 'Bool':\n        return value;\n      case 'Product':\n        return ProductType.intoMapKey(ty.value, value);\n      default: {\n        // The fallback is to serialize and base64 encode the bytes.\n        const writer = new BinaryWriter(10);\n        AlgebraicType.serializeValue(writer, ty, value);\n        return writer.toBase64();\n      }\n    }\n  },\n};\n\nfunction bindCall<F extends (this: any, ...args: any[]) => any>(\n  f: F\n): (recv: ThisParameterType<F>, ...args: Parameters<F>) => ReturnType<F> {\n  return Function.prototype.call.bind(f);\n}\n\ntype Primitives = Exclude<\n  AlgebraicType['tag'],\n  'Ref' | 'Sum' | 'Product' | 'Array'\n>;\n\nconst primitiveSerializers: Record<Primitives, Serializer<any>> = {\n  Bool: bindCall(BinaryWriter.prototype.writeBool),\n  I8: bindCall(BinaryWriter.prototype.writeI8),\n  U8: bindCall(BinaryWriter.prototype.writeU8),\n  I16: bindCall(BinaryWriter.prototype.writeI16),\n  U16: bindCall(BinaryWriter.prototype.writeU16),\n  I32: bindCall(BinaryWriter.prototype.writeI32),\n  U32: bindCall(BinaryWriter.prototype.writeU32),\n  I64: bindCall(BinaryWriter.prototype.writeI64),\n  U64: bindCall(BinaryWriter.prototype.writeU64),\n  I128: bindCall(BinaryWriter.prototype.writeI128),\n  U128: bindCall(BinaryWriter.prototype.writeU128),\n  I256: bindCall(BinaryWriter.prototype.writeI256),\n  U256: bindCall(BinaryWriter.prototype.writeU256),\n  F32: bindCall(BinaryWriter.prototype.writeF32),\n  F64: bindCall(BinaryWriter.prototype.writeF64),\n  String: bindCall(BinaryWriter.prototype.writeString),\n};\nObject.freeze(primitiveSerializers);\n\nconst serializeUint8Array = bindCall(BinaryWriter.prototype.writeUInt8Array);\n\nconst primitiveDeserializers: Record<Primitives, Deserializer<any>> = {\n  Bool: bindCall(BinaryReader.prototype.readBool),\n  I8: bindCall(BinaryReader.prototype.readI8),\n  U8: bindCall(BinaryReader.prototype.readU8),\n  I16: bindCall(BinaryReader.prototype.readI16),\n  U16: bindCall(BinaryReader.prototype.readU16),\n  I32: bindCall(BinaryReader.prototype.readI32),\n  U32: bindCall(BinaryReader.prototype.readU32),\n  I64: bindCall(BinaryReader.prototype.readI64),\n  U64: bindCall(BinaryReader.prototype.readU64),\n  I128: bindCall(BinaryReader.prototype.readI128),\n  U128: bindCall(BinaryReader.prototype.readU128),\n  I256: bindCall(BinaryReader.prototype.readI256),\n  U256: bindCall(BinaryReader.prototype.readU256),\n  F32: bindCall(BinaryReader.prototype.readF32),\n  F64: bindCall(BinaryReader.prototype.readF64),\n  String: bindCall(BinaryReader.prototype.readString),\n};\nObject.freeze(primitiveDeserializers);\n\nconst deserializeUint8Array = bindCall(BinaryReader.prototype.readUInt8Array);\n\ntype FixedSizePrimitives = Exclude<Primitives, 'String'>;\n\nconst primitiveSizes: Record<FixedSizePrimitives, number> = {\n  Bool: 1,\n  I8: 1,\n  U8: 1,\n  I16: 2,\n  U16: 2,\n  I32: 4,\n  U32: 4,\n  I64: 8,\n  U64: 8,\n  I128: 16,\n  U128: 16,\n  I256: 32,\n  U256: 32,\n  F32: 4,\n  F64: 8,\n};\n\nconst fixedSizePrimitives = new Set(Object.keys(primitiveSizes));\n\ntype FixedSizeProductType = {\n  elements: { name: string; algebraicType: { tag: FixedSizePrimitives } }[];\n};\n\nconst isFixedSizeProduct = (ty: ProductType): ty is FixedSizeProductType =>\n  ty.elements.every(({ algebraicType }) =>\n    fixedSizePrimitives.has(algebraicType.tag)\n  );\n\nconst productSize = (ty: FixedSizeProductType): number =>\n  ty.elements.reduce(\n    (acc, { algebraicType }) => acc + primitiveSizes[algebraicType.tag],\n    0\n  );\n\ntype JSPrimitives = Exclude<\n  FixedSizePrimitives,\n  'I128' | 'U128' | 'I256' | 'U256'\n>;\n\nconst primitiveJSName: Record<JSPrimitives, string> = {\n  Bool: 'Uint8',\n  I8: 'Int8',\n  U8: 'Uint8',\n  I16: 'Int16',\n  U16: 'Uint16',\n  I32: 'Int32',\n  U32: 'Uint32',\n  I64: 'BigInt64',\n  U64: 'BigUint64',\n  F32: 'Float32',\n  F64: 'Float64',\n};\n\ntype SpecialProducts = {\n  __time_duration_micros__: TimeDuration;\n  __timestamp_micros_since_unix_epoch__: Timestamp;\n  __identity__: Identity;\n  __connection_id__: ConnectionId;\n  __uuid__: Uuid;\n};\n\nconst specialProductDeserializers: {\n  [k in keyof SpecialProducts]: Deserializer<SpecialProducts[k]>;\n} = {\n  __time_duration_micros__: reader => new TimeDuration(reader.readI64()),\n  __timestamp_micros_since_unix_epoch__: reader =>\n    new Timestamp(reader.readI64()),\n  __identity__: reader => new Identity(reader.readU256()),\n  __connection_id__: reader => new ConnectionId(reader.readU128()),\n  __uuid__: reader => new Uuid(reader.readU128()),\n};\nObject.freeze(specialProductDeserializers);\n\nconst unitDeserializer: Deserializer<{}> = () => ({});\n\nconst getElementInitializer = (element: ProductTypeElement) => {\n  let init: string;\n  switch (element.algebraicType.tag) {\n    case 'String':\n      init = \"''\";\n      break;\n    case 'Bool':\n      init = 'false';\n      break;\n    case 'I8':\n    case 'U8':\n    case 'I16':\n    case 'U16':\n    case 'I32':\n    case 'U32':\n      init = '0';\n      break;\n    case 'I64':\n    case 'U64':\n    case 'I128':\n    case 'U128':\n    case 'I256':\n    case 'U256':\n      init = '0n';\n      break;\n    case 'F32':\n    case 'F64':\n      init = '0.0';\n      break;\n    default:\n      init = 'undefined';\n  }\n  return `${element.name!}: ${init}`;\n};\n\n/**\n * A structural product type  of the factors given by `elements`.\n *\n * This is also known as `struct` and `tuple` in many languages,\n * but note that unlike most languages, products in SATs are *[structural]* and not nominal.\n * When checking whether two nominal types are the same,\n * their names and/or declaration sites (e.g., module / namespace) are considered.\n * Meanwhile, a structural type system would only check the structure of the type itself,\n * e.g., the names of its fields and their types in the case of a record.\n * The name \"product\" comes from category theory.\n *\n * See also: https://ncatlab.org/nlab/show/product+type.\n *\n * These structures are known as product types because the number of possible values in product\n * ```ignore\n * { N_0: T_0, N_1: T_1, ..., N_n: T_n }\n * ```\n * is:\n * ```ignore\n *  (i  0..n). values(T_i)\n * ```\n * so for example, `values({ A: U64, B: Bool }) = values(U64) * values(Bool)`.\n *\n * [structural]: https://en.wikipedia.org/wiki/Structural_type_system\n */\nexport type ProductType = ProductTypeType;\n\nexport const ProductType = {\n  makeSerializer(\n    ty: ProductTypeType,\n    typespace?: TypespaceType\n  ): Serializer<any> {\n    let serializer = SERIALIZERS.get(ty);\n    if (serializer != null) return serializer;\n\n    if (isFixedSizeProduct(ty)) {\n      const size = productSize(ty);\n      const body = `\\\n\"use strict\";\nwriter.expandBuffer(${size});\nconst view = writer.view;\n${ty.elements\n  .map(({ name, algebraicType: { tag } }) =>\n    tag in primitiveJSName\n      ? `\\\nview.set${primitiveJSName[tag as JSPrimitives]}(writer.offset, value.${name!}, ${primitiveSizes[tag] > 1 ? 'true' : ''});\nwriter.offset += ${primitiveSizes[tag]};`\n      : `writer.write${tag}(value.${name});`\n  )\n  .join('\\n')}`;\n      serializer = Function('writer', 'value', body) as Serializer<any>;\n      SERIALIZERS.set(ty, serializer);\n      return serializer;\n    }\n\n    // Because V8 forces us to generate our code as a string, rather than a proper syntax tree,\n    // we can't have our `body` close over values.\n    // Instead, we construct an object with the values we'd otherwise \"close over\" in `serializers`,\n    // and use `Function.prototype.bind` to pass it as the `this` argument.\n    //\n    // We populate `serializers` after constructing this type's `serializer`\n    // so that it can close over itself, in the case that `ty` is recursive.\n    const serializers: Record<string, Serializer<any>> = {};\n    const body =\n      '\"use strict\";\\n' +\n      ty.elements\n        .map(\n          element => `this.${element.name!}(writer, value.${element.name!});`\n        )\n        .join('\\n');\n    serializer = Function('writer', 'value', body).bind(\n      serializers\n    ) as Serializer<any>;\n    // In case `ty` is recursive, we cache the function *before* before computing\n    // `serializers`, so that a recursive `makeSerializer` with the same `ty` has\n    // an exit condition.\n    SERIALIZERS.set(ty, serializer);\n    for (const { name, algebraicType } of ty.elements) {\n      serializers[name!] = AlgebraicType.makeSerializer(\n        algebraicType,\n        typespace\n      );\n    }\n    Object.freeze(serializers);\n    return serializer;\n  },\n  /** @deprecated Use `makeSerializer` instead. */\n  serializeValue(\n    writer: BinaryWriter,\n    ty: ProductTypeType,\n    value: any,\n    typespace?: TypespaceType\n  ): void {\n    ProductType.makeSerializer(ty, typespace)(writer, value);\n  },\n  makeDeserializer(\n    ty: ProductTypeType,\n    typespace?: TypespaceType\n  ): Deserializer<any> {\n    switch (ty.elements.length) {\n      case 0:\n        return unitDeserializer;\n      case 1: {\n        const fieldName = ty.elements[0].name!;\n        if (hasOwn(specialProductDeserializers, fieldName))\n          return specialProductDeserializers[\n            fieldName as keyof SpecialProducts\n          ];\n      }\n    }\n\n    let deserializer = DESERIALIZERS.get(ty);\n    if (deserializer != null) return deserializer;\n\n    if (isFixedSizeProduct(ty)) {\n      const body = `\\\n\"use strict\";\nconst result = { ${ty.elements.map(getElementInitializer).join(', ')} };\nconst view = reader.view;\n${ty.elements\n  .map(({ name, algebraicType: { tag } }) =>\n    tag in primitiveJSName\n      ? `\\\nresult.${name} = view.get${primitiveJSName[tag as JSPrimitives]}(reader.offset, ${primitiveSizes[tag] > 1 ? 'true' : ''});\nreader.offset += ${primitiveSizes[tag]};`\n      : `result.${name} = reader.read${tag}();`\n  )\n  .join('\\n')}\nreturn result;`;\n      deserializer = Function('reader', body) as Deserializer<any>;\n      DESERIALIZERS.set(ty, deserializer);\n      return deserializer;\n    }\n\n    // Because V8 forces us to generate our code as a string, rather than a proper syntax tree,\n    // we can't have our `body` close over values.\n    // Instead, we construct an object with the values we'd otherwise \"close over\" in `deserializers`,\n    // and use `Function.prototype.bind` to pass it as the `this` argument.\n    //\n    // We populate `deserializers` after constructing this type's `deserializer`\n    // so that it can close over itself, in the case that `ty` is recursive.\n    const deserializers: Record<string, Deserializer<any>> = {};\n    deserializer = Function(\n      'reader',\n      `\\\n\"use strict\";\nconst result = { ${ty.elements.map(getElementInitializer).join(', ')} };\n${ty.elements.map(({ name }) => `result.${name!} = this.${name!}(reader);`).join('\\n')}\nreturn result;`\n    ).bind(deserializers) as Deserializer<any>;\n    // In case `ty` is recursive, we cache the function *before* before computing\n    // `deserializers`, so that a recursive `makeDeserializer` with the same `ty` has\n    // an exit condition.\n    DESERIALIZERS.set(ty, deserializer);\n    for (const { name, algebraicType } of ty.elements) {\n      deserializers[name!] = AlgebraicType.makeDeserializer(\n        algebraicType,\n        typespace\n      );\n    }\n    Object.freeze(deserializers);\n    return deserializer;\n  },\n  /** @deprecated Use `makeDeserializer` instead. */\n  deserializeValue(\n    reader: BinaryReader,\n    ty: ProductTypeType,\n    typespace?: TypespaceType\n  ): any {\n    return ProductType.makeDeserializer(ty, typespace)(reader);\n  },\n  intoMapKey(ty: ProductTypeType, value: any): ComparablePrimitive {\n    if (ty.elements.length === 1) {\n      const fieldName = ty.elements[0].name!;\n      if (hasOwn(specialProductDeserializers, fieldName)) {\n        return value[fieldName];\n      }\n    }\n    // The fallback is to serialize and base64 encode the bytes.\n    const writer = new BinaryWriter(10);\n    AlgebraicType.serializeValue(writer, AlgebraicType.Product(ty), value);\n    return writer.toBase64();\n  },\n};\n\nexport type SumType = SumTypeType;\n\n/**\n * Unlike most languages, sums in SATS are *[structural]* and not nominal.\n * When checking whether two nominal types are the same,\n * their names and/or declaration sites (e.g., module / namespace) are considered.\n * Meanwhile, a structural type system would only check the structure of the type itself,\n * e.g., the names of its variants and their inner data types in the case of a sum.\n *\n * This is also known as a discriminated union (implementation) or disjoint union.\n * Another name is [coproduct (category theory)](https://ncatlab.org/nlab/show/coproduct).\n *\n * These structures are known as sum types because the number of possible values a sum\n * ```ignore\n * { N_0(T_0), N_1(T_1), ..., N_n(T_n) }\n * ```\n * is:\n * ```ignore\n *  (i  0..n). values(T_i)\n * ```\n * so for example, `values({ A(U64), B(Bool) }) = values(U64) + values(Bool)`.\n *\n * See also: https://ncatlab.org/nlab/show/sum+type.\n *\n * [structural]: https://en.wikipedia.org/wiki/Structural_type_system\n */\nexport const SumType = {\n  makeSerializer(ty: SumTypeType, typespace?: TypespaceType): Serializer<any> {\n    if (\n      ty.variants.length == 2 &&\n      ty.variants[0].name === 'some' &&\n      ty.variants[1].name === 'none'\n    ) {\n      const serialize = AlgebraicType.makeSerializer(\n        ty.variants[0].algebraicType,\n        typespace\n      );\n      return (writer, value) => {\n        if (value !== null && value !== undefined) {\n          writer.writeByte(0);\n          serialize(writer, value);\n        } else {\n          writer.writeByte(1);\n        }\n      };\n    } else if (\n      ty.variants.length == 2 &&\n      ty.variants[0].name === 'ok' &&\n      ty.variants[1].name === 'err'\n    ) {\n      const serializeOk = AlgebraicType.makeSerializer(\n        ty.variants[0].algebraicType,\n        typespace\n      );\n      const serializeErr = AlgebraicType.makeSerializer(\n        ty.variants[0].algebraicType,\n        typespace\n      );\n\n      return (writer, value) => {\n        if ('ok' in value) {\n          writer.writeU8(0);\n          serializeOk(writer, value.ok);\n        } else if ('err' in value) {\n          writer.writeU8(1);\n          serializeErr(writer, value.err);\n        } else {\n          throw new TypeError(\n            'could not serialize result: object had neither a `ok` nor an `err` field'\n          );\n        }\n      };\n    } else {\n      let serializer = SERIALIZERS.get(ty);\n      if (serializer != null) return serializer;\n\n      const serializers: Record<string, Serializer<any>> = {};\n\n      const body = `\\\nswitch (value.tag) {\n${ty.variants\n  .map(\n    ({ name }, i) => `\\\n  case ${JSON.stringify(name!)}:\n    writer.writeByte(${i});\n    return this.${name!}(writer, value.value);`\n  )\n  .join('\\n')}\n  default:\n    throw new TypeError(\n      \\`Could not serialize sum type; unknown tag \\${value.tag}\\`\n    )\n}\n`;\n\n      serializer = Function('writer', 'value', body).bind(\n        serializers\n      ) as Serializer<any>;\n\n      // In case `ty` is recursive, we cache the function *before* before computing\n      // `variants`, so that a recursive `makeSerializer` with the same `ty` has\n      // an exit condition.\n      SERIALIZERS.set(ty, serializer);\n\n      for (const { name, algebraicType } of ty.variants) {\n        serializers[name!] = AlgebraicType.makeSerializer(\n          algebraicType,\n          typespace\n        );\n      }\n      Object.freeze(serializers);\n      return serializer;\n    }\n  },\n  /** @deprecated Use `makeSerializer` instead. */\n  serializeValue(\n    writer: BinaryWriter,\n    ty: SumTypeType,\n    value: any,\n    typespace?: TypespaceType\n  ): void {\n    SumType.makeSerializer(ty, typespace)(writer, value);\n  },\n  makeDeserializer(\n    ty: SumTypeType,\n    typespace?: TypespaceType\n  ): Deserializer<any> {\n    // In TypeScript we handle Option values as a special case\n    // we don't represent the some and none variants, but instead\n    // we represent the value directly.\n    //\n    // For these special cases, we don't do dynamic codegen, since that has the\n    // most benefit in cases where the object has a different shape. Since\n    // option/result always have the same number of variants, there's not as\n    // much benefit for the amount of work.\n    if (\n      ty.variants.length == 2 &&\n      ty.variants[0].name === 'some' &&\n      ty.variants[1].name === 'none'\n    ) {\n      const deserialize = AlgebraicType.makeDeserializer(\n        ty.variants[0].algebraicType,\n        typespace\n      );\n      return reader => {\n        const tag = reader.readU8();\n        if (tag === 0) {\n          return deserialize(reader);\n        } else if (tag === 1) {\n          return undefined;\n        } else {\n          throw `Can't deserialize an option type, couldn't find ${tag} tag`;\n        }\n      };\n    } else if (\n      ty.variants.length == 2 &&\n      ty.variants[0].name === 'ok' &&\n      ty.variants[1].name === 'err'\n    ) {\n      const deserializeOk = AlgebraicType.makeDeserializer(\n        ty.variants[0].algebraicType,\n        typespace\n      );\n      const deserializeErr = AlgebraicType.makeDeserializer(\n        ty.variants[1].algebraicType,\n        typespace\n      );\n      return reader => {\n        const tag = reader.readByte();\n        if (tag === 0) {\n          return { ok: deserializeOk(reader) };\n        } else if (tag === 1) {\n          return { err: deserializeErr(reader) };\n        } else {\n          throw `Can't deserialize a result type, couldn't find ${tag} tag`;\n        }\n      };\n    } else {\n      let deserializer = DESERIALIZERS.get(ty);\n      if (deserializer != null) return deserializer;\n      const deserializers: Record<string, Deserializer<any>> = {};\n      deserializer = Function(\n        'reader',\n        `switch (reader.readU8()) {\\n${ty.variants\n          .map(\n            ({ name }, i) =>\n              `case ${i}: return { tag: ${JSON.stringify(name!)}, value: this.${name!}(reader) };`\n          )\n          .join('\\n')} }`\n      ).bind(deserializers) as Deserializer<any>;\n      // In case `ty` is recursive, we cache the function *before* before computing\n      // `deserializers`, so that a recursive `makeDeserializer` with the same `ty` has\n      // an exit condition.\n      DESERIALIZERS.set(ty, deserializer);\n      for (const { name, algebraicType } of ty.variants) {\n        deserializers[name!] = AlgebraicType.makeDeserializer(\n          algebraicType,\n          typespace\n        );\n      }\n      Object.freeze(deserializers);\n      return deserializer;\n    }\n  },\n  /** @deprecated Use `makeDeserializer` instead. */\n  deserializeValue(\n    reader: BinaryReader,\n    ty: SumTypeType,\n    typespace?: TypespaceType\n  ): any {\n    return SumType.makeDeserializer(ty, typespace)(reader);\n  },\n};\n\nexport type ComparablePrimitive = number | string | boolean | bigint;\n","import { AlgebraicType } from './algebraic_type';\n\nexport type OptionAlgebraicType<T extends AlgebraicType = AlgebraicType> = {\n  tag: 'Sum';\n  value: {\n    variants: [\n      { name: 'some'; algebraicType: T },\n      {\n        name: 'none';\n        algebraicType: { tag: 'Product'; value: { elements: [] } };\n      },\n    ];\n  };\n};\n\nexport const Option: {\n  getAlgebraicType<T extends AlgebraicType = AlgebraicType>(\n    innerType: T\n  ): OptionAlgebraicType<T>;\n} = {\n  getAlgebraicType<T extends AlgebraicType = AlgebraicType>(\n    innerType: T\n  ): OptionAlgebraicType<T> {\n    return AlgebraicType.Sum({\n      variants: [\n        { name: 'some', algebraicType: innerType },\n        {\n          name: 'none',\n          algebraicType: AlgebraicType.Product({ elements: [] }),\n        },\n      ],\n    });\n  },\n};\n","import { AlgebraicType } from './algebraic_type';\n\nexport type ResultAlgebraicType<\n  T extends AlgebraicType = AlgebraicType,\n  E extends AlgebraicType = AlgebraicType,\n> = {\n  tag: 'Sum';\n  value: {\n    variants: [\n      { name: 'ok'; algebraicType: T },\n      { name: 'err'; algebraicType: E },\n    ];\n  };\n};\n\nexport const Result: {\n  getAlgebraicType<\n    T extends AlgebraicType = AlgebraicType,\n    E extends AlgebraicType = AlgebraicType,\n  >(\n    okType: T,\n    errType: E\n  ): ResultAlgebraicType<T, E>;\n} = {\n  getAlgebraicType<\n    T extends AlgebraicType = AlgebraicType,\n    E extends AlgebraicType = AlgebraicType,\n  >(okType: T, errType: E): ResultAlgebraicType<T, E> {\n    return AlgebraicType.Sum({\n      variants: [\n        { name: 'ok', algebraicType: okType },\n        { name: 'err', algebraicType: errType },\n      ],\n    });\n  },\n};\n","import { AlgebraicType } from './algebraic_type';\nimport { TimeDuration, type TimeDurationAlgebraicType } from './time_duration';\nimport { Timestamp, type TimestampAlgebraicType } from './timestamp';\n\nexport type ScheduleAtAlgebraicType = {\n  tag: 'Sum';\n  value: {\n    variants: [\n      { name: 'Interval'; algebraicType: TimeDurationAlgebraicType },\n      { name: 'Time'; algebraicType: TimestampAlgebraicType },\n    ];\n  };\n};\n\ntype ScheduleAtType = Interval | Time;\n\nexport const ScheduleAt: {\n  interval: (micros: bigint) => ScheduleAtType;\n  time: (microsSinceUnixEpoch: bigint) => ScheduleAtType;\n  /**\n   * Get the algebraic type representation of the {@link ScheduleAt} type.\n   * @returns The algebraic type representation of the type.\n   */\n  getAlgebraicType(): ScheduleAtAlgebraicType;\n  isScheduleAt(\n    algebraicType: AlgebraicType\n  ): algebraicType is ScheduleAtAlgebraicType;\n} = {\n  interval(value: bigint): ScheduleAtType {\n    return Interval(value);\n  },\n  time(value: bigint): ScheduleAtType {\n    return Time(value);\n  },\n  getAlgebraicType(): ScheduleAtAlgebraicType {\n    return AlgebraicType.Sum({\n      variants: [\n        {\n          name: 'Interval',\n          algebraicType: TimeDuration.getAlgebraicType(),\n        },\n        { name: 'Time', algebraicType: Timestamp.getAlgebraicType() },\n      ],\n    });\n  },\n  isScheduleAt(\n    algebraicType: AlgebraicType\n  ): algebraicType is ScheduleAtAlgebraicType {\n    if (algebraicType.tag !== 'Sum') {\n      return false;\n    }\n    const variants = algebraicType.value.variants;\n    if (variants.length !== 2) {\n      return false;\n    }\n    const intervalVariant = variants.find(v => v.name === 'Interval');\n    const timeVariant = variants.find(v => v.name === 'Time');\n    if (!intervalVariant || !timeVariant) {\n      return false;\n    }\n    return (\n      TimeDuration.isTimeDuration(intervalVariant.algebraicType) &&\n      Timestamp.isTimestamp(timeVariant.algebraicType)\n    );\n  },\n};\n\nexport type Interval = {\n  tag: 'Interval';\n  value: TimeDuration;\n};\nexport const Interval = (micros: bigint): Interval => ({\n  tag: 'Interval',\n  value: new TimeDuration(micros),\n});\nexport type Time = {\n  tag: 'Time';\n  value: Timestamp;\n};\nexport const Time = (microsSinceUnixEpoch: bigint): Time => ({\n  tag: 'Time',\n  value: new Timestamp(microsSinceUnixEpoch),\n});\n\nexport default ScheduleAt;\nexport type ScheduleAt = ScheduleAtType;\n","import type { ConnectionId } from './connection_id';\nimport type { Identity } from './identity';\nimport type { ScheduleAt } from './schedule_at';\nimport type { TimeDuration } from './time_duration';\nimport type { Timestamp } from './timestamp';\n\ntype DoNotPrettify =\n  | Identity\n  | ConnectionId\n  | Timestamp\n  | TimeDuration\n  | ScheduleAt;\n\n/**\n * Utility to make TS show cleaner types by flattening intersections.\n */\nexport type Prettify<T> = T extends DoNotPrettify\n  ? T\n  : { [K in keyof T]: T[K] } & {};\n\n/**\n * Helper function to sets a field in an object\n */\nexport type SetField<T, F extends string, V> = Prettify<\n  Omit<T, F> & { [K in F]: V }\n>;\n\n/**\n * Sets a field in an object\n * @param x The original object\n * @param t The object containing the field to set\n * @returns A new object with the field set\n */\nexport function set<T, F extends string, V>(\n  x: T,\n  t: { [k in F]: V }\n): SetField<T, F, V> {\n  return { ...x, ...t } as SetField<T, F, V>;\n}\n\n/**\n * Helper to extract the value types from an object type\n */\nexport type Values<T> = T[keyof T];\n\n/**\n * A helper type to collapse a tuple into a single type if it has only one element.\n */\nexport type CollapseTuple<A extends any[]> = A extends [infer T] ? T : A;\n\ntype CamelCaseImpl<S extends string> = S extends `${infer Head}_${infer Tail}`\n  ? `${Head}${Capitalize<CamelCaseImpl<Tail>>}`\n  : S extends `${infer Head}-${infer Tail}`\n    ? `${Head}${Capitalize<CamelCaseImpl<Tail>>}`\n    : S;\n\n/**\n * Convert \"Some_identifier-name\" -> \"someIdentifierName\"\n * - No spaces; allowed separators: \"_\" and \"-\"\n * - Normalizes the *first* character to lowercase (e.g. \"User_Name\" -> \"userName\")\n */\nexport type CamelCase<S extends string> = Uncapitalize<CamelCaseImpl<S>>;\n\n/** Type safe conversion from \"some_identifier-name\" to \"some_identifier_name\"\n * - No spaces; allowed separators: \"_\" and \"-\"\n * - Normalizes the *first* character to lowercase (e.g. \"User_Name\" -> \"user_name\")\n */\nexport type SnakeCase<S extends string> = S extends `${infer Head}${infer Tail}`\n  ? Tail extends Uncapitalize<Tail>\n    ? `${Lowercase<Head>}${SnakeCase<Tail>}`\n    : `${Lowercase<Head>}_${SnakeCase<Tail>}`\n  : Lowercase<S>;\n\ntype PascalCaseImpl<S extends string> = S extends `${infer Head}_${infer Tail}`\n  ? `${Capitalize<Head>}${PascalCaseImpl<Tail>}`\n  : S extends `${infer Head}-${infer Tail}`\n    ? `${Capitalize<Head>}${PascalCaseImpl<Tail>}`\n    : Capitalize<S>;\n\n/**\n * Convert \"some_identifier-name\" -> \"SomeIdentifierName\"\n * - No spaces; allowed separators: \"_\" and \"-\"\n * - Normalizes the *first* character to uppercase (e.g. \"user_name\" -> \"UserName\")\n */\nexport type PascalCase<S extends string> = PascalCaseImpl<S>;\n\n/**\n * Check if a metadata type has fields that are incompatible with default values.\n * Default values cannot be combined with isPrimaryKey, isUnique, or isAutoIncrement.\n */\nexport type HasDefaultIncompatibleFields<M> = M extends {\n  isPrimaryKey: true;\n}\n  ? true\n  : M extends { isUnique: true }\n    ? true\n    : M extends { isAutoIncrement: true }\n      ? true\n      : false;\n\n/**\n * Check if a metadata type has a default value set.\n */\nexport type HasDefaultValue<M> = M extends { defaultValue: any } ? true : false;\n\n/**\n * Validate that a column's metadata doesn't have invalid combinations.\n * Returns the metadata type if valid, or an error type if invalid.\n */\nexport type ValidateColumnMetadata<M> =\n  HasDefaultValue<M> extends true\n    ? HasDefaultIncompatibleFields<M> extends true\n      ? InvalidColumnMetadata<'default() cannot be combined with primaryKey(), unique(), or autoInc()'>\n      : M\n    : M;\n\n/**\n * Error type for invalid column metadata combinations.\n * This type is designed to cause a compile-time error with a descriptive message.\n */\nexport type InvalidColumnMetadata<Message extends string> = {\n  __error: Message;\n  __brand: 'InvalidColumnMetadata';\n};\n","import { AlgebraicType, type AlgebraicTypeVariants } from './algebraic_type';\nimport type BinaryReader from './binary_reader';\nimport type BinaryWriter from './binary_writer';\nimport { ConnectionId, type ConnectionIdAlgebraicType } from './connection_id';\nimport { Identity, type IdentityAlgebraicType } from './identity';\nimport { Option, type OptionAlgebraicType } from './option';\nimport { Result, type ResultAlgebraicType } from './result';\nimport ScheduleAt, { type ScheduleAtAlgebraicType } from './schedule_at';\nimport type { CoerceRow } from './table';\nimport { TimeDuration, type TimeDurationAlgebraicType } from './time_duration';\nimport { Timestamp, type TimestampAlgebraicType } from './timestamp';\nimport { set, type Prettify, type SetField } from './type_util';\nimport { Uuid, type UuidAlgebraicType } from './uuid';\n\n// Used in codegen files\nexport { type AlgebraicTypeType } from './algebraic_type';\n\n/**\n * Helper type to extract the TypeScript type from a TypeBuilder\n */\nexport type InferTypeOfTypeBuilder<T extends TypeBuilder<any, any>> =\n  T extends TypeBuilder<infer U, any> ? Prettify<U> : never;\n\n/**\n * Helper type to extract the Spacetime type from a TypeBuilder\n */\nexport type InferSpacetimeTypeOfTypeBuilder<T extends TypeBuilder<any, any>> =\n  T extends TypeBuilder<any, infer U> ? U : never;\n\n/**\n * Helper type to extract the TypeScript type from a TypeBuilder\n */\nexport type Infer<T> = T extends RowObj\n  ? InferTypeOfRow<T>\n  : T extends TypeBuilder<any, any>\n    ? InferTypeOfTypeBuilder<T>\n    : never;\n\n/**\n * Helper type to extract the type of a row from an object.\n */\nexport type InferTypeOfRow<T extends RowObj> = {\n  [K in keyof T & string]: InferTypeOfTypeBuilder<CollapseColumn<T[K]>>;\n};\n\n/**\n * Helper type to extract the type of a row from an object.\n */\nexport type InferSpacetimeTypeOfRow<T extends RowObj> = {\n  [K in keyof T & string]: InferSpacetimeTypeOfTypeBuilder<\n    CollapseColumn<T[K]>\n  >;\n};\n\n/**\n * Helper type to extract the Spacetime type from a row object.\n */\ntype CollapseColumn<\n  T extends TypeBuilder<any, any> | ColumnBuilder<any, any, any>,\n> = T extends ColumnBuilder<any, any, any> ? T['typeBuilder'] : T;\n\n/**\n * A type representing an object which is used to define the type of\n * a row in a table.\n */\nexport type RowObj = Record<\n  string,\n  TypeBuilder<any, any> | ColumnBuilder<any, any, ColumnMetadata<any>>\n>;\n\n/**\n * Type which converts the elements of RowObj to a ProductType elements array\n */\ntype ElementsArrayFromRowObj<Obj extends RowObj> = Array<\n  {\n    [N in keyof Obj & string]: {\n      name: N;\n      algebraicType: InferSpacetimeTypeOfTypeBuilder<CollapseColumn<Obj[N]>>;\n    };\n  }[keyof Obj & string]\n>;\n\n/**\n * A type which converts the elements of RowObj to a TypeScript object type.\n * It works by `Infer`ing the types of the column builders which are the values of\n * the keys in the object passed in.\n *\n * e.g. { a: I32TypeBuilder, b: StringBuilder } -> { a: number, b: string }\n */\ntype RowType<Row extends RowObj> = {\n  [K in keyof Row]: InferTypeOfTypeBuilder<CollapseColumn<Row[K]>>;\n};\n\n/**\n * Type which represents a valid argument to the ProductColumnBuilder\n */\nexport type ElementsObj = Record<string, TypeBuilder<any, any>>;\n\n/**\n * Type which converts the elements of ElementsObj to a ProductType elements array\n */\ntype ElementsArrayFromElementsObj<Obj extends ElementsObj> = Array<\n  {\n    [N in keyof Obj & string]: {\n      name: N;\n      algebraicType: InferSpacetimeTypeOfTypeBuilder<Obj[N]>;\n    };\n  }[keyof Obj & string]\n>;\n\n/**\n * A type which converts the elements of ElementsObj to a TypeScript object type.\n * It works by `Infer`ing the types of the column builders which are the values of\n * the keys in the object passed in.\n *\n * e.g. { a: I32TypeBuilder, b: StringBuilder } -> { a: number, b: string }\n */\ntype ObjectType<Elements extends ElementsObj> = {\n  [K in keyof Elements]: InferTypeOfTypeBuilder<Elements[K]>;\n};\n\nexport type VariantsObj = Record<string, TypeBuilder<any, any>>;\ntype SimpleVariantsObj = Record<string, UnitBuilder>;\n\ntype IsUnit<B> = B extends UnitBuilder ? true : false;\n\n/**\n * A type which converts the elements of ElementsObj to a TypeScript object type.\n * It works by `Infer`ing the types of the column builders which are the values of\n * the keys in the object passed in.\n *\n * e.g. { A: I32TypeBuilder, B: StringBuilder } -> { tag: \"A\", value: number } | { tag: \"B\", value: string }\n */\ntype EnumType<Variants extends VariantsObj> = {\n  [K in keyof Variants & string]: IsUnit<Variants[K]> extends true\n    ? { tag: K }\n    : { tag: K; value: InferTypeOfTypeBuilder<Variants[K]> };\n}[keyof Variants & string];\n\n/**\n * Type which converts the elements of VariantsObj to a SumType variants array\n */\ntype VariantsArrayFromVariantsObj<Obj extends VariantsObj> = {\n  name: keyof Obj & string;\n  algebraicType: InferSpacetimeTypeOfTypeBuilder<Obj[keyof Obj & string]>;\n}[];\n\n/**\n * A generic type builder that captures both the TypeScript type\n * and the corresponding `AlgebraicType`.\n */\nexport class TypeBuilder<Type, SpacetimeType extends AlgebraicType>\n  implements Optional<Type, SpacetimeType>\n{\n  /**\n   * The TypeScript phantom type. This is not stored at runtime,\n   * but is visible to the compiler\n   */\n  readonly type!: Type;\n\n  /**\n   * The SpacetimeDB algebraic type (runtime value). In addition to storing\n   * the runtime representation of the `AlgebraicType`, it also captures\n   * the TypeScript type information of the `AlgebraicType`. That is to say\n   * the value is not merely an `AlgebraicType`, but is constructed to be\n   * the corresponding concrete `AlgebraicType` for the TypeScript type `Type`.\n   *\n   * e.g. `string` corresponds to `AlgebraicType.String`\n   */\n  readonly algebraicType: SpacetimeType;\n\n  constructor(algebraicType: SpacetimeType) {\n    this.algebraicType = algebraicType;\n  }\n\n  optional(): OptionBuilder<typeof this> {\n    return new OptionBuilder(this);\n  }\n\n  serialize(writer: BinaryWriter, value: Type): void {\n    const serialize = (this.serialize = AlgebraicType.makeSerializer(\n      this.algebraicType\n    ));\n    serialize(writer, value);\n  }\n\n  deserialize(reader: BinaryReader): Type {\n    const deserialize = (this.deserialize = AlgebraicType.makeDeserializer(\n      this.algebraicType\n    ));\n    return deserialize(reader);\n  }\n}\n\n/**\n * Interface for types that can be converted into a column builder with primary key metadata.\n *\n * Implementing this interface allows a type to be marked as the primary key of a table column\n * in a type-safe manner. The `primaryKey()` method returns a new `ColumnBuilder` instance\n * with the metadata updated to indicate that the column is a primary key.\n *\n * @typeParam Type - The TypeScript type of the column's value.\n * @typeParam SpacetimeType - The corresponding SpacetimeDB algebraic type.\n * @typeParam M - The metadata type for the column, defaulting to `DefaultMetadata`.\n *\n * @remarks\n * - This interface is typically implemented by type builders for primitive and complex types.\n * - The returned `ColumnBuilder` will have its metadata extended with `{ isPrimaryKey: true }`.\n * - **Cannot be combined with `default()`.**\n */\ninterface PrimaryKeyable<\n  Type,\n  SpacetimeType extends AlgebraicType,\n  M extends ColumnMetadata<Type> = DefaultMetadata,\n> {\n  /**\n   * Specify this column as primary key\n   * @remarks Cannot be combined with `default()`.\n   */\n  primaryKey(): ColumnBuilder<\n    Type,\n    SpacetimeType,\n    SetField<M, 'isPrimaryKey', true>\n  >;\n}\n\n/**\n * Interface for types that can be converted into a column builder with unique metadata.\n *\n * Implementing this interface allows a type to be marked as unique in a table column\n * in a type-safe manner. The `unique()` method returns a new `ColumnBuilder` instance\n * with the metadata updated to indicate that the column is unique.\n *\n * @typeParam Type - The TypeScript type of the column's value.\n * @typeParam SpacetimeType - The corresponding SpacetimeDB algebraic type.\n * @typeParam M - The metadata type for the column, defaulting to `DefaultMetadata`.\n *\n * @remarks\n * - This interface is typically implemented by type builders for primitive and complex types.\n * - The returned `ColumnBuilder` will have its metadata extended with `{ isUnique: true }`.\n * - **Cannot be combined with `default()`.**\n */\ninterface Uniqueable<\n  Type,\n  SpacetimeType extends AlgebraicType,\n  M extends ColumnMetadata<Type> = DefaultMetadata,\n> {\n  /**\n   * Specify this column as unique\n   * @remarks Cannot be combined with `default()`.\n   */\n  unique(): ColumnBuilder<Type, SpacetimeType, SetField<M, 'isUnique', true>>;\n}\n\n/**\n * Interface for types that can be converted into a column builder with index metadata.\n *\n * Implementing this interface allows a type to be indexed in a table column\n * in a type-safe manner. The `index()` method returns a new `ColumnBuilder` instance\n * with the metadata updated to indicate the index type.\n *\n * @typeParam Type - The TypeScript type of the column's value.\n * @typeParam SpacetimeType - The corresponding SpacetimeDB algebraic type.\n * @typeParam M - The metadata type for the column, defaulting to `DefaultMetadata`.\n *\n * @remarks\n * - This interface is typically implemented by type builders for primitive and complex types.\n * - The returned `ColumnBuilder` will have its metadata extended with `{ indexType: N }`.\n * - Indexing a column may have implications for performance and query optimization.\n */\ninterface Indexable<\n  Type,\n  SpacetimeType extends AlgebraicType,\n  M extends ColumnMetadata<Type> = DefaultMetadata,\n> {\n  /**\n   * Specify the index type for this column\n   * @param algorithm The index algorithm to use\n   */\n  index(): ColumnBuilder<\n    Type,\n    SpacetimeType,\n    SetField<M, 'indexType', 'btree'>\n  >;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): ColumnBuilder<Type, SpacetimeType, SetField<M, 'indexType', N>>;\n}\n\n/**\n * Interface for types that can be converted into a column builder with auto-increment metadata.\n *\n * Implementing this interface allows a type to be marked as auto-incrementing in a table column\n * in a type-safe manner. The `autoInc()` method returns a new `ColumnBuilder` instance\n * with the metadata updated to indicate that the column is auto-incrementing.\n *\n * @typeParam Type - The TypeScript type of the column's value.\n * @typeParam SpacetimeType - The corresponding SpacetimeDB algebraic type.\n * @typeParam M - The metadata type for the column, defaulting to `DefaultMetadata`.\n *\n * @remarks\n * - This interface is typically implemented by type builders for primitive and complex types.\n * - The returned `ColumnBuilder` will have its metadata extended with `{ isAutoIncrement: true }`.\n * - **Cannot be combined with `default()`.**\n */\ninterface AutoIncrementable<\n  Type,\n  SpacetimeType extends AlgebraicType,\n  M extends ColumnMetadata<Type> = DefaultMetadata,\n> {\n  /**\n   * Specify this column as auto-incrementing\n   * @remarks Cannot be combined with `default()`.\n   */\n  autoInc(): ColumnBuilder<\n    Type,\n    SpacetimeType,\n    SetField<M, 'isAutoIncrement', true>\n  >;\n}\n\n/**\n * Interface for types that can be converted into an optional type.\n * All {@link TypeBuilder}s implement this interface, however since the `optional()` method\n * returns an {@link OptionBuilder}, {@link OptionBuilder} controls what metadata is allowed\n * to be configured for the column. This allows us to restrict whether things like indexes\n * or unique constraints can be applied to optional columns.\n *\n * For this reason {@link ColumnBuilder} does not implement this interface.\n */\ninterface Optional<Type, SpacetimeType extends AlgebraicType> {\n  /**\n   * Specify this column as optional\n   */\n  optional(this: TypeBuilder<Type, SpacetimeType>): OptionBuilder<typeof this>;\n}\n\n/**\n * Interface for types that can be converted into a column builder with default value metadata.\n * Implementing this interface allows a type to have a default value specified in a table column\n * in a type-safe manner. The `default()` method returns a new `ColumnBuilder` instance\n * with the metadata updated to include the specified default value.\n *\n * @typeParam Type - The TypeScript type of the column's value.\n * @typeParam SpacetimeType - The corresponding SpacetimeDB algebraic type.\n * @typeParam M - The metadata type for the column, defaulting to `DefaultMetadata`.\n *\n * @remarks\n * - This interface is typically implemented by type builders for primitive and complex types.\n * - The returned `ColumnBuilder` will have its metadata extended with `{ default: value }`.\n * - The default value must be of the same type as the column's TypeScript type.\n * - This method can be called multiple times; the last call takes precedence.\n * - **Cannot be combined with `primaryKey()`, `unique()`, or `autoInc()`.**\n */\ninterface Defaultable<\n  Type,\n  SpacetimeType extends AlgebraicType,\n  M extends ColumnMetadata<Type> = DefaultMetadata,\n> {\n  /**\n   * Specify a default value for this column\n   * @param value The default value for the column\n   * @example\n   * ```typescript\n   * const col = t.i32().default(42);\n   * ```\n   * @remarks\n   * - This method can be called multiple times; the last call takes precedence.\n   * - The default value must be of the same type as the column's TypeScript type.\n   * - Cannot be combined with `primaryKey()`, `unique()`, or `autoInc()`.\n   */\n  default(\n    value: Type\n  ): ColumnBuilder<Type, SpacetimeType, SetField<M, 'defaultValue', Type>>;\n}\n\ninterface Nameable<\n  Type,\n  SpacetimeType extends AlgebraicType,\n  M extends ColumnMetadata<Type> = DefaultMetadata,\n> {\n  /**\n   * Specify the in-database name for this column.\n   */\n  name<const Name extends string>(\n    name: Name\n  ): Nameable<Type, SpacetimeType, SetField<M, 'name', Name>>;\n}\n\nexport class U8Builder\n  extends TypeBuilder<number, AlgebraicTypeVariants.U8>\n  implements\n    Indexable<number, AlgebraicTypeVariants.U8>,\n    Uniqueable<number, AlgebraicTypeVariants.U8>,\n    PrimaryKeyable<number, AlgebraicTypeVariants.U8>,\n    AutoIncrementable<number, AlgebraicTypeVariants.U8>,\n    Defaultable<number, AlgebraicTypeVariants.U8>,\n    Nameable<number, AlgebraicTypeVariants.U8>\n{\n  constructor() {\n    super(AlgebraicType.U8);\n  }\n  index(): U8ColumnBuilder<SetField<DefaultMetadata, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): U8ColumnBuilder<SetField<DefaultMetadata, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): U8ColumnBuilder<SetField<DefaultMetadata, 'indexType', IndexTypes>> {\n    return new U8ColumnBuilder(\n      this,\n      set(defaultMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): U8ColumnBuilder<SetField<DefaultMetadata, 'isUnique', true>> {\n    return new U8ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));\n  }\n  primaryKey(): U8ColumnBuilder<\n    SetField<DefaultMetadata, 'isPrimaryKey', true>\n  > {\n    return new U8ColumnBuilder(\n      this,\n      set(defaultMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): U8ColumnBuilder<\n    SetField<DefaultMetadata, 'isAutoIncrement', true>\n  > {\n    return new U8ColumnBuilder(\n      this,\n      set(defaultMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: number\n  ): U8ColumnBuilder<SetField<DefaultMetadata, 'defaultValue', number>> {\n    return new U8ColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): U8ColumnBuilder<SetField<DefaultMetadata, 'name', Name>> {\n    return new U8ColumnBuilder(this, set(defaultMetadata, { name }));\n  }\n}\n\nexport class U16Builder\n  extends TypeBuilder<number, AlgebraicTypeVariants.U16>\n  implements\n    Indexable<number, AlgebraicTypeVariants.U16>,\n    Uniqueable<number, AlgebraicTypeVariants.U16>,\n    PrimaryKeyable<number, AlgebraicTypeVariants.U16>,\n    AutoIncrementable<number, AlgebraicTypeVariants.U16>,\n    Defaultable<number, AlgebraicTypeVariants.U16>,\n    Nameable<number, AlgebraicTypeVariants.U16>\n{\n  constructor() {\n    super(AlgebraicType.U16);\n  }\n  index(): U16ColumnBuilder<SetField<DefaultMetadata, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): U16ColumnBuilder<SetField<DefaultMetadata, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): U16ColumnBuilder<SetField<DefaultMetadata, 'indexType', IndexTypes>> {\n    return new U16ColumnBuilder(\n      this,\n      set(defaultMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): U16ColumnBuilder<SetField<DefaultMetadata, 'isUnique', true>> {\n    return new U16ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));\n  }\n  primaryKey(): U16ColumnBuilder<\n    SetField<DefaultMetadata, 'isPrimaryKey', true>\n  > {\n    return new U16ColumnBuilder(\n      this,\n      set(defaultMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): U16ColumnBuilder<\n    SetField<DefaultMetadata, 'isAutoIncrement', true>\n  > {\n    return new U16ColumnBuilder(\n      this,\n      set(defaultMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: number\n  ): U16ColumnBuilder<SetField<DefaultMetadata, 'defaultValue', number>> {\n    return new U16ColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): U16ColumnBuilder<SetField<DefaultMetadata, 'name', Name>> {\n    return new U16ColumnBuilder(this, set(defaultMetadata, { name }));\n  }\n}\n\nexport class U32Builder\n  extends TypeBuilder<number, AlgebraicTypeVariants.U32>\n  implements\n    Indexable<number, AlgebraicTypeVariants.U32>,\n    Uniqueable<number, AlgebraicTypeVariants.U32>,\n    PrimaryKeyable<number, AlgebraicTypeVariants.U32>,\n    AutoIncrementable<number, AlgebraicTypeVariants.U32>,\n    Defaultable<number, AlgebraicTypeVariants.U32>,\n    Nameable<number, AlgebraicTypeVariants.U32>\n{\n  constructor() {\n    super(AlgebraicType.U32);\n  }\n  index(): U32ColumnBuilder<SetField<DefaultMetadata, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): U32ColumnBuilder<SetField<DefaultMetadata, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): U32ColumnBuilder<SetField<DefaultMetadata, 'indexType', IndexTypes>> {\n    return new U32ColumnBuilder(\n      this,\n      set(defaultMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): U32ColumnBuilder<SetField<DefaultMetadata, 'isUnique', true>> {\n    return new U32ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));\n  }\n  primaryKey(): U32ColumnBuilder<\n    SetField<DefaultMetadata, 'isPrimaryKey', true>\n  > {\n    return new U32ColumnBuilder(\n      this,\n      set(defaultMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): U32ColumnBuilder<\n    SetField<DefaultMetadata, 'isAutoIncrement', true>\n  > {\n    return new U32ColumnBuilder(\n      this,\n      set(defaultMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: number\n  ): U32ColumnBuilder<SetField<DefaultMetadata, 'defaultValue', number>> {\n    return new U32ColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): U32ColumnBuilder<SetField<DefaultMetadata, 'name', Name>> {\n    return new U32ColumnBuilder(this, set(defaultMetadata, { name }));\n  }\n}\n\nexport class U64Builder\n  extends TypeBuilder<bigint, AlgebraicTypeVariants.U64>\n  implements\n    Indexable<bigint, AlgebraicTypeVariants.U64>,\n    Uniqueable<bigint, AlgebraicTypeVariants.U64>,\n    PrimaryKeyable<bigint, AlgebraicTypeVariants.U64>,\n    AutoIncrementable<bigint, AlgebraicTypeVariants.U64>,\n    Defaultable<bigint, AlgebraicTypeVariants.U64>,\n    Nameable<bigint, AlgebraicTypeVariants.U64>\n{\n  constructor() {\n    super(AlgebraicType.U64);\n  }\n  index(): U64ColumnBuilder<SetField<DefaultMetadata, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): U64ColumnBuilder<SetField<DefaultMetadata, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): U64ColumnBuilder<SetField<DefaultMetadata, 'indexType', IndexTypes>> {\n    return new U64ColumnBuilder(\n      this,\n      set(defaultMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): U64ColumnBuilder<SetField<DefaultMetadata, 'isUnique', true>> {\n    return new U64ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));\n  }\n  primaryKey(): U64ColumnBuilder<\n    SetField<DefaultMetadata, 'isPrimaryKey', true>\n  > {\n    return new U64ColumnBuilder(\n      this,\n      set(defaultMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): U64ColumnBuilder<\n    SetField<DefaultMetadata, 'isAutoIncrement', true>\n  > {\n    return new U64ColumnBuilder(\n      this,\n      set(defaultMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: bigint\n  ): U64ColumnBuilder<SetField<DefaultMetadata, 'defaultValue', bigint>> {\n    return new U64ColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): U64ColumnBuilder<SetField<DefaultMetadata, 'name', Name>> {\n    return new U64ColumnBuilder(this, set(defaultMetadata, { name }));\n  }\n}\n\nexport class U128Builder\n  extends TypeBuilder<bigint, AlgebraicTypeVariants.U128>\n  implements\n    Indexable<bigint, AlgebraicTypeVariants.U128>,\n    Uniqueable<bigint, AlgebraicTypeVariants.U128>,\n    PrimaryKeyable<bigint, AlgebraicTypeVariants.U128>,\n    AutoIncrementable<bigint, AlgebraicTypeVariants.U128>,\n    Defaultable<bigint, AlgebraicTypeVariants.U128>,\n    Nameable<bigint, AlgebraicTypeVariants.U128>\n{\n  constructor() {\n    super(AlgebraicType.U128);\n  }\n  index(): U128ColumnBuilder<SetField<DefaultMetadata, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): U128ColumnBuilder<SetField<DefaultMetadata, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): U128ColumnBuilder<SetField<DefaultMetadata, 'indexType', IndexTypes>> {\n    return new U128ColumnBuilder(\n      this,\n      set(defaultMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): U128ColumnBuilder<SetField<DefaultMetadata, 'isUnique', true>> {\n    return new U128ColumnBuilder(\n      this,\n      set(defaultMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): U128ColumnBuilder<\n    SetField<DefaultMetadata, 'isPrimaryKey', true>\n  > {\n    return new U128ColumnBuilder(\n      this,\n      set(defaultMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): U128ColumnBuilder<\n    SetField<DefaultMetadata, 'isAutoIncrement', true>\n  > {\n    return new U128ColumnBuilder(\n      this,\n      set(defaultMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: bigint\n  ): U128ColumnBuilder<SetField<DefaultMetadata, 'defaultValue', bigint>> {\n    return new U128ColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): U128ColumnBuilder<SetField<DefaultMetadata, 'name', Name>> {\n    return new U128ColumnBuilder(this, set(defaultMetadata, { name }));\n  }\n}\n\nexport class U256Builder\n  extends TypeBuilder<bigint, AlgebraicTypeVariants.U256>\n  implements\n    Indexable<bigint, AlgebraicTypeVariants.U256>,\n    Uniqueable<bigint, AlgebraicTypeVariants.U256>,\n    PrimaryKeyable<bigint, AlgebraicTypeVariants.U256>,\n    AutoIncrementable<bigint, AlgebraicTypeVariants.U256>,\n    Defaultable<bigint, AlgebraicTypeVariants.U256>,\n    Nameable<bigint, AlgebraicTypeVariants.U256>\n{\n  constructor() {\n    super(AlgebraicType.U256);\n  }\n  index(): U256ColumnBuilder<SetField<DefaultMetadata, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): U256ColumnBuilder<SetField<DefaultMetadata, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): U256ColumnBuilder<SetField<DefaultMetadata, 'indexType', IndexTypes>> {\n    return new U256ColumnBuilder(\n      this,\n      set(defaultMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): U256ColumnBuilder<SetField<DefaultMetadata, 'isUnique', true>> {\n    return new U256ColumnBuilder(\n      this,\n      set(defaultMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): U256ColumnBuilder<\n    SetField<DefaultMetadata, 'isPrimaryKey', true>\n  > {\n    return new U256ColumnBuilder(\n      this,\n      set(defaultMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): U256ColumnBuilder<\n    SetField<DefaultMetadata, 'isAutoIncrement', true>\n  > {\n    return new U256ColumnBuilder(\n      this,\n      set(defaultMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: bigint\n  ): U256ColumnBuilder<SetField<DefaultMetadata, 'defaultValue', bigint>> {\n    return new U256ColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): U256ColumnBuilder<SetField<DefaultMetadata, 'name', Name>> {\n    return new U256ColumnBuilder(this, set(defaultMetadata, { name }));\n  }\n}\n\nexport class I8Builder\n  extends TypeBuilder<number, AlgebraicTypeVariants.I8>\n  implements\n    Indexable<number, AlgebraicTypeVariants.I8>,\n    Uniqueable<number, AlgebraicTypeVariants.I8>,\n    PrimaryKeyable<number, AlgebraicTypeVariants.I8>,\n    AutoIncrementable<number, AlgebraicTypeVariants.I8>,\n    Defaultable<number, AlgebraicTypeVariants.I8>,\n    Nameable<number, AlgebraicTypeVariants.I8>\n{\n  constructor() {\n    super(AlgebraicType.I8);\n  }\n  index(): I8ColumnBuilder<SetField<DefaultMetadata, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): I8ColumnBuilder<SetField<DefaultMetadata, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): I8ColumnBuilder<SetField<DefaultMetadata, 'indexType', IndexTypes>> {\n    return new I8ColumnBuilder(\n      this,\n      set(defaultMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): I8ColumnBuilder<SetField<DefaultMetadata, 'isUnique', true>> {\n    return new I8ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));\n  }\n  primaryKey(): I8ColumnBuilder<\n    SetField<DefaultMetadata, 'isPrimaryKey', true>\n  > {\n    return new I8ColumnBuilder(\n      this,\n      set(defaultMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): I8ColumnBuilder<\n    SetField<DefaultMetadata, 'isAutoIncrement', true>\n  > {\n    return new I8ColumnBuilder(\n      this,\n      set(defaultMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: number\n  ): I8ColumnBuilder<SetField<DefaultMetadata, 'defaultValue', number>> {\n    return new I8ColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): I8ColumnBuilder<SetField<DefaultMetadata, 'name', Name>> {\n    return new I8ColumnBuilder(this, set(defaultMetadata, { name }));\n  }\n}\n\nexport class I16Builder\n  extends TypeBuilder<number, AlgebraicTypeVariants.I16>\n  implements\n    Indexable<number, AlgebraicTypeVariants.I16>,\n    Uniqueable<number, AlgebraicTypeVariants.I16>,\n    PrimaryKeyable<number, AlgebraicTypeVariants.I16>,\n    AutoIncrementable<number, AlgebraicTypeVariants.I16>,\n    Defaultable<number, AlgebraicTypeVariants.I16>,\n    Nameable<number, AlgebraicTypeVariants.I16>\n{\n  constructor() {\n    super(AlgebraicType.I16);\n  }\n  index(): I16ColumnBuilder<SetField<DefaultMetadata, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): I16ColumnBuilder<SetField<DefaultMetadata, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): I16ColumnBuilder<SetField<DefaultMetadata, 'indexType', IndexTypes>> {\n    return new I16ColumnBuilder(\n      this,\n      set(defaultMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): I16ColumnBuilder<SetField<DefaultMetadata, 'isUnique', true>> {\n    return new I16ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));\n  }\n  primaryKey(): I16ColumnBuilder<\n    SetField<DefaultMetadata, 'isPrimaryKey', true>\n  > {\n    return new I16ColumnBuilder(\n      this,\n      set(defaultMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): I16ColumnBuilder<\n    SetField<DefaultMetadata, 'isAutoIncrement', true>\n  > {\n    return new I16ColumnBuilder(\n      this,\n      set(defaultMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: number\n  ): I16ColumnBuilder<SetField<DefaultMetadata, 'defaultValue', number>> {\n    return new I16ColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): I16ColumnBuilder<SetField<DefaultMetadata, 'name', Name>> {\n    return new I16ColumnBuilder(this, set(defaultMetadata, { name }));\n  }\n}\n\nexport class I32Builder\n  extends TypeBuilder<number, AlgebraicTypeVariants.I32>\n  implements\n    TypeBuilder<number, AlgebraicTypeVariants.I32>,\n    Indexable<number, AlgebraicTypeVariants.I32>,\n    Uniqueable<number, AlgebraicTypeVariants.I32>,\n    PrimaryKeyable<number, AlgebraicTypeVariants.I32>,\n    AutoIncrementable<number, AlgebraicTypeVariants.I32>,\n    Defaultable<number, AlgebraicTypeVariants.I32>,\n    Nameable<number, AlgebraicTypeVariants.I32>\n{\n  constructor() {\n    super(AlgebraicType.I32);\n  }\n  index(): I32ColumnBuilder<SetField<DefaultMetadata, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): I32ColumnBuilder<SetField<DefaultMetadata, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): I32ColumnBuilder<SetField<DefaultMetadata, 'indexType', IndexTypes>> {\n    return new I32ColumnBuilder(\n      this,\n      set(defaultMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): I32ColumnBuilder<SetField<DefaultMetadata, 'isUnique', true>> {\n    return new I32ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));\n  }\n  primaryKey(): I32ColumnBuilder<\n    SetField<DefaultMetadata, 'isPrimaryKey', true>\n  > {\n    return new I32ColumnBuilder(\n      this,\n      set(defaultMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): I32ColumnBuilder<\n    SetField<DefaultMetadata, 'isAutoIncrement', true>\n  > {\n    return new I32ColumnBuilder(\n      this,\n      set(defaultMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: number\n  ): I32ColumnBuilder<SetField<DefaultMetadata, 'defaultValue', number>> {\n    return new I32ColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): I32ColumnBuilder<SetField<DefaultMetadata, 'name', Name>> {\n    return new I32ColumnBuilder(this, set(defaultMetadata, { name }));\n  }\n}\n\nexport class I64Builder\n  extends TypeBuilder<bigint, AlgebraicTypeVariants.I64>\n  implements\n    Indexable<bigint, AlgebraicTypeVariants.I64>,\n    Uniqueable<bigint, AlgebraicTypeVariants.I64>,\n    PrimaryKeyable<bigint, AlgebraicTypeVariants.I64>,\n    AutoIncrementable<bigint, AlgebraicTypeVariants.I64>,\n    Defaultable<bigint, AlgebraicTypeVariants.I64>,\n    Nameable<bigint, AlgebraicTypeVariants.I64>\n{\n  constructor() {\n    super(AlgebraicType.I64);\n  }\n  index(): I64ColumnBuilder<SetField<DefaultMetadata, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): I64ColumnBuilder<SetField<DefaultMetadata, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): I64ColumnBuilder<SetField<DefaultMetadata, 'indexType', IndexTypes>> {\n    return new I64ColumnBuilder(\n      this,\n      set(defaultMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): I64ColumnBuilder<SetField<DefaultMetadata, 'isUnique', true>> {\n    return new I64ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));\n  }\n  primaryKey(): I64ColumnBuilder<\n    SetField<DefaultMetadata, 'isPrimaryKey', true>\n  > {\n    return new I64ColumnBuilder(\n      this,\n      set(defaultMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): I64ColumnBuilder<\n    SetField<DefaultMetadata, 'isAutoIncrement', true>\n  > {\n    return new I64ColumnBuilder(\n      this,\n      set(defaultMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: bigint\n  ): I64ColumnBuilder<SetField<DefaultMetadata, 'defaultValue', bigint>> {\n    return new I64ColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): I64ColumnBuilder<SetField<DefaultMetadata, 'name', Name>> {\n    return new I64ColumnBuilder(this, set(defaultMetadata, { name }));\n  }\n}\n\nexport class I128Builder\n  extends TypeBuilder<bigint, AlgebraicTypeVariants.I128>\n  implements\n    Indexable<bigint, AlgebraicTypeVariants.I128>,\n    Uniqueable<bigint, AlgebraicTypeVariants.I128>,\n    PrimaryKeyable<bigint, AlgebraicTypeVariants.I128>,\n    AutoIncrementable<bigint, AlgebraicTypeVariants.I128>,\n    Defaultable<bigint, AlgebraicTypeVariants.I128>,\n    Nameable<bigint, AlgebraicTypeVariants.I128>\n{\n  constructor() {\n    super(AlgebraicType.I128);\n  }\n  index(): I128ColumnBuilder<SetField<DefaultMetadata, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): I128ColumnBuilder<SetField<DefaultMetadata, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): I128ColumnBuilder<SetField<DefaultMetadata, 'indexType', IndexTypes>> {\n    return new I128ColumnBuilder(\n      this,\n      set(defaultMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): I128ColumnBuilder<SetField<DefaultMetadata, 'isUnique', true>> {\n    return new I128ColumnBuilder(\n      this,\n      set(defaultMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): I128ColumnBuilder<\n    SetField<DefaultMetadata, 'isPrimaryKey', true>\n  > {\n    return new I128ColumnBuilder(\n      this,\n      set(defaultMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): I128ColumnBuilder<\n    SetField<DefaultMetadata, 'isAutoIncrement', true>\n  > {\n    return new I128ColumnBuilder(\n      this,\n      set(defaultMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: bigint\n  ): I128ColumnBuilder<SetField<DefaultMetadata, 'defaultValue', bigint>> {\n    return new I128ColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): I128ColumnBuilder<SetField<DefaultMetadata, 'name', Name>> {\n    return new I128ColumnBuilder(this, set(defaultMetadata, { name }));\n  }\n}\n\nexport class I256Builder\n  extends TypeBuilder<bigint, AlgebraicTypeVariants.I256>\n  implements\n    Indexable<bigint, AlgebraicTypeVariants.I256>,\n    Uniqueable<bigint, AlgebraicTypeVariants.I256>,\n    PrimaryKeyable<bigint, AlgebraicTypeVariants.I256>,\n    AutoIncrementable<bigint, AlgebraicTypeVariants.I256>,\n    Defaultable<bigint, AlgebraicTypeVariants.I256>,\n    Nameable<bigint, AlgebraicTypeVariants.I256>\n{\n  constructor() {\n    super(AlgebraicType.I256);\n  }\n  index(): I256ColumnBuilder<SetField<DefaultMetadata, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): I256ColumnBuilder<SetField<DefaultMetadata, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): I256ColumnBuilder<SetField<DefaultMetadata, 'indexType', IndexTypes>> {\n    return new I256ColumnBuilder(\n      this,\n      set(defaultMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): I256ColumnBuilder<SetField<DefaultMetadata, 'isUnique', true>> {\n    return new I256ColumnBuilder(\n      this,\n      set(defaultMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): I256ColumnBuilder<\n    SetField<DefaultMetadata, 'isPrimaryKey', true>\n  > {\n    return new I256ColumnBuilder(\n      this,\n      set(defaultMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): I256ColumnBuilder<\n    SetField<DefaultMetadata, 'isAutoIncrement', true>\n  > {\n    return new I256ColumnBuilder(\n      this,\n      set(defaultMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: bigint\n  ): I256ColumnBuilder<SetField<DefaultMetadata, 'defaultValue', bigint>> {\n    return new I256ColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): I256ColumnBuilder<SetField<DefaultMetadata, 'name', Name>> {\n    return new I256ColumnBuilder(this, set(defaultMetadata, { name }));\n  }\n}\n\nexport class F32Builder\n  extends TypeBuilder<number, AlgebraicTypeVariants.F32>\n  implements\n    Defaultable<number, AlgebraicTypeVariants.F32>,\n    Nameable<number, AlgebraicTypeVariants.F32>\n{\n  constructor() {\n    super(AlgebraicType.F32);\n  }\n  default(\n    value: number\n  ): F32ColumnBuilder<SetField<DefaultMetadata, 'defaultValue', number>> {\n    return new F32ColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): F32ColumnBuilder<SetField<DefaultMetadata, 'name', Name>> {\n    return new F32ColumnBuilder(this, set(defaultMetadata, { name }));\n  }\n}\n\nexport class F64Builder\n  extends TypeBuilder<number, AlgebraicTypeVariants.F64>\n  implements\n    Defaultable<number, AlgebraicTypeVariants.F64>,\n    Nameable<number, AlgebraicTypeVariants.F64>\n{\n  constructor() {\n    super(AlgebraicType.F64);\n  }\n  default(\n    value: number\n  ): F64ColumnBuilder<SetField<DefaultMetadata, 'defaultValue', number>> {\n    return new F64ColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): F64ColumnBuilder<SetField<DefaultMetadata, 'name', Name>> {\n    return new F64ColumnBuilder(this, set(defaultMetadata, { name }));\n  }\n}\n\nexport class BoolBuilder\n  extends TypeBuilder<boolean, AlgebraicTypeVariants.Bool>\n  implements\n    Indexable<boolean, AlgebraicTypeVariants.Bool>,\n    Uniqueable<boolean, AlgebraicTypeVariants.Bool>,\n    PrimaryKeyable<boolean, AlgebraicTypeVariants.Bool>,\n    Defaultable<boolean, AlgebraicTypeVariants.Bool>,\n    Nameable<boolean, AlgebraicTypeVariants.Bool>\n{\n  constructor() {\n    super(AlgebraicType.Bool);\n  }\n  index(): BoolColumnBuilder<SetField<DefaultMetadata, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): BoolColumnBuilder<SetField<DefaultMetadata, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): BoolColumnBuilder<SetField<DefaultMetadata, 'indexType', IndexTypes>> {\n    return new BoolColumnBuilder(\n      this,\n      set(defaultMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): BoolColumnBuilder<SetField<DefaultMetadata, 'isUnique', true>> {\n    return new BoolColumnBuilder(\n      this,\n      set(defaultMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): BoolColumnBuilder<\n    SetField<DefaultMetadata, 'isPrimaryKey', true>\n  > {\n    return new BoolColumnBuilder(\n      this,\n      set(defaultMetadata, { isPrimaryKey: true })\n    );\n  }\n  default(\n    value: boolean\n  ): BoolColumnBuilder<SetField<DefaultMetadata, 'defaultValue', boolean>> {\n    return new BoolColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): BoolColumnBuilder<SetField<DefaultMetadata, 'name', Name>> {\n    return new BoolColumnBuilder(this, set(defaultMetadata, { name }));\n  }\n}\n\nexport class StringBuilder\n  extends TypeBuilder<string, AlgebraicTypeVariants.String>\n  implements\n    Indexable<string, AlgebraicTypeVariants.String>,\n    Uniqueable<string, AlgebraicTypeVariants.String>,\n    PrimaryKeyable<string, AlgebraicTypeVariants.String>,\n    Defaultable<string, AlgebraicTypeVariants.String>,\n    Nameable<string, AlgebraicTypeVariants.String>\n{\n  constructor() {\n    super(AlgebraicType.String);\n  }\n  index(): StringColumnBuilder<SetField<DefaultMetadata, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): StringColumnBuilder<SetField<DefaultMetadata, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): StringColumnBuilder<SetField<DefaultMetadata, 'indexType', IndexTypes>> {\n    return new StringColumnBuilder(\n      this,\n      set(defaultMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): StringColumnBuilder<SetField<DefaultMetadata, 'isUnique', true>> {\n    return new StringColumnBuilder(\n      this,\n      set(defaultMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): StringColumnBuilder<\n    SetField<DefaultMetadata, 'isPrimaryKey', true>\n  > {\n    return new StringColumnBuilder(\n      this,\n      set(defaultMetadata, { isPrimaryKey: true })\n    );\n  }\n  default(\n    value: string\n  ): StringColumnBuilder<SetField<DefaultMetadata, 'defaultValue', string>> {\n    return new StringColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): StringColumnBuilder<SetField<DefaultMetadata, 'name', Name>> {\n    return new StringColumnBuilder(this, set(defaultMetadata, { name }));\n  }\n}\n\nexport class ArrayBuilder<Element extends TypeBuilder<any, any>>\n  extends TypeBuilder<\n    Array<InferTypeOfTypeBuilder<Element>>,\n    { tag: 'Array'; value: InferSpacetimeTypeOfTypeBuilder<Element> }\n  >\n  implements\n    Defaultable<Array<InferTypeOfTypeBuilder<Element>>, any>,\n    Nameable<Array<InferTypeOfTypeBuilder<Element>>, any>\n{\n  element: Element;\n\n  constructor(element: Element) {\n    super(AlgebraicType.Array(element.algebraicType));\n    this.element = element;\n  }\n  default(\n    value: Array<InferTypeOfTypeBuilder<Element>>\n  ): ArrayColumnBuilder<\n    Element,\n    SetField<DefaultMetadata, 'defaultValue', any>\n  > {\n    return new ArrayColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): ArrayColumnBuilder<Element, SetField<DefaultMetadata, 'name', Name>> {\n    return new ArrayColumnBuilder(this, set(defaultMetadata, { name }));\n  }\n}\n\nexport class ByteArrayBuilder\n  extends TypeBuilder<\n    Uint8Array,\n    { tag: 'Array'; value: AlgebraicTypeVariants.U8 }\n  >\n  implements Defaultable<Uint8Array, any>, Nameable<Uint8Array, any>\n{\n  constructor() {\n    super(AlgebraicType.Array(AlgebraicType.U8));\n  }\n  default(\n    value: Uint8Array\n  ): ByteArrayColumnBuilder<SetField<DefaultMetadata, 'defaultValue', any>> {\n    return new ByteArrayColumnBuilder(\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): ByteArrayColumnBuilder<SetField<DefaultMetadata, 'name', Name>> {\n    return new ByteArrayColumnBuilder(set(defaultMetadata, { name }));\n  }\n}\n\nexport class OptionBuilder<Value extends TypeBuilder<any, any>>\n  extends TypeBuilder<\n    InferTypeOfTypeBuilder<Value> | undefined,\n    OptionAlgebraicType<InferSpacetimeTypeOfTypeBuilder<Value>>\n  >\n  implements\n    Defaultable<\n      InferTypeOfTypeBuilder<Value> | undefined,\n      OptionAlgebraicType<InferSpacetimeTypeOfTypeBuilder<Value>>\n    >,\n    Nameable<\n      InferTypeOfTypeBuilder<Value> | undefined,\n      OptionAlgebraicType<InferSpacetimeTypeOfTypeBuilder<Value>>\n    >\n{\n  value: Value;\n\n  constructor(value: Value) {\n    super(Option.getAlgebraicType(value.algebraicType));\n    this.value = value;\n  }\n  default(\n    value: InferTypeOfTypeBuilder<Value> | undefined\n  ): OptionColumnBuilder<\n    Value,\n    SetField<\n      DefaultMetadata,\n      'defaultValue',\n      InferTypeOfTypeBuilder<Value> | undefined\n    >\n  > {\n    return new OptionColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): OptionColumnBuilder<Value, SetField<DefaultMetadata, 'name', Name>> {\n    return new OptionColumnBuilder(this, set(defaultMetadata, { name }));\n  }\n}\n\ntype ElementsToProductType<Elements extends ElementsObj> = {\n  tag: 'Product';\n  value: { elements: ElementsArrayFromElementsObj<Elements> };\n};\n\nexport class ProductBuilder<Elements extends ElementsObj>\n  extends TypeBuilder<ObjectType<Elements>, ElementsToProductType<Elements>>\n  implements\n    Defaultable<ObjectType<Elements>, ElementsToProductType<Elements>>,\n    Nameable<ObjectType<Elements>, ElementsToProductType<Elements>>\n{\n  readonly typeName: string | undefined;\n  readonly elements: Elements;\n  constructor(elements: Elements, name?: string) {\n    function elementsArrayFromElementsObj<Obj extends ElementsObj>(obj: Obj) {\n      return Object.keys(obj).map(key => ({\n        name: key,\n        // Lazily resolve the underlying object's algebraicType.\n        // This will call obj[key].algebraicType only when someone\n        // actually reads this property.\n        get algebraicType() {\n          return obj[key].algebraicType;\n        },\n      }));\n    }\n    super(\n      AlgebraicType.Product({\n        elements: elementsArrayFromElementsObj(elements),\n      })\n    );\n    this.typeName = name;\n    this.elements = elements;\n  }\n  default(\n    value: ObjectType<Elements>\n  ): ProductColumnBuilder<\n    Elements,\n    SetField<DefaultMetadata, 'defaultValue', any>\n  > {\n    return new ProductColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): ProductColumnBuilder<Elements, SetField<DefaultMetadata, 'name', Name>> {\n    return new ProductColumnBuilder(this, set(defaultMetadata, { name }));\n  }\n}\n\nexport class ResultBuilder<\n    Ok extends TypeBuilder<any, any>,\n    Err extends TypeBuilder<any, any>,\n  >\n  extends TypeBuilder<\n    InferTypeOfTypeBuilder<Ok> | InferTypeOfTypeBuilder<Err>,\n    ResultAlgebraicType<\n      InferSpacetimeTypeOfTypeBuilder<Ok>,\n      InferSpacetimeTypeOfTypeBuilder<Err>\n    >\n  >\n  implements\n    Defaultable<\n      InferTypeOfTypeBuilder<Ok> | InferTypeOfTypeBuilder<Err>,\n      ResultAlgebraicType<\n        InferSpacetimeTypeOfTypeBuilder<Ok>,\n        InferSpacetimeTypeOfTypeBuilder<Err>\n      >\n    >\n{\n  ok: Ok;\n  err: Err;\n\n  constructor(ok: Ok, err: Err) {\n    super(Result.getAlgebraicType(ok.algebraicType, err.algebraicType));\n    this.ok = ok;\n    this.err = err;\n  }\n  default(\n    value: InferTypeOfTypeBuilder<Ok> | InferTypeOfTypeBuilder<Err>\n  ): ResultColumnBuilder<\n    Ok,\n    Err,\n    SetField<\n      DefaultMetadata,\n      'defaultValue',\n      InferTypeOfTypeBuilder<Ok> | InferTypeOfTypeBuilder<Err>\n    >\n  > {\n    return new ResultColumnBuilder<\n      Ok,\n      Err,\n      SetField<\n        DefaultMetadata,\n        'defaultValue',\n        InferTypeOfTypeBuilder<Ok> | InferTypeOfTypeBuilder<Err>\n      >\n    >(this, set(defaultMetadata, { defaultValue: value }));\n  }\n}\n\nclass UnitBuilder extends TypeBuilder<\n  {},\n  { tag: 'Product'; value: { elements: [] } }\n> {\n  constructor() {\n    super({ tag: 'Product', value: { elements: [] } });\n  }\n}\n\nexport class RowBuilder<Row extends RowObj> extends TypeBuilder<\n  RowType<CoerceRow<Row>>,\n  {\n    tag: 'Product';\n    value: { elements: ElementsArrayFromRowObj<CoerceRow<Row>> };\n  }\n> {\n  readonly row: CoerceRow<Row>;\n  typeName: string | undefined;\n  constructor(row: Row, name?: string) {\n    const mappedRow = Object.fromEntries(\n      Object.entries(row).map(([colName, builder]) => [\n        colName,\n        builder instanceof ColumnBuilder\n          ? builder\n          : new ColumnBuilder(builder, {}),\n      ])\n    ) as CoerceRow<Row>;\n\n    const elements = Object.keys(mappedRow).map(name => ({\n      name,\n      get algebraicType() {\n        return mappedRow[name].typeBuilder.algebraicType;\n      },\n    }));\n\n    super(AlgebraicType.Product({ elements }));\n    this.row = mappedRow;\n    this.typeName = name;\n  }\n}\n\n// Value type produced for a given variant key + builder\ntype EnumValue<K extends string, B extends TypeBuilder<any, any>> =\n  IsUnit<B> extends true\n    ? { tag: K }\n    : { tag: K; value: InferTypeOfTypeBuilder<B> };\n\ntype VariantConstructor<K extends string, V extends TypeBuilder<any, any>> =\n  IsUnit<V> extends true\n    ? EnumValue<K, V>\n    : (value: InferTypeOfTypeBuilder<V>) => EnumValue<K, V>;\n\ntype SumBuilderVariantConstructors<Variants extends VariantsObj> = {\n  [K in keyof Variants & string]: VariantConstructor<K, Variants[K]>;\n};\n\nexport type SumBuilder<Variants extends VariantsObj> =\n  SumBuilderImpl<Variants> & SumBuilderVariantConstructors<Variants>;\n\ntype VariantsToSumType<Variants extends VariantsObj> = {\n  tag: 'Sum';\n  value: { variants: VariantsArrayFromVariantsObj<Variants> };\n};\n\nclass SumBuilderImpl<Variants extends VariantsObj>\n  extends TypeBuilder<EnumType<Variants>, VariantsToSumType<Variants>>\n  implements\n    Defaultable<EnumType<Variants>, VariantsToSumType<Variants>>,\n    Nameable<EnumType<Variants>, VariantsToSumType<Variants>>\n{\n  readonly variants: Variants;\n  readonly typeName: string | undefined;\n\n  constructor(variants: Variants, name?: string) {\n    function variantsArrayFromVariantsObj<Variants extends VariantsObj>(\n      variants: Variants\n    ) {\n      return (Object.keys(variants) as Array<keyof Variants>).map(key => ({\n        name: key as string,\n        // Lazily resolve the underlying object's algebraicType.\n        // This will call obj[key].algebraicType only when someone\n        // actually reads this property.\n        get algebraicType() {\n          return variants[key].algebraicType;\n        },\n      }));\n    }\n    super(\n      AlgebraicType.Sum({\n        variants: variantsArrayFromVariantsObj(variants),\n      })\n    );\n\n    this.variants = variants;\n    this.typeName = name;\n\n    for (const key of Object.keys(variants) as Array<keyof Variants & string>) {\n      const desc = Object.getOwnPropertyDescriptor(variants, key);\n\n      const isAccessor =\n        !!desc &&\n        (typeof desc.get === 'function' || typeof desc.set === 'function');\n\n      let isUnit = false;\n\n      if (!isAccessor) {\n        // Only read variants[key] if it's a *data* property\n        // otherwise assume non-unit because it's a getter\n        const variant = variants[key];\n        isUnit = variant instanceof UnitBuilder;\n      }\n\n      if (isUnit) {\n        // Unit: expose a read-only VALUE (no call)\n        const constant = this.create(key as any) as EnumValue<\n          typeof key,\n          Variants[typeof key]\n        >;\n        Object.defineProperty(this, key, {\n          value: constant,\n          writable: false,\n          enumerable: true,\n          configurable: false,\n        });\n      } else {\n        const fn = ((value: any) =>\n          this.create(key as any, value)) as VariantConstructor<\n          typeof key & string,\n          Variants[typeof key]\n        >;\n\n        Object.defineProperty(this, key, {\n          value: fn,\n          writable: false,\n          enumerable: true,\n          configurable: false,\n        });\n      }\n    }\n  }\n\n  /**\n   * Create a value of this sum type.\n   * - Unit variants: create('bar')\n   * - Payload variants: create('foo', value)\n   */\n  private create<K extends keyof Variants & string>(\n    tag: K\n  ): EnumValue<K, Variants[K]>;\n  private create<K extends keyof Variants & string>(\n    tag: K,\n    value: InferTypeOfTypeBuilder<Variants[K]>\n  ): EnumValue<K, Variants[K]>;\n  private create(tag: string, value?: unknown) {\n    return value === undefined ? { tag } : { tag, value };\n  }\n\n  default(\n    value: EnumType<Variants>\n  ): SumColumnBuilder<\n    Variants,\n    SetField<DefaultMetadata, 'defaultValue', any>\n  > {\n    return new SumColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): SumColumnBuilder<Variants, SetField<DefaultMetadata, 'name', Name>> {\n    return new SumColumnBuilder(this, set(defaultMetadata, { name }));\n  }\n}\n\nexport const SumBuilder: {\n  new <Variants extends VariantsObj>(\n    variants: Variants,\n    name?: string\n  ): SumBuilder<Variants>;\n  [Symbol.hasInstance](x: any): x is SumBuilder<VariantsObj>;\n} = SumBuilderImpl as any;\n\nclass SimpleSumBuilderImpl<Variants extends SimpleVariantsObj>\n  extends SumBuilderImpl<Variants>\n  implements\n    Indexable<\n      EnumType<Variants>,\n      {\n        tag: 'Sum';\n        value: { variants: VariantsArrayFromVariantsObj<Variants> };\n      }\n    >,\n    PrimaryKeyable<\n      EnumType<Variants>,\n      {\n        tag: 'Sum';\n        value: { variants: VariantsArrayFromVariantsObj<Variants> };\n      }\n    >\n{\n  index(): SimpleSumColumnBuilder<\n    Variants,\n    SetField<DefaultMetadata, 'indexType', 'btree'>\n  >;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): SimpleSumColumnBuilder<\n    Variants,\n    SetField<DefaultMetadata, 'indexType', N>\n  >;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): SimpleSumColumnBuilder<\n    Variants,\n    SetField<DefaultMetadata, 'indexType', IndexTypes>\n  > {\n    return new SimpleSumColumnBuilder(\n      this,\n      set(defaultMetadata, { indexType: algorithm })\n    );\n  }\n  primaryKey(): SimpleSumColumnBuilder<\n    Variants,\n    SetField<DefaultMetadata, 'isPrimaryKey', true>\n  > {\n    return new SimpleSumColumnBuilder(\n      this,\n      set(defaultMetadata, { isPrimaryKey: true })\n    );\n  }\n}\n\nexport const SimpleSumBuilder: {\n  new <Variants extends SimpleVariantsObj>(\n    variants: Variants,\n    name?: string\n  ): SimpleSumBuilderImpl<Variants> & SumBuilderVariantConstructors<Variants>;\n} = SimpleSumBuilderImpl as any;\n\nexport type SimpleSumBuilder<Variants extends SimpleVariantsObj> =\n  SimpleSumBuilderImpl<Variants> & SumBuilderVariantConstructors<Variants>;\n\nexport class ScheduleAtBuilder\n  extends TypeBuilder<ScheduleAt, ScheduleAtAlgebraicType>\n  implements\n    Defaultable<ScheduleAt, ScheduleAtAlgebraicType>,\n    Nameable<ScheduleAt, ScheduleAtAlgebraicType>\n{\n  constructor() {\n    super(ScheduleAt.getAlgebraicType());\n  }\n  default(\n    value: ScheduleAt\n  ): ScheduleAtColumnBuilder<\n    SetField<DefaultMetadata, 'defaultValue', ScheduleAt>\n  > {\n    return new ScheduleAtColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): ScheduleAtColumnBuilder<SetField<DefaultMetadata, 'name', Name>> {\n    return new ScheduleAtColumnBuilder(this, set(defaultMetadata, { name }));\n  }\n}\n\nexport class IdentityBuilder\n  extends TypeBuilder<Identity, IdentityAlgebraicType>\n  implements\n    Indexable<Identity, IdentityAlgebraicType>,\n    Uniqueable<Identity, IdentityAlgebraicType>,\n    PrimaryKeyable<Identity, IdentityAlgebraicType>,\n    Defaultable<Identity, IdentityAlgebraicType>,\n    Nameable<Identity, IdentityAlgebraicType>\n{\n  constructor() {\n    super(Identity.getAlgebraicType());\n  }\n  index(): IdentityColumnBuilder<\n    SetField<DefaultMetadata, 'indexType', 'btree'>\n  >;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): IdentityColumnBuilder<SetField<DefaultMetadata, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): IdentityColumnBuilder<SetField<DefaultMetadata, 'indexType', IndexTypes>> {\n    return new IdentityColumnBuilder(\n      this,\n      set(defaultMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): IdentityColumnBuilder<SetField<DefaultMetadata, 'isUnique', true>> {\n    return new IdentityColumnBuilder(\n      this,\n      set(defaultMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): IdentityColumnBuilder<\n    SetField<DefaultMetadata, 'isPrimaryKey', true>\n  > {\n    return new IdentityColumnBuilder(\n      this,\n      set(defaultMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): IdentityColumnBuilder<\n    SetField<DefaultMetadata, 'isAutoIncrement', true>\n  > {\n    return new IdentityColumnBuilder(\n      this,\n      set(defaultMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: Identity\n  ): IdentityColumnBuilder<\n    SetField<DefaultMetadata, 'defaultValue', Identity>\n  > {\n    return new IdentityColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): IdentityColumnBuilder<SetField<DefaultMetadata, 'name', Name>> {\n    return new IdentityColumnBuilder(this, set(defaultMetadata, { name }));\n  }\n}\n\nexport class ConnectionIdBuilder\n  extends TypeBuilder<ConnectionId, ConnectionIdAlgebraicType>\n  implements\n    Indexable<ConnectionId, ConnectionIdAlgebraicType>,\n    Uniqueable<ConnectionId, ConnectionIdAlgebraicType>,\n    PrimaryKeyable<ConnectionId, ConnectionIdAlgebraicType>,\n    Defaultable<ConnectionId, ConnectionIdAlgebraicType>,\n    Nameable<ConnectionId, ConnectionIdAlgebraicType>\n{\n  constructor() {\n    super(ConnectionId.getAlgebraicType());\n  }\n  index(): ConnectionIdColumnBuilder<\n    SetField<DefaultMetadata, 'indexType', 'btree'>\n  >;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): ConnectionIdColumnBuilder<SetField<DefaultMetadata, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): ConnectionIdColumnBuilder<\n    SetField<DefaultMetadata, 'indexType', IndexTypes>\n  > {\n    return new ConnectionIdColumnBuilder(\n      this,\n      set(defaultMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): ConnectionIdColumnBuilder<\n    SetField<DefaultMetadata, 'isUnique', true>\n  > {\n    return new ConnectionIdColumnBuilder(\n      this,\n      set(defaultMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): ConnectionIdColumnBuilder<\n    SetField<DefaultMetadata, 'isPrimaryKey', true>\n  > {\n    return new ConnectionIdColumnBuilder(\n      this,\n      set(defaultMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): ConnectionIdColumnBuilder<\n    SetField<DefaultMetadata, 'isAutoIncrement', true>\n  > {\n    return new ConnectionIdColumnBuilder(\n      this,\n      set(defaultMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: ConnectionId\n  ): ConnectionIdColumnBuilder<\n    SetField<DefaultMetadata, 'defaultValue', ConnectionId>\n  > {\n    return new ConnectionIdColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): ConnectionIdColumnBuilder<SetField<DefaultMetadata, 'name', Name>> {\n    return new ConnectionIdColumnBuilder(this, set(defaultMetadata, { name }));\n  }\n}\n\nexport class TimestampBuilder\n  extends TypeBuilder<Timestamp, TimestampAlgebraicType>\n  implements\n    Indexable<Timestamp, TimestampAlgebraicType>,\n    Uniqueable<Timestamp, TimestampAlgebraicType>,\n    PrimaryKeyable<Timestamp, TimestampAlgebraicType>,\n    Defaultable<Timestamp, TimestampAlgebraicType>,\n    Nameable<Timestamp, TimestampAlgebraicType>\n{\n  constructor() {\n    super(Timestamp.getAlgebraicType());\n  }\n  index(): TimestampColumnBuilder<\n    SetField<DefaultMetadata, 'indexType', 'btree'>\n  >;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): TimestampColumnBuilder<SetField<DefaultMetadata, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): TimestampColumnBuilder<\n    SetField<DefaultMetadata, 'indexType', IndexTypes>\n  > {\n    return new TimestampColumnBuilder(\n      this,\n      set(defaultMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): TimestampColumnBuilder<\n    SetField<DefaultMetadata, 'isUnique', true>\n  > {\n    return new TimestampColumnBuilder(\n      this,\n      set(defaultMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): TimestampColumnBuilder<\n    SetField<DefaultMetadata, 'isPrimaryKey', true>\n  > {\n    return new TimestampColumnBuilder(\n      this,\n      set(defaultMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): TimestampColumnBuilder<\n    SetField<DefaultMetadata, 'isAutoIncrement', true>\n  > {\n    return new TimestampColumnBuilder(\n      this,\n      set(defaultMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: Timestamp\n  ): TimestampColumnBuilder<\n    SetField<DefaultMetadata, 'defaultValue', Timestamp>\n  > {\n    return new TimestampColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): TimestampColumnBuilder<SetField<DefaultMetadata, 'name', Name>> {\n    return new TimestampColumnBuilder(this, set(defaultMetadata, { name }));\n  }\n}\n\nexport class TimeDurationBuilder\n  extends TypeBuilder<TimeDuration, TimeDurationAlgebraicType>\n  implements\n    Indexable<TimeDuration, TimeDurationAlgebraicType>,\n    Uniqueable<TimeDuration, TimeDurationAlgebraicType>,\n    PrimaryKeyable<TimeDuration, TimeDurationAlgebraicType>,\n    Defaultable<TimeDuration, TimeDurationAlgebraicType>,\n    Nameable<TimeDuration, TimeDurationAlgebraicType>\n{\n  constructor() {\n    super(TimeDuration.getAlgebraicType());\n  }\n  index(): TimeDurationColumnBuilder<\n    SetField<DefaultMetadata, 'indexType', 'btree'>\n  >;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): TimeDurationColumnBuilder<SetField<DefaultMetadata, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): TimeDurationColumnBuilder<\n    SetField<DefaultMetadata, 'indexType', IndexTypes>\n  > {\n    return new TimeDurationColumnBuilder(\n      this,\n      set(defaultMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): TimeDurationColumnBuilder<\n    SetField<DefaultMetadata, 'isUnique', true>\n  > {\n    return new TimeDurationColumnBuilder(\n      this,\n      set(defaultMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): TimeDurationColumnBuilder<\n    SetField<DefaultMetadata, 'isPrimaryKey', true>\n  > {\n    return new TimeDurationColumnBuilder(\n      this,\n      set(defaultMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): TimeDurationColumnBuilder<\n    SetField<DefaultMetadata, 'isAutoIncrement', true>\n  > {\n    return new TimeDurationColumnBuilder(\n      this,\n      set(defaultMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: TimeDuration\n  ): TimeDurationColumnBuilder<\n    SetField<DefaultMetadata, 'defaultValue', TimeDuration>\n  > {\n    return new TimeDurationColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): TimeDurationColumnBuilder<SetField<DefaultMetadata, 'name', Name>> {\n    return new TimeDurationColumnBuilder(this, set(defaultMetadata, { name }));\n  }\n}\n\nexport class UuidBuilder\n  extends TypeBuilder<Uuid, UuidAlgebraicType>\n  implements\n    Indexable<Uuid, UuidAlgebraicType>,\n    Uniqueable<Uuid, UuidAlgebraicType>,\n    PrimaryKeyable<Uuid, UuidAlgebraicType>,\n    Defaultable<Uuid, UuidAlgebraicType>,\n    Nameable<Uuid, UuidAlgebraicType>\n{\n  constructor() {\n    super(Uuid.getAlgebraicType());\n  }\n  index(): UuidColumnBuilder<SetField<DefaultMetadata, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): UuidColumnBuilder<SetField<DefaultMetadata, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): UuidColumnBuilder<SetField<DefaultMetadata, 'indexType', IndexTypes>> {\n    return new UuidColumnBuilder(\n      this,\n      set(defaultMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): UuidColumnBuilder<SetField<DefaultMetadata, 'isUnique', true>> {\n    return new UuidColumnBuilder(\n      this,\n      set(defaultMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): UuidColumnBuilder<\n    SetField<DefaultMetadata, 'isPrimaryKey', true>\n  > {\n    return new UuidColumnBuilder(\n      this,\n      set(defaultMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): UuidColumnBuilder<\n    SetField<DefaultMetadata, 'isAutoIncrement', true>\n  > {\n    return new UuidColumnBuilder(\n      this,\n      set(defaultMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: Uuid\n  ): UuidColumnBuilder<SetField<DefaultMetadata, 'defaultValue', Uuid>> {\n    return new UuidColumnBuilder(\n      this,\n      set(defaultMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): UuidColumnBuilder<SetField<DefaultMetadata, 'name', Name>> {\n    return new UuidColumnBuilder(this, set(defaultMetadata, { name }));\n  }\n}\n\n/**\n * The type of index types that can be applied to a column.\n * `undefined` is the default\n */\nexport type IndexTypes = 'btree' | 'direct' | 'hash' | undefined;\n\n/**\n * Metadata describing column constraints and index type\n */\nexport type ColumnMetadata<Type = any> = {\n  isPrimaryKey?: true;\n  isUnique?: true;\n  isAutoIncrement?: true;\n  indexType?: IndexTypes;\n  defaultValue?: Type;\n  name?: string;\n};\n\n/**\n * Default metadata state type for a newly created column\n */\ntype DefaultMetadata = object;\n\n/**\n * Default metadata state value for a newly created column\n */\nconst defaultMetadata: ColumnMetadata<never> = {};\n\n/**\n * A column builder allows you to incrementally specify constraints\n * and metadata for a column in a type-safe way.\n *\n * It carries both a phantom TypeScript type (the `Type`) and\n * runtime algebraic type information.\n *\n * IMPORTANT! We have deliberately chosen to not have {@link ColumnBuilder}\n * extend {@link TypeBuilder} so that you cannot pass a {@link ColumnBuilder}\n * where a {@link TypeBuilder} is expected. i.e. We want to maintain\n * contravariance for functions that accept {@link TypeBuilder} parameters.\n */\nexport class ColumnBuilder<\n  Type,\n  SpacetimeType extends AlgebraicType,\n  M extends ColumnMetadata<Type> = DefaultMetadata,\n> {\n  typeBuilder: TypeBuilder<Type, SpacetimeType>;\n  columnMetadata: M;\n\n  constructor(typeBuilder: TypeBuilder<Type, SpacetimeType>, metadata: M) {\n    this.typeBuilder = typeBuilder;\n    this.columnMetadata = metadata;\n  }\n\n  serialize(writer: BinaryWriter, value: Type): void {\n    this.typeBuilder.serialize(writer, value);\n  }\n\n  deserialize(reader: BinaryReader): Type {\n    return this.typeBuilder.deserialize(reader);\n  }\n}\n\nexport class U8ColumnBuilder<M extends ColumnMetadata<number> = DefaultMetadata>\n  extends ColumnBuilder<number, AlgebraicTypeVariants.U8, M>\n  implements\n    Indexable<number, AlgebraicTypeVariants.U8>,\n    Uniqueable<number, AlgebraicTypeVariants.U8>,\n    PrimaryKeyable<number, AlgebraicTypeVariants.U8>,\n    AutoIncrementable<number, AlgebraicTypeVariants.U8>,\n    Defaultable<number, AlgebraicTypeVariants.U8>,\n    Nameable<number, AlgebraicTypeVariants.U8>\n{\n  index(): U8ColumnBuilder<SetField<M, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): U8ColumnBuilder<SetField<M, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): U8ColumnBuilder<SetField<M, 'indexType', IndexTypes>> {\n    return new U8ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): U8ColumnBuilder<SetField<M, 'isUnique', true>> {\n    return new U8ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): U8ColumnBuilder<SetField<M, 'isPrimaryKey', true>> {\n    return new U8ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): U8ColumnBuilder<SetField<M, 'isAutoIncrement', true>> {\n    return new U8ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isAutoIncrement: true as const })\n    );\n  }\n  default(value: number): U8ColumnBuilder<SetField<M, 'defaultValue', number>> {\n    return new U8ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, {\n        defaultValue: value,\n      })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): U8ColumnBuilder<SetField<M, 'name', Name>> {\n    return new U8ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\nexport class U16ColumnBuilder<\n    M extends ColumnMetadata<number> = DefaultMetadata,\n  >\n  extends ColumnBuilder<number, AlgebraicTypeVariants.U16, M>\n  implements\n    Indexable<number, AlgebraicTypeVariants.U16>,\n    Uniqueable<number, AlgebraicTypeVariants.U16>,\n    PrimaryKeyable<number, AlgebraicTypeVariants.U16>,\n    AutoIncrementable<number, AlgebraicTypeVariants.U16>,\n    Defaultable<number, AlgebraicTypeVariants.U16>,\n    Nameable<number, AlgebraicTypeVariants.U16>\n{\n  index(): U16ColumnBuilder<SetField<M, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): U16ColumnBuilder<SetField<M, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): U16ColumnBuilder<SetField<M, 'indexType', IndexTypes>> {\n    return new U16ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): U16ColumnBuilder<SetField<M, 'isUnique', true>> {\n    return new U16ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): U16ColumnBuilder<SetField<M, 'isPrimaryKey', true>> {\n    return new U16ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): U16ColumnBuilder<SetField<M, 'isAutoIncrement', true>> {\n    return new U16ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: number\n  ): U16ColumnBuilder<SetField<M, 'defaultValue', number>> {\n    return new U16ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, {\n        defaultValue: value,\n      })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): U16ColumnBuilder<SetField<M, 'name', Name>> {\n    return new U16ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\nexport class U32ColumnBuilder<\n    M extends ColumnMetadata<number> = DefaultMetadata,\n  >\n  extends ColumnBuilder<number, AlgebraicTypeVariants.U32, M>\n  implements\n    Indexable<number, AlgebraicTypeVariants.U32>,\n    Uniqueable<number, AlgebraicTypeVariants.U32>,\n    PrimaryKeyable<number, AlgebraicTypeVariants.U32>,\n    AutoIncrementable<number, AlgebraicTypeVariants.U32>,\n    Defaultable<number, AlgebraicTypeVariants.U32>,\n    Nameable<number, AlgebraicTypeVariants.U32>\n{\n  index(): U32ColumnBuilder<SetField<M, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): U32ColumnBuilder<SetField<M, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): U32ColumnBuilder<SetField<M, 'indexType', IndexTypes>> {\n    return new U32ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): U32ColumnBuilder<SetField<M, 'isUnique', true>> {\n    return new U32ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): U32ColumnBuilder<SetField<M, 'isPrimaryKey', true>> {\n    return new U32ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): U32ColumnBuilder<SetField<M, 'isAutoIncrement', true>> {\n    return new U32ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: number\n  ): U32ColumnBuilder<SetField<M, 'defaultValue', number>> {\n    return new U32ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, {\n        defaultValue: value,\n      })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): U32ColumnBuilder<SetField<M, 'name', Name>> {\n    return new U32ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\nexport class U64ColumnBuilder<\n    M extends ColumnMetadata<bigint> = DefaultMetadata,\n  >\n  extends ColumnBuilder<bigint, AlgebraicTypeVariants.U64, M>\n  implements\n    Indexable<bigint, AlgebraicTypeVariants.U64>,\n    Uniqueable<bigint, AlgebraicTypeVariants.U64>,\n    PrimaryKeyable<bigint, AlgebraicTypeVariants.U64>,\n    AutoIncrementable<bigint, AlgebraicTypeVariants.U64>,\n    Defaultable<bigint, AlgebraicTypeVariants.U64>,\n    Nameable<bigint, AlgebraicTypeVariants.U64>\n{\n  index(): U64ColumnBuilder<SetField<M, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): U64ColumnBuilder<SetField<M, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): U64ColumnBuilder<SetField<M, 'indexType', IndexTypes>> {\n    return new U64ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): U64ColumnBuilder<SetField<M, 'isUnique', true>> {\n    return new U64ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): U64ColumnBuilder<SetField<M, 'isPrimaryKey', true>> {\n    return new U64ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): U64ColumnBuilder<SetField<M, 'isAutoIncrement', true>> {\n    return new U64ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: bigint\n  ): U64ColumnBuilder<SetField<M, 'defaultValue', bigint>> {\n    return new U64ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, {\n        defaultValue: value,\n      })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): U64ColumnBuilder<SetField<M, 'name', Name>> {\n    return new U64ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\nexport class U128ColumnBuilder<\n    M extends ColumnMetadata<bigint> = DefaultMetadata,\n  >\n  extends ColumnBuilder<bigint, AlgebraicTypeVariants.U128, M>\n  implements\n    Indexable<bigint, AlgebraicTypeVariants.U128>,\n    Uniqueable<bigint, AlgebraicTypeVariants.U128>,\n    PrimaryKeyable<bigint, AlgebraicTypeVariants.U128>,\n    AutoIncrementable<bigint, AlgebraicTypeVariants.U128>,\n    Defaultable<bigint, AlgebraicTypeVariants.U128>,\n    Nameable<bigint, AlgebraicTypeVariants.U128>\n{\n  index(): U128ColumnBuilder<SetField<M, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): U128ColumnBuilder<SetField<M, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): U128ColumnBuilder<SetField<M, 'indexType', IndexTypes>> {\n    return new U128ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): U128ColumnBuilder<SetField<M, 'isUnique', true>> {\n    return new U128ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): U128ColumnBuilder<SetField<M, 'isPrimaryKey', true>> {\n    return new U128ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): U128ColumnBuilder<SetField<M, 'isAutoIncrement', true>> {\n    return new U128ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: bigint\n  ): U128ColumnBuilder<SetField<M, 'defaultValue', bigint>> {\n    return new U128ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, {\n        defaultValue: value,\n      })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): U128ColumnBuilder<SetField<M, 'name', Name>> {\n    return new U128ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\nexport class U256ColumnBuilder<\n    M extends ColumnMetadata<bigint> = DefaultMetadata,\n  >\n  extends ColumnBuilder<bigint, AlgebraicTypeVariants.U256, M>\n  implements\n    Indexable<bigint, AlgebraicTypeVariants.U256>,\n    Uniqueable<bigint, AlgebraicTypeVariants.U256>,\n    PrimaryKeyable<bigint, AlgebraicTypeVariants.U256>,\n    AutoIncrementable<bigint, AlgebraicTypeVariants.U256>,\n    Defaultable<bigint, AlgebraicTypeVariants.U256>,\n    Nameable<bigint, AlgebraicTypeVariants.U256>\n{\n  index(): U256ColumnBuilder<SetField<M, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): U256ColumnBuilder<SetField<M, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): U256ColumnBuilder<SetField<M, 'indexType', IndexTypes>> {\n    return new U256ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): U256ColumnBuilder<SetField<M, 'isUnique', true>> {\n    return new U256ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): U256ColumnBuilder<SetField<M, 'isPrimaryKey', true>> {\n    return new U256ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): U256ColumnBuilder<SetField<M, 'isAutoIncrement', true>> {\n    return new U256ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: bigint\n  ): U256ColumnBuilder<SetField<M, 'defaultValue', bigint>> {\n    return new U256ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, {\n        defaultValue: value,\n      })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): U256ColumnBuilder<SetField<M, 'name', Name>> {\n    return new U256ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\nexport class I8ColumnBuilder<M extends ColumnMetadata<number> = DefaultMetadata>\n  extends ColumnBuilder<number, AlgebraicTypeVariants.I8, M>\n  implements\n    Indexable<number, AlgebraicTypeVariants.I8>,\n    Uniqueable<number, AlgebraicTypeVariants.I8>,\n    PrimaryKeyable<number, AlgebraicTypeVariants.I8>,\n    AutoIncrementable<number, AlgebraicTypeVariants.I8>,\n    Defaultable<number, AlgebraicTypeVariants.I8>,\n    Nameable<number, AlgebraicTypeVariants.I8>\n{\n  index(): I8ColumnBuilder<SetField<M, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): I8ColumnBuilder<SetField<M, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): I8ColumnBuilder<SetField<M, 'indexType', IndexTypes>> {\n    return new I8ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): I8ColumnBuilder<SetField<M, 'isUnique', true>> {\n    return new I8ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): I8ColumnBuilder<SetField<M, 'isPrimaryKey', true>> {\n    return new I8ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): I8ColumnBuilder<SetField<M, 'isAutoIncrement', true>> {\n    return new I8ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(value: number): I8ColumnBuilder<SetField<M, 'defaultValue', number>> {\n    return new I8ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, {\n        defaultValue: value,\n      })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): I8ColumnBuilder<SetField<M, 'name', Name>> {\n    return new I8ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\nexport class I16ColumnBuilder<\n    M extends ColumnMetadata<number> = DefaultMetadata,\n  >\n  extends ColumnBuilder<number, AlgebraicTypeVariants.I16, M>\n  implements\n    Indexable<number, AlgebraicTypeVariants.I16>,\n    Uniqueable<number, AlgebraicTypeVariants.I16>,\n    PrimaryKeyable<number, AlgebraicTypeVariants.I16>,\n    AutoIncrementable<number, AlgebraicTypeVariants.I16>,\n    Defaultable<number, AlgebraicTypeVariants.I16>,\n    Nameable<number, AlgebraicTypeVariants.I16>\n{\n  index(): I16ColumnBuilder<SetField<M, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): I16ColumnBuilder<SetField<M, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): I16ColumnBuilder<SetField<M, 'indexType', IndexTypes>> {\n    return new I16ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): I16ColumnBuilder<SetField<M, 'isUnique', true>> {\n    return new I16ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): I16ColumnBuilder<SetField<M, 'isPrimaryKey', true>> {\n    return new I16ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): I16ColumnBuilder<SetField<M, 'isAutoIncrement', true>> {\n    return new I16ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: number\n  ): I16ColumnBuilder<SetField<M, 'defaultValue', number>> {\n    return new I16ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, {\n        defaultValue: value,\n      })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): I16ColumnBuilder<SetField<M, 'name', Name>> {\n    return new I16ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\nexport class I32ColumnBuilder<\n    M extends ColumnMetadata<number> = DefaultMetadata,\n  >\n  extends ColumnBuilder<number, AlgebraicTypeVariants.I32, M>\n  implements\n    Indexable<number, AlgebraicTypeVariants.I32>,\n    Uniqueable<number, AlgebraicTypeVariants.I32>,\n    PrimaryKeyable<number, AlgebraicTypeVariants.I32>,\n    AutoIncrementable<number, AlgebraicTypeVariants.I32>,\n    Defaultable<number, AlgebraicTypeVariants.I32>,\n    Nameable<number, AlgebraicTypeVariants.I32>\n{\n  index(): I32ColumnBuilder<SetField<M, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): I32ColumnBuilder<SetField<M, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): I32ColumnBuilder<SetField<M, 'indexType', IndexTypes>> {\n    return new I32ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): I32ColumnBuilder<SetField<M, 'isUnique', true>> {\n    return new I32ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): I32ColumnBuilder<SetField<M, 'isPrimaryKey', true>> {\n    return new I32ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): I32ColumnBuilder<SetField<M, 'isAutoIncrement', true>> {\n    return new I32ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: number\n  ): I32ColumnBuilder<SetField<M, 'defaultValue', number>> {\n    return new I32ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, {\n        defaultValue: value,\n      })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): I32ColumnBuilder<SetField<M, 'name', Name>> {\n    return new I32ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\nexport class I64ColumnBuilder<\n    M extends ColumnMetadata<bigint> = DefaultMetadata,\n  >\n  extends ColumnBuilder<bigint, AlgebraicTypeVariants.I64, M>\n  implements\n    Indexable<bigint, AlgebraicTypeVariants.I64>,\n    Uniqueable<bigint, AlgebraicTypeVariants.I64>,\n    PrimaryKeyable<bigint, AlgebraicTypeVariants.I64>,\n    AutoIncrementable<bigint, AlgebraicTypeVariants.I64>,\n    Defaultable<bigint, AlgebraicTypeVariants.I64>,\n    Nameable<bigint, AlgebraicTypeVariants.I64>\n{\n  index(): I64ColumnBuilder<SetField<M, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): I64ColumnBuilder<SetField<M, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): I64ColumnBuilder<SetField<M, 'indexType', IndexTypes>> {\n    return new I64ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): I64ColumnBuilder<SetField<M, 'isUnique', true>> {\n    return new I64ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): I64ColumnBuilder<SetField<M, 'isPrimaryKey', true>> {\n    return new I64ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): I64ColumnBuilder<SetField<M, 'isAutoIncrement', true>> {\n    return new I64ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: bigint\n  ): I64ColumnBuilder<SetField<M, 'defaultValue', bigint>> {\n    return new I64ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, {\n        defaultValue: value,\n      })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): I64ColumnBuilder<SetField<M, 'name', Name>> {\n    return new I64ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\nexport class I128ColumnBuilder<\n    M extends ColumnMetadata<bigint> = DefaultMetadata,\n  >\n  extends ColumnBuilder<bigint, AlgebraicTypeVariants.I128, M>\n  implements\n    Indexable<bigint, AlgebraicTypeVariants.I128>,\n    Uniqueable<bigint, AlgebraicTypeVariants.I128>,\n    PrimaryKeyable<bigint, AlgebraicTypeVariants.I128>,\n    AutoIncrementable<bigint, AlgebraicTypeVariants.I128>,\n    Defaultable<bigint, AlgebraicTypeVariants.I128>,\n    Nameable<bigint, AlgebraicTypeVariants.I128>\n{\n  index(): I128ColumnBuilder<SetField<M, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): I128ColumnBuilder<SetField<M, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): I128ColumnBuilder<SetField<M, 'indexType', IndexTypes>> {\n    return new I128ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): I128ColumnBuilder<SetField<M, 'isUnique', true>> {\n    return new I128ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): I128ColumnBuilder<SetField<M, 'isPrimaryKey', true>> {\n    return new I128ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): I128ColumnBuilder<SetField<M, 'isAutoIncrement', true>> {\n    return new I128ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: bigint\n  ): I128ColumnBuilder<SetField<M, 'defaultValue', bigint>> {\n    return new I128ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, {\n        defaultValue: value,\n      })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): I128ColumnBuilder<SetField<M, 'name', Name>> {\n    return new I128ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\nexport class I256ColumnBuilder<\n    M extends ColumnMetadata<bigint> = DefaultMetadata,\n  >\n  extends ColumnBuilder<bigint, AlgebraicTypeVariants.I256, M>\n  implements\n    Indexable<bigint, AlgebraicTypeVariants.I256>,\n    Uniqueable<bigint, AlgebraicTypeVariants.I256>,\n    PrimaryKeyable<bigint, AlgebraicTypeVariants.I256>,\n    AutoIncrementable<bigint, AlgebraicTypeVariants.I256>,\n    Defaultable<bigint, AlgebraicTypeVariants.I256>,\n    Nameable<bigint, AlgebraicTypeVariants.I256>\n{\n  index(): I256ColumnBuilder<SetField<M, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): I256ColumnBuilder<SetField<M, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): I256ColumnBuilder<SetField<M, 'indexType', IndexTypes>> {\n    return new I256ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): I256ColumnBuilder<SetField<M, 'isUnique', true>> {\n    return new I256ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): I256ColumnBuilder<SetField<M, 'isPrimaryKey', true>> {\n    return new I256ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isPrimaryKey: true })\n    );\n  }\n  autoInc(): I256ColumnBuilder<SetField<M, 'isAutoIncrement', true>> {\n    return new I256ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isAutoIncrement: true })\n    );\n  }\n  default(\n    value: bigint\n  ): I256ColumnBuilder<SetField<M, 'defaultValue', bigint>> {\n    return new I256ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, {\n        defaultValue: value,\n      })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): I256ColumnBuilder<SetField<M, 'name', Name>> {\n    return new I256ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\nexport class F32ColumnBuilder<\n    M extends ColumnMetadata<number> = DefaultMetadata,\n  >\n  extends ColumnBuilder<number, AlgebraicTypeVariants.F32, M>\n  implements\n    Defaultable<number, AlgebraicTypeVariants.F32>,\n    Nameable<number, AlgebraicTypeVariants.F32>\n{\n  default(\n    value: number\n  ): F32ColumnBuilder<SetField<M, 'defaultValue', number>> {\n    return new F32ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, {\n        defaultValue: value,\n      })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): F32ColumnBuilder<SetField<M, 'name', Name>> {\n    return new F32ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\nexport class F64ColumnBuilder<\n    M extends ColumnMetadata<number> = DefaultMetadata,\n  >\n  extends ColumnBuilder<number, AlgebraicTypeVariants.F64, M>\n  implements\n    Defaultable<number, AlgebraicTypeVariants.F64>,\n    Nameable<number, AlgebraicTypeVariants.F64>\n{\n  default(\n    value: number\n  ): F64ColumnBuilder<SetField<M, 'defaultValue', number>> {\n    return new F64ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, {\n        defaultValue: value,\n      })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): F64ColumnBuilder<SetField<M, 'name', Name>> {\n    return new F64ColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\nexport class BoolColumnBuilder<\n    M extends ColumnMetadata<boolean> = DefaultMetadata,\n  >\n  extends ColumnBuilder<boolean, AlgebraicTypeVariants.Bool, M>\n  implements\n    Indexable<boolean, AlgebraicTypeVariants.Bool>,\n    Uniqueable<boolean, AlgebraicTypeVariants.Bool>,\n    PrimaryKeyable<boolean, AlgebraicTypeVariants.Bool>,\n    Defaultable<boolean, AlgebraicTypeVariants.Bool>,\n    Nameable<boolean, AlgebraicTypeVariants.Bool>\n{\n  index(): BoolColumnBuilder<SetField<M, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): BoolColumnBuilder<SetField<M, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): BoolColumnBuilder<SetField<M, 'indexType', IndexTypes>> {\n    return new BoolColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): BoolColumnBuilder<SetField<M, 'isUnique', true>> {\n    return new BoolColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): BoolColumnBuilder<SetField<M, 'isPrimaryKey', true>> {\n    return new BoolColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isPrimaryKey: true })\n    );\n  }\n  default(\n    value: boolean\n  ): BoolColumnBuilder<SetField<M, 'defaultValue', boolean>> {\n    return new BoolColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, {\n        defaultValue: value,\n      })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): BoolColumnBuilder<SetField<M, 'name', Name>> {\n    return new BoolColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\nexport class StringColumnBuilder<\n    M extends ColumnMetadata<string> = DefaultMetadata,\n  >\n  extends ColumnBuilder<string, AlgebraicTypeVariants.String, M>\n  implements\n    Indexable<string, AlgebraicTypeVariants.String>,\n    Uniqueable<string, AlgebraicTypeVariants.String>,\n    PrimaryKeyable<string, AlgebraicTypeVariants.String>,\n    Defaultable<string, AlgebraicTypeVariants.String>,\n    Nameable<string, AlgebraicTypeVariants.String>\n{\n  index(): StringColumnBuilder<SetField<M, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): StringColumnBuilder<SetField<M, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): StringColumnBuilder<SetField<M, 'indexType', IndexTypes>> {\n    return new StringColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): StringColumnBuilder<SetField<M, 'isUnique', true>> {\n    return new StringColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): StringColumnBuilder<SetField<M, 'isPrimaryKey', true>> {\n    return new StringColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isPrimaryKey: true })\n    );\n  }\n  default(\n    value: string\n  ): StringColumnBuilder<SetField<M, 'defaultValue', string>> {\n    return new StringColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, {\n        defaultValue: value,\n      })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): StringColumnBuilder<SetField<M, 'name', Name>> {\n    return new StringColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\nexport class ArrayColumnBuilder<\n    Element extends TypeBuilder<any, any>,\n    M extends ColumnMetadata<\n      Array<InferTypeOfTypeBuilder<Element>>\n    > = DefaultMetadata,\n  >\n  extends ColumnBuilder<\n    Array<InferTypeOfTypeBuilder<Element>>,\n    { tag: 'Array'; value: InferSpacetimeTypeOfTypeBuilder<Element> },\n    M\n  >\n  implements\n    Defaultable<\n      Array<InferTypeOfTypeBuilder<Element>>,\n      AlgebraicTypeVariants.Array\n    >,\n    Nameable<\n      Array<InferTypeOfTypeBuilder<Element>>,\n      AlgebraicTypeVariants.Array\n    >\n{\n  default(\n    value: Array<InferTypeOfTypeBuilder<Element>>\n  ): ArrayColumnBuilder<\n    Element,\n    SetField<M, 'defaultValue', Array<InferTypeOfTypeBuilder<Element>>>\n  > {\n    return new ArrayColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, {\n        defaultValue: value,\n      })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): ArrayColumnBuilder<Element, SetField<M, 'name', Name>> {\n    return new ArrayColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\ntype ByteArrayType = {\n  tag: 'Array';\n  value: AlgebraicTypeVariants.U8;\n};\n\nexport class ByteArrayColumnBuilder<\n    M extends ColumnMetadata<Uint8Array> = DefaultMetadata,\n  >\n  extends ColumnBuilder<Uint8Array, ByteArrayType, M>\n  implements\n    Defaultable<Uint8Array, ByteArrayType, M>,\n    Nameable<Uint8Array, ByteArrayType, M>\n{\n  constructor(metadata: M) {\n    super(new TypeBuilder(AlgebraicType.Array(AlgebraicType.U8)), metadata);\n  }\n  default(\n    value: Uint8Array\n  ): ByteArrayColumnBuilder<SetField<M, 'defaultValue', Uint8Array>> {\n    return new ByteArrayColumnBuilder(\n      set(this.columnMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): ByteArrayColumnBuilder<SetField<M, 'name', Name>> {\n    return new ByteArrayColumnBuilder(set(this.columnMetadata, { name }));\n  }\n}\n\nexport class OptionColumnBuilder<\n    Value extends TypeBuilder<any, any>,\n    M extends ColumnMetadata<\n      InferTypeOfTypeBuilder<Value> | undefined\n    > = DefaultMetadata,\n  >\n  extends ColumnBuilder<\n    InferTypeOfTypeBuilder<Value> | undefined,\n    OptionAlgebraicType<InferSpacetimeTypeOfTypeBuilder<Value>>,\n    M\n  >\n  implements\n    Defaultable<\n      InferTypeOfTypeBuilder<Value> | undefined,\n      OptionAlgebraicType<InferSpacetimeTypeOfTypeBuilder<Value>>\n    >,\n    Nameable<\n      InferTypeOfTypeBuilder<Value> | undefined,\n      OptionAlgebraicType<InferSpacetimeTypeOfTypeBuilder<Value>>\n    >\n{\n  default(\n    value: InferTypeOfTypeBuilder<Value> | undefined\n  ): OptionColumnBuilder<\n    Value,\n    SetField<M, 'defaultValue', InferTypeOfTypeBuilder<Value> | undefined>\n  > {\n    return new OptionColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, {\n        defaultValue: value,\n      })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): OptionColumnBuilder<Value, SetField<M, 'name', Name>> {\n    return new OptionColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\nexport class ResultColumnBuilder<\n    Ok extends TypeBuilder<any, any>,\n    Err extends TypeBuilder<any, any>,\n    M extends ColumnMetadata<\n      InferTypeOfTypeBuilder<Ok> | InferTypeOfTypeBuilder<Err>\n    > = DefaultMetadata,\n  >\n  extends ColumnBuilder<\n    InferTypeOfTypeBuilder<Ok> | InferTypeOfTypeBuilder<Err>,\n    ResultAlgebraicType<\n      InferSpacetimeTypeOfTypeBuilder<Ok>,\n      InferSpacetimeTypeOfTypeBuilder<Err>\n    >,\n    M\n  >\n  implements\n    Defaultable<\n      InferTypeOfTypeBuilder<Ok> | InferTypeOfTypeBuilder<Err>,\n      ResultAlgebraicType<\n        InferSpacetimeTypeOfTypeBuilder<Ok>,\n        InferSpacetimeTypeOfTypeBuilder<Err>\n      >\n    >\n{\n  constructor(typeBuilder: TypeBuilder<any, any>, metadata: M) {\n    super(typeBuilder, metadata);\n  }\n\n  default(\n    value: InferTypeOfTypeBuilder<Ok> | InferTypeOfTypeBuilder<Err>\n  ): ResultColumnBuilder<\n    Ok,\n    Err,\n    SetField<\n      M,\n      'defaultValue',\n      InferTypeOfTypeBuilder<Ok> | InferTypeOfTypeBuilder<Err>\n    >\n  > {\n    return new ResultColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, {\n        defaultValue: value,\n      })\n    );\n  }\n}\n\nexport class ProductColumnBuilder<\n    Elements extends ElementsObj,\n    M extends ColumnMetadata<ObjectType<Elements>> = DefaultMetadata,\n  >\n  extends ColumnBuilder<\n    ObjectType<Elements>,\n    ElementsToProductType<Elements>,\n    M\n  >\n  implements\n    Defaultable<ObjectType<Elements>, ElementsToProductType<Elements>>,\n    Nameable<ObjectType<Elements>, ElementsToProductType<Elements>>\n{\n  default(\n    value: ObjectType<Elements>\n  ): ProductColumnBuilder<\n    Elements,\n    SetField<DefaultMetadata, 'defaultValue', any>\n  > {\n    return new ProductColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): ProductColumnBuilder<Elements, SetField<DefaultMetadata, 'name', Name>> {\n    return new ProductColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\nexport class SumColumnBuilder<\n    Variants extends VariantsObj,\n    M extends ColumnMetadata<EnumType<Variants>> = DefaultMetadata,\n  >\n  extends ColumnBuilder<EnumType<Variants>, VariantsToSumType<Variants>, M>\n  implements\n    Defaultable<EnumType<Variants>, VariantsToSumType<Variants>>,\n    Nameable<EnumType<Variants>, VariantsToSumType<Variants>>\n{\n  default(\n    value: EnumType<Variants>\n  ): SumColumnBuilder<\n    Variants,\n    SetField<DefaultMetadata, 'defaultValue', any>\n  > {\n    return new SumColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): SumColumnBuilder<Variants, SetField<DefaultMetadata, 'name', Name>> {\n    return new SumColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\nexport class SimpleSumColumnBuilder<\n    Variants extends VariantsObj,\n    M extends ColumnMetadata<EnumType<Variants>> = DefaultMetadata,\n  >\n  extends SumColumnBuilder<Variants, M>\n  implements\n    Indexable<EnumType<Variants>, AlgebraicTypeVariants.Sum>,\n    PrimaryKeyable<EnumType<Variants>, AlgebraicTypeVariants.Sum>\n{\n  index(): SimpleSumColumnBuilder<\n    Variants,\n    SetField<DefaultMetadata, 'indexType', 'btree'>\n  >;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): SimpleSumColumnBuilder<\n    Variants,\n    SetField<DefaultMetadata, 'indexType', N>\n  >;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): SimpleSumColumnBuilder<\n    Variants,\n    SetField<DefaultMetadata, 'indexType', IndexTypes>\n  > {\n    return new SimpleSumColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { indexType: algorithm })\n    );\n  }\n  primaryKey(): SimpleSumColumnBuilder<\n    Variants,\n    SetField<DefaultMetadata, 'isPrimaryKey', true>\n  > {\n    return new SimpleSumColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isPrimaryKey: true })\n    );\n  }\n}\n\nexport class ScheduleAtColumnBuilder<\n    M extends ColumnMetadata<ScheduleAt> = DefaultMetadata,\n  >\n  extends ColumnBuilder<ScheduleAt, ScheduleAtAlgebraicType, M>\n  implements\n    Defaultable<ScheduleAt, ScheduleAtAlgebraicType>,\n    Nameable<ScheduleAt, ScheduleAtAlgebraicType>\n{\n  default(\n    value: ScheduleAt\n  ): ScheduleAtColumnBuilder<SetField<M, 'defaultValue', ScheduleAt>> {\n    return new ScheduleAtColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): ScheduleAtColumnBuilder<SetField<M, 'name', Name>> {\n    return new ScheduleAtColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\nexport class IdentityColumnBuilder<\n    M extends ColumnMetadata<Identity> = DefaultMetadata,\n  >\n  extends ColumnBuilder<Identity, IdentityAlgebraicType, M>\n  implements\n    Indexable<Identity, IdentityAlgebraicType>,\n    Uniqueable<Identity, IdentityAlgebraicType>,\n    PrimaryKeyable<Identity, IdentityAlgebraicType>,\n    Defaultable<Identity, IdentityAlgebraicType>,\n    Nameable<Identity, IdentityAlgebraicType>\n{\n  index(): IdentityColumnBuilder<SetField<M, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): IdentityColumnBuilder<SetField<M, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): IdentityColumnBuilder<SetField<M, 'indexType', IndexTypes>> {\n    return new IdentityColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): IdentityColumnBuilder<SetField<M, 'isUnique', true>> {\n    return new IdentityColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): IdentityColumnBuilder<SetField<M, 'isPrimaryKey', true>> {\n    return new IdentityColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isPrimaryKey: true })\n    );\n  }\n  default(\n    value: Identity\n  ): IdentityColumnBuilder<SetField<M, 'defaultValue', Identity>> {\n    return new IdentityColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): IdentityColumnBuilder<SetField<M, 'name', Name>> {\n    return new IdentityColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\nexport class ConnectionIdColumnBuilder<\n    M extends ColumnMetadata<ConnectionId> = DefaultMetadata,\n  >\n  extends ColumnBuilder<ConnectionId, ConnectionIdAlgebraicType, M>\n  implements\n    Indexable<ConnectionId, ConnectionIdAlgebraicType>,\n    Uniqueable<ConnectionId, ConnectionIdAlgebraicType>,\n    PrimaryKeyable<ConnectionId, ConnectionIdAlgebraicType>,\n    Defaultable<ConnectionId, ConnectionIdAlgebraicType>,\n    Nameable<ConnectionId, ConnectionIdAlgebraicType>\n{\n  index(): ConnectionIdColumnBuilder<SetField<M, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): ConnectionIdColumnBuilder<SetField<M, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): ConnectionIdColumnBuilder<SetField<M, 'indexType', IndexTypes>> {\n    return new ConnectionIdColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): ConnectionIdColumnBuilder<SetField<M, 'isUnique', true>> {\n    return new ConnectionIdColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): ConnectionIdColumnBuilder<SetField<M, 'isPrimaryKey', true>> {\n    return new ConnectionIdColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isPrimaryKey: true })\n    );\n  }\n  default(\n    value: ConnectionId\n  ): ConnectionIdColumnBuilder<SetField<M, 'defaultValue', ConnectionId>> {\n    return new ConnectionIdColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): ConnectionIdColumnBuilder<SetField<M, 'name', Name>> {\n    return new ConnectionIdColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\nexport class TimestampColumnBuilder<\n    M extends ColumnMetadata<Timestamp> = DefaultMetadata,\n  >\n  extends ColumnBuilder<Timestamp, TimestampAlgebraicType, M>\n  implements\n    Indexable<Timestamp, TimestampAlgebraicType>,\n    Uniqueable<Timestamp, TimestampAlgebraicType>,\n    PrimaryKeyable<Timestamp, TimestampAlgebraicType>,\n    Defaultable<Timestamp, TimestampAlgebraicType>,\n    Nameable<Timestamp, TimestampAlgebraicType>\n{\n  index(): TimestampColumnBuilder<SetField<M, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): TimestampColumnBuilder<SetField<M, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): TimestampColumnBuilder<SetField<M, 'indexType', IndexTypes>> {\n    return new TimestampColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): TimestampColumnBuilder<SetField<M, 'isUnique', true>> {\n    return new TimestampColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): TimestampColumnBuilder<SetField<M, 'isPrimaryKey', true>> {\n    return new TimestampColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isPrimaryKey: true })\n    );\n  }\n  default(\n    value: Timestamp\n  ): TimestampColumnBuilder<SetField<M, 'defaultValue', Timestamp>> {\n    return new TimestampColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): TimestampColumnBuilder<SetField<M, 'name', Name>> {\n    return new TimestampColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\nexport class TimeDurationColumnBuilder<\n    M extends ColumnMetadata<TimeDuration> = DefaultMetadata,\n  >\n  extends ColumnBuilder<TimeDuration, TimeDurationAlgebraicType, M>\n  implements\n    Indexable<TimeDuration, TimeDurationAlgebraicType>,\n    Uniqueable<TimeDuration, TimeDurationAlgebraicType>,\n    PrimaryKeyable<TimeDuration, TimeDurationAlgebraicType>,\n    Defaultable<TimeDuration, TimeDurationAlgebraicType>,\n    Nameable<TimeDuration, TimeDurationAlgebraicType>\n{\n  index(): TimeDurationColumnBuilder<SetField<M, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): TimeDurationColumnBuilder<SetField<M, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): TimeDurationColumnBuilder<SetField<M, 'indexType', IndexTypes>> {\n    return new TimeDurationColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): TimeDurationColumnBuilder<SetField<M, 'isUnique', true>> {\n    return new TimeDurationColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): TimeDurationColumnBuilder<SetField<M, 'isPrimaryKey', true>> {\n    return new TimeDurationColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isPrimaryKey: true })\n    );\n  }\n  default(\n    value: TimeDuration\n  ): TimeDurationColumnBuilder<SetField<M, 'defaultValue', TimeDuration>> {\n    return new TimeDurationColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): TimeDurationColumnBuilder<SetField<M, 'name', Name>> {\n    return new TimeDurationColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\nexport class UuidColumnBuilder<M extends ColumnMetadata<Uuid> = DefaultMetadata>\n  extends ColumnBuilder<Uuid, UuidAlgebraicType, M>\n  implements\n    Indexable<Uuid, UuidAlgebraicType>,\n    Uniqueable<Uuid, UuidAlgebraicType>,\n    PrimaryKeyable<Uuid, UuidAlgebraicType>,\n    Defaultable<Uuid, UuidAlgebraicType>,\n    Nameable<Uuid, UuidAlgebraicType>\n{\n  index(): UuidColumnBuilder<SetField<M, 'indexType', 'btree'>>;\n  index<N extends NonNullable<IndexTypes>>(\n    algorithm: N\n  ): UuidColumnBuilder<SetField<M, 'indexType', N>>;\n  index(\n    algorithm: IndexTypes = 'btree'\n  ): UuidColumnBuilder<SetField<M, 'indexType', IndexTypes>> {\n    return new UuidColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { indexType: algorithm })\n    );\n  }\n  unique(): UuidColumnBuilder<SetField<M, 'isUnique', true>> {\n    return new UuidColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isUnique: true })\n    );\n  }\n  primaryKey(): UuidColumnBuilder<SetField<M, 'isPrimaryKey', true>> {\n    return new UuidColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { isPrimaryKey: true })\n    );\n  }\n  default(value: Uuid): UuidColumnBuilder<SetField<M, 'defaultValue', Uuid>> {\n    return new UuidColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { defaultValue: value })\n    );\n  }\n  name<const Name extends string>(\n    name: Name\n  ): UuidColumnBuilder<SetField<M, 'name', Name>> {\n    return new UuidColumnBuilder(\n      this.typeBuilder,\n      set(this.columnMetadata, { name })\n    );\n  }\n}\n\nexport class RefBuilder<Type, SpacetimeType> extends TypeBuilder<\n  Type,\n  AlgebraicTypeVariants.Ref\n> {\n  readonly ref: number;\n  /** The phantom type of the pointee of this ref. */\n  private readonly __spacetimeType!: SpacetimeType;\n  constructor(ref: number) {\n    super(AlgebraicType.Ref(ref));\n    this.ref = ref;\n  }\n}\n\ninterface EnumFn {\n  /**\n   * Creates a simple sum type whose cases are all unit variants.\n   * Each string in the array becomes a case of the enum.\n   *\n   * Example:\n   * ```ts\n   * t.enum(\"Color\", [\"red\", \"green\", \"blue\"]);\n   * ```\n   */\n  <Case extends string>(\n    name: string,\n    cases: readonly [Case, ...Case[]]\n  ): SimpleSumBuilderImpl<Record<Case, UnitBuilder>>;\n\n  /**\n   * Creates an empty simple sum type (no cases, equivalent to `never`).\n   * This can be useful for code generation or placeholder types.\n   * Example:\n   * ```ts\n   * t.enum(\"Never\", []);\n   * ```\n   */\n  (name: string, cases: []): SimpleSumBuilderImpl<Record<never, UnitBuilder>>;\n\n  /**\n   * Creates a full sum type, where each case can have a payload.\n   * Each value in the object must be a {@link TypeBuilder}.\n   *\n   * Example:\n   * ```ts\n   * t.enum(\"Result\", { Ok: t.unit(), Err: t.string() });\n   * ```\n   */\n  <Obj extends VariantsObj>(name: string, obj: Obj): SumBuilder<Obj>;\n}\n\nconst enumImpl = ((nameOrObj: any, maybeObj?: any) => {\n  let obj: any = nameOrObj;\n  let name: string | undefined = undefined;\n\n  if (typeof nameOrObj === 'string') {\n    if (!maybeObj) {\n      throw new TypeError(\n        'When providing a name, you must also provide the variants object or array.'\n      );\n    }\n    obj = maybeObj;\n    name = nameOrObj;\n  }\n\n  // Simple sum (array form)\n  if (Array.isArray(obj)) {\n    const simpleVariantsObj: Record<string, UnitBuilder> = {};\n    for (const variant of obj) {\n      simpleVariantsObj[variant] = new UnitBuilder();\n    }\n    return new SimpleSumBuilderImpl(simpleVariantsObj, name);\n  }\n\n  // Regular sum (object form)\n  return new SumBuilder(obj, name);\n}) as EnumFn;\n\n/**\n * A collection of factory functions for creating various SpacetimeDB algebraic types\n * to be used in table definitions. Each function returns a corresponding builder\n * for a specific type, such as `BoolBuilder`, `StringBuilder`, or `F64Builder`.\n *\n * These builders are used to define the schema of tables in SpacetimeDB, and each\n * builder implements the {@link TypeBuilder} interface, allowing for type-safe\n * schema construction in TypeScript.\n *\n * @remarks\n * - Primitive types (e.g., `bool`, `string`, `number`) map to their respective TypeScript types.\n * - Integer and floating-point types (e.g., `i8`, `u64`, `f32`) are represented as `number` or `bigint` in TypeScript.\n * - Complex types such as `object`, `array`, and `enum` allow for nested and structured schemas.\n * - The `scheduleAt` builder is a special column type for scheduling.\n *\n * @see {@link TypeBuilder}\n */\nexport const t = {\n  /**\n   * Creates a new `Bool` {@link AlgebraicType} to be used in table definitions\n   * Represented as `boolean` in TypeScript.\n   * @returns A new {@link BoolBuilder} instance\n   */\n  bool: (): BoolBuilder => new BoolBuilder(),\n\n  /**\n   * Creates a new `String` {@link AlgebraicType} to be used in table definitions\n   * Represented as `string` in TypeScript.\n   * @returns A new {@link StringBuilder} instance\n   */\n  string: (): StringBuilder => new StringBuilder(),\n\n  /**\n   * Creates a new `F64` {@link AlgebraicType} to be used in table definitions\n   * Represented as `number` in TypeScript.\n   * @returns A new {@link F64Builder} instance\n   */\n  number: (): F64Builder => new F64Builder(),\n\n  /**\n   * Creates a new `I8` {@link AlgebraicType} to be used in table definitions\n   * Represented as `number` in TypeScript.\n   * @returns A new {@link I8Builder} instance\n   */\n  i8: (): I8Builder => new I8Builder(),\n\n  /**\n   * Creates a new `U8` {@link AlgebraicType} to be used in table definitions\n   * Represented as `number` in TypeScript.\n   * @returns A new {@link U8Builder} instance\n   */\n  u8: (): U8Builder => new U8Builder(),\n\n  /**\n   * Creates a new `I16` {@link AlgebraicType} to be used in table definitions\n   * Represented as `number` in TypeScript.\n   * @returns A new {@link I16Builder} instance\n   */\n  i16: (): I16Builder => new I16Builder(),\n\n  /**\n   * Creates a new `U16` {@link AlgebraicType} to be used in table definitions\n   * Represented as `number` in TypeScript.\n   * @returns A new {@link U16Builder} instance\n   */\n  u16: (): U16Builder => new U16Builder(),\n\n  /**\n   * Creates a new `I32` {@link AlgebraicType} to be used in table definitions\n   * Represented as `number` in TypeScript.\n   * @returns A new {@link I32Builder} instance\n   */\n  i32: (): I32Builder => new I32Builder(),\n\n  /**\n   * Creates a new `U32` {@link AlgebraicType} to be used in table definitions\n   * Represented as `number` in TypeScript.\n   * @returns A new {@link U32Builder} instance\n   */\n  u32: (): U32Builder => new U32Builder(),\n\n  /**\n   * Creates a new `I64` {@link AlgebraicType} to be used in table definitions\n   * Represented as `bigint` in TypeScript.\n   * @returns A new {@link I64Builder} instance\n   */\n  i64: (): I64Builder => new I64Builder(),\n\n  /**\n   * Creates a new `U64` {@link AlgebraicType} to be used in table definitions\n   * Represented as `bigint` in TypeScript.\n   * @returns A new {@link U64Builder} instance\n   */\n  u64: (): U64Builder => new U64Builder(),\n\n  /**\n   * Creates a new `I128` {@link AlgebraicType} to be used in table definitions\n   * Represented as `bigint` in TypeScript.\n   * @returns A new {@link I128Builder} instance\n   */\n  i128: (): I128Builder => new I128Builder(),\n\n  /**\n   * Creates a new `U128` {@link AlgebraicType} to be used in table definitions\n   * Represented as `bigint` in TypeScript.\n   * @returns A new {@link U128Builder} instance\n   */\n  u128: (): U128Builder => new U128Builder(),\n\n  /**\n   * Creates a new `I256` {@link AlgebraicType} to be used in table definitions\n   * Represented as `bigint` in TypeScript.\n   * @returns A new {@link I256Builder} instance\n   */\n  i256: (): I256Builder => new I256Builder(),\n\n  /**\n   * Creates a new `U256` {@link AlgebraicType} to be used in table definitions\n   * Represented as `bigint` in TypeScript.\n   * @returns A new {@link U256Builder} instance\n   */\n  u256: (): U256Builder => new U256Builder(),\n\n  /**\n   * Creates a new `F32` {@link AlgebraicType} to be used in table definitions\n   * Represented as `number` in TypeScript.\n   * @returns A new {@link F32Builder} instance\n   */\n  f32: (): F32Builder => new F32Builder(),\n\n  /**\n   * Creates a new `F64` {@link AlgebraicType} to be used in table definitions\n   * Represented as `number` in TypeScript.\n   * @returns A new {@link F64Builder} instance\n   */\n  f64: (): F64Builder => new F64Builder(),\n\n  /**\n   * Creates a new `Product` {@link AlgebraicType} to be used in table definitions. Product types in SpacetimeDB\n   * are essentially the same as objects in JavaScript/TypeScript.\n   * Properties of the object must also be {@link TypeBuilder}s.\n   * Represented as an object with specific properties in TypeScript.\n   *\n   * @param name (optional) A display name for the product type. If omitted, an anonymous product type is created.\n   * @param obj The object defining the properties of the type, whose property\n   * values must be {@link TypeBuilder}s.\n   * @returns A new {@link ProductBuilder} instance.\n   */\n  object: ((nameOrObj: any, maybeObj?: any) => {\n    if (typeof nameOrObj === 'string') {\n      if (!maybeObj) {\n        throw new TypeError(\n          'When providing a name, you must also provide the object.'\n        );\n      }\n      return new ProductBuilder(maybeObj, nameOrObj);\n    }\n    return new ProductBuilder(nameOrObj, undefined);\n  }) as {\n    <Obj extends ElementsObj>(name: string, obj: Obj): ProductBuilder<Obj>;\n    // TODO: Currently names are not optional\n    // <Obj extends ElementsObj>(obj: Obj): ProductBuilder<Obj>;\n  },\n\n  /**\n   * Creates a new `Row` {@link AlgebraicType} to be used in table definitions. Row types in SpacetimeDB\n   * are similar to `Product` types, but are specifically used to define the schema of a table row.\n   * Properties of the object must also be {@link TypeBuilder} or {@link ColumnBuilder}s.\n   *\n   * You can represent a `Row` as either a {@link RowObj} or an {@link RowBuilder} type when\n   * defining a table schema.\n   *\n   * The {@link RowBuilder} type is useful when you want to create a type which can be used anywhere\n   * a {@link TypeBuilder} is accepted, such as in nested objects or arrays, or as the argument\n   * to a scheduled function.\n   *\n   * @param obj The object defining the properties of the row, whose property\n   * values must be {@link TypeBuilder}s or {@link ColumnBuilder}s.\n   * @returns A new {@link RowBuilder} instance\n   */\n  row: (<Obj extends RowObj>(\n    nameOrObj: string | Obj,\n    maybeObj?: Obj\n  ): RowBuilder<Obj> => {\n    const [obj, name] =\n      typeof nameOrObj === 'string'\n        ? [maybeObj!, nameOrObj]\n        : [nameOrObj, undefined];\n    return new RowBuilder(obj, name);\n  }) as {\n    <Obj extends RowObj>(obj: Obj): RowBuilder<Obj>;\n    <Obj extends RowObj>(name: string, obj: Obj): RowBuilder<Obj>;\n  },\n\n  /**\n   * Creates a new `Array` {@link AlgebraicType} to be used in table definitions.\n   * Represented as an array in TypeScript.\n   * @param element The element type of the array, which must be a `TypeBuilder`.\n   * @returns A new {@link ArrayBuilder} instance\n   */\n  array<Element extends TypeBuilder<any, any>>(\n    e: Element\n  ): ArrayBuilder<Element> {\n    return new ArrayBuilder(e);\n  },\n\n  enum: enumImpl,\n\n  /**\n   * This is a special helper function for conveniently creating `Product` type columns with no fields.\n   *\n   * @returns A new {@link ProductBuilder} instance with no fields.\n   */\n  unit(): UnitBuilder {\n    return new UnitBuilder();\n  },\n\n  /**\n   * Creates a lazily-evaluated {@link TypeBuilder}. This is useful for creating\n   * recursive types, such as a tree or linked list.\n   * @param thunk A function that returns a {@link TypeBuilder}.\n   * @returns A proxy {@link TypeBuilder} that evaluates the thunk on first access.\n   */\n  lazy<Build extends () => TypeBuilder<any, any>>(\n    thunk: Build\n  ): ReturnType<Build> {\n    type B = ReturnType<Build>;\n    let cached: B | null = null;\n    const get = (): B => (cached ??= thunk() as B);\n\n    const proxy = new Proxy({} as unknown as B, {\n      get(_t, prop, recv) {\n        const target = get() as any;\n        const val = Reflect.get(target, prop, recv);\n        return typeof val === 'function' ? val.bind(target) : val;\n      },\n      set(_t, prop, value, recv) {\n        return Reflect.set(get() as any, prop, value, recv);\n      },\n      has(_t, prop) {\n        return prop in (get() as any);\n      },\n      ownKeys() {\n        return Reflect.ownKeys(get() as any);\n      },\n      getOwnPropertyDescriptor(_t, prop) {\n        return Object.getOwnPropertyDescriptor(get() as any, prop);\n      },\n      getPrototypeOf() {\n        // makes `instanceof TypeBuilder` work if you care about it\n        return Object.getPrototypeOf(get() as any);\n      },\n    }) as B;\n\n    return proxy;\n  },\n\n  /**\n   * This is a special helper function for conveniently creating {@link ScheduleAt} type columns.\n   * @returns A new ColumnBuilder instance with the {@link ScheduleAt} type.\n   */\n  scheduleAt: (): ScheduleAtBuilder => {\n    return new ScheduleAtBuilder();\n  },\n\n  /**\n   * This is a convenience method for creating a column with the {@link Option} type.\n   * You can create a column of the same type by constructing an enum with a `some` and `none` variant.\n   * @param value The type of the value contained in the `some` variant of the `Option`.\n   * @returns A new {@link OptionBuilder} instance with the {@link Option} type.\n   */\n  option<Value extends TypeBuilder<any, any>>(\n    value: Value\n  ): OptionBuilder<Value> {\n    return new OptionBuilder(value);\n  },\n\n  /**\n   * This is a convenience method for creating a column with the {@link Result} type.\n   * You can create a column of the same type by constructing an enum with an `ok` and `err` variant.\n   * @param ok The type of the value contained in the `ok` variant of the `Result`.\n   * @param err The type of the value contained in the `err` variant of the `Result`.\n   * @returns A new {@link ResultBuilder} instance with the {@link Result} type.\n   */\n  result<Ok extends TypeBuilder<any, any>, Err extends TypeBuilder<any, any>>(\n    ok: Ok,\n    err: Err\n  ): ResultBuilder<Ok, Err> {\n    return new ResultBuilder(ok, err);\n  },\n\n  /**\n   * This is a convenience method for creating a column with the {@link Identity} type.\n   * You can create a column of the same type by constructing an `object` with a single `__identity__` element.\n   * @returns A new {@link TypeBuilder} instance with the {@link Identity} type.\n   */\n  identity: (): IdentityBuilder => {\n    return new IdentityBuilder();\n  },\n\n  /**\n   * This is a convenience method for creating a column with the {@link ConnectionId} type.\n   * You can create a column of the same type by constructing an `object` with a single `__connection_id__` element.\n   * @returns A new {@link TypeBuilder} instance with the {@link ConnectionId} type.\n   */\n  connectionId: (): ConnectionIdBuilder => {\n    return new ConnectionIdBuilder();\n  },\n\n  /**\n   * This is a convenience method for creating a column with the {@link Timestamp} type.\n   * You can create a column of the same type by constructing an `object` with a single `__timestamp_micros_since_unix_epoch__` element.\n   * @returns A new {@link TypeBuilder} instance with the {@link Timestamp} type.\n   */\n  timestamp: (): TimestampBuilder => {\n    return new TimestampBuilder();\n  },\n\n  /**\n   * This is a convenience method for creating a column with the {@link TimeDuration} type.\n   * You can create a column of the same type by constructing an `object` with a single `__time_duration_micros__` element.\n   * @returns A new {@link TypeBuilder} instance with the {@link TimeDuration} type.\n   */\n  timeDuration: (): TimeDurationBuilder => {\n    return new TimeDurationBuilder();\n  },\n\n  /**\n   * This is a convenience method for creating a column with the {@link Uuid} type.\n   * You can create a column of the same type by constructing an `object` with a single `__uuid__` element.\n   * @returns A new {@link TypeBuilder} instance with the {@link Uuid} type.\n   */\n  uuid: (): UuidBuilder => {\n    return new UuidBuilder();\n  },\n\n  /**\n   * This is a convenience method for creating a column with the `ByteArray` type.\n   * You can create a column of the same type by constructing an `array` of `u8`.\n   * The TypeScript representation is {@link Uint8Array}.\n   * @returns A new {@link ByteArrayBuilder} instance with the `ByteArray` type.\n   */\n  byteArray: (): ByteArrayBuilder => {\n    return new ByteArrayBuilder();\n  },\n} as const;\nexport default t;\n","// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE\n// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.\n\n/* eslint-disable */\n/* tslint:disable */\nimport {\n  TypeBuilder as __TypeBuilder,\n  t as __t,\n  type AlgebraicTypeType as __AlgebraicTypeType,\n  type Infer as __Infer,\n} from '../../lib/type_builders';\n\n// The tagged union or sum type for the algebraic type `AlgebraicType`.\nexport const AlgebraicType: __TypeBuilder<\n  __AlgebraicTypeType,\n  __AlgebraicTypeType\n> = __t.enum('AlgebraicType', {\n  Ref: __t.u32(),\n  get Sum() {\n    return SumType;\n  },\n  get Product() {\n    return ProductType;\n  },\n  get Array() {\n    return AlgebraicType;\n  },\n  String: __t.unit(),\n  Bool: __t.unit(),\n  I8: __t.unit(),\n  U8: __t.unit(),\n  I16: __t.unit(),\n  U16: __t.unit(),\n  I32: __t.unit(),\n  U32: __t.unit(),\n  I64: __t.unit(),\n  U64: __t.unit(),\n  I128: __t.unit(),\n  U128: __t.unit(),\n  I256: __t.unit(),\n  U256: __t.unit(),\n  F32: __t.unit(),\n  F64: __t.unit(),\n});\nexport type AlgebraicType = __Infer<typeof AlgebraicType>;\n\n// The tagged union or sum type for the algebraic type `CaseConversionPolicy`.\nexport const CaseConversionPolicy = __t.enum('CaseConversionPolicy', {\n  None: __t.unit(),\n  SnakeCase: __t.unit(),\n});\nexport type CaseConversionPolicy = __Infer<typeof CaseConversionPolicy>;\n\n// The tagged union or sum type for the algebraic type `ExplicitNameEntry`.\nexport const ExplicitNameEntry = __t.enum('ExplicitNameEntry', {\n  get Table() {\n    return NameMapping;\n  },\n  get Function() {\n    return NameMapping;\n  },\n  get Index() {\n    return NameMapping;\n  },\n});\nexport type ExplicitNameEntry = __Infer<typeof ExplicitNameEntry>;\n\nexport const ExplicitNames = __t.object('ExplicitNames', {\n  get entries() {\n    return __t.array(ExplicitNameEntry);\n  },\n});\nexport type ExplicitNames = __Infer<typeof ExplicitNames>;\n\n// The tagged union or sum type for the algebraic type `FunctionVisibility`.\nexport const FunctionVisibility = __t.enum('FunctionVisibility', {\n  Private: __t.unit(),\n  ClientCallable: __t.unit(),\n});\nexport type FunctionVisibility = __Infer<typeof FunctionVisibility>;\n\nexport const HttpHeaderPair = __t.object('HttpHeaderPair', {\n  name: __t.string(),\n  value: __t.byteArray(),\n});\nexport type HttpHeaderPair = __Infer<typeof HttpHeaderPair>;\n\nexport const HttpHeaders = __t.object('HttpHeaders', {\n  get entries() {\n    return __t.array(HttpHeaderPair);\n  },\n});\nexport type HttpHeaders = __Infer<typeof HttpHeaders>;\n\n// The tagged union or sum type for the algebraic type `HttpMethod`.\nexport const HttpMethod = __t.enum('HttpMethod', {\n  Get: __t.unit(),\n  Head: __t.unit(),\n  Post: __t.unit(),\n  Put: __t.unit(),\n  Delete: __t.unit(),\n  Connect: __t.unit(),\n  Options: __t.unit(),\n  Trace: __t.unit(),\n  Patch: __t.unit(),\n  Extension: __t.string(),\n});\nexport type HttpMethod = __Infer<typeof HttpMethod>;\n\nexport const HttpRequest = __t.object('HttpRequest', {\n  get method() {\n    return HttpMethod;\n  },\n  get headers() {\n    return HttpHeaders;\n  },\n  timeout: __t.option(__t.timeDuration()),\n  uri: __t.string(),\n  get version() {\n    return HttpVersion;\n  },\n});\nexport type HttpRequest = __Infer<typeof HttpRequest>;\n\nexport const HttpResponse = __t.object('HttpResponse', {\n  get headers() {\n    return HttpHeaders;\n  },\n  get version() {\n    return HttpVersion;\n  },\n  code: __t.u16(),\n});\nexport type HttpResponse = __Infer<typeof HttpResponse>;\n\n// The tagged union or sum type for the algebraic type `HttpVersion`.\nexport const HttpVersion = __t.enum('HttpVersion', {\n  Http09: __t.unit(),\n  Http10: __t.unit(),\n  Http11: __t.unit(),\n  Http2: __t.unit(),\n  Http3: __t.unit(),\n});\nexport type HttpVersion = __Infer<typeof HttpVersion>;\n\n// The tagged union or sum type for the algebraic type `IndexType`.\nexport const IndexType = __t.enum('IndexType', {\n  BTree: __t.unit(),\n  Hash: __t.unit(),\n});\nexport type IndexType = __Infer<typeof IndexType>;\n\n// The tagged union or sum type for the algebraic type `Lifecycle`.\nexport const Lifecycle = __t.enum('Lifecycle', {\n  Init: __t.unit(),\n  OnConnect: __t.unit(),\n  OnDisconnect: __t.unit(),\n});\nexport type Lifecycle = __Infer<typeof Lifecycle>;\n\n// The tagged union or sum type for the algebraic type `MiscModuleExport`.\nexport const MiscModuleExport = __t.enum('MiscModuleExport', {\n  get TypeAlias() {\n    return TypeAlias;\n  },\n});\nexport type MiscModuleExport = __Infer<typeof MiscModuleExport>;\n\nexport const NameMapping = __t.object('NameMapping', {\n  sourceName: __t.string(),\n  canonicalName: __t.string(),\n});\nexport type NameMapping = __Infer<typeof NameMapping>;\n\nexport const ProductType = __t.object('ProductType', {\n  get elements() {\n    return __t.array(ProductTypeElement);\n  },\n});\nexport type ProductType = __Infer<typeof ProductType>;\n\nexport const ProductTypeElement = __t.object('ProductTypeElement', {\n  name: __t.option(__t.string()),\n  get algebraicType() {\n    return AlgebraicType;\n  },\n});\nexport type ProductTypeElement = __Infer<typeof ProductTypeElement>;\n\nexport const RawColumnDefV8 = __t.object('RawColumnDefV8', {\n  colName: __t.string(),\n  get colType() {\n    return AlgebraicType;\n  },\n});\nexport type RawColumnDefV8 = __Infer<typeof RawColumnDefV8>;\n\nexport const RawColumnDefaultValueV10 = __t.object('RawColumnDefaultValueV10', {\n  colId: __t.u16(),\n  value: __t.byteArray(),\n});\nexport type RawColumnDefaultValueV10 = __Infer<typeof RawColumnDefaultValueV10>;\n\nexport const RawColumnDefaultValueV9 = __t.object('RawColumnDefaultValueV9', {\n  table: __t.string(),\n  colId: __t.u16(),\n  value: __t.byteArray(),\n});\nexport type RawColumnDefaultValueV9 = __Infer<typeof RawColumnDefaultValueV9>;\n\n// The tagged union or sum type for the algebraic type `RawConstraintDataV9`.\nexport const RawConstraintDataV9 = __t.enum('RawConstraintDataV9', {\n  get Unique() {\n    return RawUniqueConstraintDataV9;\n  },\n});\nexport type RawConstraintDataV9 = __Infer<typeof RawConstraintDataV9>;\n\nexport const RawConstraintDefV10 = __t.object('RawConstraintDefV10', {\n  sourceName: __t.option(__t.string()),\n  get data() {\n    return RawConstraintDataV9;\n  },\n});\nexport type RawConstraintDefV10 = __Infer<typeof RawConstraintDefV10>;\n\nexport const RawConstraintDefV8 = __t.object('RawConstraintDefV8', {\n  constraintName: __t.string(),\n  constraints: __t.u8(),\n  columns: __t.array(__t.u16()),\n});\nexport type RawConstraintDefV8 = __Infer<typeof RawConstraintDefV8>;\n\nexport const RawConstraintDefV9 = __t.object('RawConstraintDefV9', {\n  name: __t.option(__t.string()),\n  get data() {\n    return RawConstraintDataV9;\n  },\n});\nexport type RawConstraintDefV9 = __Infer<typeof RawConstraintDefV9>;\n\n// The tagged union or sum type for the algebraic type `RawIndexAlgorithm`.\nexport const RawIndexAlgorithm = __t.enum('RawIndexAlgorithm', {\n  BTree: __t.array(__t.u16()),\n  Hash: __t.array(__t.u16()),\n  Direct: __t.u16(),\n});\nexport type RawIndexAlgorithm = __Infer<typeof RawIndexAlgorithm>;\n\nexport const RawIndexDefV10 = __t.object('RawIndexDefV10', {\n  sourceName: __t.option(__t.string()),\n  accessorName: __t.option(__t.string()),\n  get algorithm() {\n    return RawIndexAlgorithm;\n  },\n});\nexport type RawIndexDefV10 = __Infer<typeof RawIndexDefV10>;\n\nexport const RawIndexDefV8 = __t.object('RawIndexDefV8', {\n  indexName: __t.string(),\n  isUnique: __t.bool(),\n  get indexType() {\n    return IndexType;\n  },\n  columns: __t.array(__t.u16()),\n});\nexport type RawIndexDefV8 = __Infer<typeof RawIndexDefV8>;\n\nexport const RawIndexDefV9 = __t.object('RawIndexDefV9', {\n  name: __t.option(__t.string()),\n  accessorName: __t.option(__t.string()),\n  get algorithm() {\n    return RawIndexAlgorithm;\n  },\n});\nexport type RawIndexDefV9 = __Infer<typeof RawIndexDefV9>;\n\nexport const RawLifeCycleReducerDefV10 = __t.object(\n  'RawLifeCycleReducerDefV10',\n  {\n    get lifecycleSpec() {\n      return Lifecycle;\n    },\n    functionName: __t.string(),\n  }\n);\nexport type RawLifeCycleReducerDefV10 = __Infer<\n  typeof RawLifeCycleReducerDefV10\n>;\n\n// The tagged union or sum type for the algebraic type `RawMiscModuleExportV9`.\nexport const RawMiscModuleExportV9 = __t.enum('RawMiscModuleExportV9', {\n  get ColumnDefaultValue() {\n    return RawColumnDefaultValueV9;\n  },\n  get Procedure() {\n    return RawProcedureDefV9;\n  },\n  get View() {\n    return RawViewDefV9;\n  },\n});\nexport type RawMiscModuleExportV9 = __Infer<typeof RawMiscModuleExportV9>;\n\n// The tagged union or sum type for the algebraic type `RawModuleDef`.\nexport const RawModuleDef = __t.enum('RawModuleDef', {\n  get V8BackCompat() {\n    return RawModuleDefV8;\n  },\n  get V9() {\n    return RawModuleDefV9;\n  },\n  get V10() {\n    return RawModuleDefV10;\n  },\n});\nexport type RawModuleDef = __Infer<typeof RawModuleDef>;\n\nexport const RawModuleDefV10 = __t.object('RawModuleDefV10', {\n  get sections() {\n    return __t.array(RawModuleDefV10Section);\n  },\n});\nexport type RawModuleDefV10 = __Infer<typeof RawModuleDefV10>;\n\n// The tagged union or sum type for the algebraic type `RawModuleDefV10Section`.\nexport const RawModuleDefV10Section = __t.enum('RawModuleDefV10Section', {\n  get Typespace() {\n    return Typespace;\n  },\n  get Types() {\n    return __t.array(RawTypeDefV10);\n  },\n  get Tables() {\n    return __t.array(RawTableDefV10);\n  },\n  get Reducers() {\n    return __t.array(RawReducerDefV10);\n  },\n  get Procedures() {\n    return __t.array(RawProcedureDefV10);\n  },\n  get Views() {\n    return __t.array(RawViewDefV10);\n  },\n  get Schedules() {\n    return __t.array(RawScheduleDefV10);\n  },\n  get LifeCycleReducers() {\n    return __t.array(RawLifeCycleReducerDefV10);\n  },\n  get RowLevelSecurity() {\n    return __t.array(RawRowLevelSecurityDefV9);\n  },\n  get CaseConversionPolicy() {\n    return CaseConversionPolicy;\n  },\n  get ExplicitNames() {\n    return ExplicitNames;\n  },\n});\nexport type RawModuleDefV10Section = __Infer<typeof RawModuleDefV10Section>;\n\nexport const RawModuleDefV8 = __t.object('RawModuleDefV8', {\n  get typespace() {\n    return Typespace;\n  },\n  get tables() {\n    return __t.array(TableDesc);\n  },\n  get reducers() {\n    return __t.array(ReducerDef);\n  },\n  get miscExports() {\n    return __t.array(MiscModuleExport);\n  },\n});\nexport type RawModuleDefV8 = __Infer<typeof RawModuleDefV8>;\n\nexport const RawModuleDefV9 = __t.object('RawModuleDefV9', {\n  get typespace() {\n    return Typespace;\n  },\n  get tables() {\n    return __t.array(RawTableDefV9);\n  },\n  get reducers() {\n    return __t.array(RawReducerDefV9);\n  },\n  get types() {\n    return __t.array(RawTypeDefV9);\n  },\n  get miscExports() {\n    return __t.array(RawMiscModuleExportV9);\n  },\n  get rowLevelSecurity() {\n    return __t.array(RawRowLevelSecurityDefV9);\n  },\n});\nexport type RawModuleDefV9 = __Infer<typeof RawModuleDefV9>;\n\nexport const RawProcedureDefV10 = __t.object('RawProcedureDefV10', {\n  sourceName: __t.string(),\n  get params() {\n    return ProductType;\n  },\n  get returnType() {\n    return AlgebraicType;\n  },\n  get visibility() {\n    return FunctionVisibility;\n  },\n});\nexport type RawProcedureDefV10 = __Infer<typeof RawProcedureDefV10>;\n\nexport const RawProcedureDefV9 = __t.object('RawProcedureDefV9', {\n  name: __t.string(),\n  get params() {\n    return ProductType;\n  },\n  get returnType() {\n    return AlgebraicType;\n  },\n});\nexport type RawProcedureDefV9 = __Infer<typeof RawProcedureDefV9>;\n\nexport const RawReducerDefV10 = __t.object('RawReducerDefV10', {\n  sourceName: __t.string(),\n  get params() {\n    return ProductType;\n  },\n  get visibility() {\n    return FunctionVisibility;\n  },\n  get okReturnType() {\n    return AlgebraicType;\n  },\n  get errReturnType() {\n    return AlgebraicType;\n  },\n});\nexport type RawReducerDefV10 = __Infer<typeof RawReducerDefV10>;\n\nexport const RawReducerDefV9 = __t.object('RawReducerDefV9', {\n  name: __t.string(),\n  get params() {\n    return ProductType;\n  },\n  get lifecycle() {\n    return __t.option(Lifecycle);\n  },\n});\nexport type RawReducerDefV9 = __Infer<typeof RawReducerDefV9>;\n\nexport const RawRowLevelSecurityDefV9 = __t.object('RawRowLevelSecurityDefV9', {\n  sql: __t.string(),\n});\nexport type RawRowLevelSecurityDefV9 = __Infer<typeof RawRowLevelSecurityDefV9>;\n\nexport const RawScheduleDefV10 = __t.object('RawScheduleDefV10', {\n  sourceName: __t.option(__t.string()),\n  tableName: __t.string(),\n  scheduleAtCol: __t.u16(),\n  functionName: __t.string(),\n});\nexport type RawScheduleDefV10 = __Infer<typeof RawScheduleDefV10>;\n\nexport const RawScheduleDefV9 = __t.object('RawScheduleDefV9', {\n  name: __t.option(__t.string()),\n  reducerName: __t.string(),\n  scheduledAtColumn: __t.u16(),\n});\nexport type RawScheduleDefV9 = __Infer<typeof RawScheduleDefV9>;\n\nexport const RawScopedTypeNameV10 = __t.object('RawScopedTypeNameV10', {\n  scope: __t.array(__t.string()),\n  sourceName: __t.string(),\n});\nexport type RawScopedTypeNameV10 = __Infer<typeof RawScopedTypeNameV10>;\n\nexport const RawScopedTypeNameV9 = __t.object('RawScopedTypeNameV9', {\n  scope: __t.array(__t.string()),\n  name: __t.string(),\n});\nexport type RawScopedTypeNameV9 = __Infer<typeof RawScopedTypeNameV9>;\n\nexport const RawSequenceDefV10 = __t.object('RawSequenceDefV10', {\n  sourceName: __t.option(__t.string()),\n  column: __t.u16(),\n  start: __t.option(__t.i128()),\n  minValue: __t.option(__t.i128()),\n  maxValue: __t.option(__t.i128()),\n  increment: __t.i128(),\n});\nexport type RawSequenceDefV10 = __Infer<typeof RawSequenceDefV10>;\n\nexport const RawSequenceDefV8 = __t.object('RawSequenceDefV8', {\n  sequenceName: __t.string(),\n  colPos: __t.u16(),\n  increment: __t.i128(),\n  start: __t.option(__t.i128()),\n  minValue: __t.option(__t.i128()),\n  maxValue: __t.option(__t.i128()),\n  allocated: __t.i128(),\n});\nexport type RawSequenceDefV8 = __Infer<typeof RawSequenceDefV8>;\n\nexport const RawSequenceDefV9 = __t.object('RawSequenceDefV9', {\n  name: __t.option(__t.string()),\n  column: __t.u16(),\n  start: __t.option(__t.i128()),\n  minValue: __t.option(__t.i128()),\n  maxValue: __t.option(__t.i128()),\n  increment: __t.i128(),\n});\nexport type RawSequenceDefV9 = __Infer<typeof RawSequenceDefV9>;\n\nexport const RawTableDefV10 = __t.object('RawTableDefV10', {\n  sourceName: __t.string(),\n  productTypeRef: __t.u32(),\n  primaryKey: __t.array(__t.u16()),\n  get indexes() {\n    return __t.array(RawIndexDefV10);\n  },\n  get constraints() {\n    return __t.array(RawConstraintDefV10);\n  },\n  get sequences() {\n    return __t.array(RawSequenceDefV10);\n  },\n  get tableType() {\n    return TableType;\n  },\n  get tableAccess() {\n    return TableAccess;\n  },\n  get defaultValues() {\n    return __t.array(RawColumnDefaultValueV10);\n  },\n  isEvent: __t.bool(),\n});\nexport type RawTableDefV10 = __Infer<typeof RawTableDefV10>;\n\nexport const RawTableDefV8 = __t.object('RawTableDefV8', {\n  tableName: __t.string(),\n  get columns() {\n    return __t.array(RawColumnDefV8);\n  },\n  get indexes() {\n    return __t.array(RawIndexDefV8);\n  },\n  get constraints() {\n    return __t.array(RawConstraintDefV8);\n  },\n  get sequences() {\n    return __t.array(RawSequenceDefV8);\n  },\n  tableType: __t.string(),\n  tableAccess: __t.string(),\n  scheduled: __t.option(__t.string()),\n});\nexport type RawTableDefV8 = __Infer<typeof RawTableDefV8>;\n\nexport const RawTableDefV9 = __t.object('RawTableDefV9', {\n  name: __t.string(),\n  productTypeRef: __t.u32(),\n  primaryKey: __t.array(__t.u16()),\n  get indexes() {\n    return __t.array(RawIndexDefV9);\n  },\n  get constraints() {\n    return __t.array(RawConstraintDefV9);\n  },\n  get sequences() {\n    return __t.array(RawSequenceDefV9);\n  },\n  get schedule() {\n    return __t.option(RawScheduleDefV9);\n  },\n  get tableType() {\n    return TableType;\n  },\n  get tableAccess() {\n    return TableAccess;\n  },\n});\nexport type RawTableDefV9 = __Infer<typeof RawTableDefV9>;\n\nexport const RawTypeDefV10 = __t.object('RawTypeDefV10', {\n  get sourceName() {\n    return RawScopedTypeNameV10;\n  },\n  ty: __t.u32(),\n  customOrdering: __t.bool(),\n});\nexport type RawTypeDefV10 = __Infer<typeof RawTypeDefV10>;\n\nexport const RawTypeDefV9 = __t.object('RawTypeDefV9', {\n  get name() {\n    return RawScopedTypeNameV9;\n  },\n  ty: __t.u32(),\n  customOrdering: __t.bool(),\n});\nexport type RawTypeDefV9 = __Infer<typeof RawTypeDefV9>;\n\nexport const RawUniqueConstraintDataV9 = __t.object(\n  'RawUniqueConstraintDataV9',\n  {\n    columns: __t.array(__t.u16()),\n  }\n);\nexport type RawUniqueConstraintDataV9 = __Infer<\n  typeof RawUniqueConstraintDataV9\n>;\n\nexport const RawViewDefV10 = __t.object('RawViewDefV10', {\n  sourceName: __t.string(),\n  index: __t.u32(),\n  isPublic: __t.bool(),\n  isAnonymous: __t.bool(),\n  get params() {\n    return ProductType;\n  },\n  get returnType() {\n    return AlgebraicType;\n  },\n});\nexport type RawViewDefV10 = __Infer<typeof RawViewDefV10>;\n\nexport const RawViewDefV9 = __t.object('RawViewDefV9', {\n  name: __t.string(),\n  index: __t.u32(),\n  isPublic: __t.bool(),\n  isAnonymous: __t.bool(),\n  get params() {\n    return ProductType;\n  },\n  get returnType() {\n    return AlgebraicType;\n  },\n});\nexport type RawViewDefV9 = __Infer<typeof RawViewDefV9>;\n\nexport const ReducerDef = __t.object('ReducerDef', {\n  name: __t.string(),\n  get args() {\n    return __t.array(ProductTypeElement);\n  },\n});\nexport type ReducerDef = __Infer<typeof ReducerDef>;\n\nexport const SumType = __t.object('SumType', {\n  get variants() {\n    return __t.array(SumTypeVariant);\n  },\n});\nexport type SumType = __Infer<typeof SumType>;\n\nexport const SumTypeVariant = __t.object('SumTypeVariant', {\n  name: __t.option(__t.string()),\n  get algebraicType() {\n    return AlgebraicType;\n  },\n});\nexport type SumTypeVariant = __Infer<typeof SumTypeVariant>;\n\n// The tagged union or sum type for the algebraic type `TableAccess`.\nexport const TableAccess = __t.enum('TableAccess', {\n  Public: __t.unit(),\n  Private: __t.unit(),\n});\nexport type TableAccess = __Infer<typeof TableAccess>;\n\nexport const TableDesc = __t.object('TableDesc', {\n  get schema() {\n    return RawTableDefV8;\n  },\n  data: __t.u32(),\n});\nexport type TableDesc = __Infer<typeof TableDesc>;\n\n// The tagged union or sum type for the algebraic type `TableType`.\nexport const TableType = __t.enum('TableType', {\n  System: __t.unit(),\n  User: __t.unit(),\n});\nexport type TableType = __Infer<typeof TableType>;\n\nexport const TypeAlias = __t.object('TypeAlias', {\n  name: __t.string(),\n  ty: __t.u32(),\n});\nexport type TypeAlias = __Infer<typeof TypeAlias>;\n\nexport const Typespace = __t.object('Typespace', {\n  get types() {\n    return __t.array(AlgebraicType);\n  },\n});\nexport type Typespace = __Infer<typeof Typespace>;\n\n// The tagged union or sum type for the algebraic type `ViewResultHeader`.\nexport const ViewResultHeader = __t.enum('ViewResultHeader', {\n  RowData: __t.unit(),\n  RawSql: __t.string(),\n});\nexport type ViewResultHeader = __Infer<typeof ViewResultHeader>;\n","import {\n  AlgebraicType,\n  ProductType,\n  SumType,\n  type AlgebraicTypeType,\n  type AlgebraicTypeVariants,\n} from './algebraic_type';\nimport type {\n  CaseConversionPolicy,\n  RawModuleDefV10,\n  RawModuleDefV10Section,\n  RawScopedTypeNameV10,\n  RawTableDefV10,\n} from './autogen/types';\nimport type { UntypedIndex } from './indexes';\nimport type { UntypedTableDef } from './table';\nimport type { UntypedTableSchema } from './table_schema';\nimport {\n  ArrayBuilder,\n  OptionBuilder,\n  ProductBuilder,\n  RefBuilder,\n  ResultBuilder,\n  RowBuilder,\n  SumBuilder,\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  TypeBuilder,\n  type ElementsObj,\n  type Infer,\n  type InferSpacetimeTypeOfTypeBuilder,\n  type RowObj,\n  type VariantsObj,\n} from './type_builders';\nimport type { Values } from './type_util';\n\nexport type TableNamesOf<S extends UntypedSchemaDef> = Values<\n  S['tables']\n>['accessorName'];\n\n/**\n * An untyped representation of the database schema.\n */\nexport type UntypedSchemaDef = {\n  tables: Record<string, UntypedTableDef>;\n};\n\n/**\n * Helper type to convert an array of TableSchema into a schema definition\n */\nexport interface TablesToSchema<T extends Record<string, UntypedTableSchema>>\n  extends UntypedSchemaDef {\n  tables: {\n    readonly [AccName in keyof T & string]: TableToSchema<AccName, T[AccName]>;\n  };\n}\n\nexport interface TableToSchema<\n  AccName extends string,\n  T extends UntypedTableSchema,\n> extends UntypedTableDef {\n  accessorName: AccName;\n  columns: T['rowType']['row'];\n  rowType: T['rowSpacetimeType'];\n  indexes: T['idxs'];\n  constraints: T['constraints'];\n}\n\nexport function tablesToSchema<\n  const T extends Record<string, UntypedTableSchema>,\n>(ctx: ModuleContext, tables: T): TablesToSchema<T> {\n  return {\n    tables: Object.fromEntries(\n      Object.entries(tables).map(([accName, schema]) => [\n        accName,\n        tableToSchema(accName, schema, schema.tableDef(ctx, accName)),\n      ])\n    ) as TablesToSchema<T>['tables'],\n  };\n}\n\nexport function tableToSchema<\n  AccName extends string,\n  const T extends UntypedTableSchema,\n>(\n  accName: AccName,\n  schema: T,\n  tableDef: RawTableDefV10\n): TableToSchema<AccName, T> {\n  const getColName = (i: number) =>\n    schema.rowType.algebraicType.value.elements[i].name;\n\n  type AllowedCol = keyof T['rowType']['row'] & string;\n  return {\n    sourceName: accName,\n    accessorName: accName,\n    columns: schema.rowType.row, // typed as T[i]['rowType']['row'] under TablesToSchema<T>\n    rowType: schema.rowSpacetimeType,\n    constraints: tableDef.constraints.map(c => ({\n      name: c.sourceName,\n      constraint: 'unique',\n      columns: c.data.value.columns.map(getColName) as [string],\n    })),\n    // TODO: horrible horrible horrible. we smuggle this `Array<UntypedIndex>`\n    // by casting it to an `Array<IndexOpts>` as `TableToSchema` expects.\n    // This is then used in `TableCacheImpl.constructor` and who knows where else.\n    // We should stop lying about our types.\n    indexes: tableDef.indexes.map((idx): UntypedIndex<AllowedCol> => {\n      const columnIds =\n        idx.algorithm.tag === 'Direct'\n          ? [idx.algorithm.value]\n          : idx.algorithm.value;\n      return {\n        name: idx.accessorName!,\n        unique: tableDef.constraints.some(c =>\n          c.data.value.columns.every(col => columnIds.includes(col))\n        ),\n        algorithm: idx.algorithm.tag.toLowerCase() as 'btree',\n        columns: columnIds.map(getColName),\n      };\n    }) as T['idxs'],\n    tableDef,\n    ...(tableDef.isEvent ? { isEvent: true } : {}),\n  };\n}\n\ntype CompoundTypeCache = Map<\n  AlgebraicTypeVariants.Product | AlgebraicTypeVariants.Sum,\n  RefBuilder<any, any>\n>;\n\nexport type ModuleDef = {\n  [S in RawModuleDefV10Section as Uncapitalize<S['tag']>]: S['value'];\n};\n\ntype Section = RawModuleDefV10Section;\n\nexport class ModuleContext {\n  #compoundTypes: CompoundTypeCache = new Map();\n\n  /**\n   * The global module definition that gets populated by calls to `reducer()` and lifecycle hooks.\n   */\n  #moduleDef: ModuleDef = {\n    typespace: { types: [] },\n    tables: [],\n    reducers: [],\n    types: [],\n    rowLevelSecurity: [],\n    schedules: [],\n    procedures: [],\n    views: [],\n    lifeCycleReducers: [],\n    caseConversionPolicy: { tag: 'SnakeCase' },\n    explicitNames: {\n      entries: [],\n    },\n  };\n\n  get moduleDef(): ModuleDef {\n    return this.#moduleDef;\n  }\n\n  rawModuleDefV10(): RawModuleDefV10 {\n    const sections: Section[] = [];\n\n    const push = <T extends Section>(s: T | undefined) => {\n      if (s) sections.push(s);\n    };\n\n    const module = this.#moduleDef;\n\n    push(module.typespace && { tag: 'Typespace', value: module.typespace });\n    push(module.types && { tag: 'Types', value: module.types });\n    push(module.tables && { tag: 'Tables', value: module.tables });\n    push(module.reducers && { tag: 'Reducers', value: module.reducers });\n    push(module.procedures && { tag: 'Procedures', value: module.procedures });\n    push(module.views && { tag: 'Views', value: module.views });\n    push(module.schedules && { tag: 'Schedules', value: module.schedules });\n    push(\n      module.lifeCycleReducers && {\n        tag: 'LifeCycleReducers',\n        value: module.lifeCycleReducers,\n      }\n    );\n    push(\n      module.rowLevelSecurity && {\n        tag: 'RowLevelSecurity',\n        value: module.rowLevelSecurity,\n      }\n    );\n    push(\n      module.explicitNames && {\n        tag: 'ExplicitNames',\n        value: module.explicitNames,\n      }\n    );\n    push(\n      module.caseConversionPolicy && {\n        tag: 'CaseConversionPolicy',\n        value: module.caseConversionPolicy,\n      }\n    );\n    return { sections };\n  }\n\n  /**\n   * Set the case conversion policy for this module.\n   * Called by the settings mechanism.\n   */\n  setCaseConversionPolicy(policy: CaseConversionPolicy) {\n    this.#moduleDef.caseConversionPolicy = policy;\n  }\n\n  get typespace() {\n    return this.#moduleDef.typespace;\n  }\n\n  /**\n   * Resolves the actual type of a TypeBuilder by following its references until it reaches a non-ref type.\n   * @param typespace The typespace to resolve types against.\n   * @param typeBuilder The TypeBuilder to resolve.\n   * @returns The resolved algebraic type.\n   */\n  public resolveType<AT extends AlgebraicTypeType>(\n    typeBuilder: RefBuilder<any, AT>\n  ): AT {\n    let ty: AlgebraicType = typeBuilder.algebraicType;\n    while (ty.tag === 'Ref') {\n      ty = this.typespace.types[ty.value];\n    }\n    return ty as AT;\n  }\n\n  /**\n   * Adds a type to the module definition's typespace as a `Ref` if it is a named compound type (Product or Sum).\n   * Otherwise, returns the type as is.\n   * @param name\n   * @param ty\n   * @returns\n   */\n  public registerTypesRecursively<T extends TypeBuilder<any, AlgebraicType>>(\n    typeBuilder: T\n  ): T extends SumBuilder<any> | ProductBuilder<any> | RowBuilder<any>\n    ? RefBuilder<Infer<T>, InferSpacetimeTypeOfTypeBuilder<T>>\n    : T {\n    if (\n      (typeBuilder instanceof ProductBuilder && !isUnit(typeBuilder)) ||\n      typeBuilder instanceof SumBuilder ||\n      typeBuilder instanceof RowBuilder\n    ) {\n      return this.#registerCompoundTypeRecursively(typeBuilder) as any;\n    } else if (typeBuilder instanceof OptionBuilder) {\n      return new OptionBuilder(\n        this.registerTypesRecursively(typeBuilder.value)\n      ) as any;\n    } else if (typeBuilder instanceof ResultBuilder) {\n      return new ResultBuilder(\n        this.registerTypesRecursively(typeBuilder.ok),\n        this.registerTypesRecursively(typeBuilder.err)\n      ) as any;\n    } else if (typeBuilder instanceof ArrayBuilder) {\n      return new ArrayBuilder(\n        this.registerTypesRecursively(typeBuilder.element)\n      ) as any;\n    } else {\n      return typeBuilder as any;\n    }\n  }\n\n  #registerCompoundTypeRecursively<\n    T extends\n      | SumBuilder<VariantsObj>\n      | ProductBuilder<ElementsObj>\n      | RowBuilder<RowObj>,\n  >(typeBuilder: T): RefBuilder<Infer<T>, InferSpacetimeTypeOfTypeBuilder<T>> {\n    const ty = typeBuilder.algebraicType;\n    // NB! You must ensure that all TypeBuilder passed into this function\n    // have a name. This function ensures that nested types always have a\n    // name by assigning them one if they are missing it.\n    const name = typeBuilder.typeName;\n    if (name === undefined) {\n      throw new Error(\n        `Missing type name for ${typeBuilder.constructor.name ?? 'TypeBuilder'} ${JSON.stringify(typeBuilder)}`\n      );\n    }\n\n    let r = this.#compoundTypes.get(ty);\n    if (r != null) {\n      // Already added to typespace\n      return r;\n    }\n\n    // Recursively register nested compound types\n    const newTy =\n      typeBuilder instanceof RowBuilder || typeBuilder instanceof ProductBuilder\n        ? ({\n            tag: 'Product',\n            value: { elements: [] },\n          } as AlgebraicTypeVariants.Product)\n        : ({\n            tag: 'Sum',\n            value: { variants: [] },\n          } as AlgebraicTypeVariants.Sum);\n\n    r = new RefBuilder(this.#moduleDef.typespace.types.length);\n    this.#moduleDef.typespace.types.push(newTy);\n\n    this.#compoundTypes.set(ty, r);\n\n    if (typeBuilder instanceof RowBuilder) {\n      for (const [name, elem] of Object.entries(typeBuilder.row)) {\n        (newTy.value as ProductType).elements.push({\n          name,\n          algebraicType: this.registerTypesRecursively(elem.typeBuilder)\n            .algebraicType,\n        });\n      }\n    } else if (typeBuilder instanceof ProductBuilder) {\n      for (const [name, elem] of Object.entries(typeBuilder.elements)) {\n        (newTy.value as ProductType).elements.push({\n          name,\n          algebraicType: this.registerTypesRecursively(elem).algebraicType,\n        });\n      }\n    } else if (typeBuilder instanceof SumBuilder) {\n      for (const [name, variant] of Object.entries(typeBuilder.variants)) {\n        (newTy.value as SumType).variants.push({\n          name,\n          algebraicType: this.registerTypesRecursively(variant).algebraicType,\n        });\n      }\n    }\n\n    this.#moduleDef.types.push({\n      sourceName: splitName(name),\n      ty: r.ref,\n      customOrdering: true,\n    });\n\n    return r;\n  }\n}\n\nfunction isUnit(typeBuilder: ProductBuilder<ElementsObj>): boolean {\n  return (\n    typeBuilder.typeName == null &&\n    typeBuilder.algebraicType.value.elements.length === 0\n  );\n}\n\nexport function splitName(name: string): RawScopedTypeNameV10 {\n  const scope = name.split('.');\n  return { sourceName: scope.pop()!, scope };\n}\n","import { Headers, headersToList } from 'headers-polyfill';\nimport status from 'statuses';\nimport BinaryReader from '../lib/binary_reader';\nimport BinaryWriter from '../lib/binary_writer';\nimport {\n  HttpHeaders,\n  HttpMethod,\n  HttpRequest,\n  HttpResponse,\n} from '../lib/http_types';\nimport type { TimeDuration } from '../lib/time_duration';\nimport { bsatnBaseSize } from '../lib/util';\nimport { sys } from './runtime';\n\nexport { Headers };\n\nconst { freeze } = Object;\n\nexport type BodyInit = ArrayBuffer | ArrayBufferView | string;\nexport type HeadersInit = [string, string][] | Record<string, string> | Headers;\nexport interface ResponseInit {\n  headers?: HeadersInit;\n  status?: number;\n  statusText?: string;\n}\n\nconst textEncoder = new TextEncoder();\nconst textDecoder = new TextDecoder('utf-8' /* { fatal: true } */);\n\nconst makeResponse = Symbol('makeResponse');\n\n// based on deno's type of the same name\ninterface InnerResponse {\n  type: 'basic' | 'cors' | 'default' | 'error' | 'opaque' | 'opaqueredirect';\n  url: string | null;\n  status: number;\n  statusText: string;\n  headers: Headers;\n  aborted: boolean;\n}\n\nexport class SyncResponse {\n  #body: string | ArrayBuffer | null;\n  #inner: InnerResponse;\n\n  constructor(body?: BodyInit | null, init?: ResponseInit) {\n    if (body == null) {\n      this.#body = null;\n    } else if (typeof body === 'string') {\n      this.#body = body;\n    } else {\n      // this call is fine, the typings are just weird\n      this.#body = new Uint8Array<ArrayBuffer>(body as any).buffer;\n    }\n\n    // there's a type mismatch - headers-polyfill's typing doesn't expect its\n    // own `Headers` type, even though the actual code handles it correctly.\n    this.#inner = {\n      headers: new Headers(init?.headers as any),\n      status: init?.status ?? 200,\n      statusText: init?.statusText ?? '',\n      type: 'default',\n      url: null,\n      aborted: false,\n    };\n  }\n\n  static [makeResponse](body: BodyInit | null, inner: InnerResponse) {\n    const me = new SyncResponse(body);\n    me.#inner = inner;\n    return me;\n  }\n\n  get headers(): Headers {\n    return this.#inner.headers;\n  }\n  get status(): number {\n    return this.#inner.status;\n  }\n  get statusText() {\n    return this.#inner.statusText;\n  }\n  get ok(): boolean {\n    return 200 <= this.#inner.status && this.#inner.status <= 299;\n  }\n  get url(): string {\n    return this.#inner.url ?? '';\n  }\n  get type() {\n    return this.#inner.type;\n  }\n\n  arrayBuffer(): ArrayBuffer {\n    return this.bytes().buffer;\n  }\n\n  bytes(): Uint8Array<ArrayBuffer> {\n    if (this.#body == null) {\n      return new Uint8Array();\n    } else if (typeof this.#body === 'string') {\n      return textEncoder.encode(this.#body);\n    } else {\n      return new Uint8Array(this.#body);\n    }\n  }\n\n  json(): any {\n    return JSON.parse(this.text());\n  }\n\n  text(): string {\n    if (this.#body == null) {\n      return '';\n    } else if (typeof this.#body === 'string') {\n      return this.#body;\n    } else {\n      return textDecoder.decode(this.#body);\n    }\n  }\n}\n\nexport interface RequestOptions {\n  /** A BodyInit object or null to set request's body. */\n  body?: BodyInit | null;\n  /** A Headers object, an object literal, or an array of two-item arrays to set request's headers. */\n  headers?: HeadersInit;\n  /** A string to set request's method. */\n  method?: string;\n  /** A duration, after which the request will timeout */\n  timeout?: TimeDuration;\n  // /** A string indicating whether request follows redirects, results in an error upon encountering a redirect, or returns the redirect (in an opaque fashion). Sets request's redirect. */\n  // redirect?: RequestRedirect;\n}\n\nexport interface HttpClient {\n  fetch(url: URL | string, init?: RequestOptions): SyncResponse;\n}\n\nconst requestBaseSize = bsatnBaseSize({ types: [] }, HttpRequest.algebraicType);\n\nconst methods = new Map<string, HttpMethod>([\n  ['GET', { tag: 'Get' }],\n  ['HEAD', { tag: 'Head' }],\n  ['POST', { tag: 'Post' }],\n  ['PUT', { tag: 'Put' }],\n  ['DELETE', { tag: 'Delete' }],\n  ['CONNECT', { tag: 'Connect' }],\n  ['OPTIONS', { tag: 'Options' }],\n  ['TRACE', { tag: 'Trace' }],\n  ['PATCH', { tag: 'Patch' }],\n]);\n\nfunction fetch(url: URL | string, init: RequestOptions = {}) {\n  const method = methods.get(init.method?.toUpperCase() ?? 'GET') ?? {\n    tag: 'Extension',\n    value: init.method!,\n  };\n  const headers: HttpHeaders = {\n    // anys because the typings are wonky - see comment in SyncResponse.constructor\n    entries: headersToList(new Headers(init.headers as any) as any)\n      .flatMap(([k, v]) => (Array.isArray(v) ? v.map(v => [k, v]) : [[k, v]]))\n      .map(([name, value]) => ({ name, value: textEncoder.encode(value) })),\n  };\n  const uri = '' + url;\n  const request: HttpRequest = freeze({\n    method,\n    headers,\n    timeout: init.timeout,\n    uri,\n    version: { tag: 'Http11' } as const,\n  });\n  const requestBuf = new BinaryWriter(requestBaseSize);\n  HttpRequest.serialize(requestBuf, request);\n  const body =\n    init.body == null\n      ? new Uint8Array()\n      : typeof init.body === 'string'\n        ? init.body\n        : new Uint8Array<ArrayBuffer>(init.body as any);\n  const [responseBuf, responseBody] = sys.procedure_http_request(\n    requestBuf.getBuffer(),\n    body\n  );\n  const response = HttpResponse.deserialize(new BinaryReader(responseBuf));\n  return SyncResponse[makeResponse](responseBody, {\n    type: 'basic',\n    url: uri,\n    status: response.code,\n    statusText: status(response.code),\n    headers: new Headers(),\n    aborted: false,\n  });\n}\n\nfreeze(fetch);\n\nexport const httpClient: HttpClient = freeze({ fetch });\n","/**\n * A class representing a range with optional lower and upper bounds.\n * This class is used to specify ranges for index scans in SpacetimeDB.\n *\n * The range can be defined with inclusive or exclusive bounds, or can be unbounded on either side.\n * @template T - The type of the values in the range.\n * @example\n * ```typescript\n * // Create a range from 10 (inclusive) to 20 (exclusive)\n * const range = new Range(\n *   { tag: 'included', value: 10 },\n *   { tag: 'excluded', value: 20 }\n * );\n * // Create an unbounded range\n * const unboundedRange = new Range();\n * ```\n */\nexport class Range<T> {\n  #from: Bound<T>;\n  #to: Bound<T>;\n  public constructor(from?: Bound<T> | null, to?: Bound<T> | null) {\n    this.#from = from ?? { tag: 'unbounded' };\n    this.#to = to ?? { tag: 'unbounded' };\n  }\n\n  public get from(): Bound<T> {\n    return this.#from;\n  }\n  public get to(): Bound<T> {\n    return this.#to;\n  }\n}\n\n/**\n * A type representing a bound in a range, which can be inclusive, exclusive, or unbounded.\n * - `included`: The bound is inclusive, meaning the value is part of the range.\n * - `excluded`: The bound is exclusive, meaning the value is not part of the range.\n * - `unbounded`: The bound is unbounded, meaning there is no limit in that direction.\n * @template T - The type of the value for the bound.\n * @example\n * ```typescript\n * // Inclusive bound\n * const inclusiveBound: Bound<number> = { tag: 'included', value: 10 };\n * // Exclusive bound\n * const exclusiveBound: Bound<number> = { tag: 'excluded', value: 20 };\n * // Unbounded bound\n * const unbounded: Bound<number> = { tag: 'unbounded' };\n * ```\n */\nexport type Bound<T> =\n  | { tag: 'included'; value: T }\n  | { tag: 'excluded'; value: T }\n  | { tag: 'unbounded' };\n","import type { ProcedureExport, ReducerExport, t } from '../server';\nimport type { errors } from '../server/errors';\nimport {\n  ExplicitNameEntry,\n  RawColumnDefaultValueV10,\n  RawConstraintDefV10,\n  RawIndexAlgorithm,\n  RawIndexDefV10,\n  RawSequenceDefV10,\n  RawTableDefV10,\n} from './autogen/types';\nimport BinaryWriter from './binary_writer';\nimport type { AllUnique, ConstraintOpts } from './constraints';\nimport type {\n  ColumnIndex,\n  IndexColumns,\n  Indexes,\n  IndexOpts,\n  ReadonlyIndexes,\n} from './indexes';\nimport ScheduleAt from './schedule_at';\nimport type { TableSchema } from './table_schema';\nimport {\n  RowBuilder,\n  type ColumnBuilder,\n  type ColumnMetadata,\n  type InferTypeOfRow,\n  type RowObj,\n  type TypeBuilder,\n} from './type_builders';\nimport type {\n  InvalidColumnMetadata,\n  Prettify,\n  ValidateColumnMetadata,\n} from './type_util';\nimport { toPascalCase } from './util';\n\nexport type AlgebraicTypeRef = number;\ntype ColId = number;\ntype ColList = ColId[];\n\n/**\n * Check if any column in the row has invalid metadata.\n */\ntype HasInvalidColumn<Row extends RowObj> =\n  // this checks if Row exactly equals RowObj - if it does, we can't\n  // do type-system-level checking, so just let it pass\n  (<G>() => G extends Row ? 1 : 2) extends <G>() => G extends RowObj ? 1 : 2\n    ? false\n    : {\n          [K in keyof Row]: Row[K] extends ColumnBuilder<any, any, infer M>\n            ? ValidateColumnMetadata<M> extends InvalidColumnMetadata<any>\n              ? true\n              : false\n            : false;\n        }[keyof Row] extends false\n      ? false\n      : true;\n\n/**\n * Extract the names of columns that have invalid metadata.\n */\ntype InvalidColumnNames<Row extends RowObj> = {\n  [K in keyof Row]: Row[K] extends ColumnBuilder<any, any, infer M>\n    ? ValidateColumnMetadata<M> extends InvalidColumnMetadata<any>\n      ? K & string\n      : never\n    : never;\n}[keyof Row];\n\n/**\n * A descriptive error type that surfaces the validation error.\n * The type name itself contains the error message for better CLI output.\n */\ntype ERROR_default_cannot_be_combined_with_primaryKey_unique_or_autoInc<\n  InvalidColumns extends string,\n> = {\n  _invalidColumns: InvalidColumns;\n  _fix: 'Remove either default() or the constraint (primaryKey/unique/autoInc) from these columns';\n};\n\n/**\n * A helper type to extract the row type from a TableDef\n */\nexport type RowType<TableDef extends Pick<UntypedTableDef, 'columns'>> =\n  InferTypeOfRow<TableDef['columns']>;\n\n/**\n * Coerces a column which may be a TypeBuilder or ColumnBuilder into a ColumnBuilder\n */\nexport type CoerceColumn<\n  Col extends TypeBuilder<any, any> | ColumnBuilder<any, any, any>,\n> =\n  Col extends TypeBuilder<infer T, infer U>\n    ? ColumnBuilder<T, U, ColumnMetadata<any>>\n    : Col;\n\n/**\n * Coerces a RowObj where TypeBuilders are replaced with ColumnBuilders\n */\nexport type CoerceRow<Row extends RowObj> = {\n  [k in keyof Row & string]: CoerceColumn<Row[k]>;\n};\n\n/**\n * Helper type to coerce an array of IndexOpts\n */\ntype CoerceArray<X extends IndexOpts<any>[]> = X;\n\n/**\n * An untyped representation of a table's schema.\n */\nexport type UntypedTableDef = {\n  sourceName: string;\n  accessorName: string;\n  columns: Record<string, ColumnBuilder<any, any, ColumnMetadata<any>>>;\n  // This is really just a ProductType where all the elements have names.\n  rowType: RowBuilder<RowObj>['algebraicType']['value'];\n  indexes: readonly IndexOpts<any>[];\n  constraints: readonly ConstraintOpts<any>[];\n  tableDef: RawTableDefV10;\n  isEvent?: boolean;\n};\n\n/**\n * A type representing the indexes defined on a table.\n */\nexport type TableIndexes<TableDef extends UntypedTableDef> = {\n  [K in keyof TableDef['columns'] & string as ColumnIndex<\n    K,\n    TableDef['columns'][K]['columnMetadata']\n  > extends never\n    ? never\n    : K]: ColumnIndex<K, TableDef['columns'][K]['columnMetadata']>;\n} & {\n  [I in TableDef['indexes'][number] as I['accessor'] & {}]: TableIndexFromDef<\n    TableDef,\n    I\n  >;\n};\n\ntype TableIndexFromDef<\n  TableDef extends UntypedTableDef,\n  I extends IndexOpts<keyof TableDef['columns'] & string>,\n> =\n  NormalizeIndexColumns<TableDef, I> extends infer Cols extends ReadonlyArray<\n    keyof TableDef['columns'] & string\n  >\n    ? {\n        name: I['accessor'];\n        unique: AllUnique<TableDef, Cols>;\n        algorithm: Lowercase<I['algorithm']>;\n        columns: Cols;\n      }\n    : never;\n\ntype NormalizeIndexColumns<\n  TableDef extends UntypedTableDef,\n  I extends IndexOpts<keyof TableDef['columns'] & string>,\n> =\n  IndexColumns<I> extends ReadonlyArray<keyof TableDef['columns'] & string>\n    ? IndexColumns<I>\n    : never;\n\n/**\n * Options for configuring a database table.\n * - `name`: The name of the table.\n * - `public`: Whether the table is publicly accessible. Defaults to `false`.\n * - `indexes`: An array of index configurations for the table.\n * - `constraints`: An array of constraint configurations for the table.\n * - `scheduled`: The name of the reducer to be executed based on the scheduled rows in this table.\n */\nexport type TableOpts<Row extends RowObj> = {\n  name?: string;\n  public?: boolean;\n  indexes?: IndexOpts<keyof Row & string>[]; // declarative multicolumn indexes\n  constraints?: ConstraintOpts<keyof Row & string>[];\n  scheduled?: () =>\n    | ReducerExport<any, { [k: string]: RowBuilder<RowObj> }>\n    | ProcedureExport<\n        any,\n        { [k: string]: RowBuilder<RowObj> },\n        ReturnType<typeof t.unit>\n      >;\n  event?: boolean;\n};\n\n/**\n * Extracts the indices from TableOpts, defaulting to an empty array if none are provided.\n */\ntype OptsIndices<Opts extends TableOpts<any>> = Opts extends {\n  indexes: infer Ixs extends NonNullable<any[]>;\n}\n  ? Ixs\n  : CoerceArray<[]>;\n\n/**\n * Extracts the constraints from TableOpts, defaulting to an empty array if none are provided.\n */\ntype OptsConstraints<Opts extends TableOpts<any>> = Opts extends {\n  constraints: infer Constraints extends NonNullable<any[]>;\n}\n  ? Constraints\n  : CoerceArray<[]>;\n\n/**\n * Table<Row, UniqueConstraintViolation = never, AutoIncOverflow = never>\n *\n * - Row: row shape\n * - UCV: unique-constraint violation error type (never if none)\n * - AIO: auto-increment overflow error type (never if none)\n */\nexport type Table<TableDef extends UntypedTableDef> = Prettify<\n  TableMethods<TableDef> & Indexes<TableDef, TableIndexes<TableDef>>\n>;\n\nexport type ReadonlyTable<TableDef extends UntypedTableDef> = Prettify<\n  ReadonlyTableMethods<TableDef> &\n    ReadonlyIndexes<TableDef, TableIndexes<TableDef>>\n>;\n\nexport interface ReadonlyTableMethods<TableDef extends UntypedTableDef> {\n  /** Returns the number of rows in the TX state. */\n  count(): bigint;\n\n  /** Iterate over all rows in the TX state. Rust Iterator<Item=Row>  TS IterableIterator<Row>. */\n  iter(): IteratorObject<Prettify<RowType<TableDef>>, undefined>;\n  [Symbol.iterator](): IteratorObject<Prettify<RowType<TableDef>>, undefined>;\n}\n\n/**\n * A type representing the methods available on a table.\n */\nexport interface TableMethods<TableDef extends UntypedTableDef>\n  extends ReadonlyTableMethods<TableDef> {\n  /**\n   * Insert and return the inserted row (auto-increment fields filled).\n   *\n   * May throw on error:\n   * * If there are any unique or primary key columns in this table, may throw {@link errors.UniqueAlreadyExists}.\n   * * If there are any auto-incrementing columns in this table, may throw {@link errors.AutoIncOverflow}.\n   * */\n  insert(row: Prettify<RowType<TableDef>>): Prettify<RowType<TableDef>>;\n\n  /** Delete a row equal to `row`. Returns true if something was deleted. */\n  delete(row: Prettify<RowType<TableDef>>): boolean;\n}\n\n/**\n * Defines a database table with schema and options.\n *\n * @param opts - Table configuration including name, indexes, and access control\n * @param row - Product type defining the table's row structure\n * @returns Table handle for use in schema() function\n *\n * @example\n * ```ts\n * const playerTable = table(\n *   { name: 'player', public: true },\n *   {\n *     id: t.u32().primaryKey(),\n *     name: t.string().index('btree')\n *   }\n * );\n * ```\n *\n * ## Column Validation Error\n *\n * **If you see an error like \"Expected 3 arguments, but got 2\"**, this means\n * one of your columns has an invalid combination of attributes.\n *\n * Specifically, `default()` cannot be combined with:\n * - `primaryKey()`\n * - `unique()`\n * - `autoInc()`\n *\n * **Example of invalid code:**\n * ```ts\n * // ERROR: default() + primaryKey() is not allowed\n * const badTable = table(\n *   { name: 'bad' },\n *   { id: t.u64().default(0n).primaryKey() }  // <- This causes \"Expected 3 arguments\"\n * );\n * ```\n *\n * **How to fix:** Remove either `default()` or the constraint (`primaryKey`/`unique`/`autoInc`).\n */\nexport function table<Row extends RowObj, const Opts extends TableOpts<Row>>(\n  opts: Opts,\n  row: Row | RowBuilder<Row>,\n  //  INTERNAL: This parameter enforces compile-time validation of column metadata.\n  // It is never passed at runtime. If you see \"Expected 3 arguments, but got 2\",\n  // it means a column has an invalid combination (e.g., default + primaryKey).\n  // See the JSDoc above for details on how to fix this error.\n  ..._: HasInvalidColumn<Row> extends true\n    ? [\n        error: ERROR_default_cannot_be_combined_with_primaryKey_unique_or_autoInc<\n          InvalidColumnNames<Row>\n        >,\n      ]\n    : []\n): TableSchema<CoerceRow<Row>, OptsIndices<Opts>> {\n  const {\n    name,\n    public: isPublic = false,\n    indexes: userIndexes = [],\n    scheduled,\n    event: isEvent = false,\n  } = opts;\n\n  // 1. column catalogue + helpers\n  const colIds = new Map<keyof Row & string, ColId>();\n  const colNameList: string[] = [];\n\n  if (!(row instanceof RowBuilder)) {\n    row = new RowBuilder(row);\n  }\n\n  row.algebraicType.value.elements.forEach((elem, i) => {\n    colIds.set(elem.name, i);\n    colNameList.push(elem.name);\n  });\n\n  // gather primary keys, percolumn indexes, uniques, sequences\n  const pk: ColList = [];\n  const indexes: (RawIndexDefV10 & { canonicalName?: string })[] = [];\n  const constraints: RawConstraintDefV10[] = [];\n  const sequences: RawSequenceDefV10[] = [];\n\n  let scheduleAtCol: ColId | undefined;\n  const defaultValues: RawColumnDefaultValueV10[] = [];\n\n  for (const [name, builder] of Object.entries(row.row)) {\n    const meta: ColumnMetadata<any> = builder.columnMetadata;\n\n    if (meta.isPrimaryKey) {\n      pk.push(colIds.get(name)!);\n    }\n\n    const isUnique = meta.isUnique || meta.isPrimaryKey;\n\n    // implicit 1column indexes\n    if (meta.indexType || isUnique) {\n      const algo = meta.indexType ?? 'btree';\n      const id = colIds.get(name)!;\n      let algorithm: RawIndexAlgorithm;\n      switch (algo) {\n        case 'btree':\n          algorithm = RawIndexAlgorithm.BTree([id]);\n          break;\n        case 'hash':\n          algorithm = RawIndexAlgorithm.Hash([id]);\n          break;\n        case 'direct':\n          algorithm = RawIndexAlgorithm.Direct(id);\n          break;\n      }\n      indexes.push({\n        sourceName: undefined, // Unnamed indexes will be assigned a globally unique name\n        accessorName: name,\n        algorithm,\n      });\n    }\n\n    if (isUnique) {\n      constraints.push({\n        sourceName: undefined,\n        data: { tag: 'Unique', value: { columns: [colIds.get(name)!] } },\n      });\n    }\n\n    if (meta.isAutoIncrement) {\n      sequences.push({\n        sourceName: undefined,\n        start: undefined,\n        minValue: undefined,\n        maxValue: undefined,\n        column: colIds.get(name)!,\n        increment: 1n,\n      });\n    }\n\n    if (meta.defaultValue) {\n      const writer = new BinaryWriter(16);\n      builder.serialize(writer, meta.defaultValue);\n      defaultValues.push({\n        colId: colIds.get(name)!,\n        value: writer.getBuffer(),\n      });\n    }\n\n    // If this column is shaped like ScheduleAtAlgebraicType, mark it as the scheduleat column\n    if (scheduled) {\n      const algebraicType = builder.typeBuilder.algebraicType;\n      if (ScheduleAt.isScheduleAt(algebraicType)) {\n        scheduleAtCol = colIds.get(name)!;\n      }\n    }\n  }\n\n  // convert explicit multicolumn indexes coming from options.indexes\n  for (const indexOpts of userIndexes ?? []) {\n    let algorithm: RawIndexAlgorithm;\n    switch (indexOpts.algorithm) {\n      case 'btree':\n        algorithm = {\n          tag: 'BTree',\n          value: indexOpts.columns.map(c => colIds.get(c)!),\n        };\n        break;\n      case 'hash':\n        algorithm = {\n          tag: 'Hash',\n          value: indexOpts.columns.map(c => colIds.get(c)!),\n        };\n        break;\n      case 'direct':\n        algorithm = { tag: 'Direct', value: colIds.get(indexOpts.column)! };\n        break;\n    }\n    // unnamed indexes will be assigned a globally unique name\n    // The name users supply is actually the accessor name which will be used\n    // in TypeScript to access the index. This will be used verbatim.\n    // This is confusing because it is not the index name and there is\n    // no actual way for the user to set the actual index name.\n    // I think we should standardize: name and accessorName as the way to set\n    // the name and accessor name of an index across all SDKs.\n    indexes.push({\n      sourceName: undefined,\n      accessorName: indexOpts.accessor,\n      algorithm,\n      canonicalName: indexOpts.name,\n    });\n  }\n\n  // add explicit constraints from options.constraints\n  for (const constraintOpts of opts.constraints ?? []) {\n    if (constraintOpts.constraint === 'unique') {\n      const data: RawConstraintDefV10['data'] = {\n        tag: 'Unique',\n        value: { columns: constraintOpts.columns.map(c => colIds.get(c)!) },\n      };\n      constraints.push({ sourceName: constraintOpts.name, data });\n      continue;\n    }\n  }\n\n  const productType = row.algebraicType.value as RowBuilder<\n    CoerceRow<Row>\n  >['algebraicType']['value'];\n\n  const schedule =\n    scheduled && scheduleAtCol !== undefined\n      ? { scheduleAtCol, reducer: scheduled }\n      : undefined;\n\n  return {\n    rowType: row as RowBuilder<CoerceRow<Row>>,\n    tableName: name,\n    rowSpacetimeType: productType,\n    tableDef: (ctx, accName) => {\n      const tableName = name ?? accName;\n      if (row.typeName === undefined) {\n        row.typeName = toPascalCase(tableName);\n      }\n\n      // Build index source names using accName\n      for (const index of indexes) {\n        const cols =\n          index.algorithm.tag === 'Direct'\n            ? [index.algorithm.value]\n            : index.algorithm.value;\n\n        const colS = cols.map(i => colNameList[i]).join('_');\n        const sourceName =\n          (index.sourceName = `${accName}_${colS}_idx_${index.algorithm.tag.toLowerCase()}`);\n\n        const { canonicalName } = index;\n        if (canonicalName !== undefined) {\n          ctx.moduleDef.explicitNames.entries.push(\n            ExplicitNameEntry.Index({ sourceName, canonicalName })\n          );\n        }\n      }\n\n      return {\n        sourceName: accName,\n        productTypeRef: ctx.registerTypesRecursively(row).ref,\n        primaryKey: pk,\n        indexes,\n        constraints,\n        sequences,\n        tableType: { tag: 'User' },\n        tableAccess: { tag: isPublic ? 'Public' : 'Private' },\n        defaultValues,\n        isEvent,\n      };\n    },\n    idxs: {} as OptsIndices<Opts>,\n    constraints: constraints as OptsConstraints<Opts>,\n    schedule,\n  };\n}\n","import { ConnectionId } from './connection_id';\nimport { Identity } from './identity';\nimport type { ColumnIndex, IndexColumns, IndexOpts } from './indexes';\nimport type { UntypedSchemaDef } from './schema';\nimport type { UntypedTableSchema } from './table_schema';\nimport { Timestamp } from './timestamp';\nimport type {\n  ColumnBuilder,\n  ColumnMetadata,\n  RowBuilder,\n  TypeBuilder,\n} from './type_builders';\nimport type { Values } from './type_util';\n\n/**\n * Helper to get the set of table names.\n */\nexport type TableNames<SchemaDef extends UntypedSchemaDef> = Values<\n  SchemaDef['tables']\n>['accessorName'] &\n  string;\n\n/** helper: pick the table def object from the schema by its name */\nexport type TableDefByName<\n  SchemaDef extends UntypedSchemaDef,\n  Name extends TableNames<SchemaDef>,\n> = Extract<Values<SchemaDef['tables']>, { accessorName: Name }>;\n\n// internal only  NOT exported.\n// This is how we make sure queries are only created with our helpers.\nconst QueryBrand = Symbol('QueryBrand');\n\nexport interface TableTypedQuery<TableDef extends TypedTableDef> {\n  readonly [QueryBrand]: true;\n  readonly __table?: TableDef;\n}\n\nexport interface RowTypedQuery<Row, ST> {\n  readonly [QueryBrand]: true;\n  // Phantom type to track the row type.\n  readonly __row?: Row;\n  readonly __algebraicType?: ST;\n}\n\nexport type Query<TableDef extends TypedTableDef> = RowTypedQuery<\n  RowType<TableDef>,\n  TableDef['rowType']\n>;\n\nexport const isRowTypedQuery = (val: unknown): val is RowTypedQuery<any, any> =>\n  !!val && typeof val === 'object' && QueryBrand in (val as object);\n\nexport const isTypedQuery = (val: unknown): val is TableTypedQuery<any> =>\n  !!val && typeof val === 'object' && QueryBrand in (val as object);\n\nexport function toSql(q: Query<any>): string {\n  return (q as unknown as { toSql(): string }).toSql();\n}\n\n// A query builder with a single table.\ntype From<TableDef extends TypedTableDef> = RowTypedQuery<\n  RowType<TableDef>,\n  TableDef['rowType']\n> &\n  Readonly<{\n    toSql(): string;\n    where(\n      predicate: (row: RowExpr<TableDef>) => BooleanExpr<TableDef>\n    ): From<TableDef>;\n    rightSemijoin<RightTable extends TypedTableDef>(\n      other: TableRef<RightTable>,\n      on: (\n        left: IndexedRowExpr<TableDef>,\n        right: IndexedRowExpr<RightTable>\n      ) => BooleanExpr<TableDef | RightTable>\n    ): SemijoinBuilder<RightTable>;\n    leftSemijoin<RightTable extends TypedTableDef>(\n      other: TableRef<RightTable>,\n      on: (\n        left: IndexedRowExpr<TableDef>,\n        right: IndexedRowExpr<RightTable>\n      ) => BooleanExpr<TableDef | RightTable>\n    ): SemijoinBuilder<TableDef>;\n    /** @deprecated No longer needed  builder is already a valid query. */\n    build(): Query<TableDef>;\n  }>;\n\n// A query builder with a semijoin.\ntype SemijoinBuilder<TableDef extends TypedTableDef> = RowTypedQuery<\n  RowType<TableDef>,\n  TableDef['rowType']\n> &\n  Readonly<{\n    toSql(): string;\n    where(\n      predicate: (row: RowExpr<TableDef>) => BooleanExpr<TableDef>\n    ): SemijoinBuilder<TableDef>;\n    /** @deprecated No longer needed  builder is already a valid query. */\n    build(): Query<TableDef>;\n  }>;\n\nclass SemijoinImpl<TableDef extends TypedTableDef>\n  implements SemijoinBuilder<TableDef>, TableTypedQuery<TableDef>\n{\n  readonly [QueryBrand] = true;\n  readonly type = 'semijoin' as const;\n  constructor(\n    readonly sourceQuery: FromBuilder<TableDef>,\n    readonly filterQuery: FromBuilder<any>,\n    readonly joinCondition: BooleanExpr<any>\n  ) {\n    if (sourceQuery.table.sourceName === filterQuery.table.sourceName) {\n      // TODO: Handle aliasing properly instead of just forbidding it.\n      throw new Error('Cannot semijoin a table to itself');\n    }\n  }\n\n  build(): Query<TableDef> {\n    return this as Query<TableDef>;\n  }\n\n  where(\n    predicate: (row: RowExpr<TableDef>) => BooleanExpr<TableDef>\n  ): SemijoinImpl<TableDef> {\n    const nextSourceQuery = this.sourceQuery.where(predicate);\n    return new SemijoinImpl<TableDef>(\n      nextSourceQuery,\n      this.filterQuery,\n      this.joinCondition\n    );\n  }\n\n  toSql(): string {\n    const left = this.filterQuery;\n    const right = this.sourceQuery;\n    const leftTable = quoteIdentifier(left.table.sourceName);\n    const rightTable = quoteIdentifier(right.table.sourceName);\n    let sql = `SELECT ${rightTable}.* FROM ${leftTable} JOIN ${rightTable} ON ${booleanExprToSql(this.joinCondition)}`;\n\n    const clauses: string[] = [];\n    if (left.whereClause) {\n      clauses.push(booleanExprToSql(left.whereClause));\n    }\n    if (right.whereClause) {\n      clauses.push(booleanExprToSql(right.whereClause));\n    }\n\n    if (clauses.length > 0) {\n      const whereSql =\n        clauses.length === 1\n          ? clauses[0]\n          : clauses.map(wrapInParens).join(' AND ');\n      sql += ` WHERE ${whereSql}`;\n    }\n\n    return sql;\n  }\n}\n\nclass FromBuilder<TableDef extends TypedTableDef>\n  implements From<TableDef>, TableTypedQuery<TableDef>\n{\n  readonly [QueryBrand] = true;\n  constructor(\n    readonly table: TableRef<TableDef>,\n    readonly whereClause?: BooleanExpr<TableDef>\n  ) {}\n\n  where(\n    predicate: (row: RowExpr<TableDef>) => BooleanExpr<TableDef>\n  ): FromBuilder<TableDef> {\n    const newCondition = predicate(this.table.cols);\n    const nextWhere = this.whereClause\n      ? this.whereClause.and(newCondition)\n      : newCondition;\n    return new FromBuilder<TableDef>(this.table, nextWhere);\n  }\n\n  rightSemijoin<OtherTable extends TypedTableDef>(\n    right: TableRef<OtherTable>,\n    on: (\n      left: IndexedRowExpr<TableDef>,\n      right: IndexedRowExpr<OtherTable>\n    ) => BooleanExpr<TableDef | OtherTable>\n  ): SemijoinBuilder<OtherTable> {\n    const sourceQuery = new FromBuilder(right);\n    const joinCondition = on(\n      this.table.indexedCols,\n      right.indexedCols\n    ) as BooleanExpr<any>;\n    return new SemijoinImpl<OtherTable>(sourceQuery, this, joinCondition);\n  }\n\n  leftSemijoin<OtherTable extends TypedTableDef>(\n    right: TableRef<OtherTable>,\n    on: (\n      left: IndexedRowExpr<TableDef>,\n      right: IndexedRowExpr<OtherTable>\n    ) => BooleanExpr<TableDef | OtherTable>\n  ): SemijoinBuilder<TableDef> {\n    const filterQuery = new FromBuilder(right);\n    const joinCondition = on(\n      this.table.indexedCols,\n      right.indexedCols\n    ) as BooleanExpr<any>;\n    return new SemijoinImpl<TableDef>(this, filterQuery, joinCondition);\n  }\n\n  toSql(): string {\n    return renderSelectSqlWithJoins(this.table, this.whereClause);\n  }\n\n  build(): Query<TableDef> {\n    return this as Query<TableDef>;\n  }\n}\n\nexport type QueryBuilder<SchemaDef extends UntypedSchemaDef> = {\n  readonly [Tbl in Values<\n    SchemaDef['tables']\n  > as Tbl['accessorName']]: TableRef<Tbl> & From<Tbl>;\n} & {};\n\n/**\n * A runtime reference to a table. This materializes the RowExpr for us.\n * TODO: Maybe add the full SchemaDef to the type signature depending on how joins will work.\n */\nexport type TableRef<TableDef extends TypedTableDef> = Readonly<{\n  type: 'table';\n  sourceName: TableDef['sourceName'];\n  accessorName: string;\n  cols: RowExpr<TableDef>;\n  indexedCols: IndexedRowExpr<TableDef>;\n  tableDef: TableDef;\n  // Delegated UntypedTableDef properties for compatibility.\n  columns: TableDef['columns'];\n  indexes: TableDef['indexes'];\n  rowType: TableDef['rowType'];\n  constraints: any;\n}>;\n\nclass TableRefImpl<TableDef extends TypedTableDef>\n  implements TableRef<TableDef>, From<TableDef>\n{\n  readonly [QueryBrand] = true;\n  readonly type = 'table' as const;\n  sourceName: string;\n  accessorName: string;\n  cols: RowExpr<TableDef>;\n  indexedCols: IndexedRowExpr<TableDef>;\n  tableDef: TableDef;\n  // Delegate UntypedTableDef properties from tableDef so this can be used as a table def.\n  get columns() {\n    return this.tableDef.columns;\n  }\n  get indexes() {\n    return this.tableDef.indexes;\n  }\n  get rowType() {\n    return this.tableDef.rowType;\n  }\n  get constraints() {\n    return (this.tableDef as any).constraints;\n  }\n  constructor(tableDef: TableDef) {\n    this.sourceName = tableDef.sourceName;\n    this.accessorName = tableDef.accessorName;\n    this.cols = createRowExpr(tableDef);\n    // this.indexedCols = createIndexedRowExpr(tableDef, this.cols);\n    // TODO: we could create an indexedRowExpr to avoid having the extra columns.\n    // Right now, the objects we pass will actually have all the columns, but the\n    // type system will consider it an error.\n    this.indexedCols = this.cols;\n    this.tableDef = tableDef;\n    Object.freeze(this);\n  }\n\n  asFrom(): FromBuilder<TableDef> {\n    return new FromBuilder<TableDef>(this);\n  }\n\n  rightSemijoin<RightTable extends TypedTableDef>(\n    other: TableRef<RightTable>,\n    on: (\n      left: IndexedRowExpr<TableDef>,\n      right: IndexedRowExpr<RightTable>\n    ) => EqExpr<TableDef | RightTable>\n  ): SemijoinBuilder<RightTable> {\n    return this.asFrom().rightSemijoin(other, on);\n  }\n\n  leftSemijoin<RightTable extends TypedTableDef>(\n    other: TableRef<RightTable>,\n    on: (\n      left: IndexedRowExpr<TableDef>,\n      right: IndexedRowExpr<RightTable>\n    ) => EqExpr<TableDef | RightTable>\n  ): SemijoinBuilder<TableDef> {\n    return this.asFrom().leftSemijoin(other, on);\n  }\n\n  build(): Query<TableDef> {\n    return this.asFrom().build();\n  }\n\n  toSql(): string {\n    return this.asFrom().toSql();\n  }\n\n  where(\n    predicate: (row: RowExpr<TableDef>) => BooleanExpr<TableDef>\n  ): FromBuilder<TableDef> {\n    return this.asFrom().where(predicate);\n  }\n}\n\nexport function createTableRefFromDef<TableDef extends TypedTableDef>(\n  tableDef: TableDef\n): TableRef<TableDef> {\n  return new TableRefImpl<TableDef>(tableDef);\n}\n\nexport function makeQueryBuilder<SchemaDef extends UntypedSchemaDef>(\n  schema: SchemaDef\n): QueryBuilder<SchemaDef> {\n  const qb = Object.create(null) as QueryBuilder<SchemaDef>;\n  for (const table of Object.values(schema.tables)) {\n    const ref = createTableRefFromDef(\n      table as TableDefByName<SchemaDef, TableNames<SchemaDef>>\n    );\n    (qb as Record<string, TableRef<any>>)[table.accessorName] = ref;\n  }\n  return Object.freeze(qb) as QueryBuilder<SchemaDef>;\n}\n\nfunction createRowExpr<TableDef extends TypedTableDef>(\n  tableDef: TableDef\n): RowExpr<TableDef> {\n  const row: Record<string, ColumnExpr<TableDef, any>> = {};\n  for (const columnName of Object.keys(tableDef.columns) as Array<\n    keyof TableDef['columns'] & string\n  >) {\n    const columnBuilder = tableDef.columns[columnName];\n    const column = new ColumnExpression<TableDef, typeof columnName>(\n      tableDef.sourceName,\n      columnName,\n      columnBuilder.typeBuilder.algebraicType as InferSpacetimeTypeOfColumn<\n        TableDef,\n        typeof columnName\n      >\n    );\n    row[columnName] = Object.freeze(column);\n  }\n  return Object.freeze(row) as RowExpr<TableDef>;\n}\n\nfunction renderSelectSqlWithJoins<Table extends TypedTableDef>(\n  table: TableRef<Table>,\n  where?: BooleanExpr<Table>,\n  extraClauses: readonly string[] = []\n): string {\n  const quotedTable = quoteIdentifier(table.sourceName);\n  const sql = `SELECT * FROM ${quotedTable}`;\n  const clauses: string[] = [];\n  if (where) clauses.push(booleanExprToSql(where));\n  clauses.push(...extraClauses);\n  if (clauses.length === 0) return sql;\n  const whereSql =\n    clauses.length === 1 ? clauses[0] : clauses.map(wrapInParens).join(' AND ');\n  return `${sql} WHERE ${whereSql}`;\n}\n\n// TODO: Just use UntypedTableDef if they end up being the same.\nexport type TypedTableDef<\n  Columns extends Record<\n    string,\n    ColumnBuilder<any, any, ColumnMetadata<any>>\n  > = Record<string, ColumnBuilder<any, any, ColumnMetadata<any>>>,\n> = {\n  sourceName: string;\n  accessorName: string;\n  columns: Columns;\n  indexes: readonly IndexOpts<any>[];\n  rowType: RowBuilder<Columns>['algebraicType']['value'];\n};\n\nexport type TableSchemaAsTableDef<TSchema extends UntypedTableSchema> = {\n  name: TSchema['tableName'];\n  columns: TSchema['rowType']['row'];\n  indexes: TSchema['idxs'];\n};\n\ntype RowType<TableDef extends TypedTableDef> = {\n  [K in keyof TableDef['columns']]: TableDef['columns'][K] extends ColumnBuilder<\n    infer T,\n    any,\n    any\n  >\n    ? T\n    : never;\n};\n\n// TODO: Consider making a smaller version of these types that doesn't expose the internals.\n// Restricting it later should not break anyone in practice.\nexport type ColumnExpr<\n  TableDef extends TypedTableDef,\n  ColumnName extends ColumnNames<TableDef>,\n> = ColumnExpression<TableDef, ColumnName>;\n\ntype ColumnSpacetimeType<Col extends ColumnExpr<any, any>> =\n  Col extends ColumnExpr<infer T, infer N>\n    ? InferSpacetimeTypeOfColumn<T, N>\n    : never;\n\n// TODO: This checks that they match, but we also need to make sure that they are comparable types,\n// since you can use product types at all.\ntype ColumnSameSpacetime<\n  ThisTable extends TypedTableDef,\n  ThisCol extends ColumnNames<ThisTable>,\n  OtherCol extends ColumnExpr<any, any>,\n> = [InferSpacetimeTypeOfColumn<ThisTable, ThisCol>] extends [\n  ColumnSpacetimeType<OtherCol>,\n]\n  ? [ColumnSpacetimeType<OtherCol>] extends [\n      InferSpacetimeTypeOfColumn<ThisTable, ThisCol>,\n    ]\n    ? OtherCol\n    : never\n  : never;\n\n// Helper to get the table back from a column.\ntype ExtractTable<Col extends ColumnExpr<any, any>> =\n  Col extends ColumnExpr<infer T, any> ? T : never;\n\nexport class ColumnExpression<\n  TableDef extends TypedTableDef,\n  ColumnName extends ColumnNames<TableDef>,\n> {\n  readonly type = 'column' as const;\n  readonly column: ColumnName;\n  readonly table: TableDef['sourceName'];\n  // phantom: actual runtime value is undefined\n  readonly tsValueType?: RowType<TableDef>[ColumnName];\n  readonly spacetimeType: InferSpacetimeTypeOfColumn<TableDef, ColumnName>;\n\n  constructor(\n    table: TableDef['sourceName'],\n    column: ColumnName,\n    spacetimeType: InferSpacetimeTypeOfColumn<TableDef, ColumnName>\n  ) {\n    this.table = table;\n    this.column = column;\n    this.spacetimeType = spacetimeType;\n  }\n\n  eq(\n    literal: LiteralValue & RowType<TableDef>[ColumnName]\n  ): BooleanExpr<TableDef>;\n  eq<OtherCol extends ColumnExpr<any, any>>(\n    value: ColumnSameSpacetime<TableDef, ColumnName, OtherCol>\n  ): BooleanExpr<TableDef | ExtractTable<OtherCol>>;\n\n  eq(x: any): any {\n    return new BooleanExpr({\n      type: 'eq',\n      left: this as unknown as ValueExpr<TableDef, any>,\n      right: normalizeValue(x) as ValueExpr<TableDef, any>,\n    });\n  }\n\n  ne(\n    literal: LiteralValue & RowType<TableDef>[ColumnName]\n  ): BooleanExpr<TableDef>;\n  ne<OtherCol extends ColumnExpr<any, any>>(\n    value: ColumnSameSpacetime<TableDef, ColumnName, OtherCol>\n  ): BooleanExpr<TableDef | ExtractTable<OtherCol>>;\n\n  ne(x: any): any {\n    return new BooleanExpr({\n      type: 'ne',\n      left: this as unknown as ValueExpr<TableDef, any>,\n      right: normalizeValue(x) as ValueExpr<TableDef, any>,\n    });\n  }\n\n  lt(\n    literal: LiteralValue & RowType<TableDef>[ColumnName]\n  ): BooleanExpr<TableDef>;\n  lt<OtherCol extends ColumnExpr<any, any>>(\n    value: ColumnSameSpacetime<TableDef, ColumnName, OtherCol>\n  ): BooleanExpr<TableDef | ExtractTable<OtherCol>>;\n\n  lt(x: any): any {\n    return new BooleanExpr({\n      type: 'lt',\n      left: this as unknown as ValueExpr<TableDef, any>,\n      right: normalizeValue(x) as ValueExpr<TableDef, any>,\n    });\n  }\n\n  lte(\n    literal: LiteralValue & RowType<TableDef>[ColumnName]\n  ): BooleanExpr<TableDef>;\n  lte<OtherCol extends ColumnExpr<any, any>>(\n    value: ColumnSameSpacetime<TableDef, ColumnName, OtherCol>\n  ): BooleanExpr<TableDef | ExtractTable<OtherCol>>;\n\n  lte(x: any): any {\n    return new BooleanExpr({\n      type: 'lte',\n      left: this as unknown as ValueExpr<TableDef, any>,\n      right: normalizeValue(x) as ValueExpr<TableDef, any>,\n    });\n  }\n\n  gt(\n    literal: LiteralValue & RowType<TableDef>[ColumnName]\n  ): BooleanExpr<TableDef>;\n  gt<OtherCol extends ColumnExpr<any, any>>(\n    value: ColumnSameSpacetime<TableDef, ColumnName, OtherCol>\n  ): BooleanExpr<TableDef | ExtractTable<OtherCol>>;\n\n  gt(x: any): any {\n    return new BooleanExpr({\n      type: 'gt',\n      left: this as unknown as ValueExpr<TableDef, any>,\n      right: normalizeValue(x) as ValueExpr<TableDef, any>,\n    });\n  }\n\n  gte(\n    literal: LiteralValue & RowType<TableDef>[ColumnName]\n  ): BooleanExpr<TableDef>;\n  gte<OtherCol extends ColumnExpr<any, any>>(\n    value: ColumnSameSpacetime<TableDef, ColumnName, OtherCol>\n  ): BooleanExpr<TableDef | ExtractTable<OtherCol>>;\n\n  gte(x: any): any {\n    return new BooleanExpr({\n      type: 'gte',\n      left: this as unknown as ValueExpr<TableDef, any>,\n      right: normalizeValue(x) as ValueExpr<TableDef, any>,\n    });\n  }\n}\n\n/**\n * Helper to get the spacetime type of a column.\n */\ntype InferSpacetimeTypeOfColumn<\n  TableDef extends TypedTableDef,\n  ColumnName extends ColumnNames<TableDef>,\n> =\n  TableDef['columns'][ColumnName]['typeBuilder'] extends TypeBuilder<\n    any,\n    infer U\n  >\n    ? U\n    : never;\n\ntype ColumnNames<TableDef extends TypedTableDef> = keyof RowType<TableDef> &\n  string;\n\n// For composite indexes, we only consider it as an index over the first column in the index.\ntype FirstIndexColumn<I extends IndexOpts<any>> =\n  IndexColumns<I> extends readonly [infer Head extends string, ...infer _Rest]\n    ? Head\n    : never;\n\n// Columns that are indexed by something in the indexes: [...] part.\ntype ExplicitIndexedColumns<TableDef extends TypedTableDef> =\n  TableDef['indexes'][number] extends infer I\n    ? I extends IndexOpts<ColumnNames<TableDef>>\n      ? FirstIndexColumn<I> & ColumnNames<TableDef>\n      : never\n    : never;\n\n// Columns with an index defined on the column definition.\ntype MetadataIndexedColumns<TableDef extends TypedTableDef> = {\n  [K in ColumnNames<TableDef>]: ColumnIndex<\n    K,\n    TableDef['columns'][K]['columnMetadata']\n  > extends never\n    ? never\n    : K;\n}[ColumnNames<TableDef>];\n\nexport type IndexedColumnNames<TableDef extends TypedTableDef> =\n  | ExplicitIndexedColumns<TableDef>\n  | MetadataIndexedColumns<TableDef>;\n\nexport type IndexedRowExpr<TableDef extends TypedTableDef> = Readonly<{\n  readonly [C in IndexedColumnNames<TableDef>]: ColumnExpr<TableDef, C>;\n}>;\n\n/**\n * Acts as a row when writing filters for queries. It is a way to get column references.\n */\nexport type RowExpr<TableDef extends TypedTableDef> = Readonly<{\n  readonly [C in ColumnNames<TableDef>]: ColumnExpr<TableDef, C>;\n}>;\n\n/**\n * Union of ColumnExprs from Table whose spacetimeType is compatible with Value\n * (produces a union of ColumnExpr<Table, C> for matching columns).\n */\nexport type ColumnExprForValue<Table extends TypedTableDef, Value> = {\n  [C in ColumnNames<Table>]: InferSpacetimeTypeOfColumn<Table, C> extends Value\n    ? ColumnExpr<Table, C>\n    : never;\n}[ColumnNames<Table>];\n\ntype LiteralValue =\n  | string\n  | number\n  | bigint\n  | boolean\n  | Identity\n  | Timestamp\n  | ConnectionId;\n\ntype ValueLike = LiteralValue | ColumnExpr<any, any> | LiteralExpr<any>;\ntype ValueInput<TableDef extends TypedTableDef> =\n  | ValueLike\n  | ValueExpr<TableDef, any>;\n\nexport type ValueExpr<TableDef extends TypedTableDef, Value> =\n  | LiteralExpr<Value & LiteralValue>\n  | ColumnExprForValue<TableDef, Value>;\n\ntype LiteralExpr<Value> = {\n  type: 'literal';\n  value: Value;\n};\n\nexport function literal<Value extends LiteralValue>(\n  value: Value\n): ValueExpr<never, Value> {\n  return { type: 'literal', value };\n}\n\n// This is here to take literal values and wrap them in an AST node.\nfunction normalizeValue(val: ValueInput<any>): ValueExpr<any, any> {\n  if ((val as LiteralExpr<any>).type === 'literal')\n    return val as LiteralExpr<any>;\n  if (\n    typeof val === 'object' &&\n    val != null &&\n    'type' in (val as any) &&\n    (val as any).type === 'column'\n  ) {\n    return val as ColumnExpr<any, any>;\n  }\n  return literal(val as LiteralValue);\n}\n\ntype EqExpr<Table extends TypedTableDef = any> = BooleanExpr<Table>;\n\ntype BooleanExprData<Table extends TypedTableDef> = (\n  | {\n      type: 'eq' | 'ne' | 'gt' | 'lt' | 'gte' | 'lte';\n      left: ValueExpr<Table, any>;\n      right: ValueExpr<Table, any>;\n    }\n  | {\n      type: 'and';\n      clauses: readonly [\n        BooleanExprData<Table>,\n        BooleanExprData<Table>,\n        ...BooleanExprData<Table>[],\n      ];\n    }\n  | {\n      type: 'or';\n      clauses: readonly [\n        BooleanExprData<Table>,\n        BooleanExprData<Table>,\n        ...BooleanExprData<Table>[],\n      ];\n    }\n  | {\n      type: 'not';\n      clause: BooleanExprData<Table>;\n    }\n) & {\n  _tableType?: Table;\n};\n\nexport class BooleanExpr<Table extends TypedTableDef> {\n  constructor(readonly data: BooleanExprData<Table>) {}\n\n  and(other: BooleanExpr<Table>): BooleanExpr<Table> {\n    return new BooleanExpr({ type: 'and', clauses: [this.data, other.data] });\n  }\n\n  or(other: BooleanExpr<Table>): BooleanExpr<Table> {\n    return new BooleanExpr({ type: 'or', clauses: [this.data, other.data] });\n  }\n\n  not(): BooleanExpr<Table> {\n    return new BooleanExpr({ type: 'not', clause: this.data });\n  }\n}\n\nexport function not<T extends TypedTableDef>(\n  clause: BooleanExpr<T>\n): BooleanExpr<T> {\n  return new BooleanExpr({ type: 'not', clause: clause.data });\n}\n\nexport function and<T extends TypedTableDef>(\n  ...clauses: readonly [BooleanExpr<T>, BooleanExpr<T>, ...BooleanExpr<T>[]]\n): BooleanExpr<T> {\n  return new BooleanExpr({\n    type: 'and',\n    clauses: clauses.map(c => c.data) as [\n      BooleanExprData<T>,\n      BooleanExprData<T>,\n      ...BooleanExprData<T>[],\n    ],\n  });\n}\n\nexport function or<T extends TypedTableDef>(\n  ...clauses: readonly [BooleanExpr<T>, BooleanExpr<T>, ...BooleanExpr<T>[]]\n): BooleanExpr<T> {\n  return new BooleanExpr({\n    type: 'or',\n    clauses: clauses.map(c => c.data) as [\n      BooleanExprData<T>,\n      BooleanExprData<T>,\n      ...BooleanExprData<T>[],\n    ],\n  });\n}\n\nfunction booleanExprToSql<Table extends TypedTableDef>(\n  expr: BooleanExpr<Table> | BooleanExprData<Table>,\n  tableAlias?: string\n): string {\n  const data = expr instanceof BooleanExpr ? expr.data : expr;\n  switch (data.type) {\n    case 'eq':\n      return `${valueExprToSql(data.left, tableAlias)} = ${valueExprToSql(data.right, tableAlias)}`;\n    case 'ne':\n      return `${valueExprToSql(data.left, tableAlias)} <> ${valueExprToSql(data.right, tableAlias)}`;\n    case 'gt':\n      return `${valueExprToSql(data.left, tableAlias)} > ${valueExprToSql(data.right, tableAlias)}`;\n    case 'gte':\n      return `${valueExprToSql(data.left, tableAlias)} >= ${valueExprToSql(data.right, tableAlias)}`;\n    case 'lt':\n      return `${valueExprToSql(data.left, tableAlias)} < ${valueExprToSql(data.right, tableAlias)}`;\n    case 'lte':\n      return `${valueExprToSql(data.left, tableAlias)} <= ${valueExprToSql(data.right, tableAlias)}`;\n    case 'and':\n      return data.clauses\n        .map(c => booleanExprToSql(c, tableAlias))\n        .map(wrapInParens)\n        .join(' AND ');\n    case 'or':\n      return data.clauses\n        .map(c => booleanExprToSql(c, tableAlias))\n        .map(wrapInParens)\n        .join(' OR ');\n    case 'not':\n      return `NOT ${wrapInParens(booleanExprToSql(data.clause, tableAlias))}`;\n  }\n}\n\nfunction wrapInParens(sql: string): string {\n  return `(${sql})`;\n}\n\nfunction valueExprToSql<Table extends TypedTableDef>(\n  expr: ValueExpr<Table, any>,\n  tableAlias?: string\n): string {\n  if (isLiteralExpr(expr)) {\n    return literalValueToSql(expr.value);\n  }\n  const table = tableAlias ?? expr.table;\n  return `${quoteIdentifier(table)}.${quoteIdentifier(expr.column)}`;\n}\n\nfunction literalValueToSql(value: unknown): string {\n  if (value === null || value === undefined) {\n    return 'NULL';\n  }\n  if (value instanceof Identity || value instanceof ConnectionId) {\n    // We use this hex string syntax.\n    return `0x${value.toHexString()}`;\n  }\n  if (value instanceof Timestamp) {\n    return `'${value.toISOString()}'`;\n  }\n  switch (typeof value) {\n    case 'number':\n    case 'bigint':\n      return String(value);\n    case 'boolean':\n      return value ? 'TRUE' : 'FALSE';\n    case 'string':\n      return `'${value.replace(/'/g, \"''\")}'`;\n    default:\n      // It might be safer to error here?\n      return `'${JSON.stringify(value).replace(/'/g, \"''\")}'`;\n  }\n}\n\nfunction quoteIdentifier(name: string): string {\n  return `\"${name.replace(/\"/g, '\"\"')}\"`;\n}\n\nfunction isLiteralExpr<Value>(\n  expr: ValueExpr<any, Value>\n): expr is LiteralExpr<Value & LiteralValue> {\n  return (expr as LiteralExpr<Value>).type === 'literal';\n}\n\n/**\n * Evaluate a BooleanExpr against a row at runtime for client-side filtering.\n */\nexport function evaluateBooleanExpr(\n  expr: BooleanExpr<any>,\n  row: Record<string, any>\n): boolean {\n  return evaluateData(expr.data, row);\n}\n\nfunction evaluateData(\n  data: BooleanExprData<any>,\n  row: Record<string, any>\n): boolean {\n  switch (data.type) {\n    case 'eq':\n      return resolveValue(data.left, row) === resolveValue(data.right, row);\n    case 'ne':\n      return resolveValue(data.left, row) !== resolveValue(data.right, row);\n    case 'gt':\n      return resolveValue(data.left, row) > resolveValue(data.right, row);\n    case 'gte':\n      return resolveValue(data.left, row) >= resolveValue(data.right, row);\n    case 'lt':\n      return resolveValue(data.left, row) < resolveValue(data.right, row);\n    case 'lte':\n      return resolveValue(data.left, row) <= resolveValue(data.right, row);\n    case 'and':\n      return data.clauses.every(c => evaluateData(c, row));\n    case 'or':\n      return data.clauses.some(c => evaluateData(c, row));\n    case 'not':\n      return !evaluateData(data.clause, row);\n  }\n}\n\nfunction resolveValue(\n  expr: ValueExpr<any, any>,\n  row: Record<string, any>\n): any {\n  if (isLiteralExpr(expr)) {\n    return toComparableValue(expr.value);\n  }\n  return toComparableValue(row[expr.column]);\n}\n\ntype TimestampLike = {\n  __timestamp_micros_since_unix_epoch__: bigint;\n};\n\ntype HexSerializableLike = {\n  toHexString: () => string;\n};\n\nfunction isHexSerializableLike(value: unknown): value is HexSerializableLike {\n  return (\n    !!value &&\n    typeof value === 'object' &&\n    typeof (value as { toHexString?: unknown }).toHexString === 'function'\n  );\n}\n\n// Check if this value is a Timestamp-like object. This is here because\n// running locally can end up with different versions of the Timestamp class,\n// which breaks the simple instanceof version.\nfunction isTimestampLike(value: unknown): value is TimestampLike {\n  if (!value || typeof value !== 'object') return false;\n\n  if (value instanceof Timestamp) return true;\n\n  const micros = (value as Record<string, unknown>)[\n    '__timestamp_micros_since_unix_epoch__'\n  ];\n  return typeof micros === 'bigint';\n}\n\n// Exported for tests.\nexport function toComparableValue(value: any): any {\n  // Handle `ConnectionId` and `Identity`.\n  if (isHexSerializableLike(value)) {\n    return value.toHexString();\n  }\n  if (isTimestampLike(value)) {\n    return value.__timestamp_micros_since_unix_epoch__;\n  }\n  return value;\n}\n\n/**\n * Extract the table name from a query builder expression.\n */\nexport function getQueryTableName(query: any): string {\n  if (query.table) return query.table.name; // FromBuilder\n  if (query.name) return query.name; // TableRefImpl\n  if (query.sourceQuery) return query.sourceQuery.table.name; // SemijoinImpl (source table)\n  throw new Error('Cannot extract table name from query');\n}\n\n/**\n * Extract the accessor name from a query builder expression.\n */\nexport function getQueryAccessorName(query: any): string {\n  if (query.table) return query.table.accessorName; // FromBuilder\n  if (query.accessorName) return query.accessorName; // TableRefImpl\n  if (query.sourceQuery) return query.sourceQuery.table.accessorName; // SemijoinImpl\n  throw new Error('Cannot extract accessor name from query');\n}\n\n/**\n * Extract the BooleanExpr from a query builder, if any.\n */\nexport function getQueryWhereClause(query: any): BooleanExpr<any> | undefined {\n  if (query.whereClause) return query.whereClause; // FromBuilder\n  return undefined; // TableRefImpl has no where clause\n}\n\n// TODO: Fix this.\nfunction _createIndexedRowExpr<TableDef extends TypedTableDef>(\n  tableDef: TableDef,\n  cols: RowExpr<TableDef>\n): IndexedRowExpr<TableDef> {\n  const indexed = new Set<ColumnNames<TableDef>>();\n  for (const idx of tableDef.indexes) {\n    if ('columns' in idx) {\n      const [first] = idx.columns;\n      if (first) indexed.add(first);\n    } else if ('column' in idx) {\n      indexed.add(idx.column);\n    }\n  }\n  const pickedEntries = [...indexed].map(name => [name, cols[name]]);\n  return Object.freeze(\n    Object.fromEntries(pickedEntries)\n  ) as IndexedRowExpr<TableDef>;\n}\n","import {\n  AlgebraicType,\n  ProductType,\n  type AlgebraicTypeVariants,\n  type Deserializer,\n  type Serializer,\n} from '../lib/algebraic_type';\nimport type { Identity } from '../lib/identity';\nimport type { OptionAlgebraicType } from '../lib/option';\nimport type { ParamsObj } from '../lib/reducers';\nimport { type UntypedSchemaDef } from '../lib/schema';\nimport {\n  RowBuilder,\n  type Infer,\n  type InferSpacetimeTypeOfTypeBuilder,\n  type InferTypeOfRow,\n  type TypeBuilder,\n} from '../lib/type_builders';\nimport { bsatnBaseSize, toPascalCase } from '../lib/util';\nimport type { ReadonlyDbView } from './db_view';\nimport { type QueryBuilder, type RowTypedQuery } from './query';\nimport {\n  exportContext,\n  registerExport,\n  type ModuleExport,\n  type SchemaInner,\n} from './schema';\n\nexport type ViewExport<ViewFn> = ViewFn & ModuleExport;\n\nexport function makeViewExport<\n  S extends UntypedSchemaDef,\n  Params extends ParamsObj,\n  Ret extends ViewReturnTypeBuilder,\n  F extends ViewFn<S, Params, Ret>,\n>(\n  ctx: SchemaInner,\n  opts: ViewOpts,\n  params: Params,\n  ret: Ret,\n  fn: F\n): ViewExport<F> {\n  const viewExport =\n    // @ts-expect-error typescript incorrectly says Function#bind requires an argument.\n    fn.bind() as ViewExport<F>;\n  viewExport[exportContext] = ctx;\n  viewExport[registerExport] = (ctx, exportName) => {\n    registerView(ctx, opts, exportName, false, params, ret, fn);\n  };\n  return viewExport;\n}\n\nexport function makeAnonViewExport<\n  S extends UntypedSchemaDef,\n  Params extends ParamsObj,\n  Ret extends ViewReturnTypeBuilder,\n  F extends AnonymousViewFn<S, Params, Ret>,\n>(\n  ctx: SchemaInner,\n  opts: ViewOpts,\n  params: Params,\n  ret: Ret,\n  fn: F\n): ViewExport<F> {\n  const viewExport =\n    // @ts-expect-error typescript incorrectly says Function#bind requires an argument.\n    fn.bind() as ViewExport<F>;\n  viewExport[exportContext] = ctx;\n  viewExport[registerExport] = (ctx, exportName) => {\n    registerView(ctx, opts, exportName, true, params, ret, fn);\n  };\n  return viewExport;\n}\n\nexport type ViewCtx<S extends UntypedSchemaDef> = Readonly<{\n  sender: Identity;\n  db: ReadonlyDbView<S>;\n  from: QueryBuilder<S>;\n}>;\n\nexport type AnonymousViewCtx<S extends UntypedSchemaDef> = Readonly<{\n  db: ReadonlyDbView<S>;\n  from: QueryBuilder<S>;\n}>;\n\nexport type ViewOpts = {\n  name?: string;\n  public: true;\n};\n\ntype FlattenedArray<T> = T extends readonly (infer E)[] ? E : never;\n\n// // If we allowed functions to return either.\n// type ViewReturn<Ret extends ViewReturnTypeBuilder> =\n//   | Infer<Ret>\n//   | RowTypedQuery<FlattenedArray<Infer<Ret>>>;\n\nexport type ViewFn<\n  S extends UntypedSchemaDef,\n  Params extends ParamsObj,\n  Ret extends ViewReturnTypeBuilder,\n> =\n  | ((ctx: ViewCtx<S>, params: InferTypeOfRow<Params>) => Infer<Ret>)\n  | ((\n      ctx: ViewCtx<S>,\n      params: InferTypeOfRow<Params>\n    ) => RowTypedQuery<FlattenedArray<Infer<Ret>>, ExtractArrayProduct<Ret>>);\n\nexport type AnonymousViewFn<\n  S extends UntypedSchemaDef,\n  Params extends ParamsObj,\n  Ret extends ViewReturnTypeBuilder,\n> =\n  | ((ctx: AnonymousViewCtx<S>, params: InferTypeOfRow<Params>) => Infer<Ret>)\n  | ((\n      ctx: AnonymousViewCtx<S>,\n      params: InferTypeOfRow<Params>\n    ) => RowTypedQuery<FlattenedArray<Infer<Ret>>, ExtractArrayProduct<Ret>>);\n\nexport type ViewReturnTypeBuilder =\n  | TypeBuilder<\n      readonly object[],\n      { tag: 'Array'; value: AlgebraicTypeVariants.Product }\n    >\n  | TypeBuilder<\n      object | undefined,\n      OptionAlgebraicType<AlgebraicTypeVariants.Product>\n    >;\n\nexport function registerView<\n  S extends UntypedSchemaDef,\n  const Anonymous extends boolean,\n  Params extends ParamsObj,\n  Ret extends ViewReturnTypeBuilder,\n>(\n  ctx: SchemaInner,\n  opts: ViewOpts,\n  exportName: string,\n  anon: Anonymous,\n  params: Params,\n  ret: Ret,\n  fn: Anonymous extends true\n    ? AnonymousViewFn<S, Params, Ret>\n    : ViewFn<S, Params, Ret>\n) {\n  const paramsBuilder = new RowBuilder(params, toPascalCase(exportName));\n\n  // Register return types if they are product types\n  let returnType = ctx.registerTypesRecursively(ret).algebraicType;\n\n  const { typespace } = ctx;\n\n  const { value: paramType } = ctx.resolveType(\n    ctx.registerTypesRecursively(paramsBuilder)\n  );\n\n  ctx.moduleDef.views.push({\n    sourceName: exportName,\n    index: (anon ? ctx.anonViews : ctx.views).length,\n    isPublic: opts.public,\n    isAnonymous: anon,\n    params: paramType,\n    returnType,\n  });\n\n  if (opts.name != null) {\n    ctx.moduleDef.explicitNames.entries.push({\n      tag: 'Function',\n      value: {\n        sourceName: exportName,\n        canonicalName: opts.name,\n      },\n    });\n  }\n\n  // If it is an option, we wrap the function to make the return look like an array.\n  if (returnType.tag == 'Sum') {\n    const originalFn = fn;\n    fn = ((ctx: ViewCtx<S>, args: InferTypeOfRow<Params>) => {\n      const ret = originalFn(ctx, args);\n      return ret == null ? [] : [ret];\n    }) as any;\n    returnType = AlgebraicType.Array(\n      returnType.value.variants[0].algebraicType\n    );\n  }\n\n  (anon ? ctx.anonViews : ctx.views).push({\n    fn,\n    deserializeParams: ProductType.makeDeserializer(paramType, typespace),\n    serializeReturn: AlgebraicType.makeSerializer(returnType, typespace),\n    returnTypeBaseSize: bsatnBaseSize(typespace, returnType),\n  });\n}\n\ntype ViewInfo<F> = {\n  fn: F;\n  deserializeParams: Deserializer<any>;\n  serializeReturn: Serializer<any>;\n  returnTypeBaseSize: number;\n};\n\nexport type Views = ViewInfo<ViewFn<any, any, any>>[];\nexport type AnonViews = ViewInfo<AnonymousViewFn<any, any, any>>[];\n\n// A helper to get the product type out of a type builder.\n// This is only non-never if the type builder is an array.\ntype ExtractArrayProduct<T extends TypeBuilder<any, any>> =\n  InferSpacetimeTypeOfTypeBuilder<T> extends { tag: 'Array'; value: infer V }\n    ? V extends { tag: 'Product'; value: infer P }\n      ? P\n      : never\n    : never;\n","/**\n * An error thrown by a reducer that indicates a problem to the sender.\n *\n * When this error is thrown by a reducer, the sender will be notified\n * that the reducer failed gracefully with the given message.\n */\nexport class SenderError extends Error {\n  constructor(message: string) {\n    super(message);\n  }\n  get name(): string {\n    return 'SenderError';\n  }\n}\n\n/**\n * An internal reducer error returned by the server runtime.\n */\nexport class InternalError extends Error {\n  constructor(message: string) {\n    super(message);\n  }\n  get name(): string {\n    return 'InternalError';\n  }\n}\n","import { SenderError } from '../lib/errors';\n\n/**\n * Base class for all Spacetime host errors (i.e. errors that may be thrown\n * by database functions).\n */\nexport class SpacetimeHostError extends Error {\n  constructor(message: string) {\n    super(message);\n  }\n  get name(): string {\n    return 'SpacetimeHostError';\n  }\n}\n\nexport { SenderError };\n\nconst errorData = {\n  /**\n   * A generic error class for unknown error codes.\n   */\n  HostCallFailure: 1,\n\n  /**\n   * Error indicating that an ABI call was made outside of a transaction.\n   */\n  NotInTransaction: 2,\n\n  /**\n   * Error indicating that BSATN decoding failed.\n   * This typically means that the data could not be decoded to the expected type.\n   */\n  BsatnDecodeError: 3,\n\n  /**\n   * Error indicating that a specified table does not exist.\n   */\n  NoSuchTable: 4,\n\n  /**\n   * Error indicating that a specified index does not exist.\n   */\n  NoSuchIndex: 5,\n\n  /**\n   * Error indicating that a specified row iterator is not valid.\n   */\n  NoSuchIter: 6,\n\n  /**\n   * Error indicating that a specified console timer does not exist.\n   */\n  NoSuchConsoleTimer: 7,\n\n  /**\n   * Error indicating that a specified bytes source or sink is not valid.\n   */\n  NoSuchBytes: 8,\n\n  /**\n   * Error indicating that a provided sink has no more space left.\n   */\n  NoSpace: 9,\n\n  /**\n   * Error indicating that there is no more space in the database.\n   */\n  BufferTooSmall: 11,\n\n  /**\n   * Error indicating that a value with a given unique identifier already exists.\n   */\n  UniqueAlreadyExists: 12,\n\n  /**\n   * Error indicating that the specified delay in scheduling a row was too long.\n   */\n  ScheduleAtDelayTooLong: 13,\n\n  /**\n   * Error indicating that an index was not unique when it was expected to be.\n   */\n  IndexNotUnique: 14,\n\n  /**\n   * Error indicating that an index was not unique when it was expected to be.\n   */\n  NoSuchRow: 15,\n\n  /**\n   * Error indicating that an auto-increment sequence has overflowed.\n   */\n  AutoIncOverflow: 16,\n\n  WouldBlockTransaction: 17,\n\n  TransactionNotAnonymous: 18,\n\n  TransactionIsReadOnly: 19,\n\n  TransactionIsMut: 20,\n\n  HttpError: 21,\n};\n\nfunction mapEntries<const T extends Record<string, any>, U>(\n  x: T,\n  f: (key: keyof T, value: T[keyof T]) => U\n): { [k in keyof T]: U } {\n  return Object.fromEntries(\n    Object.entries(x).map(([k, v]) => [k, f(k, v)])\n  ) as any;\n}\n\n/**\n * Map from error codes to their corresponding SpacetimeError subclass.\n */\nconst errnoToClass = new Map<number, new (msg: string) => Error>();\n\nexport const errors = Object.freeze(\n  mapEntries(errorData, (name, code) => {\n    const cls = Object.defineProperty(\n      class extends SpacetimeHostError {\n        get name() {\n          return name;\n        }\n      },\n      'name',\n      { value: name, writable: false }\n    );\n    errnoToClass.set(code, cls);\n    return cls;\n  })\n);\n\nexport function getErrorConstructor(code: number): new (msg: string) => Error {\n  return errnoToClass.get(code) ?? SpacetimeHostError;\n}\n","var SBigInt = typeof BigInt !== 'undefined' ? BigInt : undefined;\nvar One = typeof BigInt !== 'undefined' ? BigInt(1) : undefined;\nvar ThirtyTwo = typeof BigInt !== 'undefined' ? BigInt(32) : undefined;\nvar NumValues = typeof BigInt !== 'undefined' ? BigInt(0x100000000) : undefined;\nexport function unsafeUniformBigIntDistribution(from, to, rng) {\n    var diff = to - from + One;\n    var FinalNumValues = NumValues;\n    var NumIterations = 1;\n    while (FinalNumValues < diff) {\n        FinalNumValues <<= ThirtyTwo;\n        ++NumIterations;\n    }\n    var value = generateNext(NumIterations, rng);\n    if (value < diff) {\n        return value + from;\n    }\n    if (value + diff < FinalNumValues) {\n        return (value % diff) + from;\n    }\n    var MaxAcceptedRandom = FinalNumValues - (FinalNumValues % diff);\n    while (value >= MaxAcceptedRandom) {\n        value = generateNext(NumIterations, rng);\n    }\n    return (value % diff) + from;\n}\nfunction generateNext(NumIterations, rng) {\n    var value = SBigInt(rng.unsafeNext() + 0x80000000);\n    for (var num = 1; num < NumIterations; ++num) {\n        var out = rng.unsafeNext();\n        value = (value << ThirtyTwo) + SBigInt(out + 0x80000000);\n    }\n    return value;\n}\n","export function unsafeUniformIntDistributionInternal(rangeSize, rng) {\n    var MaxAllowed = rangeSize > 2 ? ~~(0x100000000 / rangeSize) * rangeSize : 0x100000000;\n    var deltaV = rng.unsafeNext() + 0x80000000;\n    while (deltaV >= MaxAllowed) {\n        deltaV = rng.unsafeNext() + 0x80000000;\n    }\n    return deltaV % rangeSize;\n}\n","export function fromNumberToArrayInt64(out, n) {\n    if (n < 0) {\n        var posN = -n;\n        out.sign = -1;\n        out.data[0] = ~~(posN / 0x100000000);\n        out.data[1] = posN >>> 0;\n    }\n    else {\n        out.sign = 1;\n        out.data[0] = ~~(n / 0x100000000);\n        out.data[1] = n >>> 0;\n    }\n    return out;\n}\nexport function substractArrayInt64(out, arrayIntA, arrayIntB) {\n    var lowA = arrayIntA.data[1];\n    var highA = arrayIntA.data[0];\n    var signA = arrayIntA.sign;\n    var lowB = arrayIntB.data[1];\n    var highB = arrayIntB.data[0];\n    var signB = arrayIntB.sign;\n    out.sign = 1;\n    if (signA === 1 && signB === -1) {\n        var low_1 = lowA + lowB;\n        var high = highA + highB + (low_1 > 0xffffffff ? 1 : 0);\n        out.data[0] = high >>> 0;\n        out.data[1] = low_1 >>> 0;\n        return out;\n    }\n    var lowFirst = lowA;\n    var highFirst = highA;\n    var lowSecond = lowB;\n    var highSecond = highB;\n    if (signA === -1) {\n        lowFirst = lowB;\n        highFirst = highB;\n        lowSecond = lowA;\n        highSecond = highA;\n    }\n    var reminderLow = 0;\n    var low = lowFirst - lowSecond;\n    if (low < 0) {\n        reminderLow = 1;\n        low = low >>> 0;\n    }\n    out.data[0] = highFirst - highSecond - reminderLow;\n    out.data[1] = low;\n    return out;\n}\n","import { unsafeUniformIntDistributionInternal } from './UnsafeUniformIntDistributionInternal.js';\nexport function unsafeUniformArrayIntDistributionInternal(out, rangeSize, rng) {\n    var rangeLength = rangeSize.length;\n    while (true) {\n        for (var index = 0; index !== rangeLength; ++index) {\n            var indexRangeSize = index === 0 ? rangeSize[0] + 1 : 0x100000000;\n            var g = unsafeUniformIntDistributionInternal(indexRangeSize, rng);\n            out[index] = g;\n        }\n        for (var index = 0; index !== rangeLength; ++index) {\n            var current = out[index];\n            var currentInRange = rangeSize[index];\n            if (current < currentInRange) {\n                return out;\n            }\n            else if (current > currentInRange) {\n                break;\n            }\n        }\n    }\n}\n","import { unsafeUniformIntDistributionInternal } from './internals/UnsafeUniformIntDistributionInternal.js';\nimport { fromNumberToArrayInt64, substractArrayInt64 } from './internals/ArrayInt64.js';\nimport { unsafeUniformArrayIntDistributionInternal } from './internals/UnsafeUniformArrayIntDistributionInternal.js';\nvar safeNumberMaxSafeInteger = Number.MAX_SAFE_INTEGER;\nvar sharedA = { sign: 1, data: [0, 0] };\nvar sharedB = { sign: 1, data: [0, 0] };\nvar sharedC = { sign: 1, data: [0, 0] };\nvar sharedData = [0, 0];\nfunction uniformLargeIntInternal(from, to, rangeSize, rng) {\n    var rangeSizeArrayIntValue = rangeSize <= safeNumberMaxSafeInteger\n        ? fromNumberToArrayInt64(sharedC, rangeSize)\n        : substractArrayInt64(sharedC, fromNumberToArrayInt64(sharedA, to), fromNumberToArrayInt64(sharedB, from));\n    if (rangeSizeArrayIntValue.data[1] === 0xffffffff) {\n        rangeSizeArrayIntValue.data[0] += 1;\n        rangeSizeArrayIntValue.data[1] = 0;\n    }\n    else {\n        rangeSizeArrayIntValue.data[1] += 1;\n    }\n    unsafeUniformArrayIntDistributionInternal(sharedData, rangeSizeArrayIntValue.data, rng);\n    return sharedData[0] * 0x100000000 + sharedData[1] + from;\n}\nexport function unsafeUniformIntDistribution(from, to, rng) {\n    var rangeSize = to - from;\n    if (rangeSize <= 0xffffffff) {\n        var g = unsafeUniformIntDistributionInternal(rangeSize + 1, rng);\n        return g + from;\n    }\n    return uniformLargeIntInternal(from, to, rangeSize, rng);\n}\n","var XoroShiro128Plus = (function () {\n    function XoroShiro128Plus(s01, s00, s11, s10) {\n        this.s01 = s01;\n        this.s00 = s00;\n        this.s11 = s11;\n        this.s10 = s10;\n    }\n    XoroShiro128Plus.prototype.clone = function () {\n        return new XoroShiro128Plus(this.s01, this.s00, this.s11, this.s10);\n    };\n    XoroShiro128Plus.prototype.next = function () {\n        var nextRng = new XoroShiro128Plus(this.s01, this.s00, this.s11, this.s10);\n        var out = nextRng.unsafeNext();\n        return [out, nextRng];\n    };\n    XoroShiro128Plus.prototype.unsafeNext = function () {\n        var out = (this.s00 + this.s10) | 0;\n        var a0 = this.s10 ^ this.s00;\n        var a1 = this.s11 ^ this.s01;\n        var s00 = this.s00;\n        var s01 = this.s01;\n        this.s00 = (s00 << 24) ^ (s01 >>> 8) ^ a0 ^ (a0 << 16);\n        this.s01 = (s01 << 24) ^ (s00 >>> 8) ^ a1 ^ ((a1 << 16) | (a0 >>> 16));\n        this.s10 = (a1 << 5) ^ (a0 >>> 27);\n        this.s11 = (a0 << 5) ^ (a1 >>> 27);\n        return out;\n    };\n    XoroShiro128Plus.prototype.jump = function () {\n        var nextRng = new XoroShiro128Plus(this.s01, this.s00, this.s11, this.s10);\n        nextRng.unsafeJump();\n        return nextRng;\n    };\n    XoroShiro128Plus.prototype.unsafeJump = function () {\n        var ns01 = 0;\n        var ns00 = 0;\n        var ns11 = 0;\n        var ns10 = 0;\n        var jump = [0xd8f554a5, 0xdf900294, 0x4b3201fc, 0x170865df];\n        for (var i = 0; i !== 4; ++i) {\n            for (var mask = 1; mask; mask <<= 1) {\n                if (jump[i] & mask) {\n                    ns01 ^= this.s01;\n                    ns00 ^= this.s00;\n                    ns11 ^= this.s11;\n                    ns10 ^= this.s10;\n                }\n                this.unsafeNext();\n            }\n        }\n        this.s01 = ns01;\n        this.s00 = ns00;\n        this.s11 = ns11;\n        this.s10 = ns10;\n    };\n    XoroShiro128Plus.prototype.getState = function () {\n        return [this.s01, this.s00, this.s11, this.s10];\n    };\n    return XoroShiro128Plus;\n}());\nfunction fromState(state) {\n    var valid = state.length === 4;\n    if (!valid) {\n        throw new Error('The state must have been produced by a xoroshiro128plus RandomGenerator');\n    }\n    return new XoroShiro128Plus(state[0], state[1], state[2], state[3]);\n}\nexport var xoroshiro128plus = Object.assign(function (seed) {\n    return new XoroShiro128Plus(-1, ~seed, seed | 0, 0);\n}, { fromState: fromState });\n","import type { RandomGenerator } from 'pure-rand';\nimport { unsafeUniformBigIntDistribution } from 'pure-rand/distribution/UnsafeUniformBigIntDistribution';\nimport { unsafeUniformIntDistribution } from 'pure-rand/distribution/UnsafeUniformIntDistribution';\nimport { xoroshiro128plus } from 'pure-rand/generator/XoroShiro';\nimport type { Timestamp } from '../lib/timestamp';\n\ntype IntArray =\n  | Int8Array\n  | Uint8Array\n  | Uint8ClampedArray\n  | Int16Array\n  | Uint16Array\n  | Int32Array\n  | Uint32Array\n  | BigInt64Array\n  | BigUint64Array;\n\n/**\n * A collection of random-number-generating functions, seeded based on `ctx.timestamp`.\n *\n * ## Usage\n *\n * ```\n * const floatOneToTen = ctx.random() * 10;\n * const randomBytes = ctx.random.fill(new Uint8Array(16));\n * const intOneToTen = ctx.random.integerInRange(0, 10);\n * ```\n */\nexport interface Random {\n  /**\n   * Returns a random floating-point number in the range `[0.0, 1.0)`.\n   *\n   * The returned float will have 53 bits of randomness.\n   */\n  (): number;\n\n  /**\n   * Like `crypto.getRandomValues()`. Fills a `TypedArray` with random integers\n   * in a uniform distribution, mutating and returning it.\n   */\n  fill<T extends IntArray>(array: T): T;\n\n  /**\n   * Returns a random unsigned 32-bit integer in a uniform distribution in the\n   * range `[0, 2**32)`.\n   */\n  uint32(): number;\n\n  /**\n   * Returns an integer in the range `[min, max]`.\n   */\n  integerInRange(min: number, max: number): number;\n\n  /**\n   * Returns a bigint in the range `[min, max]`.\n   */\n  bigintInRange(min: bigint, max: bigint): bigint;\n}\n\nconst { asUintN } = BigInt;\n\n/** Based on the function of the same name in `rand_core::SeedableRng::seed_from_u64` */\nfunction pcg32(state: bigint): number {\n  const MUL = 6364136223846793005n;\n  const INC = 11634580027462260723n;\n\n  state = asUintN(64, state * MUL + INC);\n  const xorshifted = Number(asUintN(32, ((state >> 18n) ^ state) >> 27n));\n  const rot = Number(asUintN(32, state >> 59n));\n  // rotate `xorshifted` right by `rot` bits\n  return (xorshifted >> rot) | (xorshifted << (32 - rot));\n}\n\n/** From the `pure-rand` README */\nfunction generateFloat64(rng: RandomGenerator): number {\n  const g1 = unsafeUniformIntDistribution(0, (1 << 26) - 1, rng);\n  const g2 = unsafeUniformIntDistribution(0, (1 << 27) - 1, rng);\n  const value = (g1 * Math.pow(2, 27) + g2) * Math.pow(2, -53);\n  return value;\n}\n\nexport function makeRandom(seed: Timestamp): Random {\n  // Use PCG32 to turn a 64-bit seed into a 32-bit seed, as the Rust `rand` crate does.\n  const rng = xoroshiro128plus(pcg32(seed.microsSinceUnixEpoch));\n\n  const random: Random = () => generateFloat64(rng);\n\n  random.fill = array => {\n    const elem = array.at(0);\n    if (typeof elem === 'bigint') {\n      const upper = (1n << BigInt(array.BYTES_PER_ELEMENT * 8)) - 1n;\n      for (let i = 0; i < array.length; i++) {\n        array[i] = unsafeUniformBigIntDistribution(0n, upper, rng);\n      }\n    } else if (typeof elem === 'number') {\n      const upper = (1 << (array.BYTES_PER_ELEMENT * 8)) - 1;\n      for (let i = 0; i < array.length; i++) {\n        array[i] = unsafeUniformIntDistribution(0, upper, rng);\n      }\n    }\n    return array;\n  };\n\n  random.uint32 = () => rng.unsafeNext();\n\n  random.integerInRange = (min, max) =>\n    unsafeUniformIntDistribution(min, max, rng);\n\n  random.bigintInRange = (min, max) =>\n    unsafeUniformBigIntDistribution(min, max, rng);\n\n  return random;\n}\n","import * as _syscalls2_0 from 'spacetime:sys@2.0';\n\nimport type { ModuleHooks, u128, u16, u256, u32 } from 'spacetime:sys@2.0';\nimport {\n  AlgebraicType,\n  ProductType,\n  type Deserializer,\n} from '../lib/algebraic_type';\nimport {\n  RawModuleDef,\n  ViewResultHeader,\n  type RawTableDefV10,\n  type Typespace,\n} from '../lib/autogen/types';\nimport { ConnectionId } from '../lib/connection_id';\nimport { Identity } from '../lib/identity';\nimport { Timestamp } from '../lib/timestamp';\nimport { Uuid } from '../lib/uuid';\nimport BinaryReader from '../lib/binary_reader';\nimport BinaryWriter, { ResizableBuffer } from '../lib/binary_writer';\nimport {\n  type Index,\n  type IndexVal,\n  type PointIndex,\n  type RangedIndex,\n  type UniqueIndex,\n} from '../lib/indexes';\nimport { callProcedure } from './procedures';\nimport {\n  type AuthCtx,\n  type JsonObject,\n  type JwtClaims,\n  type ReducerCtx as IReducerCtx,\n} from '../lib/reducers';\nimport { type UntypedSchemaDef } from '../lib/schema';\nimport { type RowType, type Table, type TableMethods } from '../lib/table';\nimport { hasOwn } from '../lib/util';\nimport { type AnonymousViewCtx, type ViewCtx } from './views';\nimport { isRowTypedQuery, makeQueryBuilder, toSql } from './query';\nimport type { DbView } from './db_view';\nimport { getErrorConstructor, SenderError } from './errors';\nimport { Range, type Bound } from './range';\nimport { makeRandom, type Random } from './rng';\nimport type { SchemaInner } from './schema';\n\nconst { freeze } = Object;\n\nexport const sys = _syscalls2_0;\n\nexport function parseJsonObject(json: string): JsonObject {\n  let value: unknown;\n\n  try {\n    value = JSON.parse(json);\n  } catch {\n    throw new Error('Invalid JSON: failed to parse string');\n  }\n\n  if (value === null || typeof value !== 'object' || Array.isArray(value)) {\n    throw new Error('Expected a JSON object at the top level');\n  }\n\n  // The runtime check above guarantees this cast is safe\n  return value as JsonObject;\n}\n\nclass JwtClaimsImpl implements JwtClaims {\n  readonly fullPayload: JsonObject;\n  private readonly _identity: Identity;\n  /**\n   * Creates a new JwtClaims instance.\n   * @param rawPayload The JWT payload as a raw JSON string.\n   * @param identity The identity for this JWT. We are only taking this because we don't have a blake3 implementation (which we need to compute it).\n   */\n  constructor(\n    public readonly rawPayload: string,\n    identity: Identity\n  ) {\n    this.fullPayload = parseJsonObject(rawPayload);\n    this._identity = identity;\n  }\n  readonly [claim: string]: unknown;\n  get identity(): Identity {\n    return this._identity;\n  }\n  get subject() {\n    return this.fullPayload['sub'] as string;\n  }\n  get issuer() {\n    return this.fullPayload['iss'] as string;\n  }\n  get audience() {\n    const aud = this.fullPayload['aud'];\n    if (aud == null) {\n      return [];\n    }\n    return typeof aud === 'string' ? [aud] : (aud as string[]);\n  }\n}\n\nclass AuthCtxImpl implements AuthCtx {\n  public readonly isInternal: boolean;\n\n  // Source of the JWT payload string, if there is one.\n  private readonly _jwtSource: () => string | null;\n  // Whether we have initialized the JWT claims.\n  private _initializedJWT: boolean = false;\n  private _jwtClaims?: JwtClaims | null;\n  private _senderIdentity: Identity;\n\n  private constructor(opts: {\n    isInternal: boolean;\n    jwtSource: () => string | null;\n    senderIdentity: Identity;\n  }) {\n    this.isInternal = opts.isInternal;\n    this._jwtSource = opts.jwtSource;\n    this._senderIdentity = opts.senderIdentity;\n  }\n\n  private _initializeJWT() {\n    if (this._initializedJWT) return;\n    this._initializedJWT = true;\n\n    const token = this._jwtSource();\n    if (!token) {\n      this._jwtClaims = null;\n    } else {\n      this._jwtClaims = new JwtClaimsImpl(token, this._senderIdentity);\n    }\n    // At this point we can safely freeze the object.\n    Object.freeze(this);\n  }\n\n  /** Lazily compute whether a JWT exists and is parseable. */\n  get hasJWT(): boolean {\n    this._initializeJWT();\n    return this._jwtClaims !== null;\n  }\n\n  /** Lazily parse the JwtClaims only when accessed. */\n  get jwt(): JwtClaims | null {\n    this._initializeJWT();\n    return this._jwtClaims!;\n  }\n\n  /** Create a context representing internal (non-user) requests. */\n  static internal(): AuthCtx {\n    return new AuthCtxImpl({\n      isInternal: true,\n      jwtSource: () => null,\n      senderIdentity: Identity.zero(),\n    });\n  }\n\n  /** If there is a connection id, look up the JWT payload from the system tables. */\n  static fromSystemTables(\n    connectionId: ConnectionId | null,\n    sender: Identity\n  ): AuthCtx {\n    if (connectionId === null) {\n      return new AuthCtxImpl({\n        isInternal: false,\n        jwtSource: () => null,\n        senderIdentity: sender,\n      });\n    }\n    return new AuthCtxImpl({\n      isInternal: false,\n      jwtSource: () => {\n        const payloadBuf = sys.get_jwt_payload(connectionId.__connection_id__);\n        if (payloadBuf.length === 0) return null;\n        const payloadStr = new TextDecoder().decode(payloadBuf);\n        return payloadStr;\n      },\n      senderIdentity: sender,\n    });\n  }\n}\n\n// Using a class expression rather than declaration keeps the class out of the\n// type namespace, so that `ReducerCtx` still refers to the interface.\nexport const ReducerCtxImpl = class ReducerCtx<\n  SchemaDef extends UntypedSchemaDef,\n> implements IReducerCtx<SchemaDef>\n{\n  #identity: Identity | undefined;\n  #senderAuth: AuthCtx | undefined;\n  #uuidCounter: { value: number } | undefined;\n  #random: Random | undefined;\n  sender: Identity;\n  timestamp: Timestamp;\n  connectionId: ConnectionId | null;\n  db: DbView<SchemaDef>;\n\n  constructor(\n    sender: Identity,\n    timestamp: Timestamp,\n    connectionId: ConnectionId | null,\n    dbView: DbView<any>\n  ) {\n    Object.seal(this);\n    this.sender = sender;\n    this.timestamp = timestamp;\n    this.connectionId = connectionId;\n    this.db = dbView;\n  }\n\n  /** Reset the `ReducerCtx` to be used for a new transaction */\n  static reset(\n    me: InstanceType<typeof this>,\n    sender: Identity,\n    timestamp: Timestamp,\n    connectionId: ConnectionId | null\n  ) {\n    me.sender = sender;\n    me.timestamp = timestamp;\n    me.connectionId = connectionId;\n    me.#uuidCounter = undefined;\n    me.#senderAuth = undefined;\n  }\n\n  get identity() {\n    return (this.#identity ??= new Identity(sys.identity()));\n  }\n\n  get senderAuth() {\n    return (this.#senderAuth ??= AuthCtxImpl.fromSystemTables(\n      this.connectionId,\n      this.sender\n    ));\n  }\n\n  get random() {\n    return (this.#random ??= makeRandom(this.timestamp));\n  }\n\n  /**\n   * Create a new random {@link Uuid} `v4` using this `ReducerCtx`'s RNG.\n   */\n  newUuidV4(): Uuid {\n    const bytes = this.random.fill(new Uint8Array(16));\n    return Uuid.fromRandomBytesV4(bytes);\n  }\n\n  /**\n   * Create a new sortable {@link Uuid} `v7` using this `ReducerCtx`'s RNG, counter,\n   * and timestamp.\n   */\n  newUuidV7(): Uuid {\n    const bytes = this.random.fill(new Uint8Array(4));\n    const counter = (this.#uuidCounter ??= { value: 0 });\n    return Uuid.fromCounterV7(counter, this.timestamp, bytes);\n  }\n};\n\n/**\n * Call into a user function `fn` - the backtrace from an exception thrown in\n * `fn` or one of its descendants in the callgraph will be stripped by host\n * code in `crates/core/src/host/v8/error.rs` such that `fn` will be shown to\n * be the root of the call stack.\n */\nexport const callUserFunction = function __spacetimedb_end_short_backtrace<\n  Args extends any[],\n  R,\n>(fn: (...args: Args) => R, ...args: Args): R {\n  return fn(...args);\n};\n\nexport const makeHooks = (schema: SchemaInner): ModuleHooks =>\n  new ModuleHooksImpl(schema);\n\nclass ModuleHooksImpl implements ModuleHooks {\n  #schema: SchemaInner;\n  #dbView_: DbView<any> | undefined;\n  #reducerArgsDeserializers;\n  /** Cache the `ReducerCtx` object to avoid allocating anew for ever reducer call. */\n  #reducerCtx_: InstanceType<typeof ReducerCtxImpl> | undefined;\n\n  constructor(schema: SchemaInner) {\n    this.#schema = schema;\n    this.#reducerArgsDeserializers = schema.moduleDef.reducers.map(\n      ({ params }) => ProductType.makeDeserializer(params, schema.typespace)\n    );\n  }\n\n  get #dbView() {\n    return (this.#dbView_ ??= freeze(\n      Object.fromEntries(\n        Object.values(this.#schema.schemaType.tables).map(table => [\n          table.accessorName,\n          makeTableView(this.#schema.typespace, table.tableDef),\n        ])\n      )\n    ));\n  }\n\n  get #reducerCtx() {\n    return (this.#reducerCtx_ ??= new ReducerCtxImpl(\n      Identity.zero(),\n      Timestamp.UNIX_EPOCH,\n      null,\n      this.#dbView\n    ));\n  }\n\n  __describe_module__() {\n    const writer = new BinaryWriter(128);\n    RawModuleDef.serialize(\n      writer,\n      RawModuleDef.V10(this.#schema.rawModuleDefV10())\n    );\n    return writer.getBuffer();\n  }\n\n  __get_error_constructor__(code: number): new (msg: string) => Error {\n    return getErrorConstructor(code);\n  }\n\n  get __sender_error_class__() {\n    return SenderError;\n  }\n\n  __call_reducer__(\n    reducerId: u32,\n    sender: u256,\n    connId: u128,\n    timestamp: bigint,\n    argsBuf: DataView\n  ): void {\n    const moduleCtx = this.#schema;\n    const deserializeArgs = this.#reducerArgsDeserializers[reducerId];\n    BINARY_READER.reset(argsBuf);\n    const args = deserializeArgs(BINARY_READER);\n    const senderIdentity = new Identity(sender);\n    const ctx = this.#reducerCtx;\n    ReducerCtxImpl.reset(\n      ctx,\n      senderIdentity,\n      new Timestamp(timestamp),\n      ConnectionId.nullIfZero(new ConnectionId(connId))\n    );\n    callUserFunction(moduleCtx.reducers[reducerId], ctx, args);\n  }\n\n  __call_view__(\n    id: u32,\n    sender: u256,\n    argsBuf: Uint8Array\n  ): { data: Uint8Array } {\n    const moduleCtx = this.#schema;\n    const { fn, deserializeParams, serializeReturn, returnTypeBaseSize } =\n      moduleCtx.views[id];\n    const ctx: ViewCtx<any> = freeze({\n      sender: new Identity(sender),\n      // this is the non-readonly DbView, but the typing for the user will be\n      // the readonly one, and if they do call mutating functions it will fail\n      // at runtime\n      db: this.#dbView,\n      from: makeQueryBuilder(moduleCtx.schemaType),\n    });\n    const args = deserializeParams(new BinaryReader(argsBuf));\n    const ret = callUserFunction(fn, ctx, args);\n    const retBuf = new BinaryWriter(returnTypeBaseSize);\n    if (isRowTypedQuery(ret)) {\n      const query = toSql(ret);\n      ViewResultHeader.serialize(retBuf, ViewResultHeader.RawSql(query));\n    } else {\n      ViewResultHeader.serialize(retBuf, ViewResultHeader.RowData);\n      serializeReturn(retBuf, ret);\n    }\n    return { data: retBuf.getBuffer() };\n  }\n\n  __call_view_anon__(id: u32, argsBuf: Uint8Array): { data: Uint8Array } {\n    const moduleCtx = this.#schema;\n    const { fn, deserializeParams, serializeReturn, returnTypeBaseSize } =\n      moduleCtx.anonViews[id];\n    const ctx: AnonymousViewCtx<any> = freeze({\n      // this is the non-readonly DbView, but the typing for the user will be\n      // the readonly one, and if they do call mutating functions it will fail\n      // at runtime\n      db: this.#dbView,\n      from: makeQueryBuilder(moduleCtx.schemaType),\n    });\n    const args = deserializeParams(new BinaryReader(argsBuf));\n    const ret = callUserFunction(fn, ctx, args);\n    const retBuf = new BinaryWriter(returnTypeBaseSize);\n    if (isRowTypedQuery(ret)) {\n      const query = toSql(ret);\n      ViewResultHeader.serialize(retBuf, ViewResultHeader.RawSql(query));\n    } else {\n      ViewResultHeader.serialize(retBuf, ViewResultHeader.RowData);\n      serializeReturn(retBuf, ret);\n    }\n    return { data: retBuf.getBuffer() };\n  }\n\n  __call_procedure__(\n    id: u32,\n    sender: u256,\n    connection_id: u128,\n    timestamp: bigint,\n    args: Uint8Array\n  ): Uint8Array {\n    return callProcedure(\n      this.#schema,\n      id,\n      new Identity(sender),\n      ConnectionId.nullIfZero(new ConnectionId(connection_id)),\n      new Timestamp(timestamp),\n      args,\n      () => this.#dbView\n    );\n  }\n}\n\nconst BINARY_WRITER = new BinaryWriter(0);\nconst BINARY_READER = new BinaryReader(new Uint8Array());\n\nfunction makeTableView(\n  typespace: Typespace,\n  table: RawTableDefV10\n): Table<any> {\n  const table_id = sys.table_id_from_name(table.sourceName);\n  const rowType = typespace.types[table.productTypeRef];\n  if (rowType.tag !== 'Product') {\n    throw 'impossible';\n  }\n\n  const serializeRow = AlgebraicType.makeSerializer(rowType, typespace);\n  const deserializeRow = AlgebraicType.makeDeserializer(rowType, typespace);\n\n  const sequences = table.sequences.map(seq => {\n    const col = rowType.value.elements[seq.column];\n    const colType = col.algebraicType;\n\n    // Determine the sentinel value which users will pass to as a placeholder\n    // to cause the sequence to advance.\n    // For small integer SATS types which fit in V8 `number`s, this is `0: number`,\n    // and for larger integer SATS types it's `0n: BigInt`.\n    let sequenceTrigger: bigint | number;\n    switch (colType.tag) {\n      case 'U8':\n      case 'I8':\n      case 'U16':\n      case 'I16':\n      case 'U32':\n      case 'I32':\n        sequenceTrigger = 0;\n        break;\n      case 'U64':\n      case 'I64':\n      case 'U128':\n      case 'I128':\n      case 'U256':\n      case 'I256':\n        sequenceTrigger = 0n;\n        break;\n      default:\n        throw new TypeError('invalid sequence type');\n    }\n    return {\n      colName: col.name!,\n      sequenceTrigger,\n      deserialize: AlgebraicType.makeDeserializer(colType, typespace),\n    };\n  });\n  const hasAutoIncrement = sequences.length > 0;\n\n  const iter = () =>\n    tableIterator(sys.datastore_table_scan_bsatn(table_id), deserializeRow);\n\n  const integrateGeneratedColumns = hasAutoIncrement\n    ? (row: RowType<any>, ret_buf: DataView) => {\n        BINARY_READER.reset(ret_buf);\n        for (const { colName, deserialize, sequenceTrigger } of sequences) {\n          if (row[colName] === sequenceTrigger) {\n            row[colName] = deserialize(BINARY_READER);\n          }\n        }\n      }\n    : null;\n\n  const tableMethods: TableMethods<any> = {\n    count: () => sys.datastore_table_row_count(table_id),\n    iter,\n    [Symbol.iterator]: () => iter(),\n    insert: row => {\n      const buf = LEAF_BUF;\n      BINARY_WRITER.reset(buf);\n      serializeRow(BINARY_WRITER, row);\n      sys.datastore_insert_bsatn(table_id, buf.buffer, BINARY_WRITER.offset);\n      const ret = { ...row };\n      integrateGeneratedColumns?.(ret, buf.view);\n\n      return ret;\n    },\n    delete: (row: RowType<any>): boolean => {\n      const buf = LEAF_BUF;\n      BINARY_WRITER.reset(buf);\n      BINARY_WRITER.writeU32(1);\n      serializeRow(BINARY_WRITER, row);\n      const count = sys.datastore_delete_all_by_eq_bsatn(\n        table_id,\n        buf.buffer,\n        BINARY_WRITER.offset\n      );\n      return count > 0;\n    },\n  };\n\n  const tableView = Object.assign(\n    Object.create(null),\n    tableMethods\n  ) as Table<any>;\n\n  for (const indexDef of table.indexes) {\n    const index_id = sys.index_id_from_name(indexDef.sourceName!);\n\n    let column_ids: number[];\n    let isHashIndex = false;\n    switch (indexDef.algorithm.tag) {\n      case 'Hash':\n        isHashIndex = true;\n        column_ids = indexDef.algorithm.value;\n        break;\n      case 'BTree':\n        column_ids = indexDef.algorithm.value;\n        break;\n      case 'Direct':\n        column_ids = [indexDef.algorithm.value];\n        break;\n    }\n    const numColumns = column_ids.length;\n\n    const columnSet = new Set(column_ids);\n    const isUnique = table.constraints\n      .filter(x => x.data.tag === 'Unique')\n      .some(x => columnSet.isSubsetOf(new Set(x.data.value.columns)));\n\n    const isPrimaryKey =\n      isUnique &&\n      column_ids.length === table.primaryKey.length &&\n      column_ids.every((id, i) => table.primaryKey[i] === id);\n\n    const indexSerializers = column_ids.map(id =>\n      AlgebraicType.makeSerializer(\n        rowType.value.elements[id].algebraicType,\n        typespace\n      )\n    );\n\n    const serializePoint = (buffer: ResizableBuffer, colVal: any[]): number => {\n      BINARY_WRITER.reset(buffer);\n      for (let i = 0; i < numColumns; i++) {\n        indexSerializers[i](BINARY_WRITER, colVal[i]);\n      }\n      return BINARY_WRITER.offset;\n    };\n\n    const serializeSingleElement =\n      numColumns === 1 ? indexSerializers[0] : null;\n\n    const serializeSinglePoint =\n      serializeSingleElement &&\n      ((buffer: ResizableBuffer, colVal: any): number => {\n        BINARY_WRITER.reset(buffer);\n        serializeSingleElement(BINARY_WRITER, colVal);\n        return BINARY_WRITER.offset;\n      });\n\n    type IndexScanArgs = [\n      prefix_len: u32,\n      prefix_elems: u16,\n      rstart_len: u32,\n      rend_len: u32,\n    ];\n\n    let index: Index<any, any>;\n    if (isUnique && serializeSinglePoint) {\n      // numColumns == 1, unique index\n      const base = {\n        find: (colVal: IndexVal<any, any>): RowType<any> | null => {\n          const buf = LEAF_BUF;\n          const point_len = serializeSinglePoint(buf, colVal);\n          const iter_id = sys.datastore_index_scan_point_bsatn(\n            index_id,\n            buf.buffer,\n            point_len\n          );\n          return tableIterateOne(iter_id, deserializeRow);\n        },\n        delete: (colVal: IndexVal<any, any>): boolean => {\n          const buf = LEAF_BUF;\n          const point_len = serializeSinglePoint(buf, colVal);\n          const num = sys.datastore_delete_by_index_scan_point_bsatn(\n            index_id,\n            buf.buffer,\n            point_len\n          );\n          return num > 0;\n        },\n      };\n      if (isPrimaryKey) {\n        (base as any).update = (row: RowType<any>): RowType<any> => {\n          const buf = LEAF_BUF;\n          BINARY_WRITER.reset(buf);\n          serializeRow(BINARY_WRITER, row);\n          sys.datastore_update_bsatn(\n            table_id,\n            index_id,\n            buf.buffer,\n            BINARY_WRITER.offset\n          );\n          integrateGeneratedColumns?.(row, buf.view);\n          return row;\n        };\n      }\n      index = base as UniqueIndex<any, any>;\n    } else if (isUnique) {\n      // numColumns != 1, unique index\n      const base = {\n        find: (colVal: IndexVal<any, any>): RowType<any> | null => {\n          if (colVal.length !== numColumns) {\n            throw new TypeError('wrong number of elements');\n          }\n          const buf = LEAF_BUF;\n          const point_len = serializePoint(buf, colVal);\n          const iter_id = sys.datastore_index_scan_point_bsatn(\n            index_id,\n            buf.buffer,\n            point_len\n          );\n          return tableIterateOne(iter_id, deserializeRow);\n        },\n        delete: (colVal: IndexVal<any, any>): boolean => {\n          if (colVal.length !== numColumns)\n            throw new TypeError('wrong number of elements');\n\n          const buf = LEAF_BUF;\n          const point_len = serializePoint(buf, colVal);\n          const num = sys.datastore_delete_by_index_scan_point_bsatn(\n            index_id,\n            buf.buffer,\n            point_len\n          );\n          return num > 0;\n        },\n      };\n      if (isPrimaryKey) {\n        (base as any).update = (row: RowType<any>): RowType<any> => {\n          const buf = LEAF_BUF;\n          BINARY_WRITER.reset(buf);\n          serializeRow(BINARY_WRITER, row);\n          sys.datastore_update_bsatn(\n            table_id,\n            index_id,\n            buf.buffer,\n            BINARY_WRITER.offset\n          );\n          integrateGeneratedColumns?.(row, buf.view);\n          return row;\n        };\n      }\n      index = base as UniqueIndex<any, any>;\n    } else if (serializeSinglePoint) {\n      // numColumns == 1\n      const rawIndex = {\n        filter: (range: any): IteratorObject<RowType<any>> => {\n          const buf = LEAF_BUF;\n          const point_len = serializeSinglePoint(buf, range);\n          const iter_id = sys.datastore_index_scan_point_bsatn(\n            index_id,\n            buf.buffer,\n            point_len\n          );\n          return tableIterator(iter_id, deserializeRow);\n        },\n        delete: (range: any): u32 => {\n          const buf = LEAF_BUF;\n          const point_len = serializeSinglePoint(buf, range);\n          return sys.datastore_delete_by_index_scan_point_bsatn(\n            index_id,\n            buf.buffer,\n            point_len\n          );\n        },\n      };\n      if (isHashIndex) {\n        index = rawIndex as PointIndex<any, any>;\n      } else {\n        index = rawIndex as RangedIndex<any, any>;\n      }\n    } else if (isHashIndex) {\n      // numColumns != 1\n      index = {\n        filter: (range: any[]): IteratorObject<RowType<any>> => {\n          const buf = LEAF_BUF;\n          const point_len = serializePoint(buf, range);\n          const iter_id = sys.datastore_index_scan_point_bsatn(\n            index_id,\n            buf.buffer,\n            point_len\n          );\n          return tableIterator(iter_id, deserializeRow);\n        },\n        delete: (range: any[]): u32 => {\n          const buf = LEAF_BUF;\n          const point_len = serializePoint(buf, range);\n          return sys.datastore_delete_by_index_scan_point_bsatn(\n            index_id,\n            buf.buffer,\n            point_len\n          );\n        },\n      } as PointIndex<any, any>;\n    } else {\n      // numColumns != 1\n      const serializeRange = (\n        buffer: ResizableBuffer,\n        range: any[]\n      ): IndexScanArgs => {\n        if (range.length > numColumns) throw new TypeError('too many elements');\n\n        BINARY_WRITER.reset(buffer);\n        const writer = BINARY_WRITER;\n        const prefix_elems = range.length - 1;\n        for (let i = 0; i < prefix_elems; i++) {\n          indexSerializers[i](writer, range[i]);\n        }\n        const rstartOffset = writer.offset;\n        const term = range[range.length - 1];\n        const serializeTerm = indexSerializers[range.length - 1];\n        if (term instanceof Range) {\n          const writeBound = (bound: Bound<any>) => {\n            const tags = { included: 0, excluded: 1, unbounded: 2 };\n            writer.writeU8(tags[bound.tag]);\n            if (bound.tag !== 'unbounded') serializeTerm(writer, bound.value);\n          };\n          writeBound(term.from);\n          const rstartLen = writer.offset - rstartOffset;\n          writeBound(term.to);\n          const rendLen = writer.offset - rstartLen;\n          return [rstartOffset, prefix_elems, rstartLen, rendLen];\n        } else {\n          writer.writeU8(0);\n          serializeTerm(writer, term);\n          const rstartLen = writer.offset;\n          const rendLen = 0;\n          return [rstartOffset, prefix_elems, rstartLen, rendLen];\n        }\n      };\n      index = {\n        filter: (range: any[]): IteratorObject<RowType<any>> => {\n          if (range.length === numColumns) {\n            const buf = LEAF_BUF;\n            const point_len = serializePoint(buf, range);\n            const iter_id = sys.datastore_index_scan_point_bsatn(\n              index_id,\n              buf.buffer,\n              point_len\n            );\n            return tableIterator(iter_id, deserializeRow);\n          } else {\n            const buf = LEAF_BUF;\n            const args = serializeRange(buf, range);\n            const iter_id = sys.datastore_index_scan_range_bsatn(\n              index_id,\n              buf.buffer,\n              ...args\n            );\n            return tableIterator(iter_id, deserializeRow);\n          }\n        },\n        delete: (range: any[]): u32 => {\n          if (range.length === numColumns) {\n            const buf = LEAF_BUF;\n            const point_len = serializePoint(buf, range);\n            return sys.datastore_delete_by_index_scan_point_bsatn(\n              index_id,\n              buf.buffer,\n              point_len\n            );\n          } else {\n            const buf = LEAF_BUF;\n            const args = serializeRange(buf, range);\n            return sys.datastore_delete_by_index_scan_range_bsatn(\n              index_id,\n              buf.buffer,\n              ...args\n            );\n          }\n        },\n      } as RangedIndex<any, any>;\n    }\n\n    if (Object.hasOwn(tableView, indexDef.accessorName!)) {\n      freeze(Object.assign(tableView[indexDef.accessorName!], index));\n    } else {\n      tableView[indexDef.accessorName!] = freeze(index) as any;\n    }\n  }\n\n  return freeze(tableView);\n}\n\nfunction* tableIterator<T>(\n  id: u32,\n  deserialize: Deserializer<T>\n): Generator<T, undefined> {\n  using iter = new IteratorHandle(id);\n\n  const iterBuf = takeBuf();\n  try {\n    let amt;\n    while ((amt = iter.advance(iterBuf))) {\n      const reader = new BinaryReader(iterBuf.view);\n      while (reader.offset < amt) {\n        yield deserialize(reader);\n      }\n    }\n  } finally {\n    returnBuf(iterBuf);\n  }\n}\n\nfunction tableIterateOne<T>(id: u32, deserialize: Deserializer<T>): T | null {\n  const buf = LEAF_BUF;\n  // we only need to check for the `<= 0` case, since this function is only used\n  // with iterators that should only have zero or one element.\n  const ret = advanceIterRaw(id, buf);\n  if (ret !== 0) {\n    BINARY_READER.reset(buf.view);\n    return deserialize(BINARY_READER);\n  }\n  return null;\n}\n\n/**\n * `ret < 0` means the iterator yielded elements but is now exhausted and has been destroyed.\n * `ret === 0` means the iterator was empty and has been destroyed.\n * `ret > 0` means the iterator yielded elements and has more to give.\n */\nfunction advanceIterRaw(id: u32, buf: ResizableBuffer): number {\n  while (true) {\n    try {\n      return 0 | sys.row_iter_bsatn_advance(id, buf.buffer);\n    } catch (e) {\n      if (e && typeof e === 'object' && hasOwn(e, '__buffer_too_small__')) {\n        buf.grow(e.__buffer_too_small__ as number);\n        continue;\n      }\n      throw e;\n    }\n  }\n}\n\n// This should guarantee in most cases that we don't have to reallocate an iterator\n// buffer, unless there's a single row that serializes to >1 MiB.\nconst DEFAULT_BUFFER_CAPACITY = 32 * 1024 * 2;\n\nconst ITER_BUFS: ResizableBuffer[] = [\n  new ResizableBuffer(DEFAULT_BUFFER_CAPACITY),\n];\nlet ITER_BUF_COUNT = 1;\n\nfunction takeBuf(): ResizableBuffer {\n  return ITER_BUF_COUNT\n    ? ITER_BUFS[--ITER_BUF_COUNT]\n    : new ResizableBuffer(DEFAULT_BUFFER_CAPACITY);\n}\n\nfunction returnBuf(buf: ResizableBuffer) {\n  ITER_BUFS[ITER_BUF_COUNT++] = buf;\n}\n\n/**\n * This should only be used from functions that don't need persistent ownership\n * over the buffer. While using this value, one should not call a function that\n * also uses this value.\n */\nconst LEAF_BUF = new ResizableBuffer(DEFAULT_BUFFER_CAPACITY);\n\n/** A class to manage the lifecycle of an iterator handle. */\nclass IteratorHandle implements Disposable {\n  #id: u32 | -1;\n\n  static #finalizationRegistry = new FinalizationRegistry<u32>(\n    sys.row_iter_bsatn_close\n  );\n\n  constructor(id: u32) {\n    this.#id = id;\n    IteratorHandle.#finalizationRegistry.register(this, id, this);\n  }\n\n  /** Unregister this object with the finalization registry and return the id */\n  #detach() {\n    const id = this.#id;\n    this.#id = -1;\n    IteratorHandle.#finalizationRegistry.unregister(this);\n    return id;\n  }\n\n  /** Call `row_iter_bsatn_advance`, returning 0 if this iterator has been exhausted. */\n  advance(buf: ResizableBuffer): number {\n    if (this.#id === -1) return 0;\n    const ret = advanceIterRaw(this.#id, buf);\n    if (ret <= 0) this.#detach();\n    return ret < 0 ? -ret : ret;\n  }\n\n  [Symbol.dispose]() {\n    if (this.#id >= 0) {\n      const id = this.#detach();\n      sys.row_iter_bsatn_close(id);\n    }\n  }\n}\n","import {\n  AlgebraicType,\n  ProductType,\n  type Deserializer,\n  type Serializer,\n} from '../lib/algebraic_type';\nimport { FunctionVisibility } from '../lib/autogen/types';\nimport BinaryReader from '../lib/binary_reader';\nimport BinaryWriter from '../lib/binary_writer';\nimport type { ConnectionId } from '../lib/connection_id';\nimport { Identity } from '../lib/identity';\nimport type { ParamsObj, ReducerCtx } from '../lib/reducers';\nimport { type UntypedSchemaDef } from '../lib/schema';\nimport { Timestamp } from '../lib/timestamp';\nimport {\n  type Infer,\n  type InferTypeOfRow,\n  type TypeBuilder,\n} from '../lib/type_builders';\nimport { bsatnBaseSize } from '../lib/util';\nimport { Uuid } from '../lib/uuid';\nimport { httpClient, type HttpClient } from './http_internal';\nimport type { DbView } from './db_view';\nimport { makeRandom, type Random } from './rng';\nimport { callUserFunction, ReducerCtxImpl, sys } from './runtime';\nimport {\n  exportContext,\n  registerExport,\n  type ModuleExport,\n  type SchemaInner,\n} from './schema';\n\nexport type ProcedureExport<\n  S extends UntypedSchemaDef,\n  Params extends ParamsObj,\n  Ret extends TypeBuilder<any, any>,\n> = ProcedureFn<S, Params, Ret> & ModuleExport;\n\nexport function makeProcedureExport<\n  S extends UntypedSchemaDef,\n  Params extends ParamsObj,\n  Ret extends TypeBuilder<any, any>,\n>(\n  ctx: SchemaInner,\n  opts: ProcedureOpts | undefined,\n  params: Params,\n  ret: Ret,\n  fn: ProcedureFn<S, Params, Ret>\n): ProcedureExport<S, Params, Ret> {\n  const name = opts?.name;\n\n  const procedureExport: ProcedureExport<S, Params, Ret> = (...args) =>\n    fn(...args);\n  procedureExport[exportContext] = ctx;\n  procedureExport[registerExport] = (ctx, exportName) => {\n    registerProcedure(ctx, name ?? exportName, params, ret, fn);\n    ctx.functionExports.set(\n      procedureExport as ProcedureExport<any, any, any>,\n      name ?? exportName\n    );\n  };\n\n  return procedureExport;\n}\n\nexport type ProcedureFn<\n  S extends UntypedSchemaDef,\n  Params extends ParamsObj,\n  Ret extends TypeBuilder<any, any>,\n> = (ctx: ProcedureCtx<S>, args: InferTypeOfRow<Params>) => Infer<Ret>;\n\nexport interface ProcedureOpts {\n  name: string;\n}\n\nexport interface ProcedureCtx<S extends UntypedSchemaDef> {\n  readonly sender: Identity;\n  readonly identity: Identity;\n  readonly timestamp: Timestamp;\n  readonly connectionId: ConnectionId | null;\n  readonly http: HttpClient;\n  readonly random: Random;\n  withTx<T>(body: (ctx: TransactionCtx<S>) => T): T;\n  newUuidV4(): Uuid;\n  newUuidV7(): Uuid;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-object-type\nexport interface TransactionCtx<S extends UntypedSchemaDef>\n  extends ReducerCtx<S> {}\n\ntype ITransactionCtx<S extends UntypedSchemaDef> = TransactionCtx<S>;\n\nconst TransactionCtxImpl = class TransactionCtx<S extends UntypedSchemaDef>\n  extends ReducerCtxImpl<S>\n  implements ITransactionCtx<S> {};\n\nfunction registerProcedure<\n  S extends UntypedSchemaDef,\n  Params extends ParamsObj,\n  Ret extends TypeBuilder<any, any>,\n>(\n  ctx: SchemaInner,\n  exportName: string,\n  params: Params,\n  ret: Ret,\n  fn: ProcedureFn<S, Params, Ret>,\n  opts?: ProcedureOpts\n) {\n  ctx.defineFunction(exportName);\n  const paramsType: ProductType = {\n    elements: Object.entries(params).map(([n, c]) => ({\n      name: n,\n      algebraicType: ctx.registerTypesRecursively(\n        'typeBuilder' in c ? c.typeBuilder : c\n      ).algebraicType,\n    })),\n  };\n  const returnType = ctx.registerTypesRecursively(ret).algebraicType;\n\n  ctx.moduleDef.procedures.push({\n    sourceName: exportName,\n    params: paramsType,\n    returnType,\n    visibility: FunctionVisibility.ClientCallable,\n  });\n\n  if (opts?.name != null) {\n    ctx.moduleDef.explicitNames.entries.push({\n      tag: 'Function',\n      value: {\n        sourceName: exportName,\n        canonicalName: opts.name,\n      },\n    });\n  }\n  const { typespace } = ctx;\n\n  ctx.procedures.push({\n    fn,\n    deserializeArgs: ProductType.makeDeserializer(paramsType, typespace),\n    serializeReturn: AlgebraicType.makeSerializer(returnType, typespace),\n    returnTypeBaseSize: bsatnBaseSize(typespace, returnType),\n  });\n}\n\nexport type Procedures = Array<{\n  fn: ProcedureFn<any, any, any>;\n  deserializeArgs: Deserializer<any>;\n  serializeReturn: Serializer<any>;\n  returnTypeBaseSize: number;\n}>;\n\nexport function callProcedure(\n  moduleCtx: SchemaInner,\n  id: number,\n  sender: Identity,\n  connectionId: ConnectionId | null,\n  timestamp: Timestamp,\n  argsBuf: Uint8Array,\n  dbView: () => DbView<any>\n): Uint8Array {\n  const { fn, deserializeArgs, serializeReturn, returnTypeBaseSize } =\n    moduleCtx.procedures[id];\n  const args = deserializeArgs(new BinaryReader(argsBuf));\n\n  const ctx: ProcedureCtx<UntypedSchemaDef> = new ProcedureCtxImpl(\n    sender,\n    timestamp,\n    connectionId,\n    dbView\n  );\n\n  const ret = callUserFunction(fn, ctx, args);\n  const retBuf = new BinaryWriter(returnTypeBaseSize);\n  serializeReturn(retBuf, ret);\n  return retBuf.getBuffer();\n}\n\ntype IProcedureCtx<S extends UntypedSchemaDef> = ProcedureCtx<S>;\nconst ProcedureCtxImpl = class ProcedureCtx<S extends UntypedSchemaDef>\n  implements IProcedureCtx<S>\n{\n  #identity: Identity | undefined;\n  #uuidCounter: { value: 0 } | undefined;\n  #random: Random | undefined;\n  #dbView: () => DbView<any>;\n\n  constructor(\n    readonly sender: Identity,\n    readonly timestamp: Timestamp,\n    readonly connectionId: ConnectionId | null,\n    dbView: () => DbView<any>\n  ) {\n    this.#dbView = dbView;\n  }\n\n  get identity() {\n    return (this.#identity ??= new Identity(sys.identity()));\n  }\n\n  get random() {\n    return (this.#random ??= makeRandom(this.timestamp));\n  }\n\n  get http() {\n    return httpClient;\n  }\n\n  withTx<T>(body: (ctx: TransactionCtx<S>) => T): T {\n    const run = () => {\n      const timestamp = sys.procedure_start_mut_tx();\n\n      try {\n        const ctx: TransactionCtx<S> = new TransactionCtxImpl(\n          this.sender,\n          new Timestamp(timestamp),\n          this.connectionId,\n          this.#dbView()\n        );\n        return body(ctx);\n      } catch (e) {\n        sys.procedure_abort_mut_tx();\n        throw e;\n      }\n    };\n\n    let res = run();\n    try {\n      sys.procedure_commit_mut_tx();\n      return res;\n    } catch {\n      // ignore the commit error\n    }\n    console.warn('committing anonymous transaction failed');\n    res = run();\n    try {\n      sys.procedure_commit_mut_tx();\n      return res;\n    } catch (e) {\n      throw new Error('transaction retry failed again', { cause: e });\n    }\n  }\n\n  newUuidV4(): Uuid {\n    const bytes = this.random.fill(new Uint8Array(16));\n    return Uuid.fromRandomBytesV4(bytes);\n  }\n\n  newUuidV7(): Uuid {\n    const bytes = this.random.fill(new Uint8Array(4));\n    const counter = (this.#uuidCounter ??= { value: 0 });\n    return Uuid.fromCounterV7(counter, this.timestamp, bytes);\n  }\n};\n","import { AlgebraicType } from '../lib/algebraic_type';\nimport { FunctionVisibility, type Lifecycle } from '../lib/autogen/types';\nimport type { ParamsObj, Reducer } from '../lib/reducers';\nimport { type UntypedSchemaDef } from '../lib/schema';\nimport { RowBuilder, type RowObj } from '../lib/type_builders';\nimport { toPascalCase } from '../lib/util';\nimport {\n  exportContext,\n  registerExport,\n  type ModuleExport,\n  type SchemaInner,\n} from './schema';\n\nexport interface ReducerExport<\n  S extends UntypedSchemaDef,\n  Params extends ParamsObj,\n> extends Reducer<S, Params>,\n    ModuleExport {}\n\nexport interface ReducerOpts {\n  name: string;\n}\n\nexport function makeReducerExport<\n  S extends UntypedSchemaDef,\n  Params extends ParamsObj,\n>(\n  ctx: SchemaInner,\n  opts: ReducerOpts | undefined,\n  params: RowObj | RowBuilder<RowObj>,\n  fn: Reducer<any, any>,\n  lifecycle?: Lifecycle\n): ReducerExport<S, Params> {\n  const reducerExport: ReducerExport<S, Params> = (...args) => fn(...args);\n  reducerExport[exportContext] = ctx;\n  reducerExport[registerExport] = (ctx, exportName) => {\n    registerReducer(ctx, exportName, params, fn, opts, lifecycle);\n    ctx.functionExports.set(\n      reducerExport as ReducerExport<any, any>,\n      exportName\n    );\n  };\n\n  return reducerExport;\n}\n\n/**\n * internal: pushReducer() helper used by reducer() and lifecycle wrappers\n *\n * @param name - The name of the reducer.\n * @param params - The parameters for the reducer.\n * @param fn - The reducer function.\n * @param lifecycle - Optional lifecycle hooks for the reducer.\n */\nexport function registerReducer(\n  ctx: SchemaInner,\n  exportName: string,\n  params: RowObj | RowBuilder<RowObj>,\n  fn: Reducer<any, any>,\n  opts?: ReducerOpts,\n  lifecycle?: Lifecycle\n): void {\n  ctx.defineFunction(exportName);\n\n  if (!(params instanceof RowBuilder)) {\n    params = new RowBuilder(params);\n  }\n\n  if (params.typeName === undefined) {\n    params.typeName = toPascalCase(exportName);\n  }\n\n  const ref = ctx.registerTypesRecursively(params);\n  const paramsType = ctx.resolveType(ref).value;\n  const isLifecycle = lifecycle != null;\n\n  ctx.moduleDef.reducers.push({\n    sourceName: exportName,\n    params: paramsType,\n    //ModuleDef validation code is responsible to mark private reducers\n    visibility: FunctionVisibility.ClientCallable,\n    //Hardcoded for now - reducers do not return values yet\n    okReturnType: AlgebraicType.Product({ elements: [] }),\n    errReturnType: AlgebraicType.String,\n  });\n\n  if (opts?.name != null) {\n    ctx.moduleDef.explicitNames.entries.push({\n      tag: 'Function',\n      value: {\n        sourceName: exportName,\n        canonicalName: opts.name,\n      },\n    });\n  }\n\n  if (isLifecycle) {\n    ctx.moduleDef.lifeCycleReducers.push({\n      lifecycleSpec: lifecycle,\n      functionName: exportName,\n    });\n  }\n\n  // If the function isn't named (e.g. `function foobar() {}`), give it the same\n  // name as the reducer so that it's clear what it is in in backtraces.\n  if (!fn.name) {\n    Object.defineProperty(fn, 'name', { value: exportName, writable: false });\n  }\n\n  ctx.reducers.push(fn);\n}\n\nexport type Reducers = Reducer<any, any>[];\n","import { moduleHooks, type ModuleDefaultExport } from 'spacetime:sys@2.0';\nimport { CaseConversionPolicy, Lifecycle } from '../lib/autogen/types';\nimport {\n  type ParamsAsObject,\n  type ParamsObj,\n  type Reducer,\n  type ReducerCtx,\n} from '../lib/reducers';\nimport {\n  ModuleContext,\n  tableToSchema,\n  type TablesToSchema,\n  type UntypedSchemaDef,\n} from '../lib/schema';\nimport type { UntypedTableSchema } from '../lib/table_schema';\nimport { ColumnBuilder, TypeBuilder } from '../lib/type_builders';\nimport {\n  makeProcedureExport,\n  type ProcedureExport,\n  type ProcedureFn,\n  type ProcedureOpts,\n  type Procedures,\n} from './procedures';\nimport {\n  makeReducerExport,\n  type ReducerExport,\n  type ReducerOpts,\n  type Reducers,\n} from './reducers';\nimport { makeHooks } from './runtime';\n\nimport {\n  makeAnonViewExport,\n  makeViewExport,\n  type AnonViews,\n  type AnonymousViewFn,\n  type ViewExport,\n  type ViewFn,\n  type ViewOpts,\n  type ViewReturnTypeBuilder,\n  type Views,\n} from './views';\nimport type { UntypedTableDef } from '../lib/table';\n\nexport class SchemaInner<\n  S extends UntypedSchemaDef = UntypedSchemaDef,\n> extends ModuleContext {\n  schemaType: S;\n  existingFunctions = new Set<string>();\n  reducers: Reducers = [];\n  procedures: Procedures = [];\n  views: Views = [];\n  anonViews: AnonViews = [];\n  /**\n   * Maps ReducerExport objects to the name of the reducer.\n   * Used for resolving the reducers of scheduled tables.\n   */\n  functionExports: Map<\n    | ReducerExport<UntypedSchemaDef, any>\n    | ProcedureExport<UntypedSchemaDef, any, any>,\n    string\n  > = new Map();\n  pendingSchedules: PendingSchedule[] = [];\n\n  constructor(getSchemaType: (ctx: SchemaInner<S>) => S) {\n    super();\n    this.schemaType = getSchemaType(this);\n  }\n\n  defineFunction(name: string) {\n    if (this.existingFunctions.has(name)) {\n      throw new TypeError(\n        `There is already a reducer or procedure with the name '${name}'`\n      );\n    }\n    this.existingFunctions.add(name);\n  }\n\n  resolveSchedules() {\n    for (const { reducer, scheduleAtCol, tableName } of this.pendingSchedules) {\n      const functionName = this.functionExports.get(reducer());\n      if (functionName === undefined) {\n        const msg = `Table ${tableName} defines a schedule, but it seems like the associated function was not exported.`;\n        throw new TypeError(msg);\n      }\n      this.moduleDef.schedules.push({\n        sourceName: undefined,\n        tableName,\n        scheduleAtCol,\n        functionName,\n      });\n    }\n  }\n}\n\ntype PendingSchedule = UntypedTableSchema['schedule'] & { tableName: string };\n\n/**\n * The Schema class represents the database schema for a SpacetimeDB application.\n * It encapsulates the table definitions and typespace, and provides methods to define\n * reducers and lifecycle hooks.\n *\n * Schema has a generic parameter S which represents the inferred schema type. This type\n * is automatically inferred when creating a schema using the `schema()` function and is\n * used to type the database view in reducer contexts.\n *\n * The methods on this class are used to register reducers and lifecycle hooks\n * with the SpacetimeDB runtime. Theey forward to free functions that handle the actual\n * registration logic, but having them as methods on the Schema class helps with type inference.\n *\n * @template S - The inferred schema type of the SpacetimeDB module.\n *\n * @example\n * ```typescript\n * const spacetimedb = schema({\n *   user: table({}, userType),\n *   post: table({}, postType)\n * });\n * spacetimedb.reducer(\n *   'create_user',\n *   {  username: t.string(), email: t.string() },\n *   (ctx, { username, email }) => {\n *     ctx.db.user.insert({ username, email, created_at: ctx.timestamp });\n *     console.log(`User ${username} created by ${ctx.sender.identityId}`);\n *   }\n * );\n * ```\n */\n// TODO(cloutiertyler): It might be nice to have a way to access the types\n// for the tables from the schema object, e.g. `spacetimedb.user.type` would\n// be the type of the user table.\nexport class Schema<S extends UntypedSchemaDef> implements ModuleDefaultExport {\n  #ctx: SchemaInner<S>;\n\n  constructor(ctx: SchemaInner<S>) {\n    // TODO: TableSchema and TableDef should really be unified\n    this.#ctx = ctx;\n  }\n\n  [moduleHooks](exports: object) {\n    // if (!(hasOwn(exports, 'default') && exports.default instanceof Schema)) {\n    //   throw new TypeError('must export schema as default export');\n    // }\n    const registeredSchema = this.#ctx;\n    for (const [name, moduleExport] of Object.entries(exports)) {\n      if (name === 'default') continue;\n      if (!isModuleExport(moduleExport)) {\n        throw new TypeError(\n          'exporting something that is not a spacetime export'\n        );\n      }\n      checkExportContext(moduleExport, registeredSchema);\n      moduleExport[registerExport](registeredSchema, name);\n    }\n    registeredSchema.resolveSchedules();\n    return makeHooks(registeredSchema);\n  }\n\n  get schemaType(): S {\n    return this.#ctx.schemaType;\n  }\n\n  get moduleDef() {\n    return this.#ctx.moduleDef;\n  }\n\n  get typespace() {\n    return this.#ctx.typespace;\n  }\n\n  /**\n   * Defines a SpacetimeDB reducer function.\n   *\n   * Reducers are the primary way to modify the state of your SpacetimeDB application.\n   * They are atomic, meaning that either all operations within a reducer succeed,\n   * or none of them do.\n   *\n   * @template S - The inferred schema type of the SpacetimeDB module.\n   * @template Params - The type of the parameters object expected by the reducer.\n   *\n   * @param {Params} params - An object defining the parameters that the reducer accepts.\n   *                          Each key-value pair represents a parameter name and its corresponding\n   *                          {@link TypeBuilder} or {@link ColumnBuilder}.\n   * @param {(ctx: ReducerCtx<S>, payload: ParamsAsObject<Params>) => void} fn - The reducer function itself.\n   *   - `ctx`: The reducer context, providing access to `sender`, `timestamp`, `connection_id`, and `db`.\n   *   - `payload`: An object containing the arguments passed to the reducer, typed according to `params`.\n   *\n   * @example\n   * ```typescript\n   * // Define a reducer named 'create_user' that takes 'username' (string) and 'email' (string)\n   * export const create_user = spacetime.reducer(\n   *   {\n   *     username: t.string(),\n   *     email: t.string(),\n   *   },\n   *   (ctx, { username, email }) => {\n   *     // Access the 'user' table from the database view in the context\n   *     ctx.db.user.insert({ username, email, created_at: ctx.timestamp });\n   *     console.log(`User ${username} created by ${ctx.sender.identityId}`);\n   *   }\n   * );\n   * ```\n   */\n  reducer<Params extends ParamsObj>(\n    params: Params,\n    fn: Reducer<S, Params>\n  ): ReducerExport<S, Params>;\n  reducer(fn: Reducer<S, {}>): ReducerExport<S, {}>;\n  reducer<Params extends ParamsObj>(\n    opts: ReducerOpts,\n    params: Params,\n    fn: Reducer<S, Params>\n  ): ReducerExport<S, Params>;\n  reducer(opts: ReducerOpts, fn: Reducer<S, {}>): ReducerExport<S, {}>;\n  reducer<Params extends ParamsObj>(\n    ...args:\n      | [Params, Reducer<S, Params>]\n      | [Reducer<S, {}>]\n      | [ReducerOpts, Params, Reducer<S, Params>]\n      | [ReducerOpts, Reducer<S, {}>]\n  ): ReducerExport<S, Params> {\n    let opts: ReducerOpts | undefined,\n      params: Params = {} as Params,\n      fn: Reducer<S, Params>;\n    switch (args.length) {\n      case 1:\n        [fn] = args;\n        break;\n      case 2: {\n        let arg1;\n        [arg1, fn] = args;\n        if (typeof arg1.name === 'string') opts = arg1 as ReducerOpts;\n        else params = arg1 as Params;\n        break;\n      }\n      case 3:\n        [opts, params, fn] = args;\n        break;\n    }\n    return makeReducerExport(this.#ctx, opts, params, fn);\n  }\n\n  /**\n   * Registers an initialization reducer that runs when the SpacetimeDB module is published\n   * for the first time.\n   *\n   * This function is useful to set up any initial state of your database that is guaranteed\n   * to run only once, and before any other reducers or client connections.\n   *\n   * @template S - The inferred schema type of the SpacetimeDB module.\n   * @param {Reducer<S, {}>} fn - The initialization reducer function.\n   *  - `ctx`: The reducer context, providing access to `sender`, `timestamp`, `connection_id`, and `db`.\n   * @example\n   * ```typescript\n   * export const init = spacetime.init((ctx) => {\n   *   ctx.db.user.insert({ username: 'admin', email: 'admin@example.com' });\n   * });\n   * ```\n   */\n  init(fn: Reducer<S, {}>): ReducerExport<S, {}>;\n  init(opts: ReducerOpts, fn: Reducer<S, {}>): ReducerExport<S, {}>;\n  init(\n    ...args: [Reducer<S, {}>] | [ReducerOpts, Reducer<S, {}>]\n  ): ReducerExport<S, {}> {\n    let opts: ReducerOpts | undefined, fn: Reducer<S, {}>;\n    switch (args.length) {\n      case 1:\n        [fn] = args;\n        break;\n      case 2:\n        [opts, fn] = args;\n        break;\n    }\n    return makeReducerExport(this.#ctx, opts, {}, fn, Lifecycle.Init);\n  }\n\n  /**\n   * Registers a reducer to be called when a client connects to the SpacetimeDB module.\n   * This function allows you to define custom logic that should execute\n   * whenever a new client establishes a connection.\n   * @template S - The inferred schema type of the SpacetimeDB module.\n   *\n   * @param fn - The reducer function to execute on client connection.\n   *\n   * @example\n   * ```typescript\n   * export const onConnect = spacetime.clientConnected(\n   *   (ctx) => {\n   *     console.log(`Client ${ctx.connectionId} connected`);\n   *   }\n   * );\n   */\n  clientConnected(fn: Reducer<S, {}>): ReducerExport<S, {}>;\n  clientConnected(opts: ReducerOpts, fn: Reducer<S, {}>): ReducerExport<S, {}>;\n  clientConnected(\n    ...args: [Reducer<S, {}>] | [ReducerOpts, Reducer<S, {}>]\n  ): ReducerExport<S, {}> {\n    let opts: ReducerOpts | undefined, fn: Reducer<S, {}>;\n    switch (args.length) {\n      case 1:\n        [fn] = args;\n        break;\n      case 2:\n        [opts, fn] = args;\n        break;\n    }\n    return makeReducerExport(this.#ctx, opts, {}, fn, Lifecycle.OnConnect);\n  }\n\n  /**\n   * Registers a reducer to be called when a client disconnects from the SpacetimeDB module.\n   * This function allows you to define custom logic that should execute\n   * whenever a client disconnects.\n   * @template S - The inferred schema type of the SpacetimeDB module.\n   *\n   * @param fn - The reducer function to execute on client disconnection.\n   *\n   * @example\n   * ```typescript\n   * export const onDisconnect = spacetime.clientDisconnected(\n   *   (ctx) => {\n   *     console.log(`Client ${ctx.connectionId} disconnected`);\n   *   }\n   * );\n   * ```\n   */\n  clientDisconnected(fn: Reducer<S, {}>): ReducerExport<S, {}>;\n  clientDisconnected(\n    opts: ReducerOpts,\n    fn: Reducer<S, {}>\n  ): ReducerExport<S, {}>;\n  clientDisconnected(\n    ...args: [Reducer<S, {}>] | [ReducerOpts, Reducer<S, {}>]\n  ): ReducerExport<S, {}> {\n    let opts: ReducerOpts | undefined, fn: Reducer<S, {}>;\n    switch (args.length) {\n      case 1:\n        [fn] = args;\n        break;\n      case 2:\n        [opts, fn] = args;\n        break;\n    }\n    return makeReducerExport(this.#ctx, opts, {}, fn, Lifecycle.OnDisconnect);\n  }\n\n  view<Ret extends ViewReturnTypeBuilder, F extends ViewFn<S, {}, Ret>>(\n    opts: ViewOpts,\n    ret: Ret,\n    fn: F\n  ): ViewExport<F> {\n    return makeViewExport<S, {}, Ret, F>(this.#ctx, opts, {}, ret, fn);\n  }\n\n  // TODO: re-enable once parameterized views are supported in SQL\n  // view<Ret extends ViewReturnTypeBuilder>(\n  //   opts: ViewOpts,\n  //   ret: Ret,\n  //   fn: ViewFn<S, {}, Ret>\n  // ): void;\n  // view<Params extends ParamsObj, Ret extends ViewReturnTypeBuilder>(\n  //   opts: ViewOpts,\n  //   params: Params,\n  //   ret: Ret,\n  //   fn: ViewFn<S, {}, Ret>\n  // ): void;\n  // view<Params extends ParamsObj, Ret extends ViewReturnTypeBuilder>(\n  //   opts: ViewOpts,\n  //   paramsOrRet: Ret | Params,\n  //   retOrFn: ViewFn<S, {}, Ret> | Ret,\n  //   maybeFn?: ViewFn<S, Params, Ret>\n  // ): void {\n  //   if (typeof retOrFn === 'function') {\n  //     defineView(name, false, {}, paramsOrRet as Ret, retOrFn);\n  //   } else {\n  //     defineView(name, false, paramsOrRet as Params, retOrFn, maybeFn!);\n  //   }\n  // }\n\n  anonymousView<\n    Ret extends ViewReturnTypeBuilder,\n    F extends AnonymousViewFn<S, {}, Ret>,\n  >(opts: ViewOpts, ret: Ret, fn: F): ViewExport<F> {\n    return makeAnonViewExport<S, {}, Ret, F>(this.#ctx, opts, {}, ret, fn);\n  }\n\n  // TODO: re-enable once parameterized views are supported in SQL\n  // anonymousView<Ret extends ViewReturnTypeBuilder>(\n  //   opts: ViewOpts,\n  //   ret: Ret,\n  //   fn: AnonymousViewFn<S, {}, Ret>\n  // ): void;\n  // anonymousView<Params extends ParamsObj, Ret extends ViewReturnTypeBuilder>(\n  //   opts: ViewOpts,\n  //   params: Params,\n  //   ret: Ret,\n  //   fn: AnonymousViewFn<S, {}, Ret>\n  // ): void;\n  // anonymousView<Params extends ParamsObj, Ret extends ViewReturnTypeBuilder>(\n  //   opts: ViewOpts,\n  //   paramsOrRet: Ret | Params,\n  //   retOrFn: AnonymousViewFn<S, {}, Ret> | Ret,\n  //   maybeFn?: AnonymousViewFn<S, Params, Ret>\n  // ): void {\n  //   if (typeof retOrFn === 'function') {\n  //     defineView(name, true, {}, paramsOrRet as Ret, retOrFn);\n  //   } else {\n  //     defineView(name, true, paramsOrRet as Params, retOrFn, maybeFn!);\n  //   }\n  // }\n\n  procedure<Params extends ParamsObj, Ret extends TypeBuilder<any, any>>(\n    params: Params,\n    ret: Ret,\n    fn: ProcedureFn<S, Params, Ret>\n  ): ProcedureFn<S, Params, Ret>;\n  procedure<Ret extends TypeBuilder<any, any>>(\n    ret: Ret,\n    fn: ProcedureFn<S, {}, Ret>\n  ): ProcedureFn<S, {}, Ret>;\n  procedure<Params extends ParamsObj, Ret extends TypeBuilder<any, any>>(\n    opts: ProcedureOpts,\n    params: Params,\n    ret: Ret,\n    fn: ProcedureFn<S, Params, Ret>\n  ): ProcedureFn<S, Params, Ret>;\n  procedure<Ret extends TypeBuilder<any, any>>(\n    opts: ProcedureOpts,\n    ret: Ret,\n    fn: ProcedureFn<S, {}, Ret>\n  ): ProcedureFn<S, {}, Ret>;\n  procedure<Params extends ParamsObj, Ret extends TypeBuilder<any, any>>(\n    ...args:\n      | [Params, Ret, ProcedureFn<S, Params, Ret>]\n      | [Ret, ProcedureFn<S, Params, Ret>]\n      | [ProcedureOpts, Params, Ret, ProcedureFn<S, Params, Ret>]\n      | [ProcedureOpts, Ret, ProcedureFn<S, Params, Ret>]\n  ): ProcedureExport<S, Params, Ret> {\n    let opts: ProcedureOpts | undefined,\n      params: Params = {} as Params,\n      ret: Ret,\n      fn: ProcedureFn<S, Params, Ret>;\n    switch (args.length) {\n      case 2:\n        [ret, fn] = args;\n        break;\n      case 3: {\n        let arg1;\n        [arg1, ret, fn] = args;\n        if (typeof arg1.name === 'string') opts = arg1 as ProcedureOpts;\n        else params = arg1 as Params;\n        break;\n      }\n      case 4:\n        [opts, params, ret, fn] = args;\n        break;\n    }\n    return makeProcedureExport(this.#ctx, opts, params, ret, fn);\n  }\n\n  /**\n   * Bundle multiple reducers, procedures, etc into one value to export.\n   * The name they will be exported with is their corresponding key in the `exports` argument.\n   */\n  exportGroup(exports: Record<string, ModuleExport>): ModuleExport {\n    return {\n      [exportContext]: this.#ctx,\n      [registerExport](ctx, _exportName) {\n        for (const [exportName, moduleExport] of Object.entries(exports)) {\n          checkExportContext(moduleExport, ctx);\n          moduleExport[registerExport](ctx, exportName);\n        }\n      },\n    };\n  }\n\n  clientVisibilityFilter = {\n    sql: (filter: string): ModuleExport => ({\n      [exportContext]: this.#ctx,\n      [registerExport](ctx, _exportName) {\n        ctx.moduleDef.rowLevelSecurity.push({ sql: filter });\n      },\n    }),\n  };\n}\n\nexport const registerExport = Symbol('SpacetimeDB.registerExport');\nexport const exportContext = Symbol('SpacetimeDB.exportContext');\n\nexport interface ModuleExport {\n  [registerExport](ctx: SchemaInner, exportName: string): void;\n  [exportContext]?: SchemaInner;\n}\n\nfunction isModuleExport(x: unknown): x is ModuleExport {\n  return (\n    (typeof x === 'function' || typeof x === 'object') &&\n    x !== null &&\n    registerExport in x\n  );\n}\n\n/** Verify that the ModuleContext that `exp` comes from is the same as `schema` */\nfunction checkExportContext(exp: ModuleExport, schema: SchemaInner) {\n  if (exp[exportContext] != null && exp[exportContext] !== schema) {\n    throw new TypeError('multiple schemas are not supported');\n  }\n}\n\n/**\n * Extracts the inferred schema type from a Schema instance\n */\nexport type InferSchema<SchemaDef extends Schema<any>> =\n  SchemaDef extends Schema<infer S> ? S : never;\n\n/**\n * Creates a schema from table definitions\n * @param handles - Array of table handles created by table() function\n * @returns ColumnBuilder representing the complete database schema\n * @example\n * ```ts\n * const spacetimedb = schema({\n *   user: table({}, userType),\n *   post: table({}, postType)\n * });\n * ```\n */\n/**\n * Module-level settings that can be passed to `schema()`.\n */\nexport interface ModuleSettings {\n  /**\n   * The case conversion policy for this module.\n   * Defaults to `SnakeCase` if not specified.\n   *\n   * @example\n   * ```ts\n   * export default schema({\n   *   player,\n   * }, { CASE_CONVERSION_POLICY: CaseConversionPolicy.None });\n   * ```\n   */\n  CASE_CONVERSION_POLICY?: CaseConversionPolicy;\n}\n\nexport function schema<const H extends Record<string, UntypedTableSchema>>(\n  tables: H,\n  moduleSettings?: ModuleSettings\n): Schema<TablesToSchema<H>> {\n  const ctx = new SchemaInner<TablesToSchema<H>>(ctx => {\n    // Apply module settings.\n    if (moduleSettings?.CASE_CONVERSION_POLICY != null) {\n      ctx.setCaseConversionPolicy(moduleSettings.CASE_CONVERSION_POLICY);\n    }\n\n    const tableSchemas: Record<string, UntypedTableDef> = {};\n    for (const [accName, table] of Object.entries(tables)) {\n      const tableDef = table.tableDef(ctx, accName);\n      tableSchemas[accName] = tableToSchema(accName, table, tableDef);\n      ctx.moduleDef.tables.push(tableDef);\n      if (table.schedule) {\n        ctx.pendingSchedules.push({\n          ...table.schedule,\n          tableName: tableDef.sourceName,\n        });\n      }\n      if (table.tableName) {\n        ctx.moduleDef.explicitNames.entries.push({\n          tag: 'Table',\n          value: {\n            sourceName: accName,\n            canonicalName: table.tableName,\n          },\n        });\n      }\n    }\n    return { tables: tableSchemas } as TablesToSchema<H>;\n  });\n\n  return new Schema(ctx);\n}\n","import type { u32 } from 'spacetime:sys@2.0';\nimport { sys } from './runtime';\nimport inspect from 'object-inspect';\n\nconst fmtLog = (...data: any[]) =>\n  data.map(x => (typeof x === 'string' ? x : inspect(x))).join(' ');\n\nconst console_level_error = 0;\nconst console_level_warn = 1;\nconst console_level_info = 2;\nconst console_level_debug = 3;\nconst console_level_trace = 4;\nconst _console_level_panic = 101;\n\nconst timerMap = new Map<string, u32>();\n\nexport const console: Console = {\n  // @ts-expect-error we want a blank prototype, but typescript complains\n  __proto__: {},\n  [Symbol.toStringTag]: 'console',\n  assert: (condition = false, ...data: any[]) => {\n    if (!condition) {\n      sys.console_log(console_level_error, fmtLog(...data));\n    }\n  },\n  clear: () => {},\n  debug: (...data: any[]) => {\n    sys.console_log(console_level_debug, fmtLog(...data));\n  },\n  error: (...data: any[]) => {\n    sys.console_log(console_level_error, fmtLog(...data));\n  },\n  info: (...data: any[]) => {\n    sys.console_log(console_level_info, fmtLog(...data));\n  },\n  log: (...data: any[]) => {\n    sys.console_log(console_level_info, fmtLog(...data));\n  },\n  table: (tabularData: any, _properties: any) => {\n    sys.console_log(console_level_info, fmtLog(tabularData));\n  },\n  trace: (...data: any[]) => {\n    sys.console_log(console_level_trace, fmtLog(...data));\n  },\n  warn: (...data: any[]) => {\n    sys.console_log(console_level_warn, fmtLog(...data));\n  },\n  dir: (_item: any, _options: any) => {},\n  dirxml: (..._data: any[]) => {},\n  // Counting\n  count: (_label = 'default') => {},\n  countReset: (_label = 'default') => {},\n  // Grouping\n  group: (..._data: any[]) => {},\n  groupCollapsed: (..._data: any[]) => {},\n  groupEnd: () => {},\n  // Timing\n  time: (label = 'default') => {\n    if (timerMap.has(label)) {\n      sys.console_log(console_level_warn, `Timer '${label}' already exists.`);\n      return;\n    }\n    timerMap.set(label, sys.console_timer_start(label));\n  },\n  timeLog: (label = 'default', ...data: any[]) => {\n    sys.console_log(console_level_info, fmtLog(label, ...data));\n  },\n  timeEnd: (label = 'default') => {\n    const spanId = timerMap.get(label);\n    if (spanId === undefined) {\n      sys.console_log(console_level_warn, `Timer '${label}' does not exist.`);\n      return;\n    }\n    sys.console_timer_end(spanId);\n    timerMap.delete(label);\n  },\n  // Additional console methods to satisfy the Console interface\n  timeStamp: () => {},\n  profile: () => {},\n  profileEnd: () => {},\n};\n","import 'url-polyfill';\nimport { console } from './console';\n\nglobalThis.console = console;\n"]}