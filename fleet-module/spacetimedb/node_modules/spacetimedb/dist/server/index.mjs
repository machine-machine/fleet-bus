import * as _syscalls2_0 from 'spacetime:sys@2.0';
import { moduleHooks } from 'spacetime:sys@2.0';
import { headersToList, Headers } from 'headers-polyfill';

typeof globalThis!=="undefined"&&((globalThis.global=globalThis.global||globalThis),(globalThis.window=globalThis.window||globalThis));
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  __defProp(target, "default", { value: mod, enumerable: true }) ,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// ../../node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js
var require_base64_js = __commonJS({
  "../../node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js"(exports) {
    exports.byteLength = byteLength;
    exports.toByteArray = toByteArray;
    exports.fromByteArray = fromByteArray2;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i];
      revLookup[code.charCodeAt(i)] = i;
    }
    var i;
    var len;
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1) validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i2;
      for (i2 = 0; i2 < len2; i2 += 4) {
        tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i2 = start; i2 < end; i2 += 3) {
        tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray2(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
        );
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
        );
      }
      return parts.join("");
    }
  }
});

// ../../node_modules/.pnpm/statuses@2.0.2/node_modules/statuses/codes.json
var require_codes = __commonJS({
  "../../node_modules/.pnpm/statuses@2.0.2/node_modules/statuses/codes.json"(exports, module) {
    module.exports = {
      "100": "Continue",
      "101": "Switching Protocols",
      "102": "Processing",
      "103": "Early Hints",
      "200": "OK",
      "201": "Created",
      "202": "Accepted",
      "203": "Non-Authoritative Information",
      "204": "No Content",
      "205": "Reset Content",
      "206": "Partial Content",
      "207": "Multi-Status",
      "208": "Already Reported",
      "226": "IM Used",
      "300": "Multiple Choices",
      "301": "Moved Permanently",
      "302": "Found",
      "303": "See Other",
      "304": "Not Modified",
      "305": "Use Proxy",
      "307": "Temporary Redirect",
      "308": "Permanent Redirect",
      "400": "Bad Request",
      "401": "Unauthorized",
      "402": "Payment Required",
      "403": "Forbidden",
      "404": "Not Found",
      "405": "Method Not Allowed",
      "406": "Not Acceptable",
      "407": "Proxy Authentication Required",
      "408": "Request Timeout",
      "409": "Conflict",
      "410": "Gone",
      "411": "Length Required",
      "412": "Precondition Failed",
      "413": "Payload Too Large",
      "414": "URI Too Long",
      "415": "Unsupported Media Type",
      "416": "Range Not Satisfiable",
      "417": "Expectation Failed",
      "418": "I'm a Teapot",
      "421": "Misdirected Request",
      "422": "Unprocessable Entity",
      "423": "Locked",
      "424": "Failed Dependency",
      "425": "Too Early",
      "426": "Upgrade Required",
      "428": "Precondition Required",
      "429": "Too Many Requests",
      "431": "Request Header Fields Too Large",
      "451": "Unavailable For Legal Reasons",
      "500": "Internal Server Error",
      "501": "Not Implemented",
      "502": "Bad Gateway",
      "503": "Service Unavailable",
      "504": "Gateway Timeout",
      "505": "HTTP Version Not Supported",
      "506": "Variant Also Negotiates",
      "507": "Insufficient Storage",
      "508": "Loop Detected",
      "509": "Bandwidth Limit Exceeded",
      "510": "Not Extended",
      "511": "Network Authentication Required"
    };
  }
});

// ../../node_modules/.pnpm/statuses@2.0.2/node_modules/statuses/index.js
var require_statuses = __commonJS({
  "../../node_modules/.pnpm/statuses@2.0.2/node_modules/statuses/index.js"(exports, module) {
    var codes = require_codes();
    module.exports = status2;
    status2.message = codes;
    status2.code = createMessageToStatusCodeMap(codes);
    status2.codes = createStatusCodeList(codes);
    status2.redirect = {
      300: true,
      301: true,
      302: true,
      303: true,
      305: true,
      307: true,
      308: true
    };
    status2.empty = {
      204: true,
      205: true,
      304: true
    };
    status2.retry = {
      502: true,
      503: true,
      504: true
    };
    function createMessageToStatusCodeMap(codes2) {
      var map = {};
      Object.keys(codes2).forEach(function forEachCode(code) {
        var message = codes2[code];
        var status3 = Number(code);
        map[message.toLowerCase()] = status3;
      });
      return map;
    }
    function createStatusCodeList(codes2) {
      return Object.keys(codes2).map(function mapCode(code) {
        return Number(code);
      });
    }
    function getStatusCode(message) {
      var msg = message.toLowerCase();
      if (!Object.prototype.hasOwnProperty.call(status2.code, msg)) {
        throw new Error('invalid status message: "' + message + '"');
      }
      return status2.code[msg];
    }
    function getStatusMessage(code) {
      if (!Object.prototype.hasOwnProperty.call(status2.message, code)) {
        throw new Error("invalid status code: " + code);
      }
      return status2.message[code];
    }
    function status2(code) {
      if (typeof code === "number") {
        return getStatusMessage(code);
      }
      if (typeof code !== "string") {
        throw new TypeError("code must be a number or string");
      }
      var n = parseInt(code, 10);
      if (!isNaN(n)) {
        return getStatusMessage(n);
      }
      return getStatusCode(code);
    }
  }
});

// src/util-stub.ts
var util_stub_exports = {};
__export(util_stub_exports, {
  inspect: () => inspect
});
var inspect;
var init_util_stub = __esm({
  "src/util-stub.ts"() {
    inspect = {};
  }
});

// ../../node_modules/.pnpm/object-inspect@1.13.4/node_modules/object-inspect/util.inspect.js
var require_util_inspect = __commonJS({
  "../../node_modules/.pnpm/object-inspect@1.13.4/node_modules/object-inspect/util.inspect.js"(exports, module) {
    module.exports = (init_util_stub(), __toCommonJS(util_stub_exports)).inspect;
  }
});

// ../../node_modules/.pnpm/object-inspect@1.13.4/node_modules/object-inspect/index.js
var require_object_inspect = __commonJS({
  "../../node_modules/.pnpm/object-inspect@1.13.4/node_modules/object-inspect/index.js"(exports, module) {
    var hasMap = typeof Map === "function" && Map.prototype;
    var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
    var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
    var mapForEach = hasMap && Map.prototype.forEach;
    var hasSet = typeof Set === "function" && Set.prototype;
    var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
    var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
    var setForEach = hasSet && Set.prototype.forEach;
    var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
    var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
    var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
    var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
    var hasWeakRef = typeof WeakRef === "function" && WeakRef.prototype;
    var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
    var booleanValueOf = Boolean.prototype.valueOf;
    var objectToString = Object.prototype.toString;
    var functionToString = Function.prototype.toString;
    var $match = String.prototype.match;
    var $slice = String.prototype.slice;
    var $replace = String.prototype.replace;
    var $toUpperCase = String.prototype.toUpperCase;
    var $toLowerCase = String.prototype.toLowerCase;
    var $test = RegExp.prototype.test;
    var $concat = Array.prototype.concat;
    var $join = Array.prototype.join;
    var $arrSlice = Array.prototype.slice;
    var $floor = Math.floor;
    var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
    var gOPS = Object.getOwnPropertySymbols;
    var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
    var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
    var toStringTag = typeof Symbol === "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol") ? Symbol.toStringTag : null;
    var isEnumerable = Object.prototype.propertyIsEnumerable;
    var gPO = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O) {
      return O.__proto__;
    } : null);
    function addNumericSeparator(num, str) {
      if (num === Infinity || num === -Infinity || num !== num || num && num > -1e3 && num < 1e3 || $test.call(/e/, str)) {
        return str;
      }
      var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
      if (typeof num === "number") {
        var int = num < 0 ? -$floor(-num) : $floor(num);
        if (int !== num) {
          var intStr = String(int);
          var dec = $slice.call(str, intStr.length + 1);
          return $replace.call(intStr, sepRegex, "$&_") + "." + $replace.call($replace.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "");
        }
      }
      return $replace.call(str, sepRegex, "$&_");
    }
    var utilInspect = require_util_inspect();
    var inspectCustom = utilInspect.custom;
    var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;
    var quotes = {
      __proto__: null,
      "double": '"',
      single: "'"
    };
    var quoteREs = {
      __proto__: null,
      "double": /(["\\])/g,
      single: /(['\\])/g
    };
    module.exports = function inspect_(obj, options, depth, seen) {
      var opts = options || {};
      if (has(opts, "quoteStyle") && !has(quotes, opts.quoteStyle)) {
        throw new TypeError('option "quoteStyle" must be "single" or "double"');
      }
      if (has(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
        throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
      }
      var customInspect = has(opts, "customInspect") ? opts.customInspect : true;
      if (typeof customInspect !== "boolean" && customInspect !== "symbol") {
        throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
      }
      if (has(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
        throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
      }
      if (has(opts, "numericSeparator") && typeof opts.numericSeparator !== "boolean") {
        throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
      }
      var numericSeparator = opts.numericSeparator;
      if (typeof obj === "undefined") {
        return "undefined";
      }
      if (obj === null) {
        return "null";
      }
      if (typeof obj === "boolean") {
        return obj ? "true" : "false";
      }
      if (typeof obj === "string") {
        return inspectString(obj, opts);
      }
      if (typeof obj === "number") {
        if (obj === 0) {
          return Infinity / obj > 0 ? "0" : "-0";
        }
        var str = String(obj);
        return numericSeparator ? addNumericSeparator(obj, str) : str;
      }
      if (typeof obj === "bigint") {
        var bigIntStr = String(obj) + "n";
        return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
      }
      var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
      if (typeof depth === "undefined") {
        depth = 0;
      }
      if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") {
        return isArray(obj) ? "[Array]" : "[Object]";
      }
      var indent = getIndent(opts, depth);
      if (typeof seen === "undefined") {
        seen = [];
      } else if (indexOf(seen, obj) >= 0) {
        return "[Circular]";
      }
      function inspect3(value, from, noIndent) {
        if (from) {
          seen = $arrSlice.call(seen);
          seen.push(from);
        }
        if (noIndent) {
          var newOpts = {
            depth: opts.depth
          };
          if (has(opts, "quoteStyle")) {
            newOpts.quoteStyle = opts.quoteStyle;
          }
          return inspect_(value, newOpts, depth + 1, seen);
        }
        return inspect_(value, opts, depth + 1, seen);
      }
      if (typeof obj === "function" && !isRegExp(obj)) {
        var name = nameOf(obj);
        var keys = arrObjKeys(obj, inspect3);
        return "[Function" + (name ? ": " + name : " (anonymous)") + "]" + (keys.length > 0 ? " { " + $join.call(keys, ", ") + " }" : "");
      }
      if (isSymbol(obj)) {
        var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj);
        return typeof obj === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
      }
      if (isElement(obj)) {
        var s = "<" + $toLowerCase.call(String(obj.nodeName));
        var attrs = obj.attributes || [];
        for (var i = 0; i < attrs.length; i++) {
          s += " " + attrs[i].name + "=" + wrapQuotes(quote(attrs[i].value), "double", opts);
        }
        s += ">";
        if (obj.childNodes && obj.childNodes.length) {
          s += "...";
        }
        s += "</" + $toLowerCase.call(String(obj.nodeName)) + ">";
        return s;
      }
      if (isArray(obj)) {
        if (obj.length === 0) {
          return "[]";
        }
        var xs = arrObjKeys(obj, inspect3);
        if (indent && !singleLineValues(xs)) {
          return "[" + indentedJoin(xs, indent) + "]";
        }
        return "[ " + $join.call(xs, ", ") + " ]";
      }
      if (isError(obj)) {
        var parts = arrObjKeys(obj, inspect3);
        if (!("cause" in Error.prototype) && "cause" in obj && !isEnumerable.call(obj, "cause")) {
          return "{ [" + String(obj) + "] " + $join.call($concat.call("[cause]: " + inspect3(obj.cause), parts), ", ") + " }";
        }
        if (parts.length === 0) {
          return "[" + String(obj) + "]";
        }
        return "{ [" + String(obj) + "] " + $join.call(parts, ", ") + " }";
      }
      if (typeof obj === "object" && customInspect) {
        if (inspectSymbol && typeof obj[inspectSymbol] === "function" && utilInspect) {
          return utilInspect(obj, { depth: maxDepth - depth });
        } else if (customInspect !== "symbol" && typeof obj.inspect === "function") {
          return obj.inspect();
        }
      }
      if (isMap(obj)) {
        var mapParts = [];
        if (mapForEach) {
          mapForEach.call(obj, function(value, key) {
            mapParts.push(inspect3(key, obj, true) + " => " + inspect3(value, obj));
          });
        }
        return collectionOf("Map", mapSize.call(obj), mapParts, indent);
      }
      if (isSet(obj)) {
        var setParts = [];
        if (setForEach) {
          setForEach.call(obj, function(value) {
            setParts.push(inspect3(value, obj));
          });
        }
        return collectionOf("Set", setSize.call(obj), setParts, indent);
      }
      if (isWeakMap(obj)) {
        return weakCollectionOf("WeakMap");
      }
      if (isWeakSet(obj)) {
        return weakCollectionOf("WeakSet");
      }
      if (isWeakRef(obj)) {
        return weakCollectionOf("WeakRef");
      }
      if (isNumber(obj)) {
        return markBoxed(inspect3(Number(obj)));
      }
      if (isBigInt(obj)) {
        return markBoxed(inspect3(bigIntValueOf.call(obj)));
      }
      if (isBoolean(obj)) {
        return markBoxed(booleanValueOf.call(obj));
      }
      if (isString(obj)) {
        return markBoxed(inspect3(String(obj)));
      }
      if (typeof window !== "undefined" && obj === window) {
        return "{ [object Window] }";
      }
      if (typeof globalThis !== "undefined" && obj === globalThis || typeof global !== "undefined" && obj === global) {
        return "{ [object globalThis] }";
      }
      if (!isDate(obj) && !isRegExp(obj)) {
        var ys = arrObjKeys(obj, inspect3);
        var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
        var protoTag = obj instanceof Object ? "" : "null prototype";
        var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? "Object" : "";
        var constructorTag = isPlainObject || typeof obj.constructor !== "function" ? "" : obj.constructor.name ? obj.constructor.name + " " : "";
        var tag = constructorTag + (stringTag || protoTag ? "[" + $join.call($concat.call([], stringTag || [], protoTag || []), ": ") + "] " : "");
        if (ys.length === 0) {
          return tag + "{}";
        }
        if (indent) {
          return tag + "{" + indentedJoin(ys, indent) + "}";
        }
        return tag + "{ " + $join.call(ys, ", ") + " }";
      }
      return String(obj);
    };
    function wrapQuotes(s, defaultStyle, opts) {
      var style = opts.quoteStyle || defaultStyle;
      var quoteChar = quotes[style];
      return quoteChar + s + quoteChar;
    }
    function quote(s) {
      return $replace.call(String(s), /"/g, "&quot;");
    }
    function canTrustToString(obj) {
      return !toStringTag || !(typeof obj === "object" && (toStringTag in obj || typeof obj[toStringTag] !== "undefined"));
    }
    function isArray(obj) {
      return toStr(obj) === "[object Array]" && canTrustToString(obj);
    }
    function isDate(obj) {
      return toStr(obj) === "[object Date]" && canTrustToString(obj);
    }
    function isRegExp(obj) {
      return toStr(obj) === "[object RegExp]" && canTrustToString(obj);
    }
    function isError(obj) {
      return toStr(obj) === "[object Error]" && canTrustToString(obj);
    }
    function isString(obj) {
      return toStr(obj) === "[object String]" && canTrustToString(obj);
    }
    function isNumber(obj) {
      return toStr(obj) === "[object Number]" && canTrustToString(obj);
    }
    function isBoolean(obj) {
      return toStr(obj) === "[object Boolean]" && canTrustToString(obj);
    }
    function isSymbol(obj) {
      if (hasShammedSymbols) {
        return obj && typeof obj === "object" && obj instanceof Symbol;
      }
      if (typeof obj === "symbol") {
        return true;
      }
      if (!obj || typeof obj !== "object" || !symToString) {
        return false;
      }
      try {
        symToString.call(obj);
        return true;
      } catch (e) {
      }
      return false;
    }
    function isBigInt(obj) {
      if (!obj || typeof obj !== "object" || !bigIntValueOf) {
        return false;
      }
      try {
        bigIntValueOf.call(obj);
        return true;
      } catch (e) {
      }
      return false;
    }
    var hasOwn2 = Object.prototype.hasOwnProperty || function(key) {
      return key in this;
    };
    function has(obj, key) {
      return hasOwn2.call(obj, key);
    }
    function toStr(obj) {
      return objectToString.call(obj);
    }
    function nameOf(f) {
      if (f.name) {
        return f.name;
      }
      var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
      if (m) {
        return m[1];
      }
      return null;
    }
    function indexOf(xs, x) {
      if (xs.indexOf) {
        return xs.indexOf(x);
      }
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) {
          return i;
        }
      }
      return -1;
    }
    function isMap(x) {
      if (!mapSize || !x || typeof x !== "object") {
        return false;
      }
      try {
        mapSize.call(x);
        try {
          setSize.call(x);
        } catch (s) {
          return true;
        }
        return x instanceof Map;
      } catch (e) {
      }
      return false;
    }
    function isWeakMap(x) {
      if (!weakMapHas || !x || typeof x !== "object") {
        return false;
      }
      try {
        weakMapHas.call(x, weakMapHas);
        try {
          weakSetHas.call(x, weakSetHas);
        } catch (s) {
          return true;
        }
        return x instanceof WeakMap;
      } catch (e) {
      }
      return false;
    }
    function isWeakRef(x) {
      if (!weakRefDeref || !x || typeof x !== "object") {
        return false;
      }
      try {
        weakRefDeref.call(x);
        return true;
      } catch (e) {
      }
      return false;
    }
    function isSet(x) {
      if (!setSize || !x || typeof x !== "object") {
        return false;
      }
      try {
        setSize.call(x);
        try {
          mapSize.call(x);
        } catch (m) {
          return true;
        }
        return x instanceof Set;
      } catch (e) {
      }
      return false;
    }
    function isWeakSet(x) {
      if (!weakSetHas || !x || typeof x !== "object") {
        return false;
      }
      try {
        weakSetHas.call(x, weakSetHas);
        try {
          weakMapHas.call(x, weakMapHas);
        } catch (s) {
          return true;
        }
        return x instanceof WeakSet;
      } catch (e) {
      }
      return false;
    }
    function isElement(x) {
      if (!x || typeof x !== "object") {
        return false;
      }
      if (typeof HTMLElement !== "undefined" && x instanceof HTMLElement) {
        return true;
      }
      return typeof x.nodeName === "string" && typeof x.getAttribute === "function";
    }
    function inspectString(str, opts) {
      if (str.length > opts.maxStringLength) {
        var remaining = str.length - opts.maxStringLength;
        var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
        return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
      }
      var quoteRE = quoteREs[opts.quoteStyle || "single"];
      quoteRE.lastIndex = 0;
      var s = $replace.call($replace.call(str, quoteRE, "\\$1"), /[\x00-\x1f]/g, lowbyte);
      return wrapQuotes(s, "single", opts);
    }
    function lowbyte(c) {
      var n = c.charCodeAt(0);
      var x = {
        8: "b",
        9: "t",
        10: "n",
        12: "f",
        13: "r"
      }[n];
      if (x) {
        return "\\" + x;
      }
      return "\\x" + (n < 16 ? "0" : "") + $toUpperCase.call(n.toString(16));
    }
    function markBoxed(str) {
      return "Object(" + str + ")";
    }
    function weakCollectionOf(type) {
      return type + " { ? }";
    }
    function collectionOf(type, size, entries, indent) {
      var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ", ");
      return type + " (" + size + ") {" + joinedEntries + "}";
    }
    function singleLineValues(xs) {
      for (var i = 0; i < xs.length; i++) {
        if (indexOf(xs[i], "\n") >= 0) {
          return false;
        }
      }
      return true;
    }
    function getIndent(opts, depth) {
      var baseIndent;
      if (opts.indent === "	") {
        baseIndent = "	";
      } else if (typeof opts.indent === "number" && opts.indent > 0) {
        baseIndent = $join.call(Array(opts.indent + 1), " ");
      } else {
        return null;
      }
      return {
        base: baseIndent,
        prev: $join.call(Array(depth + 1), baseIndent)
      };
    }
    function indentedJoin(xs, indent) {
      if (xs.length === 0) {
        return "";
      }
      var lineJoiner = "\n" + indent.prev + indent.base;
      return lineJoiner + $join.call(xs, "," + lineJoiner) + "\n" + indent.prev;
    }
    function arrObjKeys(obj, inspect3) {
      var isArr = isArray(obj);
      var xs = [];
      if (isArr) {
        xs.length = obj.length;
        for (var i = 0; i < obj.length; i++) {
          xs[i] = has(obj, i) ? inspect3(obj[i], obj) : "";
        }
      }
      var syms = typeof gOPS === "function" ? gOPS(obj) : [];
      var symMap;
      if (hasShammedSymbols) {
        symMap = {};
        for (var k = 0; k < syms.length; k++) {
          symMap["$" + syms[k]] = syms[k];
        }
      }
      for (var key in obj) {
        if (!has(obj, key)) {
          continue;
        }
        if (isArr && String(Number(key)) === key && key < obj.length) {
          continue;
        }
        if (hasShammedSymbols && symMap["$" + key] instanceof Symbol) {
          continue;
        } else if ($test.call(/[^\w$]/, key)) {
          xs.push(inspect3(key, obj) + ": " + inspect3(obj[key], obj));
        } else {
          xs.push(key + ": " + inspect3(obj[key], obj));
        }
      }
      if (typeof gOPS === "function") {
        for (var j = 0; j < syms.length; j++) {
          if (isEnumerable.call(obj, syms[j])) {
            xs.push("[" + inspect3(syms[j]) + "]: " + inspect3(obj[syms[j]], obj));
          }
        }
      }
      return xs;
    }
  }
});

// src/lib/time_duration.ts
var TimeDuration = class _TimeDuration {
  __time_duration_micros__;
  static MICROS_PER_MILLIS = 1000n;
  /**
   * Get the algebraic type representation of the {@link TimeDuration} type.
   * @returns The algebraic type representation of the type.
   */
  static getAlgebraicType() {
    return AlgebraicType.Product({
      elements: [
        {
          name: "__time_duration_micros__",
          algebraicType: AlgebraicType.I64
        }
      ]
    });
  }
  static isTimeDuration(algebraicType) {
    if (algebraicType.tag !== "Product") {
      return false;
    }
    const elements = algebraicType.value.elements;
    if (elements.length !== 1) {
      return false;
    }
    const microsElement = elements[0];
    return microsElement.name === "__time_duration_micros__" && microsElement.algebraicType.tag === "I64";
  }
  get micros() {
    return this.__time_duration_micros__;
  }
  get millis() {
    return Number(this.micros / _TimeDuration.MICROS_PER_MILLIS);
  }
  constructor(micros) {
    this.__time_duration_micros__ = micros;
  }
  static fromMillis(millis) {
    return new _TimeDuration(BigInt(millis) * _TimeDuration.MICROS_PER_MILLIS);
  }
  /** This outputs the same string format that we use in the host and in Rust modules */
  toString() {
    const micros = this.micros;
    const sign = micros < 0 ? "-" : "+";
    const pos = micros < 0 ? -micros : micros;
    const secs = pos / 1000000n;
    const micros_remaining = pos % 1000000n;
    return `${sign}${secs}.${String(micros_remaining).padStart(6, "0")}`;
  }
};

// src/lib/timestamp.ts
var Timestamp = class _Timestamp {
  __timestamp_micros_since_unix_epoch__;
  static MICROS_PER_MILLIS = 1000n;
  get microsSinceUnixEpoch() {
    return this.__timestamp_micros_since_unix_epoch__;
  }
  constructor(micros) {
    this.__timestamp_micros_since_unix_epoch__ = micros;
  }
  /**
   * Get the algebraic type representation of the {@link Timestamp} type.
   * @returns The algebraic type representation of the type.
   */
  static getAlgebraicType() {
    return AlgebraicType.Product({
      elements: [
        {
          name: "__timestamp_micros_since_unix_epoch__",
          algebraicType: AlgebraicType.I64
        }
      ]
    });
  }
  static isTimestamp(algebraicType) {
    if (algebraicType.tag !== "Product") {
      return false;
    }
    const elements = algebraicType.value.elements;
    if (elements.length !== 1) {
      return false;
    }
    const microsElement = elements[0];
    return microsElement.name === "__timestamp_micros_since_unix_epoch__" && microsElement.algebraicType.tag === "I64";
  }
  /**
   * The Unix epoch, the midnight at the beginning of January 1, 1970, UTC.
   */
  static UNIX_EPOCH = new _Timestamp(0n);
  /**
   * Get a `Timestamp` representing the execution environment's belief of the current moment in time.
   */
  static now() {
    return _Timestamp.fromDate(/* @__PURE__ */ new Date());
  }
  /** Convert to milliseconds since Unix epoch. */
  toMillis() {
    return this.microsSinceUnixEpoch / 1000n;
  }
  /**
   * Get a `Timestamp` representing the same point in time as `date`.
   */
  static fromDate(date) {
    const millis = date.getTime();
    const micros = BigInt(millis) * _Timestamp.MICROS_PER_MILLIS;
    return new _Timestamp(micros);
  }
  /**
   * Get a `Date` representing approximately the same point in time as `this`.
   *
   * This method truncates to millisecond precision,
   * and throws `RangeError` if the `Timestamp` is outside the range representable as a `Date`.
   */
  toDate() {
    const micros = this.__timestamp_micros_since_unix_epoch__;
    const millis = micros / _Timestamp.MICROS_PER_MILLIS;
    if (millis > BigInt(Number.MAX_SAFE_INTEGER) || millis < BigInt(Number.MIN_SAFE_INTEGER)) {
      throw new RangeError(
        "Timestamp is outside of the representable range of JS's Date"
      );
    }
    return new Date(Number(millis));
  }
  /**
   * Get an ISO 8601 / RFC 3339 formatted string representation of this timestamp with microsecond precision.
   *
   * This method preserves the full microsecond precision of the timestamp,
   * and throws `RangeError` if the `Timestamp` is outside the range representable in ISO format.
   *
   * @returns ISO 8601 formatted string with microsecond precision (e.g., '2025-02-17T10:30:45.123456Z')
   */
  toISOString() {
    const micros = this.__timestamp_micros_since_unix_epoch__;
    const millis = micros / _Timestamp.MICROS_PER_MILLIS;
    if (millis > BigInt(Number.MAX_SAFE_INTEGER) || millis < BigInt(Number.MIN_SAFE_INTEGER)) {
      throw new RangeError(
        "Timestamp is outside of the representable range for ISO string formatting"
      );
    }
    const date = new Date(Number(millis));
    const isoBase = date.toISOString();
    const microsRemainder = Math.abs(Number(micros % 1000000n));
    const fractionalPart = String(microsRemainder).padStart(6, "0");
    return isoBase.replace(/\.\d{3}Z$/, `.${fractionalPart}Z`);
  }
  since(other) {
    return new TimeDuration(
      this.__timestamp_micros_since_unix_epoch__ - other.__timestamp_micros_since_unix_epoch__
    );
  }
};

// src/lib/uuid.ts
var Uuid = class _Uuid {
  __uuid__;
  /**
   * The nil UUID (all zeros).
   *
   * @example
   * ```ts
   * const uuid = Uuid.NIL;
   * console.assert(
   *   uuid.toString() === "00000000-0000-0000-0000-000000000000"
   * );
   * ```
   */
  static NIL = new _Uuid(0n);
  static MAX_UUID_BIGINT = 0xffffffffffffffffffffffffffffffffn;
  /**
   * The max UUID (all ones).
   *
   * @example
   * ```ts
   * const uuid = Uuid.MAX;
   * console.assert(
   *   uuid.toString() === "ffffffff-ffff-ffff-ffff-ffffffffffff"
   * );
   * ```
   */
  static MAX = new _Uuid(_Uuid.MAX_UUID_BIGINT);
  /**
   * Create a UUID from a raw 128-bit value.
   *
   * @param u - Unsigned 128-bit integer
   * @throws {Error} If the value is outside the valid UUID range
   */
  constructor(u) {
    if (u < 0n || u > _Uuid.MAX_UUID_BIGINT) {
      throw new Error("Invalid UUID: must be between 0 and `MAX_UUID_BIGINT`");
    }
    this.__uuid__ = u;
  }
  /**
   * Create a UUID `v4` from explicit random bytes.
   *
   * This method assumes the bytes are already sufficiently random.
   * It only sets the appropriate bits for the UUID version and variant.
   *
   * @param bytes - Exactly 16 random bytes
   * @returns A UUID `v4`
   * @throws {Error} If `bytes.length !== 16`
   *
   * @example
   * ```ts
   * const randomBytes = new Uint8Array(16);
   * const uuid = Uuid.fromRandomBytesV4(randomBytes);
   *
   * console.assert(
   *   uuid.toString() === "00000000-0000-4000-8000-000000000000"
   * );
   * ```
   */
  static fromRandomBytesV4(bytes) {
    if (bytes.length !== 16) throw new Error("UUID v4 requires 16 bytes");
    const arr = new Uint8Array(bytes);
    arr[6] = arr[6] & 15 | 64;
    arr[8] = arr[8] & 63 | 128;
    return new _Uuid(_Uuid.bytesToBigInt(arr));
  }
  /**
   * Generate a UUID `v7` using a monotonic counter from `0` to `2^31 - 1`,
   * a timestamp, and 4 random bytes.
   *
   * The counter wraps around on overflow.
   *
   * The UUID `v7` is structured as follows:
   *
   * ```ascii
   * ┌───────────────────────────────────────────────┬───────────────────┐
   * | B0  | B1  | B2  | B3  | B4  | B5              |         B6        |
   * ├───────────────────────────────────────────────┼───────────────────┤
   * |                 unix_ts_ms                    |      version 7    |
   * └───────────────────────────────────────────────┴───────────────────┘
   * ┌──────────────┬─────────┬──────────────────┬───────────────────────┐
   * | B7           | B8      | B9  | B10 | B11  | B12 | B13 | B14 | B15 |
   * ├──────────────┼─────────┼──────────────────┼───────────────────────┤
   * | counter_high | variant |    counter_low   |        random         |
   * └──────────────┴─────────┴──────────────────┴───────────────────────┘
   * ```
   *
   * @param counter - Mutable monotonic counter (31-bit)
   * @param now - Timestamp since the Unix epoch
   * @param randomBytes - Exactly 4 random bytes
   * @returns A UUID `v7`
   *
   * @throws {Error} If the `counter` is negative
   * @throws {Error} If the `timestamp` is before the Unix epoch
   * @throws {Error} If `randomBytes.length !== 4`
   *
   * @example
   * ```ts
   * const now = Timestamp.fromMillis(1_686_000_000_000n);
   * const counter = { value: 1 };
   * const randomBytes = new Uint8Array(4);
   *
   * const uuid = Uuid.fromCounterV7(counter, now, randomBytes);
   *
   * console.assert(
   *   uuid.toString() === "0000647e-5180-7000-8000-000200000000"
   * );
   * ```
   */
  static fromCounterV7(counter, now, randomBytes) {
    if (randomBytes.length !== 4) {
      throw new Error("`fromCounterV7` requires `randomBytes.length == 4`");
    }
    if (counter.value < 0) {
      throw new Error("`fromCounterV7` uuid `counter` must be non-negative");
    }
    if (now.__timestamp_micros_since_unix_epoch__ < 0) {
      throw new Error("`fromCounterV7` `timestamp` before unix epoch");
    }
    const counterVal = counter.value;
    counter.value = counterVal + 1 & 2147483647;
    const tsMs = now.toMillis() & 0xffffffffffffn;
    const bytes = new Uint8Array(16);
    bytes[0] = Number(tsMs >> 40n & 0xffn);
    bytes[1] = Number(tsMs >> 32n & 0xffn);
    bytes[2] = Number(tsMs >> 24n & 0xffn);
    bytes[3] = Number(tsMs >> 16n & 0xffn);
    bytes[4] = Number(tsMs >> 8n & 0xffn);
    bytes[5] = Number(tsMs & 0xffn);
    bytes[7] = counterVal >>> 23 & 255;
    bytes[9] = counterVal >>> 15 & 255;
    bytes[10] = counterVal >>> 7 & 255;
    bytes[11] = (counterVal & 127) << 1 & 255;
    bytes[12] |= randomBytes[0] & 127;
    bytes[13] = randomBytes[1];
    bytes[14] = randomBytes[2];
    bytes[15] = randomBytes[3];
    bytes[6] = bytes[6] & 15 | 112;
    bytes[8] = bytes[8] & 63 | 128;
    return new _Uuid(_Uuid.bytesToBigInt(bytes));
  }
  /**
   * Parse a UUID from a string representation.
   *
   * @param s - UUID string
   * @returns Parsed UUID
   * @throws {Error} If the string is not a valid UUID
   *
   * @example
   * ```ts
   * const s = "01888d6e-5c00-7000-8000-000000000000";
   * const uuid = Uuid.parse(s);
   *
   * console.assert(uuid.toString() === s);
   * ```
   */
  static parse(s) {
    const hex = s.replace(/-/g, "");
    if (hex.length !== 32) throw new Error("Invalid hex UUID");
    let v = 0n;
    for (let i = 0; i < 32; i += 2) {
      v = v << 8n | BigInt(parseInt(hex.slice(i, i + 2), 16));
    }
    return new _Uuid(v);
  }
  /** Convert to string (hyphenated form). */
  toString() {
    const bytes = _Uuid.bigIntToBytes(this.__uuid__);
    const hex = [...bytes].map((b) => b.toString(16).padStart(2, "0")).join("");
    return hex.slice(0, 8) + "-" + hex.slice(8, 12) + "-" + hex.slice(12, 16) + "-" + hex.slice(16, 20) + "-" + hex.slice(20);
  }
  /** Convert to bigint (u128). */
  asBigInt() {
    return this.__uuid__;
  }
  /** Return a `Uint8Array` of 16 bytes. */
  toBytes() {
    return _Uuid.bigIntToBytes(this.__uuid__);
  }
  static bytesToBigInt(bytes) {
    let result = 0n;
    for (const b of bytes) result = result << 8n | BigInt(b);
    return result;
  }
  static bigIntToBytes(value) {
    const bytes = new Uint8Array(16);
    for (let i = 15; i >= 0; i--) {
      bytes[i] = Number(value & 0xffn);
      value >>= 8n;
    }
    return bytes;
  }
  /**
   * Returns the version of this UUID.
   *
   * This represents the algorithm used to generate the value.
   *
   * @returns A `UuidVersion`
   * @throws {Error} If the version field is not recognized
   */
  getVersion() {
    const version = this.toBytes()[6] >> 4 & 15;
    switch (version) {
      case 4:
        return "V4";
      case 7:
        return "V7";
      default:
        if (this == _Uuid.NIL) {
          return "Nil";
        }
        if (this == _Uuid.MAX) {
          return "Max";
        }
        throw new Error(`Unsupported UUID version: ${version}`);
    }
  }
  /**
   * Extract the monotonic counter from a UUIDv7.
   *
   * Intended for testing and diagnostics.
   * Behavior is undefined if called on a non-V7 UUID.
   *
   * @returns 31-bit counter value
   */
  getCounter() {
    const bytes = this.toBytes();
    const high = bytes[7];
    const mid1 = bytes[9];
    const mid2 = bytes[10];
    const low = bytes[11] >>> 1;
    return high << 23 | mid1 << 15 | mid2 << 7 | low | 0;
  }
  compareTo(other) {
    if (this.__uuid__ < other.__uuid__) return -1;
    if (this.__uuid__ > other.__uuid__) return 1;
    return 0;
  }
  static getAlgebraicType() {
    return AlgebraicType.Product({
      elements: [
        {
          name: "__uuid__",
          algebraicType: AlgebraicType.U128
        }
      ]
    });
  }
};

// src/lib/binary_reader.ts
var BinaryReader = class {
  /**
   * The DataView used to read values from the binary data.
   *
   * Note: The DataView's `byteOffset` is relative to the beginning of the
   * underlying ArrayBuffer, not the start of the provided Uint8Array input.
   * This `BinaryReader`'s `#offset` field is used to track the current read position
   * relative to the start of the provided Uint8Array input.
   */
  view;
  /**
   * Represents the offset (in bytes) relative to the start of the DataView
   * and provided Uint8Array input.
   *
   * Note: This is *not* the absolute byte offset within the underlying ArrayBuffer.
   */
  offset = 0;
  constructor(input) {
    this.view = input instanceof DataView ? input : new DataView(input.buffer, input.byteOffset, input.byteLength);
    this.offset = 0;
  }
  reset(view) {
    this.view = view;
    this.offset = 0;
  }
  get remaining() {
    return this.view.byteLength - this.offset;
  }
  /** Ensure we have at least `n` bytes left to read */
  #ensure(n) {
    if (this.offset + n > this.view.byteLength) {
      throw new RangeError(
        `Tried to read ${n} byte(s) at relative offset ${this.offset}, but only ${this.remaining} byte(s) remain`
      );
    }
  }
  readUInt8Array() {
    const length = this.readU32();
    this.#ensure(length);
    return this.readBytes(length);
  }
  readBool() {
    const value = this.view.getUint8(this.offset);
    this.offset += 1;
    return value !== 0;
  }
  readByte() {
    const value = this.view.getUint8(this.offset);
    this.offset += 1;
    return value;
  }
  readBytes(length) {
    const array = new Uint8Array(
      this.view.buffer,
      this.view.byteOffset + this.offset,
      length
    );
    this.offset += length;
    return array;
  }
  readI8() {
    const value = this.view.getInt8(this.offset);
    this.offset += 1;
    return value;
  }
  readU8() {
    return this.readByte();
  }
  readI16() {
    const value = this.view.getInt16(this.offset, true);
    this.offset += 2;
    return value;
  }
  readU16() {
    const value = this.view.getUint16(this.offset, true);
    this.offset += 2;
    return value;
  }
  readI32() {
    const value = this.view.getInt32(this.offset, true);
    this.offset += 4;
    return value;
  }
  readU32() {
    const value = this.view.getUint32(this.offset, true);
    this.offset += 4;
    return value;
  }
  readI64() {
    const value = this.view.getBigInt64(this.offset, true);
    this.offset += 8;
    return value;
  }
  readU64() {
    const value = this.view.getBigUint64(this.offset, true);
    this.offset += 8;
    return value;
  }
  readU128() {
    const lowerPart = this.view.getBigUint64(this.offset, true);
    const upperPart = this.view.getBigUint64(this.offset + 8, true);
    this.offset += 16;
    return (upperPart << BigInt(64)) + lowerPart;
  }
  readI128() {
    const lowerPart = this.view.getBigUint64(this.offset, true);
    const upperPart = this.view.getBigInt64(this.offset + 8, true);
    this.offset += 16;
    return (upperPart << BigInt(64)) + lowerPart;
  }
  readU256() {
    const p0 = this.view.getBigUint64(this.offset, true);
    const p1 = this.view.getBigUint64(this.offset + 8, true);
    const p2 = this.view.getBigUint64(this.offset + 16, true);
    const p3 = this.view.getBigUint64(this.offset + 24, true);
    this.offset += 32;
    return (p3 << BigInt(3 * 64)) + (p2 << BigInt(2 * 64)) + (p1 << BigInt(1 * 64)) + p0;
  }
  readI256() {
    const p0 = this.view.getBigUint64(this.offset, true);
    const p1 = this.view.getBigUint64(this.offset + 8, true);
    const p2 = this.view.getBigUint64(this.offset + 16, true);
    const p3 = this.view.getBigInt64(this.offset + 24, true);
    this.offset += 32;
    return (p3 << BigInt(3 * 64)) + (p2 << BigInt(2 * 64)) + (p1 << BigInt(1 * 64)) + p0;
  }
  readF32() {
    const value = this.view.getFloat32(this.offset, true);
    this.offset += 4;
    return value;
  }
  readF64() {
    const value = this.view.getFloat64(this.offset, true);
    this.offset += 8;
    return value;
  }
  readString() {
    const uint8Array = this.readUInt8Array();
    return new TextDecoder("utf-8").decode(uint8Array);
  }
};

// src/lib/binary_writer.ts
var import_base64_js = __toESM(require_base64_js());
var ArrayBufferPrototypeTransfer = ArrayBuffer.prototype.transfer ?? function(newByteLength) {
  if (newByteLength === void 0) {
    return this.slice();
  } else if (newByteLength <= this.byteLength) {
    return this.slice(0, newByteLength);
  } else {
    const copy = new Uint8Array(newByteLength);
    copy.set(new Uint8Array(this));
    return copy.buffer;
  }
};
var ResizableBuffer = class {
  buffer;
  view;
  constructor(init) {
    this.buffer = typeof init === "number" ? new ArrayBuffer(init) : init;
    this.view = new DataView(this.buffer);
  }
  get capacity() {
    return this.buffer.byteLength;
  }
  grow(newSize) {
    if (newSize <= this.buffer.byteLength) return;
    this.buffer = ArrayBufferPrototypeTransfer.call(this.buffer, newSize);
    this.view = new DataView(this.buffer);
  }
};
var BinaryWriter = class {
  buffer;
  offset = 0;
  constructor(init) {
    this.buffer = typeof init === "number" ? new ResizableBuffer(init) : init;
  }
  reset(buffer) {
    this.buffer = buffer;
    this.offset = 0;
  }
  expandBuffer(additionalCapacity) {
    const minCapacity = this.offset + additionalCapacity + 1;
    if (minCapacity <= this.buffer.capacity) return;
    let newCapacity = this.buffer.capacity * 2;
    if (newCapacity < minCapacity) newCapacity = minCapacity;
    this.buffer.grow(newCapacity);
  }
  toBase64() {
    return (0, import_base64_js.fromByteArray)(this.getBuffer());
  }
  getBuffer() {
    return new Uint8Array(this.buffer.buffer, 0, this.offset);
  }
  get view() {
    return this.buffer.view;
  }
  writeUInt8Array(value) {
    const length = value.length;
    this.expandBuffer(4 + length);
    this.writeU32(length);
    new Uint8Array(this.buffer.buffer, this.offset).set(value);
    this.offset += length;
  }
  writeBool(value) {
    this.expandBuffer(1);
    this.view.setUint8(this.offset, value ? 1 : 0);
    this.offset += 1;
  }
  writeByte(value) {
    this.expandBuffer(1);
    this.view.setUint8(this.offset, value);
    this.offset += 1;
  }
  writeI8(value) {
    this.expandBuffer(1);
    this.view.setInt8(this.offset, value);
    this.offset += 1;
  }
  writeU8(value) {
    this.expandBuffer(1);
    this.view.setUint8(this.offset, value);
    this.offset += 1;
  }
  writeI16(value) {
    this.expandBuffer(2);
    this.view.setInt16(this.offset, value, true);
    this.offset += 2;
  }
  writeU16(value) {
    this.expandBuffer(2);
    this.view.setUint16(this.offset, value, true);
    this.offset += 2;
  }
  writeI32(value) {
    this.expandBuffer(4);
    this.view.setInt32(this.offset, value, true);
    this.offset += 4;
  }
  writeU32(value) {
    this.expandBuffer(4);
    this.view.setUint32(this.offset, value, true);
    this.offset += 4;
  }
  writeI64(value) {
    this.expandBuffer(8);
    this.view.setBigInt64(this.offset, value, true);
    this.offset += 8;
  }
  writeU64(value) {
    this.expandBuffer(8);
    this.view.setBigUint64(this.offset, value, true);
    this.offset += 8;
  }
  writeU128(value) {
    this.expandBuffer(16);
    const lowerPart = value & BigInt("0xFFFFFFFFFFFFFFFF");
    const upperPart = value >> BigInt(64);
    this.view.setBigUint64(this.offset, lowerPart, true);
    this.view.setBigUint64(this.offset + 8, upperPart, true);
    this.offset += 16;
  }
  writeI128(value) {
    this.expandBuffer(16);
    const lowerPart = value & BigInt("0xFFFFFFFFFFFFFFFF");
    const upperPart = value >> BigInt(64);
    this.view.setBigInt64(this.offset, lowerPart, true);
    this.view.setBigInt64(this.offset + 8, upperPart, true);
    this.offset += 16;
  }
  writeU256(value) {
    this.expandBuffer(32);
    const low_64_mask = BigInt("0xFFFFFFFFFFFFFFFF");
    const p0 = value & low_64_mask;
    const p1 = value >> BigInt(64 * 1) & low_64_mask;
    const p2 = value >> BigInt(64 * 2) & low_64_mask;
    const p3 = value >> BigInt(64 * 3);
    this.view.setBigUint64(this.offset + 8 * 0, p0, true);
    this.view.setBigUint64(this.offset + 8 * 1, p1, true);
    this.view.setBigUint64(this.offset + 8 * 2, p2, true);
    this.view.setBigUint64(this.offset + 8 * 3, p3, true);
    this.offset += 32;
  }
  writeI256(value) {
    this.expandBuffer(32);
    const low_64_mask = BigInt("0xFFFFFFFFFFFFFFFF");
    const p0 = value & low_64_mask;
    const p1 = value >> BigInt(64 * 1) & low_64_mask;
    const p2 = value >> BigInt(64 * 2) & low_64_mask;
    const p3 = value >> BigInt(64 * 3);
    this.view.setBigUint64(this.offset + 8 * 0, p0, true);
    this.view.setBigUint64(this.offset + 8 * 1, p1, true);
    this.view.setBigUint64(this.offset + 8 * 2, p2, true);
    this.view.setBigInt64(this.offset + 8 * 3, p3, true);
    this.offset += 32;
  }
  writeF32(value) {
    this.expandBuffer(4);
    this.view.setFloat32(this.offset, value, true);
    this.offset += 4;
  }
  writeF64(value) {
    this.expandBuffer(8);
    this.view.setFloat64(this.offset, value, true);
    this.offset += 8;
  }
  writeString(value) {
    const encoder = new TextEncoder();
    const encodedString = encoder.encode(value);
    this.writeUInt8Array(encodedString);
  }
};

// src/lib/util.ts
function toPascalCase(s) {
  const str = s.replace(/([-_][a-z])/gi, ($1) => {
    return $1.toUpperCase().replace("-", "").replace("_", "");
  });
  return str.charAt(0).toUpperCase() + str.slice(1);
}
function uint8ArrayToHexString(array) {
  return Array.prototype.map.call(array.reverse(), (x) => ("00" + x.toString(16)).slice(-2)).join("");
}
function uint8ArrayToU128(array) {
  if (array.length != 16) {
    throw new Error(`Uint8Array is not 16 bytes long: ${array}`);
  }
  return new BinaryReader(array).readU128();
}
function uint8ArrayToU256(array) {
  if (array.length != 32) {
    throw new Error(`Uint8Array is not 32 bytes long: [${array}]`);
  }
  return new BinaryReader(array).readU256();
}
function hexStringToUint8Array(str) {
  if (str.startsWith("0x")) {
    str = str.slice(2);
  }
  const matches = str.match(/.{1,2}/g) || [];
  const data = Uint8Array.from(
    matches.map((byte) => parseInt(byte, 16))
  );
  return data.reverse();
}
function hexStringToU128(str) {
  return uint8ArrayToU128(hexStringToUint8Array(str));
}
function hexStringToU256(str) {
  return uint8ArrayToU256(hexStringToUint8Array(str));
}
function u128ToUint8Array(data) {
  const writer = new BinaryWriter(16);
  writer.writeU128(data);
  return writer.getBuffer();
}
function u128ToHexString(data) {
  return uint8ArrayToHexString(u128ToUint8Array(data));
}
function u256ToUint8Array(data) {
  const writer = new BinaryWriter(32);
  writer.writeU256(data);
  return writer.getBuffer();
}
function u256ToHexString(data) {
  return uint8ArrayToHexString(u256ToUint8Array(data));
}
function toCamelCase(str) {
  return str.replace(/[-_]+/g, "_").replace(/_([a-zA-Z0-9])/g, (_, c) => c.toUpperCase());
}
function bsatnBaseSize(typespace, ty) {
  const assumedArrayLength = 4;
  while (ty.tag === "Ref") ty = typespace.types[ty.value];
  if (ty.tag === "Product") {
    let sum = 0;
    for (const { algebraicType: elem } of ty.value.elements) {
      sum += bsatnBaseSize(typespace, elem);
    }
    return sum;
  } else if (ty.tag === "Sum") {
    let min = Infinity;
    for (const { algebraicType: vari } of ty.value.variants) {
      const vSize = bsatnBaseSize(typespace, vari);
      if (vSize < min) min = vSize;
    }
    if (min === Infinity) min = 0;
    return 4 + min;
  } else if (ty.tag == "Array") {
    return 4 + assumedArrayLength * bsatnBaseSize(typespace, ty.value);
  }
  return {
    String: 4 + assumedArrayLength,
    Sum: 1,
    Bool: 1,
    I8: 1,
    U8: 1,
    I16: 2,
    U16: 2,
    I32: 4,
    U32: 4,
    F32: 4,
    I64: 8,
    U64: 8,
    F64: 8,
    I128: 16,
    U128: 16,
    I256: 32,
    U256: 32
  }[ty.tag];
}
var hasOwn = Object.hasOwn;

// src/lib/connection_id.ts
var ConnectionId = class _ConnectionId {
  __connection_id__;
  /**
   * Creates a new `ConnectionId`.
   */
  constructor(data) {
    this.__connection_id__ = data;
  }
  /**
   * Get the algebraic type representation of the {@link ConnectionId} type.
   * @returns The algebraic type representation of the type.
   */
  static getAlgebraicType() {
    return AlgebraicType.Product({
      elements: [
        { name: "__connection_id__", algebraicType: AlgebraicType.U128 }
      ]
    });
  }
  isZero() {
    return this.__connection_id__ === BigInt(0);
  }
  static nullIfZero(addr) {
    if (addr.isZero()) {
      return null;
    } else {
      return addr;
    }
  }
  static random() {
    function randomU8() {
      return Math.floor(Math.random() * 255);
    }
    let result = BigInt(0);
    for (let i = 0; i < 16; i++) {
      result = result << BigInt(8) | BigInt(randomU8());
    }
    return new _ConnectionId(result);
  }
  /**
   * Compare two connection IDs for equality.
   */
  isEqual(other) {
    return this.__connection_id__ == other.__connection_id__;
  }
  /**
   * Check if two connection IDs are equal.
   */
  equals(other) {
    return this.isEqual(other);
  }
  /**
   * Print the connection ID as a hexadecimal string.
   */
  toHexString() {
    return u128ToHexString(this.__connection_id__);
  }
  /**
   * Convert the connection ID to a Uint8Array.
   */
  toUint8Array() {
    return u128ToUint8Array(this.__connection_id__);
  }
  /**
   * Parse a connection ID from a hexadecimal string.
   */
  static fromString(str) {
    return new _ConnectionId(hexStringToU128(str));
  }
  static fromStringOrNull(str) {
    const addr = _ConnectionId.fromString(str);
    if (addr.isZero()) {
      return null;
    } else {
      return addr;
    }
  }
};

// src/lib/identity.ts
var Identity = class _Identity {
  __identity__;
  /**
   * Creates a new `Identity`.
   *
   * `data` can be a hexadecimal string or a `bigint`.
   */
  constructor(data) {
    this.__identity__ = typeof data === "string" ? hexStringToU256(data) : data;
  }
  /**
   * Get the algebraic type representation of the {@link Identity} type.
   * @returns The algebraic type representation of the type.
   */
  static getAlgebraicType() {
    return AlgebraicType.Product({
      elements: [{ name: "__identity__", algebraicType: AlgebraicType.U256 }]
    });
  }
  /**
   * Check if two identities are equal.
   */
  isEqual(other) {
    return this.toHexString() === other.toHexString();
  }
  /**
   * Check if two identities are equal.
   */
  equals(other) {
    return this.isEqual(other);
  }
  /**
   * Print the identity as a hexadecimal string.
   */
  toHexString() {
    return u256ToHexString(this.__identity__);
  }
  /**
   * Convert the address to a Uint8Array.
   */
  toUint8Array() {
    return u256ToUint8Array(this.__identity__);
  }
  /**
   * Parse an Identity from a hexadecimal string.
   */
  static fromString(str) {
    return new _Identity(str);
  }
  /**
   * Zero identity (0x0000000000000000000000000000000000000000000000000000000000000000)
   */
  static zero() {
    return new _Identity(0n);
  }
  toString() {
    return this.toHexString();
  }
};

// src/lib/algebraic_type.ts
var SERIALIZERS = /* @__PURE__ */ new Map();
var DESERIALIZERS = /* @__PURE__ */ new Map();
var AlgebraicType = {
  Ref: (value) => ({ tag: "Ref", value }),
  Sum: (value) => ({
    tag: "Sum",
    value
  }),
  Product: (value) => ({
    tag: "Product",
    value
  }),
  Array: (value) => ({
    tag: "Array",
    value
  }),
  String: { tag: "String" },
  Bool: { tag: "Bool" },
  I8: { tag: "I8" },
  U8: { tag: "U8" },
  I16: { tag: "I16" },
  U16: { tag: "U16" },
  I32: { tag: "I32" },
  U32: { tag: "U32" },
  I64: { tag: "I64" },
  U64: { tag: "U64" },
  I128: { tag: "I128" },
  U128: { tag: "U128" },
  I256: { tag: "I256" },
  U256: { tag: "U256" },
  F32: { tag: "F32" },
  F64: { tag: "F64" },
  makeSerializer(ty, typespace) {
    if (ty.tag === "Ref") {
      if (!typespace)
        throw new Error("cannot serialize refs without a typespace");
      while (ty.tag === "Ref") ty = typespace.types[ty.value];
    }
    switch (ty.tag) {
      case "Product":
        return ProductType.makeSerializer(ty.value, typespace);
      case "Sum":
        return SumType.makeSerializer(ty.value, typespace);
      case "Array":
        if (ty.value.tag === "U8") {
          return serializeUint8Array;
        } else {
          const serialize = AlgebraicType.makeSerializer(ty.value, typespace);
          return (writer, value) => {
            writer.writeU32(value.length);
            for (const elem of value) {
              serialize(writer, elem);
            }
          };
        }
      default:
        return primitiveSerializers[ty.tag];
    }
  },
  /** @deprecated Use `makeSerializer` instead. */
  serializeValue(writer, ty, value, typespace) {
    AlgebraicType.makeSerializer(ty, typespace)(writer, value);
  },
  makeDeserializer(ty, typespace) {
    if (ty.tag === "Ref") {
      if (!typespace)
        throw new Error("cannot deserialize refs without a typespace");
      while (ty.tag === "Ref") ty = typespace.types[ty.value];
    }
    switch (ty.tag) {
      case "Product":
        return ProductType.makeDeserializer(ty.value, typespace);
      case "Sum":
        return SumType.makeDeserializer(ty.value, typespace);
      case "Array":
        if (ty.value.tag === "U8") {
          return deserializeUint8Array;
        } else {
          const deserialize = AlgebraicType.makeDeserializer(
            ty.value,
            typespace
          );
          return (reader) => {
            const length = reader.readU32();
            const result = Array(length);
            for (let i = 0; i < length; i++) {
              result[i] = deserialize(reader);
            }
            return result;
          };
        }
      default:
        return primitiveDeserializers[ty.tag];
    }
  },
  /** @deprecated Use `makeDeserializer` instead. */
  deserializeValue(reader, ty, typespace) {
    return AlgebraicType.makeDeserializer(ty, typespace)(reader);
  },
  /**
   * Convert a value of the algebraic type into something that can be used as a key in a map.
   * There are no guarantees about being able to order it.
   * This is only guaranteed to be comparable to other values of the same type.
   * @param value A value of the algebraic type
   * @returns Something that can be used as a key in a map.
   */
  intoMapKey: function(ty, value) {
    switch (ty.tag) {
      case "U8":
      case "U16":
      case "U32":
      case "U64":
      case "U128":
      case "U256":
      case "I8":
      case "I16":
      case "I32":
      case "I64":
      case "I128":
      case "I256":
      case "F32":
      case "F64":
      case "String":
      case "Bool":
        return value;
      case "Product":
        return ProductType.intoMapKey(ty.value, value);
      default: {
        const writer = new BinaryWriter(10);
        AlgebraicType.serializeValue(writer, ty, value);
        return writer.toBase64();
      }
    }
  }
};
function bindCall(f) {
  return Function.prototype.call.bind(f);
}
var primitiveSerializers = {
  Bool: bindCall(BinaryWriter.prototype.writeBool),
  I8: bindCall(BinaryWriter.prototype.writeI8),
  U8: bindCall(BinaryWriter.prototype.writeU8),
  I16: bindCall(BinaryWriter.prototype.writeI16),
  U16: bindCall(BinaryWriter.prototype.writeU16),
  I32: bindCall(BinaryWriter.prototype.writeI32),
  U32: bindCall(BinaryWriter.prototype.writeU32),
  I64: bindCall(BinaryWriter.prototype.writeI64),
  U64: bindCall(BinaryWriter.prototype.writeU64),
  I128: bindCall(BinaryWriter.prototype.writeI128),
  U128: bindCall(BinaryWriter.prototype.writeU128),
  I256: bindCall(BinaryWriter.prototype.writeI256),
  U256: bindCall(BinaryWriter.prototype.writeU256),
  F32: bindCall(BinaryWriter.prototype.writeF32),
  F64: bindCall(BinaryWriter.prototype.writeF64),
  String: bindCall(BinaryWriter.prototype.writeString)
};
Object.freeze(primitiveSerializers);
var serializeUint8Array = bindCall(BinaryWriter.prototype.writeUInt8Array);
var primitiveDeserializers = {
  Bool: bindCall(BinaryReader.prototype.readBool),
  I8: bindCall(BinaryReader.prototype.readI8),
  U8: bindCall(BinaryReader.prototype.readU8),
  I16: bindCall(BinaryReader.prototype.readI16),
  U16: bindCall(BinaryReader.prototype.readU16),
  I32: bindCall(BinaryReader.prototype.readI32),
  U32: bindCall(BinaryReader.prototype.readU32),
  I64: bindCall(BinaryReader.prototype.readI64),
  U64: bindCall(BinaryReader.prototype.readU64),
  I128: bindCall(BinaryReader.prototype.readI128),
  U128: bindCall(BinaryReader.prototype.readU128),
  I256: bindCall(BinaryReader.prototype.readI256),
  U256: bindCall(BinaryReader.prototype.readU256),
  F32: bindCall(BinaryReader.prototype.readF32),
  F64: bindCall(BinaryReader.prototype.readF64),
  String: bindCall(BinaryReader.prototype.readString)
};
Object.freeze(primitiveDeserializers);
var deserializeUint8Array = bindCall(BinaryReader.prototype.readUInt8Array);
var primitiveSizes = {
  Bool: 1,
  I8: 1,
  U8: 1,
  I16: 2,
  U16: 2,
  I32: 4,
  U32: 4,
  I64: 8,
  U64: 8,
  I128: 16,
  U128: 16,
  I256: 32,
  U256: 32,
  F32: 4,
  F64: 8
};
var fixedSizePrimitives = new Set(Object.keys(primitiveSizes));
var isFixedSizeProduct = (ty) => ty.elements.every(
  ({ algebraicType }) => fixedSizePrimitives.has(algebraicType.tag)
);
var productSize = (ty) => ty.elements.reduce(
  (acc, { algebraicType }) => acc + primitiveSizes[algebraicType.tag],
  0
);
var primitiveJSName = {
  Bool: "Uint8",
  I8: "Int8",
  U8: "Uint8",
  I16: "Int16",
  U16: "Uint16",
  I32: "Int32",
  U32: "Uint32",
  I64: "BigInt64",
  U64: "BigUint64",
  F32: "Float32",
  F64: "Float64"
};
var specialProductDeserializers = {
  __time_duration_micros__: (reader) => new TimeDuration(reader.readI64()),
  __timestamp_micros_since_unix_epoch__: (reader) => new Timestamp(reader.readI64()),
  __identity__: (reader) => new Identity(reader.readU256()),
  __connection_id__: (reader) => new ConnectionId(reader.readU128()),
  __uuid__: (reader) => new Uuid(reader.readU128())
};
Object.freeze(specialProductDeserializers);
var unitDeserializer = () => ({});
var getElementInitializer = (element) => {
  let init;
  switch (element.algebraicType.tag) {
    case "String":
      init = "''";
      break;
    case "Bool":
      init = "false";
      break;
    case "I8":
    case "U8":
    case "I16":
    case "U16":
    case "I32":
    case "U32":
      init = "0";
      break;
    case "I64":
    case "U64":
    case "I128":
    case "U128":
    case "I256":
    case "U256":
      init = "0n";
      break;
    case "F32":
    case "F64":
      init = "0.0";
      break;
    default:
      init = "undefined";
  }
  return `${element.name}: ${init}`;
};
var ProductType = {
  makeSerializer(ty, typespace) {
    let serializer = SERIALIZERS.get(ty);
    if (serializer != null) return serializer;
    if (isFixedSizeProduct(ty)) {
      const size = productSize(ty);
      const body2 = `"use strict";
writer.expandBuffer(${size});
const view = writer.view;
${ty.elements.map(
        ({ name, algebraicType: { tag } }) => tag in primitiveJSName ? `view.set${primitiveJSName[tag]}(writer.offset, value.${name}, ${primitiveSizes[tag] > 1 ? "true" : ""});
writer.offset += ${primitiveSizes[tag]};` : `writer.write${tag}(value.${name});`
      ).join("\n")}`;
      serializer = Function("writer", "value", body2);
      SERIALIZERS.set(ty, serializer);
      return serializer;
    }
    const serializers = {};
    const body = '"use strict";\n' + ty.elements.map(
      (element) => `this.${element.name}(writer, value.${element.name});`
    ).join("\n");
    serializer = Function("writer", "value", body).bind(
      serializers
    );
    SERIALIZERS.set(ty, serializer);
    for (const { name, algebraicType } of ty.elements) {
      serializers[name] = AlgebraicType.makeSerializer(
        algebraicType,
        typespace
      );
    }
    Object.freeze(serializers);
    return serializer;
  },
  /** @deprecated Use `makeSerializer` instead. */
  serializeValue(writer, ty, value, typespace) {
    ProductType.makeSerializer(ty, typespace)(writer, value);
  },
  makeDeserializer(ty, typespace) {
    switch (ty.elements.length) {
      case 0:
        return unitDeserializer;
      case 1: {
        const fieldName = ty.elements[0].name;
        if (hasOwn(specialProductDeserializers, fieldName))
          return specialProductDeserializers[fieldName];
      }
    }
    let deserializer = DESERIALIZERS.get(ty);
    if (deserializer != null) return deserializer;
    if (isFixedSizeProduct(ty)) {
      const body = `"use strict";
const result = { ${ty.elements.map(getElementInitializer).join(", ")} };
const view = reader.view;
${ty.elements.map(
        ({ name, algebraicType: { tag } }) => tag in primitiveJSName ? `result.${name} = view.get${primitiveJSName[tag]}(reader.offset, ${primitiveSizes[tag] > 1 ? "true" : ""});
reader.offset += ${primitiveSizes[tag]};` : `result.${name} = reader.read${tag}();`
      ).join("\n")}
return result;`;
      deserializer = Function("reader", body);
      DESERIALIZERS.set(ty, deserializer);
      return deserializer;
    }
    const deserializers = {};
    deserializer = Function(
      "reader",
      `"use strict";
const result = { ${ty.elements.map(getElementInitializer).join(", ")} };
${ty.elements.map(({ name }) => `result.${name} = this.${name}(reader);`).join("\n")}
return result;`
    ).bind(deserializers);
    DESERIALIZERS.set(ty, deserializer);
    for (const { name, algebraicType } of ty.elements) {
      deserializers[name] = AlgebraicType.makeDeserializer(
        algebraicType,
        typespace
      );
    }
    Object.freeze(deserializers);
    return deserializer;
  },
  /** @deprecated Use `makeDeserializer` instead. */
  deserializeValue(reader, ty, typespace) {
    return ProductType.makeDeserializer(ty, typespace)(reader);
  },
  intoMapKey(ty, value) {
    if (ty.elements.length === 1) {
      const fieldName = ty.elements[0].name;
      if (hasOwn(specialProductDeserializers, fieldName)) {
        return value[fieldName];
      }
    }
    const writer = new BinaryWriter(10);
    AlgebraicType.serializeValue(writer, AlgebraicType.Product(ty), value);
    return writer.toBase64();
  }
};
var SumType = {
  makeSerializer(ty, typespace) {
    if (ty.variants.length == 2 && ty.variants[0].name === "some" && ty.variants[1].name === "none") {
      const serialize = AlgebraicType.makeSerializer(
        ty.variants[0].algebraicType,
        typespace
      );
      return (writer, value) => {
        if (value !== null && value !== void 0) {
          writer.writeByte(0);
          serialize(writer, value);
        } else {
          writer.writeByte(1);
        }
      };
    } else if (ty.variants.length == 2 && ty.variants[0].name === "ok" && ty.variants[1].name === "err") {
      const serializeOk = AlgebraicType.makeSerializer(
        ty.variants[0].algebraicType,
        typespace
      );
      const serializeErr = AlgebraicType.makeSerializer(
        ty.variants[0].algebraicType,
        typespace
      );
      return (writer, value) => {
        if ("ok" in value) {
          writer.writeU8(0);
          serializeOk(writer, value.ok);
        } else if ("err" in value) {
          writer.writeU8(1);
          serializeErr(writer, value.err);
        } else {
          throw new TypeError(
            "could not serialize result: object had neither a `ok` nor an `err` field"
          );
        }
      };
    } else {
      let serializer = SERIALIZERS.get(ty);
      if (serializer != null) return serializer;
      const serializers = {};
      const body = `switch (value.tag) {
${ty.variants.map(
        ({ name }, i) => `  case ${JSON.stringify(name)}:
    writer.writeByte(${i});
    return this.${name}(writer, value.value);`
      ).join("\n")}
  default:
    throw new TypeError(
      \`Could not serialize sum type; unknown tag \${value.tag}\`
    )
}
`;
      serializer = Function("writer", "value", body).bind(
        serializers
      );
      SERIALIZERS.set(ty, serializer);
      for (const { name, algebraicType } of ty.variants) {
        serializers[name] = AlgebraicType.makeSerializer(
          algebraicType,
          typespace
        );
      }
      Object.freeze(serializers);
      return serializer;
    }
  },
  /** @deprecated Use `makeSerializer` instead. */
  serializeValue(writer, ty, value, typespace) {
    SumType.makeSerializer(ty, typespace)(writer, value);
  },
  makeDeserializer(ty, typespace) {
    if (ty.variants.length == 2 && ty.variants[0].name === "some" && ty.variants[1].name === "none") {
      const deserialize = AlgebraicType.makeDeserializer(
        ty.variants[0].algebraicType,
        typespace
      );
      return (reader) => {
        const tag = reader.readU8();
        if (tag === 0) {
          return deserialize(reader);
        } else if (tag === 1) {
          return void 0;
        } else {
          throw `Can't deserialize an option type, couldn't find ${tag} tag`;
        }
      };
    } else if (ty.variants.length == 2 && ty.variants[0].name === "ok" && ty.variants[1].name === "err") {
      const deserializeOk = AlgebraicType.makeDeserializer(
        ty.variants[0].algebraicType,
        typespace
      );
      const deserializeErr = AlgebraicType.makeDeserializer(
        ty.variants[1].algebraicType,
        typespace
      );
      return (reader) => {
        const tag = reader.readByte();
        if (tag === 0) {
          return { ok: deserializeOk(reader) };
        } else if (tag === 1) {
          return { err: deserializeErr(reader) };
        } else {
          throw `Can't deserialize a result type, couldn't find ${tag} tag`;
        }
      };
    } else {
      let deserializer = DESERIALIZERS.get(ty);
      if (deserializer != null) return deserializer;
      const deserializers = {};
      deserializer = Function(
        "reader",
        `switch (reader.readU8()) {
${ty.variants.map(
          ({ name }, i) => `case ${i}: return { tag: ${JSON.stringify(name)}, value: this.${name}(reader) };`
        ).join("\n")} }`
      ).bind(deserializers);
      DESERIALIZERS.set(ty, deserializer);
      for (const { name, algebraicType } of ty.variants) {
        deserializers[name] = AlgebraicType.makeDeserializer(
          algebraicType,
          typespace
        );
      }
      Object.freeze(deserializers);
      return deserializer;
    }
  },
  /** @deprecated Use `makeDeserializer` instead. */
  deserializeValue(reader, ty, typespace) {
    return SumType.makeDeserializer(ty, typespace)(reader);
  }
};

// src/lib/option.ts
var Option = {
  getAlgebraicType(innerType) {
    return AlgebraicType.Sum({
      variants: [
        { name: "some", algebraicType: innerType },
        {
          name: "none",
          algebraicType: AlgebraicType.Product({ elements: [] })
        }
      ]
    });
  }
};

// src/lib/result.ts
var Result = {
  getAlgebraicType(okType, errType) {
    return AlgebraicType.Sum({
      variants: [
        { name: "ok", algebraicType: okType },
        { name: "err", algebraicType: errType }
      ]
    });
  }
};

// src/lib/schedule_at.ts
var ScheduleAt = {
  interval(value) {
    return Interval(value);
  },
  time(value) {
    return Time(value);
  },
  getAlgebraicType() {
    return AlgebraicType.Sum({
      variants: [
        {
          name: "Interval",
          algebraicType: TimeDuration.getAlgebraicType()
        },
        { name: "Time", algebraicType: Timestamp.getAlgebraicType() }
      ]
    });
  },
  isScheduleAt(algebraicType) {
    if (algebraicType.tag !== "Sum") {
      return false;
    }
    const variants = algebraicType.value.variants;
    if (variants.length !== 2) {
      return false;
    }
    const intervalVariant = variants.find((v) => v.name === "Interval");
    const timeVariant = variants.find((v) => v.name === "Time");
    if (!intervalVariant || !timeVariant) {
      return false;
    }
    return TimeDuration.isTimeDuration(intervalVariant.algebraicType) && Timestamp.isTimestamp(timeVariant.algebraicType);
  }
};
var Interval = (micros) => ({
  tag: "Interval",
  value: new TimeDuration(micros)
});
var Time = (microsSinceUnixEpoch) => ({
  tag: "Time",
  value: new Timestamp(microsSinceUnixEpoch)
});
var schedule_at_default = ScheduleAt;

// src/lib/type_util.ts
function set(x, t2) {
  return { ...x, ...t2 };
}

// src/lib/type_builders.ts
var TypeBuilder = class {
  /**
   * The TypeScript phantom type. This is not stored at runtime,
   * but is visible to the compiler
   */
  type;
  /**
   * The SpacetimeDB algebraic type (run‑time value). In addition to storing
   * the runtime representation of the `AlgebraicType`, it also captures
   * the TypeScript type information of the `AlgebraicType`. That is to say
   * the value is not merely an `AlgebraicType`, but is constructed to be
   * the corresponding concrete `AlgebraicType` for the TypeScript type `Type`.
   *
   * e.g. `string` corresponds to `AlgebraicType.String`
   */
  algebraicType;
  constructor(algebraicType) {
    this.algebraicType = algebraicType;
  }
  optional() {
    return new OptionBuilder(this);
  }
  serialize(writer, value) {
    const serialize = this.serialize = AlgebraicType.makeSerializer(
      this.algebraicType
    );
    serialize(writer, value);
  }
  deserialize(reader) {
    const deserialize = this.deserialize = AlgebraicType.makeDeserializer(
      this.algebraicType
    );
    return deserialize(reader);
  }
};
var U8Builder = class extends TypeBuilder {
  constructor() {
    super(AlgebraicType.U8);
  }
  index(algorithm = "btree") {
    return new U8ColumnBuilder(
      this,
      set(defaultMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new U8ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));
  }
  primaryKey() {
    return new U8ColumnBuilder(
      this,
      set(defaultMetadata, { isPrimaryKey: true })
    );
  }
  autoInc() {
    return new U8ColumnBuilder(
      this,
      set(defaultMetadata, { isAutoIncrement: true })
    );
  }
  default(value) {
    return new U8ColumnBuilder(
      this,
      set(defaultMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new U8ColumnBuilder(this, set(defaultMetadata, { name }));
  }
};
var U16Builder = class extends TypeBuilder {
  constructor() {
    super(AlgebraicType.U16);
  }
  index(algorithm = "btree") {
    return new U16ColumnBuilder(
      this,
      set(defaultMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new U16ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));
  }
  primaryKey() {
    return new U16ColumnBuilder(
      this,
      set(defaultMetadata, { isPrimaryKey: true })
    );
  }
  autoInc() {
    return new U16ColumnBuilder(
      this,
      set(defaultMetadata, { isAutoIncrement: true })
    );
  }
  default(value) {
    return new U16ColumnBuilder(
      this,
      set(defaultMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new U16ColumnBuilder(this, set(defaultMetadata, { name }));
  }
};
var U32Builder = class extends TypeBuilder {
  constructor() {
    super(AlgebraicType.U32);
  }
  index(algorithm = "btree") {
    return new U32ColumnBuilder(
      this,
      set(defaultMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new U32ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));
  }
  primaryKey() {
    return new U32ColumnBuilder(
      this,
      set(defaultMetadata, { isPrimaryKey: true })
    );
  }
  autoInc() {
    return new U32ColumnBuilder(
      this,
      set(defaultMetadata, { isAutoIncrement: true })
    );
  }
  default(value) {
    return new U32ColumnBuilder(
      this,
      set(defaultMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new U32ColumnBuilder(this, set(defaultMetadata, { name }));
  }
};
var U64Builder = class extends TypeBuilder {
  constructor() {
    super(AlgebraicType.U64);
  }
  index(algorithm = "btree") {
    return new U64ColumnBuilder(
      this,
      set(defaultMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new U64ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));
  }
  primaryKey() {
    return new U64ColumnBuilder(
      this,
      set(defaultMetadata, { isPrimaryKey: true })
    );
  }
  autoInc() {
    return new U64ColumnBuilder(
      this,
      set(defaultMetadata, { isAutoIncrement: true })
    );
  }
  default(value) {
    return new U64ColumnBuilder(
      this,
      set(defaultMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new U64ColumnBuilder(this, set(defaultMetadata, { name }));
  }
};
var U128Builder = class extends TypeBuilder {
  constructor() {
    super(AlgebraicType.U128);
  }
  index(algorithm = "btree") {
    return new U128ColumnBuilder(
      this,
      set(defaultMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new U128ColumnBuilder(
      this,
      set(defaultMetadata, { isUnique: true })
    );
  }
  primaryKey() {
    return new U128ColumnBuilder(
      this,
      set(defaultMetadata, { isPrimaryKey: true })
    );
  }
  autoInc() {
    return new U128ColumnBuilder(
      this,
      set(defaultMetadata, { isAutoIncrement: true })
    );
  }
  default(value) {
    return new U128ColumnBuilder(
      this,
      set(defaultMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new U128ColumnBuilder(this, set(defaultMetadata, { name }));
  }
};
var U256Builder = class extends TypeBuilder {
  constructor() {
    super(AlgebraicType.U256);
  }
  index(algorithm = "btree") {
    return new U256ColumnBuilder(
      this,
      set(defaultMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new U256ColumnBuilder(
      this,
      set(defaultMetadata, { isUnique: true })
    );
  }
  primaryKey() {
    return new U256ColumnBuilder(
      this,
      set(defaultMetadata, { isPrimaryKey: true })
    );
  }
  autoInc() {
    return new U256ColumnBuilder(
      this,
      set(defaultMetadata, { isAutoIncrement: true })
    );
  }
  default(value) {
    return new U256ColumnBuilder(
      this,
      set(defaultMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new U256ColumnBuilder(this, set(defaultMetadata, { name }));
  }
};
var I8Builder = class extends TypeBuilder {
  constructor() {
    super(AlgebraicType.I8);
  }
  index(algorithm = "btree") {
    return new I8ColumnBuilder(
      this,
      set(defaultMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new I8ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));
  }
  primaryKey() {
    return new I8ColumnBuilder(
      this,
      set(defaultMetadata, { isPrimaryKey: true })
    );
  }
  autoInc() {
    return new I8ColumnBuilder(
      this,
      set(defaultMetadata, { isAutoIncrement: true })
    );
  }
  default(value) {
    return new I8ColumnBuilder(
      this,
      set(defaultMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new I8ColumnBuilder(this, set(defaultMetadata, { name }));
  }
};
var I16Builder = class extends TypeBuilder {
  constructor() {
    super(AlgebraicType.I16);
  }
  index(algorithm = "btree") {
    return new I16ColumnBuilder(
      this,
      set(defaultMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new I16ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));
  }
  primaryKey() {
    return new I16ColumnBuilder(
      this,
      set(defaultMetadata, { isPrimaryKey: true })
    );
  }
  autoInc() {
    return new I16ColumnBuilder(
      this,
      set(defaultMetadata, { isAutoIncrement: true })
    );
  }
  default(value) {
    return new I16ColumnBuilder(
      this,
      set(defaultMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new I16ColumnBuilder(this, set(defaultMetadata, { name }));
  }
};
var I32Builder = class extends TypeBuilder {
  constructor() {
    super(AlgebraicType.I32);
  }
  index(algorithm = "btree") {
    return new I32ColumnBuilder(
      this,
      set(defaultMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new I32ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));
  }
  primaryKey() {
    return new I32ColumnBuilder(
      this,
      set(defaultMetadata, { isPrimaryKey: true })
    );
  }
  autoInc() {
    return new I32ColumnBuilder(
      this,
      set(defaultMetadata, { isAutoIncrement: true })
    );
  }
  default(value) {
    return new I32ColumnBuilder(
      this,
      set(defaultMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new I32ColumnBuilder(this, set(defaultMetadata, { name }));
  }
};
var I64Builder = class extends TypeBuilder {
  constructor() {
    super(AlgebraicType.I64);
  }
  index(algorithm = "btree") {
    return new I64ColumnBuilder(
      this,
      set(defaultMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new I64ColumnBuilder(this, set(defaultMetadata, { isUnique: true }));
  }
  primaryKey() {
    return new I64ColumnBuilder(
      this,
      set(defaultMetadata, { isPrimaryKey: true })
    );
  }
  autoInc() {
    return new I64ColumnBuilder(
      this,
      set(defaultMetadata, { isAutoIncrement: true })
    );
  }
  default(value) {
    return new I64ColumnBuilder(
      this,
      set(defaultMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new I64ColumnBuilder(this, set(defaultMetadata, { name }));
  }
};
var I128Builder = class extends TypeBuilder {
  constructor() {
    super(AlgebraicType.I128);
  }
  index(algorithm = "btree") {
    return new I128ColumnBuilder(
      this,
      set(defaultMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new I128ColumnBuilder(
      this,
      set(defaultMetadata, { isUnique: true })
    );
  }
  primaryKey() {
    return new I128ColumnBuilder(
      this,
      set(defaultMetadata, { isPrimaryKey: true })
    );
  }
  autoInc() {
    return new I128ColumnBuilder(
      this,
      set(defaultMetadata, { isAutoIncrement: true })
    );
  }
  default(value) {
    return new I128ColumnBuilder(
      this,
      set(defaultMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new I128ColumnBuilder(this, set(defaultMetadata, { name }));
  }
};
var I256Builder = class extends TypeBuilder {
  constructor() {
    super(AlgebraicType.I256);
  }
  index(algorithm = "btree") {
    return new I256ColumnBuilder(
      this,
      set(defaultMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new I256ColumnBuilder(
      this,
      set(defaultMetadata, { isUnique: true })
    );
  }
  primaryKey() {
    return new I256ColumnBuilder(
      this,
      set(defaultMetadata, { isPrimaryKey: true })
    );
  }
  autoInc() {
    return new I256ColumnBuilder(
      this,
      set(defaultMetadata, { isAutoIncrement: true })
    );
  }
  default(value) {
    return new I256ColumnBuilder(
      this,
      set(defaultMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new I256ColumnBuilder(this, set(defaultMetadata, { name }));
  }
};
var F32Builder = class extends TypeBuilder {
  constructor() {
    super(AlgebraicType.F32);
  }
  default(value) {
    return new F32ColumnBuilder(
      this,
      set(defaultMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new F32ColumnBuilder(this, set(defaultMetadata, { name }));
  }
};
var F64Builder = class extends TypeBuilder {
  constructor() {
    super(AlgebraicType.F64);
  }
  default(value) {
    return new F64ColumnBuilder(
      this,
      set(defaultMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new F64ColumnBuilder(this, set(defaultMetadata, { name }));
  }
};
var BoolBuilder = class extends TypeBuilder {
  constructor() {
    super(AlgebraicType.Bool);
  }
  index(algorithm = "btree") {
    return new BoolColumnBuilder(
      this,
      set(defaultMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new BoolColumnBuilder(
      this,
      set(defaultMetadata, { isUnique: true })
    );
  }
  primaryKey() {
    return new BoolColumnBuilder(
      this,
      set(defaultMetadata, { isPrimaryKey: true })
    );
  }
  default(value) {
    return new BoolColumnBuilder(
      this,
      set(defaultMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new BoolColumnBuilder(this, set(defaultMetadata, { name }));
  }
};
var StringBuilder = class extends TypeBuilder {
  constructor() {
    super(AlgebraicType.String);
  }
  index(algorithm = "btree") {
    return new StringColumnBuilder(
      this,
      set(defaultMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new StringColumnBuilder(
      this,
      set(defaultMetadata, { isUnique: true })
    );
  }
  primaryKey() {
    return new StringColumnBuilder(
      this,
      set(defaultMetadata, { isPrimaryKey: true })
    );
  }
  default(value) {
    return new StringColumnBuilder(
      this,
      set(defaultMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new StringColumnBuilder(this, set(defaultMetadata, { name }));
  }
};
var ArrayBuilder = class extends TypeBuilder {
  element;
  constructor(element) {
    super(AlgebraicType.Array(element.algebraicType));
    this.element = element;
  }
  default(value) {
    return new ArrayColumnBuilder(
      this,
      set(defaultMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new ArrayColumnBuilder(this, set(defaultMetadata, { name }));
  }
};
var ByteArrayBuilder = class extends TypeBuilder {
  constructor() {
    super(AlgebraicType.Array(AlgebraicType.U8));
  }
  default(value) {
    return new ByteArrayColumnBuilder(
      set(defaultMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new ByteArrayColumnBuilder(set(defaultMetadata, { name }));
  }
};
var OptionBuilder = class extends TypeBuilder {
  value;
  constructor(value) {
    super(Option.getAlgebraicType(value.algebraicType));
    this.value = value;
  }
  default(value) {
    return new OptionColumnBuilder(
      this,
      set(defaultMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new OptionColumnBuilder(this, set(defaultMetadata, { name }));
  }
};
var ProductBuilder = class extends TypeBuilder {
  typeName;
  elements;
  constructor(elements, name) {
    function elementsArrayFromElementsObj(obj) {
      return Object.keys(obj).map((key) => ({
        name: key,
        // Lazily resolve the underlying object's algebraicType.
        // This will call obj[key].algebraicType only when someone
        // actually reads this property.
        get algebraicType() {
          return obj[key].algebraicType;
        }
      }));
    }
    super(
      AlgebraicType.Product({
        elements: elementsArrayFromElementsObj(elements)
      })
    );
    this.typeName = name;
    this.elements = elements;
  }
  default(value) {
    return new ProductColumnBuilder(
      this,
      set(defaultMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new ProductColumnBuilder(this, set(defaultMetadata, { name }));
  }
};
var ResultBuilder = class extends TypeBuilder {
  ok;
  err;
  constructor(ok, err) {
    super(Result.getAlgebraicType(ok.algebraicType, err.algebraicType));
    this.ok = ok;
    this.err = err;
  }
  default(value) {
    return new ResultColumnBuilder(this, set(defaultMetadata, { defaultValue: value }));
  }
};
var UnitBuilder = class extends TypeBuilder {
  constructor() {
    super({ tag: "Product", value: { elements: [] } });
  }
};
var RowBuilder = class extends TypeBuilder {
  row;
  typeName;
  constructor(row, name) {
    const mappedRow = Object.fromEntries(
      Object.entries(row).map(([colName, builder]) => [
        colName,
        builder instanceof ColumnBuilder ? builder : new ColumnBuilder(builder, {})
      ])
    );
    const elements = Object.keys(mappedRow).map((name2) => ({
      name: name2,
      get algebraicType() {
        return mappedRow[name2].typeBuilder.algebraicType;
      }
    }));
    super(AlgebraicType.Product({ elements }));
    this.row = mappedRow;
    this.typeName = name;
  }
};
var SumBuilderImpl = class extends TypeBuilder {
  variants;
  typeName;
  constructor(variants, name) {
    function variantsArrayFromVariantsObj(variants2) {
      return Object.keys(variants2).map((key) => ({
        name: key,
        // Lazily resolve the underlying object's algebraicType.
        // This will call obj[key].algebraicType only when someone
        // actually reads this property.
        get algebraicType() {
          return variants2[key].algebraicType;
        }
      }));
    }
    super(
      AlgebraicType.Sum({
        variants: variantsArrayFromVariantsObj(variants)
      })
    );
    this.variants = variants;
    this.typeName = name;
    for (const key of Object.keys(variants)) {
      const desc = Object.getOwnPropertyDescriptor(variants, key);
      const isAccessor = !!desc && (typeof desc.get === "function" || typeof desc.set === "function");
      let isUnit2 = false;
      if (!isAccessor) {
        const variant = variants[key];
        isUnit2 = variant instanceof UnitBuilder;
      }
      if (isUnit2) {
        const constant = this.create(key);
        Object.defineProperty(this, key, {
          value: constant,
          writable: false,
          enumerable: true,
          configurable: false
        });
      } else {
        const fn = ((value) => this.create(key, value));
        Object.defineProperty(this, key, {
          value: fn,
          writable: false,
          enumerable: true,
          configurable: false
        });
      }
    }
  }
  create(tag, value) {
    return value === void 0 ? { tag } : { tag, value };
  }
  default(value) {
    return new SumColumnBuilder(
      this,
      set(defaultMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new SumColumnBuilder(this, set(defaultMetadata, { name }));
  }
};
var SumBuilder = SumBuilderImpl;
var SimpleSumBuilderImpl = class extends SumBuilderImpl {
  index(algorithm = "btree") {
    return new SimpleSumColumnBuilder(
      this,
      set(defaultMetadata, { indexType: algorithm })
    );
  }
  primaryKey() {
    return new SimpleSumColumnBuilder(
      this,
      set(defaultMetadata, { isPrimaryKey: true })
    );
  }
};
var SimpleSumBuilder = SimpleSumBuilderImpl;
var ScheduleAtBuilder = class extends TypeBuilder {
  constructor() {
    super(schedule_at_default.getAlgebraicType());
  }
  default(value) {
    return new ScheduleAtColumnBuilder(
      this,
      set(defaultMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new ScheduleAtColumnBuilder(this, set(defaultMetadata, { name }));
  }
};
var IdentityBuilder = class extends TypeBuilder {
  constructor() {
    super(Identity.getAlgebraicType());
  }
  index(algorithm = "btree") {
    return new IdentityColumnBuilder(
      this,
      set(defaultMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new IdentityColumnBuilder(
      this,
      set(defaultMetadata, { isUnique: true })
    );
  }
  primaryKey() {
    return new IdentityColumnBuilder(
      this,
      set(defaultMetadata, { isPrimaryKey: true })
    );
  }
  autoInc() {
    return new IdentityColumnBuilder(
      this,
      set(defaultMetadata, { isAutoIncrement: true })
    );
  }
  default(value) {
    return new IdentityColumnBuilder(
      this,
      set(defaultMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new IdentityColumnBuilder(this, set(defaultMetadata, { name }));
  }
};
var ConnectionIdBuilder = class extends TypeBuilder {
  constructor() {
    super(ConnectionId.getAlgebraicType());
  }
  index(algorithm = "btree") {
    return new ConnectionIdColumnBuilder(
      this,
      set(defaultMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new ConnectionIdColumnBuilder(
      this,
      set(defaultMetadata, { isUnique: true })
    );
  }
  primaryKey() {
    return new ConnectionIdColumnBuilder(
      this,
      set(defaultMetadata, { isPrimaryKey: true })
    );
  }
  autoInc() {
    return new ConnectionIdColumnBuilder(
      this,
      set(defaultMetadata, { isAutoIncrement: true })
    );
  }
  default(value) {
    return new ConnectionIdColumnBuilder(
      this,
      set(defaultMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new ConnectionIdColumnBuilder(this, set(defaultMetadata, { name }));
  }
};
var TimestampBuilder = class extends TypeBuilder {
  constructor() {
    super(Timestamp.getAlgebraicType());
  }
  index(algorithm = "btree") {
    return new TimestampColumnBuilder(
      this,
      set(defaultMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new TimestampColumnBuilder(
      this,
      set(defaultMetadata, { isUnique: true })
    );
  }
  primaryKey() {
    return new TimestampColumnBuilder(
      this,
      set(defaultMetadata, { isPrimaryKey: true })
    );
  }
  autoInc() {
    return new TimestampColumnBuilder(
      this,
      set(defaultMetadata, { isAutoIncrement: true })
    );
  }
  default(value) {
    return new TimestampColumnBuilder(
      this,
      set(defaultMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new TimestampColumnBuilder(this, set(defaultMetadata, { name }));
  }
};
var TimeDurationBuilder = class extends TypeBuilder {
  constructor() {
    super(TimeDuration.getAlgebraicType());
  }
  index(algorithm = "btree") {
    return new TimeDurationColumnBuilder(
      this,
      set(defaultMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new TimeDurationColumnBuilder(
      this,
      set(defaultMetadata, { isUnique: true })
    );
  }
  primaryKey() {
    return new TimeDurationColumnBuilder(
      this,
      set(defaultMetadata, { isPrimaryKey: true })
    );
  }
  autoInc() {
    return new TimeDurationColumnBuilder(
      this,
      set(defaultMetadata, { isAutoIncrement: true })
    );
  }
  default(value) {
    return new TimeDurationColumnBuilder(
      this,
      set(defaultMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new TimeDurationColumnBuilder(this, set(defaultMetadata, { name }));
  }
};
var UuidBuilder = class extends TypeBuilder {
  constructor() {
    super(Uuid.getAlgebraicType());
  }
  index(algorithm = "btree") {
    return new UuidColumnBuilder(
      this,
      set(defaultMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new UuidColumnBuilder(
      this,
      set(defaultMetadata, { isUnique: true })
    );
  }
  primaryKey() {
    return new UuidColumnBuilder(
      this,
      set(defaultMetadata, { isPrimaryKey: true })
    );
  }
  autoInc() {
    return new UuidColumnBuilder(
      this,
      set(defaultMetadata, { isAutoIncrement: true })
    );
  }
  default(value) {
    return new UuidColumnBuilder(
      this,
      set(defaultMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new UuidColumnBuilder(this, set(defaultMetadata, { name }));
  }
};
var defaultMetadata = {};
var ColumnBuilder = class {
  typeBuilder;
  columnMetadata;
  constructor(typeBuilder, metadata) {
    this.typeBuilder = typeBuilder;
    this.columnMetadata = metadata;
  }
  serialize(writer, value) {
    this.typeBuilder.serialize(writer, value);
  }
  deserialize(reader) {
    return this.typeBuilder.deserialize(reader);
  }
};
var U8ColumnBuilder = class _U8ColumnBuilder extends ColumnBuilder {
  index(algorithm = "btree") {
    return new _U8ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new _U8ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isUnique: true })
    );
  }
  primaryKey() {
    return new _U8ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isPrimaryKey: true })
    );
  }
  autoInc() {
    return new _U8ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isAutoIncrement: true })
    );
  }
  default(value) {
    return new _U8ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, {
        defaultValue: value
      })
    );
  }
  name(name) {
    return new _U8ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { name })
    );
  }
};
var U16ColumnBuilder = class _U16ColumnBuilder extends ColumnBuilder {
  index(algorithm = "btree") {
    return new _U16ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new _U16ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isUnique: true })
    );
  }
  primaryKey() {
    return new _U16ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isPrimaryKey: true })
    );
  }
  autoInc() {
    return new _U16ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isAutoIncrement: true })
    );
  }
  default(value) {
    return new _U16ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, {
        defaultValue: value
      })
    );
  }
  name(name) {
    return new _U16ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { name })
    );
  }
};
var U32ColumnBuilder = class _U32ColumnBuilder extends ColumnBuilder {
  index(algorithm = "btree") {
    return new _U32ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new _U32ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isUnique: true })
    );
  }
  primaryKey() {
    return new _U32ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isPrimaryKey: true })
    );
  }
  autoInc() {
    return new _U32ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isAutoIncrement: true })
    );
  }
  default(value) {
    return new _U32ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, {
        defaultValue: value
      })
    );
  }
  name(name) {
    return new _U32ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { name })
    );
  }
};
var U64ColumnBuilder = class _U64ColumnBuilder extends ColumnBuilder {
  index(algorithm = "btree") {
    return new _U64ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new _U64ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isUnique: true })
    );
  }
  primaryKey() {
    return new _U64ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isPrimaryKey: true })
    );
  }
  autoInc() {
    return new _U64ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isAutoIncrement: true })
    );
  }
  default(value) {
    return new _U64ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, {
        defaultValue: value
      })
    );
  }
  name(name) {
    return new _U64ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { name })
    );
  }
};
var U128ColumnBuilder = class _U128ColumnBuilder extends ColumnBuilder {
  index(algorithm = "btree") {
    return new _U128ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new _U128ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isUnique: true })
    );
  }
  primaryKey() {
    return new _U128ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isPrimaryKey: true })
    );
  }
  autoInc() {
    return new _U128ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isAutoIncrement: true })
    );
  }
  default(value) {
    return new _U128ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, {
        defaultValue: value
      })
    );
  }
  name(name) {
    return new _U128ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { name })
    );
  }
};
var U256ColumnBuilder = class _U256ColumnBuilder extends ColumnBuilder {
  index(algorithm = "btree") {
    return new _U256ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new _U256ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isUnique: true })
    );
  }
  primaryKey() {
    return new _U256ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isPrimaryKey: true })
    );
  }
  autoInc() {
    return new _U256ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isAutoIncrement: true })
    );
  }
  default(value) {
    return new _U256ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, {
        defaultValue: value
      })
    );
  }
  name(name) {
    return new _U256ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { name })
    );
  }
};
var I8ColumnBuilder = class _I8ColumnBuilder extends ColumnBuilder {
  index(algorithm = "btree") {
    return new _I8ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new _I8ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isUnique: true })
    );
  }
  primaryKey() {
    return new _I8ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isPrimaryKey: true })
    );
  }
  autoInc() {
    return new _I8ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isAutoIncrement: true })
    );
  }
  default(value) {
    return new _I8ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, {
        defaultValue: value
      })
    );
  }
  name(name) {
    return new _I8ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { name })
    );
  }
};
var I16ColumnBuilder = class _I16ColumnBuilder extends ColumnBuilder {
  index(algorithm = "btree") {
    return new _I16ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new _I16ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isUnique: true })
    );
  }
  primaryKey() {
    return new _I16ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isPrimaryKey: true })
    );
  }
  autoInc() {
    return new _I16ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isAutoIncrement: true })
    );
  }
  default(value) {
    return new _I16ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, {
        defaultValue: value
      })
    );
  }
  name(name) {
    return new _I16ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { name })
    );
  }
};
var I32ColumnBuilder = class _I32ColumnBuilder extends ColumnBuilder {
  index(algorithm = "btree") {
    return new _I32ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new _I32ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isUnique: true })
    );
  }
  primaryKey() {
    return new _I32ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isPrimaryKey: true })
    );
  }
  autoInc() {
    return new _I32ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isAutoIncrement: true })
    );
  }
  default(value) {
    return new _I32ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, {
        defaultValue: value
      })
    );
  }
  name(name) {
    return new _I32ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { name })
    );
  }
};
var I64ColumnBuilder = class _I64ColumnBuilder extends ColumnBuilder {
  index(algorithm = "btree") {
    return new _I64ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new _I64ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isUnique: true })
    );
  }
  primaryKey() {
    return new _I64ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isPrimaryKey: true })
    );
  }
  autoInc() {
    return new _I64ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isAutoIncrement: true })
    );
  }
  default(value) {
    return new _I64ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, {
        defaultValue: value
      })
    );
  }
  name(name) {
    return new _I64ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { name })
    );
  }
};
var I128ColumnBuilder = class _I128ColumnBuilder extends ColumnBuilder {
  index(algorithm = "btree") {
    return new _I128ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new _I128ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isUnique: true })
    );
  }
  primaryKey() {
    return new _I128ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isPrimaryKey: true })
    );
  }
  autoInc() {
    return new _I128ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isAutoIncrement: true })
    );
  }
  default(value) {
    return new _I128ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, {
        defaultValue: value
      })
    );
  }
  name(name) {
    return new _I128ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { name })
    );
  }
};
var I256ColumnBuilder = class _I256ColumnBuilder extends ColumnBuilder {
  index(algorithm = "btree") {
    return new _I256ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new _I256ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isUnique: true })
    );
  }
  primaryKey() {
    return new _I256ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isPrimaryKey: true })
    );
  }
  autoInc() {
    return new _I256ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isAutoIncrement: true })
    );
  }
  default(value) {
    return new _I256ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, {
        defaultValue: value
      })
    );
  }
  name(name) {
    return new _I256ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { name })
    );
  }
};
var F32ColumnBuilder = class _F32ColumnBuilder extends ColumnBuilder {
  default(value) {
    return new _F32ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, {
        defaultValue: value
      })
    );
  }
  name(name) {
    return new _F32ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { name })
    );
  }
};
var F64ColumnBuilder = class _F64ColumnBuilder extends ColumnBuilder {
  default(value) {
    return new _F64ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, {
        defaultValue: value
      })
    );
  }
  name(name) {
    return new _F64ColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { name })
    );
  }
};
var BoolColumnBuilder = class _BoolColumnBuilder extends ColumnBuilder {
  index(algorithm = "btree") {
    return new _BoolColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new _BoolColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isUnique: true })
    );
  }
  primaryKey() {
    return new _BoolColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isPrimaryKey: true })
    );
  }
  default(value) {
    return new _BoolColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, {
        defaultValue: value
      })
    );
  }
  name(name) {
    return new _BoolColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { name })
    );
  }
};
var StringColumnBuilder = class _StringColumnBuilder extends ColumnBuilder {
  index(algorithm = "btree") {
    return new _StringColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new _StringColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isUnique: true })
    );
  }
  primaryKey() {
    return new _StringColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isPrimaryKey: true })
    );
  }
  default(value) {
    return new _StringColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, {
        defaultValue: value
      })
    );
  }
  name(name) {
    return new _StringColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { name })
    );
  }
};
var ArrayColumnBuilder = class _ArrayColumnBuilder extends ColumnBuilder {
  default(value) {
    return new _ArrayColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, {
        defaultValue: value
      })
    );
  }
  name(name) {
    return new _ArrayColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { name })
    );
  }
};
var ByteArrayColumnBuilder = class _ByteArrayColumnBuilder extends ColumnBuilder {
  constructor(metadata) {
    super(new TypeBuilder(AlgebraicType.Array(AlgebraicType.U8)), metadata);
  }
  default(value) {
    return new _ByteArrayColumnBuilder(
      set(this.columnMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new _ByteArrayColumnBuilder(set(this.columnMetadata, { name }));
  }
};
var OptionColumnBuilder = class _OptionColumnBuilder extends ColumnBuilder {
  default(value) {
    return new _OptionColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, {
        defaultValue: value
      })
    );
  }
  name(name) {
    return new _OptionColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { name })
    );
  }
};
var ResultColumnBuilder = class _ResultColumnBuilder extends ColumnBuilder {
  constructor(typeBuilder, metadata) {
    super(typeBuilder, metadata);
  }
  default(value) {
    return new _ResultColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, {
        defaultValue: value
      })
    );
  }
};
var ProductColumnBuilder = class _ProductColumnBuilder extends ColumnBuilder {
  default(value) {
    return new _ProductColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new _ProductColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { name })
    );
  }
};
var SumColumnBuilder = class _SumColumnBuilder extends ColumnBuilder {
  default(value) {
    return new _SumColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new _SumColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { name })
    );
  }
};
var SimpleSumColumnBuilder = class _SimpleSumColumnBuilder extends SumColumnBuilder {
  index(algorithm = "btree") {
    return new _SimpleSumColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { indexType: algorithm })
    );
  }
  primaryKey() {
    return new _SimpleSumColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isPrimaryKey: true })
    );
  }
};
var ScheduleAtColumnBuilder = class _ScheduleAtColumnBuilder extends ColumnBuilder {
  default(value) {
    return new _ScheduleAtColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new _ScheduleAtColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { name })
    );
  }
};
var IdentityColumnBuilder = class _IdentityColumnBuilder extends ColumnBuilder {
  index(algorithm = "btree") {
    return new _IdentityColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new _IdentityColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isUnique: true })
    );
  }
  primaryKey() {
    return new _IdentityColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isPrimaryKey: true })
    );
  }
  default(value) {
    return new _IdentityColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new _IdentityColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { name })
    );
  }
};
var ConnectionIdColumnBuilder = class _ConnectionIdColumnBuilder extends ColumnBuilder {
  index(algorithm = "btree") {
    return new _ConnectionIdColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new _ConnectionIdColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isUnique: true })
    );
  }
  primaryKey() {
    return new _ConnectionIdColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isPrimaryKey: true })
    );
  }
  default(value) {
    return new _ConnectionIdColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new _ConnectionIdColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { name })
    );
  }
};
var TimestampColumnBuilder = class _TimestampColumnBuilder extends ColumnBuilder {
  index(algorithm = "btree") {
    return new _TimestampColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new _TimestampColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isUnique: true })
    );
  }
  primaryKey() {
    return new _TimestampColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isPrimaryKey: true })
    );
  }
  default(value) {
    return new _TimestampColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new _TimestampColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { name })
    );
  }
};
var TimeDurationColumnBuilder = class _TimeDurationColumnBuilder extends ColumnBuilder {
  index(algorithm = "btree") {
    return new _TimeDurationColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new _TimeDurationColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isUnique: true })
    );
  }
  primaryKey() {
    return new _TimeDurationColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isPrimaryKey: true })
    );
  }
  default(value) {
    return new _TimeDurationColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new _TimeDurationColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { name })
    );
  }
};
var UuidColumnBuilder = class _UuidColumnBuilder extends ColumnBuilder {
  index(algorithm = "btree") {
    return new _UuidColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { indexType: algorithm })
    );
  }
  unique() {
    return new _UuidColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isUnique: true })
    );
  }
  primaryKey() {
    return new _UuidColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { isPrimaryKey: true })
    );
  }
  default(value) {
    return new _UuidColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { defaultValue: value })
    );
  }
  name(name) {
    return new _UuidColumnBuilder(
      this.typeBuilder,
      set(this.columnMetadata, { name })
    );
  }
};
var RefBuilder = class extends TypeBuilder {
  ref;
  /** The phantom type of the pointee of this ref. */
  __spacetimeType;
  constructor(ref) {
    super(AlgebraicType.Ref(ref));
    this.ref = ref;
  }
};
var enumImpl = ((nameOrObj, maybeObj) => {
  let obj = nameOrObj;
  let name = void 0;
  if (typeof nameOrObj === "string") {
    if (!maybeObj) {
      throw new TypeError(
        "When providing a name, you must also provide the variants object or array."
      );
    }
    obj = maybeObj;
    name = nameOrObj;
  }
  if (Array.isArray(obj)) {
    const simpleVariantsObj = {};
    for (const variant of obj) {
      simpleVariantsObj[variant] = new UnitBuilder();
    }
    return new SimpleSumBuilderImpl(simpleVariantsObj, name);
  }
  return new SumBuilder(obj, name);
});
var t = {
  /**
   * Creates a new `Bool` {@link AlgebraicType} to be used in table definitions
   * Represented as `boolean` in TypeScript.
   * @returns A new {@link BoolBuilder} instance
   */
  bool: () => new BoolBuilder(),
  /**
   * Creates a new `String` {@link AlgebraicType} to be used in table definitions
   * Represented as `string` in TypeScript.
   * @returns A new {@link StringBuilder} instance
   */
  string: () => new StringBuilder(),
  /**
   * Creates a new `F64` {@link AlgebraicType} to be used in table definitions
   * Represented as `number` in TypeScript.
   * @returns A new {@link F64Builder} instance
   */
  number: () => new F64Builder(),
  /**
   * Creates a new `I8` {@link AlgebraicType} to be used in table definitions
   * Represented as `number` in TypeScript.
   * @returns A new {@link I8Builder} instance
   */
  i8: () => new I8Builder(),
  /**
   * Creates a new `U8` {@link AlgebraicType} to be used in table definitions
   * Represented as `number` in TypeScript.
   * @returns A new {@link U8Builder} instance
   */
  u8: () => new U8Builder(),
  /**
   * Creates a new `I16` {@link AlgebraicType} to be used in table definitions
   * Represented as `number` in TypeScript.
   * @returns A new {@link I16Builder} instance
   */
  i16: () => new I16Builder(),
  /**
   * Creates a new `U16` {@link AlgebraicType} to be used in table definitions
   * Represented as `number` in TypeScript.
   * @returns A new {@link U16Builder} instance
   */
  u16: () => new U16Builder(),
  /**
   * Creates a new `I32` {@link AlgebraicType} to be used in table definitions
   * Represented as `number` in TypeScript.
   * @returns A new {@link I32Builder} instance
   */
  i32: () => new I32Builder(),
  /**
   * Creates a new `U32` {@link AlgebraicType} to be used in table definitions
   * Represented as `number` in TypeScript.
   * @returns A new {@link U32Builder} instance
   */
  u32: () => new U32Builder(),
  /**
   * Creates a new `I64` {@link AlgebraicType} to be used in table definitions
   * Represented as `bigint` in TypeScript.
   * @returns A new {@link I64Builder} instance
   */
  i64: () => new I64Builder(),
  /**
   * Creates a new `U64` {@link AlgebraicType} to be used in table definitions
   * Represented as `bigint` in TypeScript.
   * @returns A new {@link U64Builder} instance
   */
  u64: () => new U64Builder(),
  /**
   * Creates a new `I128` {@link AlgebraicType} to be used in table definitions
   * Represented as `bigint` in TypeScript.
   * @returns A new {@link I128Builder} instance
   */
  i128: () => new I128Builder(),
  /**
   * Creates a new `U128` {@link AlgebraicType} to be used in table definitions
   * Represented as `bigint` in TypeScript.
   * @returns A new {@link U128Builder} instance
   */
  u128: () => new U128Builder(),
  /**
   * Creates a new `I256` {@link AlgebraicType} to be used in table definitions
   * Represented as `bigint` in TypeScript.
   * @returns A new {@link I256Builder} instance
   */
  i256: () => new I256Builder(),
  /**
   * Creates a new `U256` {@link AlgebraicType} to be used in table definitions
   * Represented as `bigint` in TypeScript.
   * @returns A new {@link U256Builder} instance
   */
  u256: () => new U256Builder(),
  /**
   * Creates a new `F32` {@link AlgebraicType} to be used in table definitions
   * Represented as `number` in TypeScript.
   * @returns A new {@link F32Builder} instance
   */
  f32: () => new F32Builder(),
  /**
   * Creates a new `F64` {@link AlgebraicType} to be used in table definitions
   * Represented as `number` in TypeScript.
   * @returns A new {@link F64Builder} instance
   */
  f64: () => new F64Builder(),
  /**
   * Creates a new `Product` {@link AlgebraicType} to be used in table definitions. Product types in SpacetimeDB
   * are essentially the same as objects in JavaScript/TypeScript.
   * Properties of the object must also be {@link TypeBuilder}s.
   * Represented as an object with specific properties in TypeScript.
   *
   * @param name (optional) A display name for the product type. If omitted, an anonymous product type is created.
   * @param obj The object defining the properties of the type, whose property
   * values must be {@link TypeBuilder}s.
   * @returns A new {@link ProductBuilder} instance.
   */
  object: ((nameOrObj, maybeObj) => {
    if (typeof nameOrObj === "string") {
      if (!maybeObj) {
        throw new TypeError(
          "When providing a name, you must also provide the object."
        );
      }
      return new ProductBuilder(maybeObj, nameOrObj);
    }
    return new ProductBuilder(nameOrObj, void 0);
  }),
  /**
   * Creates a new `Row` {@link AlgebraicType} to be used in table definitions. Row types in SpacetimeDB
   * are similar to `Product` types, but are specifically used to define the schema of a table row.
   * Properties of the object must also be {@link TypeBuilder} or {@link ColumnBuilder}s.
   *
   * You can represent a `Row` as either a {@link RowObj} or an {@link RowBuilder} type when
   * defining a table schema.
   *
   * The {@link RowBuilder} type is useful when you want to create a type which can be used anywhere
   * a {@link TypeBuilder} is accepted, such as in nested objects or arrays, or as the argument
   * to a scheduled function.
   *
   * @param obj The object defining the properties of the row, whose property
   * values must be {@link TypeBuilder}s or {@link ColumnBuilder}s.
   * @returns A new {@link RowBuilder} instance
   */
  row: ((nameOrObj, maybeObj) => {
    const [obj, name] = typeof nameOrObj === "string" ? [maybeObj, nameOrObj] : [nameOrObj, void 0];
    return new RowBuilder(obj, name);
  }),
  /**
   * Creates a new `Array` {@link AlgebraicType} to be used in table definitions.
   * Represented as an array in TypeScript.
   * @param element The element type of the array, which must be a `TypeBuilder`.
   * @returns A new {@link ArrayBuilder} instance
   */
  array(e) {
    return new ArrayBuilder(e);
  },
  enum: enumImpl,
  /**
   * This is a special helper function for conveniently creating `Product` type columns with no fields.
   *
   * @returns A new {@link ProductBuilder} instance with no fields.
   */
  unit() {
    return new UnitBuilder();
  },
  /**
   * Creates a lazily-evaluated {@link TypeBuilder}. This is useful for creating
   * recursive types, such as a tree or linked list.
   * @param thunk A function that returns a {@link TypeBuilder}.
   * @returns A proxy {@link TypeBuilder} that evaluates the thunk on first access.
   */
  lazy(thunk) {
    let cached = null;
    const get = () => cached ??= thunk();
    const proxy = new Proxy({}, {
      get(_t, prop, recv) {
        const target = get();
        const val = Reflect.get(target, prop, recv);
        return typeof val === "function" ? val.bind(target) : val;
      },
      set(_t, prop, value, recv) {
        return Reflect.set(get(), prop, value, recv);
      },
      has(_t, prop) {
        return prop in get();
      },
      ownKeys() {
        return Reflect.ownKeys(get());
      },
      getOwnPropertyDescriptor(_t, prop) {
        return Object.getOwnPropertyDescriptor(get(), prop);
      },
      getPrototypeOf() {
        return Object.getPrototypeOf(get());
      }
    });
    return proxy;
  },
  /**
   * This is a special helper function for conveniently creating {@link ScheduleAt} type columns.
   * @returns A new ColumnBuilder instance with the {@link ScheduleAt} type.
   */
  scheduleAt: () => {
    return new ScheduleAtBuilder();
  },
  /**
   * This is a convenience method for creating a column with the {@link Option} type.
   * You can create a column of the same type by constructing an enum with a `some` and `none` variant.
   * @param value The type of the value contained in the `some` variant of the `Option`.
   * @returns A new {@link OptionBuilder} instance with the {@link Option} type.
   */
  option(value) {
    return new OptionBuilder(value);
  },
  /**
   * This is a convenience method for creating a column with the {@link Result} type.
   * You can create a column of the same type by constructing an enum with an `ok` and `err` variant.
   * @param ok The type of the value contained in the `ok` variant of the `Result`.
   * @param err The type of the value contained in the `err` variant of the `Result`.
   * @returns A new {@link ResultBuilder} instance with the {@link Result} type.
   */
  result(ok, err) {
    return new ResultBuilder(ok, err);
  },
  /**
   * This is a convenience method for creating a column with the {@link Identity} type.
   * You can create a column of the same type by constructing an `object` with a single `__identity__` element.
   * @returns A new {@link TypeBuilder} instance with the {@link Identity} type.
   */
  identity: () => {
    return new IdentityBuilder();
  },
  /**
   * This is a convenience method for creating a column with the {@link ConnectionId} type.
   * You can create a column of the same type by constructing an `object` with a single `__connection_id__` element.
   * @returns A new {@link TypeBuilder} instance with the {@link ConnectionId} type.
   */
  connectionId: () => {
    return new ConnectionIdBuilder();
  },
  /**
   * This is a convenience method for creating a column with the {@link Timestamp} type.
   * You can create a column of the same type by constructing an `object` with a single `__timestamp_micros_since_unix_epoch__` element.
   * @returns A new {@link TypeBuilder} instance with the {@link Timestamp} type.
   */
  timestamp: () => {
    return new TimestampBuilder();
  },
  /**
   * This is a convenience method for creating a column with the {@link TimeDuration} type.
   * You can create a column of the same type by constructing an `object` with a single `__time_duration_micros__` element.
   * @returns A new {@link TypeBuilder} instance with the {@link TimeDuration} type.
   */
  timeDuration: () => {
    return new TimeDurationBuilder();
  },
  /**
   * This is a convenience method for creating a column with the {@link Uuid} type.
   * You can create a column of the same type by constructing an `object` with a single `__uuid__` element.
   * @returns A new {@link TypeBuilder} instance with the {@link Uuid} type.
   */
  uuid: () => {
    return new UuidBuilder();
  },
  /**
   * This is a convenience method for creating a column with the `ByteArray` type.
   * You can create a column of the same type by constructing an `array` of `u8`.
   * The TypeScript representation is {@link Uint8Array}.
   * @returns A new {@link ByteArrayBuilder} instance with the `ByteArray` type.
   */
  byteArray: () => {
    return new ByteArrayBuilder();
  }
};

// src/lib/autogen/types.ts
var AlgebraicType2 = t.enum("AlgebraicType", {
  Ref: t.u32(),
  get Sum() {
    return SumType2;
  },
  get Product() {
    return ProductType2;
  },
  get Array() {
    return AlgebraicType2;
  },
  String: t.unit(),
  Bool: t.unit(),
  I8: t.unit(),
  U8: t.unit(),
  I16: t.unit(),
  U16: t.unit(),
  I32: t.unit(),
  U32: t.unit(),
  I64: t.unit(),
  U64: t.unit(),
  I128: t.unit(),
  U128: t.unit(),
  I256: t.unit(),
  U256: t.unit(),
  F32: t.unit(),
  F64: t.unit()
});
var CaseConversionPolicy = t.enum("CaseConversionPolicy", {
  None: t.unit(),
  SnakeCase: t.unit()
});
var ExplicitNameEntry = t.enum("ExplicitNameEntry", {
  get Table() {
    return NameMapping;
  },
  get Function() {
    return NameMapping;
  },
  get Index() {
    return NameMapping;
  }
});
var ExplicitNames = t.object("ExplicitNames", {
  get entries() {
    return t.array(ExplicitNameEntry);
  }
});
var FunctionVisibility = t.enum("FunctionVisibility", {
  Private: t.unit(),
  ClientCallable: t.unit()
});
var HttpHeaderPair = t.object("HttpHeaderPair", {
  name: t.string(),
  value: t.byteArray()
});
var HttpHeaders = t.object("HttpHeaders", {
  get entries() {
    return t.array(HttpHeaderPair);
  }
});
var HttpMethod = t.enum("HttpMethod", {
  Get: t.unit(),
  Head: t.unit(),
  Post: t.unit(),
  Put: t.unit(),
  Delete: t.unit(),
  Connect: t.unit(),
  Options: t.unit(),
  Trace: t.unit(),
  Patch: t.unit(),
  Extension: t.string()
});
var HttpRequest = t.object("HttpRequest", {
  get method() {
    return HttpMethod;
  },
  get headers() {
    return HttpHeaders;
  },
  timeout: t.option(t.timeDuration()),
  uri: t.string(),
  get version() {
    return HttpVersion;
  }
});
var HttpResponse = t.object("HttpResponse", {
  get headers() {
    return HttpHeaders;
  },
  get version() {
    return HttpVersion;
  },
  code: t.u16()
});
var HttpVersion = t.enum("HttpVersion", {
  Http09: t.unit(),
  Http10: t.unit(),
  Http11: t.unit(),
  Http2: t.unit(),
  Http3: t.unit()
});
var IndexType = t.enum("IndexType", {
  BTree: t.unit(),
  Hash: t.unit()
});
var Lifecycle = t.enum("Lifecycle", {
  Init: t.unit(),
  OnConnect: t.unit(),
  OnDisconnect: t.unit()
});
var MiscModuleExport = t.enum("MiscModuleExport", {
  get TypeAlias() {
    return TypeAlias;
  }
});
var NameMapping = t.object("NameMapping", {
  sourceName: t.string(),
  canonicalName: t.string()
});
var ProductType2 = t.object("ProductType", {
  get elements() {
    return t.array(ProductTypeElement);
  }
});
var ProductTypeElement = t.object("ProductTypeElement", {
  name: t.option(t.string()),
  get algebraicType() {
    return AlgebraicType2;
  }
});
var RawColumnDefV8 = t.object("RawColumnDefV8", {
  colName: t.string(),
  get colType() {
    return AlgebraicType2;
  }
});
var RawColumnDefaultValueV10 = t.object("RawColumnDefaultValueV10", {
  colId: t.u16(),
  value: t.byteArray()
});
var RawColumnDefaultValueV9 = t.object("RawColumnDefaultValueV9", {
  table: t.string(),
  colId: t.u16(),
  value: t.byteArray()
});
var RawConstraintDataV9 = t.enum("RawConstraintDataV9", {
  get Unique() {
    return RawUniqueConstraintDataV9;
  }
});
var RawConstraintDefV10 = t.object("RawConstraintDefV10", {
  sourceName: t.option(t.string()),
  get data() {
    return RawConstraintDataV9;
  }
});
var RawConstraintDefV8 = t.object("RawConstraintDefV8", {
  constraintName: t.string(),
  constraints: t.u8(),
  columns: t.array(t.u16())
});
var RawConstraintDefV9 = t.object("RawConstraintDefV9", {
  name: t.option(t.string()),
  get data() {
    return RawConstraintDataV9;
  }
});
var RawIndexAlgorithm = t.enum("RawIndexAlgorithm", {
  BTree: t.array(t.u16()),
  Hash: t.array(t.u16()),
  Direct: t.u16()
});
var RawIndexDefV10 = t.object("RawIndexDefV10", {
  sourceName: t.option(t.string()),
  accessorName: t.option(t.string()),
  get algorithm() {
    return RawIndexAlgorithm;
  }
});
var RawIndexDefV8 = t.object("RawIndexDefV8", {
  indexName: t.string(),
  isUnique: t.bool(),
  get indexType() {
    return IndexType;
  },
  columns: t.array(t.u16())
});
var RawIndexDefV9 = t.object("RawIndexDefV9", {
  name: t.option(t.string()),
  accessorName: t.option(t.string()),
  get algorithm() {
    return RawIndexAlgorithm;
  }
});
var RawLifeCycleReducerDefV10 = t.object(
  "RawLifeCycleReducerDefV10",
  {
    get lifecycleSpec() {
      return Lifecycle;
    },
    functionName: t.string()
  }
);
var RawMiscModuleExportV9 = t.enum("RawMiscModuleExportV9", {
  get ColumnDefaultValue() {
    return RawColumnDefaultValueV9;
  },
  get Procedure() {
    return RawProcedureDefV9;
  },
  get View() {
    return RawViewDefV9;
  }
});
var RawModuleDef = t.enum("RawModuleDef", {
  get V8BackCompat() {
    return RawModuleDefV8;
  },
  get V9() {
    return RawModuleDefV9;
  },
  get V10() {
    return RawModuleDefV10;
  }
});
var RawModuleDefV10 = t.object("RawModuleDefV10", {
  get sections() {
    return t.array(RawModuleDefV10Section);
  }
});
var RawModuleDefV10Section = t.enum("RawModuleDefV10Section", {
  get Typespace() {
    return Typespace;
  },
  get Types() {
    return t.array(RawTypeDefV10);
  },
  get Tables() {
    return t.array(RawTableDefV10);
  },
  get Reducers() {
    return t.array(RawReducerDefV10);
  },
  get Procedures() {
    return t.array(RawProcedureDefV10);
  },
  get Views() {
    return t.array(RawViewDefV10);
  },
  get Schedules() {
    return t.array(RawScheduleDefV10);
  },
  get LifeCycleReducers() {
    return t.array(RawLifeCycleReducerDefV10);
  },
  get RowLevelSecurity() {
    return t.array(RawRowLevelSecurityDefV9);
  },
  get CaseConversionPolicy() {
    return CaseConversionPolicy;
  },
  get ExplicitNames() {
    return ExplicitNames;
  }
});
var RawModuleDefV8 = t.object("RawModuleDefV8", {
  get typespace() {
    return Typespace;
  },
  get tables() {
    return t.array(TableDesc);
  },
  get reducers() {
    return t.array(ReducerDef);
  },
  get miscExports() {
    return t.array(MiscModuleExport);
  }
});
var RawModuleDefV9 = t.object("RawModuleDefV9", {
  get typespace() {
    return Typespace;
  },
  get tables() {
    return t.array(RawTableDefV9);
  },
  get reducers() {
    return t.array(RawReducerDefV9);
  },
  get types() {
    return t.array(RawTypeDefV9);
  },
  get miscExports() {
    return t.array(RawMiscModuleExportV9);
  },
  get rowLevelSecurity() {
    return t.array(RawRowLevelSecurityDefV9);
  }
});
var RawProcedureDefV10 = t.object("RawProcedureDefV10", {
  sourceName: t.string(),
  get params() {
    return ProductType2;
  },
  get returnType() {
    return AlgebraicType2;
  },
  get visibility() {
    return FunctionVisibility;
  }
});
var RawProcedureDefV9 = t.object("RawProcedureDefV9", {
  name: t.string(),
  get params() {
    return ProductType2;
  },
  get returnType() {
    return AlgebraicType2;
  }
});
var RawReducerDefV10 = t.object("RawReducerDefV10", {
  sourceName: t.string(),
  get params() {
    return ProductType2;
  },
  get visibility() {
    return FunctionVisibility;
  },
  get okReturnType() {
    return AlgebraicType2;
  },
  get errReturnType() {
    return AlgebraicType2;
  }
});
var RawReducerDefV9 = t.object("RawReducerDefV9", {
  name: t.string(),
  get params() {
    return ProductType2;
  },
  get lifecycle() {
    return t.option(Lifecycle);
  }
});
var RawRowLevelSecurityDefV9 = t.object("RawRowLevelSecurityDefV9", {
  sql: t.string()
});
var RawScheduleDefV10 = t.object("RawScheduleDefV10", {
  sourceName: t.option(t.string()),
  tableName: t.string(),
  scheduleAtCol: t.u16(),
  functionName: t.string()
});
var RawScheduleDefV9 = t.object("RawScheduleDefV9", {
  name: t.option(t.string()),
  reducerName: t.string(),
  scheduledAtColumn: t.u16()
});
var RawScopedTypeNameV10 = t.object("RawScopedTypeNameV10", {
  scope: t.array(t.string()),
  sourceName: t.string()
});
var RawScopedTypeNameV9 = t.object("RawScopedTypeNameV9", {
  scope: t.array(t.string()),
  name: t.string()
});
var RawSequenceDefV10 = t.object("RawSequenceDefV10", {
  sourceName: t.option(t.string()),
  column: t.u16(),
  start: t.option(t.i128()),
  minValue: t.option(t.i128()),
  maxValue: t.option(t.i128()),
  increment: t.i128()
});
var RawSequenceDefV8 = t.object("RawSequenceDefV8", {
  sequenceName: t.string(),
  colPos: t.u16(),
  increment: t.i128(),
  start: t.option(t.i128()),
  minValue: t.option(t.i128()),
  maxValue: t.option(t.i128()),
  allocated: t.i128()
});
var RawSequenceDefV9 = t.object("RawSequenceDefV9", {
  name: t.option(t.string()),
  column: t.u16(),
  start: t.option(t.i128()),
  minValue: t.option(t.i128()),
  maxValue: t.option(t.i128()),
  increment: t.i128()
});
var RawTableDefV10 = t.object("RawTableDefV10", {
  sourceName: t.string(),
  productTypeRef: t.u32(),
  primaryKey: t.array(t.u16()),
  get indexes() {
    return t.array(RawIndexDefV10);
  },
  get constraints() {
    return t.array(RawConstraintDefV10);
  },
  get sequences() {
    return t.array(RawSequenceDefV10);
  },
  get tableType() {
    return TableType;
  },
  get tableAccess() {
    return TableAccess;
  },
  get defaultValues() {
    return t.array(RawColumnDefaultValueV10);
  },
  isEvent: t.bool()
});
var RawTableDefV8 = t.object("RawTableDefV8", {
  tableName: t.string(),
  get columns() {
    return t.array(RawColumnDefV8);
  },
  get indexes() {
    return t.array(RawIndexDefV8);
  },
  get constraints() {
    return t.array(RawConstraintDefV8);
  },
  get sequences() {
    return t.array(RawSequenceDefV8);
  },
  tableType: t.string(),
  tableAccess: t.string(),
  scheduled: t.option(t.string())
});
var RawTableDefV9 = t.object("RawTableDefV9", {
  name: t.string(),
  productTypeRef: t.u32(),
  primaryKey: t.array(t.u16()),
  get indexes() {
    return t.array(RawIndexDefV9);
  },
  get constraints() {
    return t.array(RawConstraintDefV9);
  },
  get sequences() {
    return t.array(RawSequenceDefV9);
  },
  get schedule() {
    return t.option(RawScheduleDefV9);
  },
  get tableType() {
    return TableType;
  },
  get tableAccess() {
    return TableAccess;
  }
});
var RawTypeDefV10 = t.object("RawTypeDefV10", {
  get sourceName() {
    return RawScopedTypeNameV10;
  },
  ty: t.u32(),
  customOrdering: t.bool()
});
var RawTypeDefV9 = t.object("RawTypeDefV9", {
  get name() {
    return RawScopedTypeNameV9;
  },
  ty: t.u32(),
  customOrdering: t.bool()
});
var RawUniqueConstraintDataV9 = t.object(
  "RawUniqueConstraintDataV9",
  {
    columns: t.array(t.u16())
  }
);
var RawViewDefV10 = t.object("RawViewDefV10", {
  sourceName: t.string(),
  index: t.u32(),
  isPublic: t.bool(),
  isAnonymous: t.bool(),
  get params() {
    return ProductType2;
  },
  get returnType() {
    return AlgebraicType2;
  }
});
var RawViewDefV9 = t.object("RawViewDefV9", {
  name: t.string(),
  index: t.u32(),
  isPublic: t.bool(),
  isAnonymous: t.bool(),
  get params() {
    return ProductType2;
  },
  get returnType() {
    return AlgebraicType2;
  }
});
var ReducerDef = t.object("ReducerDef", {
  name: t.string(),
  get args() {
    return t.array(ProductTypeElement);
  }
});
var SumType2 = t.object("SumType", {
  get variants() {
    return t.array(SumTypeVariant);
  }
});
var SumTypeVariant = t.object("SumTypeVariant", {
  name: t.option(t.string()),
  get algebraicType() {
    return AlgebraicType2;
  }
});
var TableAccess = t.enum("TableAccess", {
  Public: t.unit(),
  Private: t.unit()
});
var TableDesc = t.object("TableDesc", {
  get schema() {
    return RawTableDefV8;
  },
  data: t.u32()
});
var TableType = t.enum("TableType", {
  System: t.unit(),
  User: t.unit()
});
var TypeAlias = t.object("TypeAlias", {
  name: t.string(),
  ty: t.u32()
});
var Typespace = t.object("Typespace", {
  get types() {
    return t.array(AlgebraicType2);
  }
});
var ViewResultHeader = t.enum("ViewResultHeader", {
  RowData: t.unit(),
  RawSql: t.string()
});

// src/lib/schema.ts
function tableToSchema(accName, schema2, tableDef) {
  const getColName = (i) => schema2.rowType.algebraicType.value.elements[i].name;
  return {
    sourceName: accName,
    accessorName: accName,
    columns: schema2.rowType.row,
    // typed as T[i]['rowType']['row'] under TablesToSchema<T>
    rowType: schema2.rowSpacetimeType,
    constraints: tableDef.constraints.map((c) => ({
      name: c.sourceName,
      constraint: "unique",
      columns: c.data.value.columns.map(getColName)
    })),
    // TODO: horrible horrible horrible. we smuggle this `Array<UntypedIndex>`
    // by casting it to an `Array<IndexOpts>` as `TableToSchema` expects.
    // This is then used in `TableCacheImpl.constructor` and who knows where else.
    // We should stop lying about our types.
    indexes: tableDef.indexes.map((idx) => {
      const columnIds = idx.algorithm.tag === "Direct" ? [idx.algorithm.value] : idx.algorithm.value;
      return {
        name: idx.accessorName,
        unique: tableDef.constraints.some(
          (c) => c.data.value.columns.every((col) => columnIds.includes(col))
        ),
        algorithm: idx.algorithm.tag.toLowerCase(),
        columns: columnIds.map(getColName)
      };
    }),
    tableDef,
    ...tableDef.isEvent ? { isEvent: true } : {}
  };
}
var ModuleContext = class {
  #compoundTypes = /* @__PURE__ */ new Map();
  /**
   * The global module definition that gets populated by calls to `reducer()` and lifecycle hooks.
   */
  #moduleDef = {
    typespace: { types: [] },
    tables: [],
    reducers: [],
    types: [],
    rowLevelSecurity: [],
    schedules: [],
    procedures: [],
    views: [],
    lifeCycleReducers: [],
    caseConversionPolicy: { tag: "SnakeCase" },
    explicitNames: {
      entries: []
    }
  };
  get moduleDef() {
    return this.#moduleDef;
  }
  rawModuleDefV10() {
    const sections = [];
    const push = (s) => {
      if (s) sections.push(s);
    };
    const module = this.#moduleDef;
    push(module.typespace && { tag: "Typespace", value: module.typespace });
    push(module.types && { tag: "Types", value: module.types });
    push(module.tables && { tag: "Tables", value: module.tables });
    push(module.reducers && { tag: "Reducers", value: module.reducers });
    push(module.procedures && { tag: "Procedures", value: module.procedures });
    push(module.views && { tag: "Views", value: module.views });
    push(module.schedules && { tag: "Schedules", value: module.schedules });
    push(
      module.lifeCycleReducers && {
        tag: "LifeCycleReducers",
        value: module.lifeCycleReducers
      }
    );
    push(
      module.rowLevelSecurity && {
        tag: "RowLevelSecurity",
        value: module.rowLevelSecurity
      }
    );
    push(
      module.explicitNames && {
        tag: "ExplicitNames",
        value: module.explicitNames
      }
    );
    push(
      module.caseConversionPolicy && {
        tag: "CaseConversionPolicy",
        value: module.caseConversionPolicy
      }
    );
    return { sections };
  }
  /**
   * Set the case conversion policy for this module.
   * Called by the settings mechanism.
   */
  setCaseConversionPolicy(policy) {
    this.#moduleDef.caseConversionPolicy = policy;
  }
  get typespace() {
    return this.#moduleDef.typespace;
  }
  /**
   * Resolves the actual type of a TypeBuilder by following its references until it reaches a non-ref type.
   * @param typespace The typespace to resolve types against.
   * @param typeBuilder The TypeBuilder to resolve.
   * @returns The resolved algebraic type.
   */
  resolveType(typeBuilder) {
    let ty = typeBuilder.algebraicType;
    while (ty.tag === "Ref") {
      ty = this.typespace.types[ty.value];
    }
    return ty;
  }
  /**
   * Adds a type to the module definition's typespace as a `Ref` if it is a named compound type (Product or Sum).
   * Otherwise, returns the type as is.
   * @param name
   * @param ty
   * @returns
   */
  registerTypesRecursively(typeBuilder) {
    if (typeBuilder instanceof ProductBuilder && !isUnit(typeBuilder) || typeBuilder instanceof SumBuilder || typeBuilder instanceof RowBuilder) {
      return this.#registerCompoundTypeRecursively(typeBuilder);
    } else if (typeBuilder instanceof OptionBuilder) {
      return new OptionBuilder(
        this.registerTypesRecursively(typeBuilder.value)
      );
    } else if (typeBuilder instanceof ResultBuilder) {
      return new ResultBuilder(
        this.registerTypesRecursively(typeBuilder.ok),
        this.registerTypesRecursively(typeBuilder.err)
      );
    } else if (typeBuilder instanceof ArrayBuilder) {
      return new ArrayBuilder(
        this.registerTypesRecursively(typeBuilder.element)
      );
    } else {
      return typeBuilder;
    }
  }
  #registerCompoundTypeRecursively(typeBuilder) {
    const ty = typeBuilder.algebraicType;
    const name = typeBuilder.typeName;
    if (name === void 0) {
      throw new Error(
        `Missing type name for ${typeBuilder.constructor.name ?? "TypeBuilder"} ${JSON.stringify(typeBuilder)}`
      );
    }
    let r = this.#compoundTypes.get(ty);
    if (r != null) {
      return r;
    }
    const newTy = typeBuilder instanceof RowBuilder || typeBuilder instanceof ProductBuilder ? {
      tag: "Product",
      value: { elements: [] }
    } : {
      tag: "Sum",
      value: { variants: [] }
    };
    r = new RefBuilder(this.#moduleDef.typespace.types.length);
    this.#moduleDef.typespace.types.push(newTy);
    this.#compoundTypes.set(ty, r);
    if (typeBuilder instanceof RowBuilder) {
      for (const [name2, elem] of Object.entries(typeBuilder.row)) {
        newTy.value.elements.push({
          name: name2,
          algebraicType: this.registerTypesRecursively(elem.typeBuilder).algebraicType
        });
      }
    } else if (typeBuilder instanceof ProductBuilder) {
      for (const [name2, elem] of Object.entries(typeBuilder.elements)) {
        newTy.value.elements.push({
          name: name2,
          algebraicType: this.registerTypesRecursively(elem).algebraicType
        });
      }
    } else if (typeBuilder instanceof SumBuilder) {
      for (const [name2, variant] of Object.entries(typeBuilder.variants)) {
        newTy.value.variants.push({
          name: name2,
          algebraicType: this.registerTypesRecursively(variant).algebraicType
        });
      }
    }
    this.#moduleDef.types.push({
      sourceName: splitName(name),
      ty: r.ref,
      customOrdering: true
    });
    return r;
  }
};
function isUnit(typeBuilder) {
  return typeBuilder.typeName == null && typeBuilder.algebraicType.value.elements.length === 0;
}
function splitName(name) {
  const scope = name.split(".");
  return { sourceName: scope.pop(), scope };
}

// src/server/http_internal.ts
var import_statuses = __toESM(require_statuses());

// src/server/range.ts
var Range = class {
  #from;
  #to;
  constructor(from, to) {
    this.#from = from ?? { tag: "unbounded" };
    this.#to = to ?? { tag: "unbounded" };
  }
  get from() {
    return this.#from;
  }
  get to() {
    return this.#to;
  }
};

// src/lib/table.ts
function table(opts, row, ..._) {
  const {
    name,
    public: isPublic = false,
    indexes: userIndexes = [],
    scheduled,
    event: isEvent = false
  } = opts;
  const colIds = /* @__PURE__ */ new Map();
  const colNameList = [];
  if (!(row instanceof RowBuilder)) {
    row = new RowBuilder(row);
  }
  row.algebraicType.value.elements.forEach((elem, i) => {
    colIds.set(elem.name, i);
    colNameList.push(elem.name);
  });
  const pk = [];
  const indexes = [];
  const constraints = [];
  const sequences = [];
  let scheduleAtCol;
  const defaultValues = [];
  for (const [name2, builder] of Object.entries(row.row)) {
    const meta = builder.columnMetadata;
    if (meta.isPrimaryKey) {
      pk.push(colIds.get(name2));
    }
    const isUnique = meta.isUnique || meta.isPrimaryKey;
    if (meta.indexType || isUnique) {
      const algo = meta.indexType ?? "btree";
      const id = colIds.get(name2);
      let algorithm;
      switch (algo) {
        case "btree":
          algorithm = RawIndexAlgorithm.BTree([id]);
          break;
        case "hash":
          algorithm = RawIndexAlgorithm.Hash([id]);
          break;
        case "direct":
          algorithm = RawIndexAlgorithm.Direct(id);
          break;
      }
      indexes.push({
        sourceName: void 0,
        // Unnamed indexes will be assigned a globally unique name
        accessorName: name2,
        algorithm
      });
    }
    if (isUnique) {
      constraints.push({
        sourceName: void 0,
        data: { tag: "Unique", value: { columns: [colIds.get(name2)] } }
      });
    }
    if (meta.isAutoIncrement) {
      sequences.push({
        sourceName: void 0,
        start: void 0,
        minValue: void 0,
        maxValue: void 0,
        column: colIds.get(name2),
        increment: 1n
      });
    }
    if (meta.defaultValue) {
      const writer = new BinaryWriter(16);
      builder.serialize(writer, meta.defaultValue);
      defaultValues.push({
        colId: colIds.get(name2),
        value: writer.getBuffer()
      });
    }
    if (scheduled) {
      const algebraicType = builder.typeBuilder.algebraicType;
      if (schedule_at_default.isScheduleAt(algebraicType)) {
        scheduleAtCol = colIds.get(name2);
      }
    }
  }
  for (const indexOpts of userIndexes ?? []) {
    let algorithm;
    switch (indexOpts.algorithm) {
      case "btree":
        algorithm = {
          tag: "BTree",
          value: indexOpts.columns.map((c) => colIds.get(c))
        };
        break;
      case "hash":
        algorithm = {
          tag: "Hash",
          value: indexOpts.columns.map((c) => colIds.get(c))
        };
        break;
      case "direct":
        algorithm = { tag: "Direct", value: colIds.get(indexOpts.column) };
        break;
    }
    indexes.push({
      sourceName: void 0,
      accessorName: indexOpts.accessor,
      algorithm,
      canonicalName: indexOpts.name
    });
  }
  for (const constraintOpts of opts.constraints ?? []) {
    if (constraintOpts.constraint === "unique") {
      const data = {
        tag: "Unique",
        value: { columns: constraintOpts.columns.map((c) => colIds.get(c)) }
      };
      constraints.push({ sourceName: constraintOpts.name, data });
      continue;
    }
  }
  const productType = row.algebraicType.value;
  const schedule = scheduled && scheduleAtCol !== void 0 ? { scheduleAtCol, reducer: scheduled } : void 0;
  return {
    rowType: row,
    tableName: name,
    rowSpacetimeType: productType,
    tableDef: (ctx, accName) => {
      const tableName = name ?? accName;
      if (row.typeName === void 0) {
        row.typeName = toPascalCase(tableName);
      }
      for (const index of indexes) {
        const cols = index.algorithm.tag === "Direct" ? [index.algorithm.value] : index.algorithm.value;
        const colS = cols.map((i) => colNameList[i]).join("_");
        const sourceName = index.sourceName = `${accName}_${colS}_idx_${index.algorithm.tag.toLowerCase()}`;
        const { canonicalName } = index;
        if (canonicalName !== void 0) {
          ctx.moduleDef.explicitNames.entries.push(
            ExplicitNameEntry.Index({ sourceName, canonicalName })
          );
        }
      }
      return {
        sourceName: accName,
        productTypeRef: ctx.registerTypesRecursively(row).ref,
        primaryKey: pk,
        indexes,
        constraints,
        sequences,
        tableType: { tag: "User" },
        tableAccess: { tag: isPublic ? "Public" : "Private" },
        defaultValues,
        isEvent
      };
    },
    idxs: {},
    constraints,
    schedule
  };
}

// src/lib/query.ts
var QueryBrand = Symbol("QueryBrand");
var isRowTypedQuery = (val) => !!val && typeof val === "object" && QueryBrand in val;
var isTypedQuery = (val) => !!val && typeof val === "object" && QueryBrand in val;
function toSql(q) {
  return q.toSql();
}
var SemijoinImpl = class _SemijoinImpl {
  constructor(sourceQuery, filterQuery, joinCondition) {
    this.sourceQuery = sourceQuery;
    this.filterQuery = filterQuery;
    this.joinCondition = joinCondition;
    if (sourceQuery.table.sourceName === filterQuery.table.sourceName) {
      throw new Error("Cannot semijoin a table to itself");
    }
  }
  [QueryBrand] = true;
  type = "semijoin";
  build() {
    return this;
  }
  where(predicate) {
    const nextSourceQuery = this.sourceQuery.where(predicate);
    return new _SemijoinImpl(
      nextSourceQuery,
      this.filterQuery,
      this.joinCondition
    );
  }
  toSql() {
    const left = this.filterQuery;
    const right = this.sourceQuery;
    const leftTable = quoteIdentifier(left.table.sourceName);
    const rightTable = quoteIdentifier(right.table.sourceName);
    let sql = `SELECT ${rightTable}.* FROM ${leftTable} JOIN ${rightTable} ON ${booleanExprToSql(this.joinCondition)}`;
    const clauses = [];
    if (left.whereClause) {
      clauses.push(booleanExprToSql(left.whereClause));
    }
    if (right.whereClause) {
      clauses.push(booleanExprToSql(right.whereClause));
    }
    if (clauses.length > 0) {
      const whereSql = clauses.length === 1 ? clauses[0] : clauses.map(wrapInParens).join(" AND ");
      sql += ` WHERE ${whereSql}`;
    }
    return sql;
  }
};
var FromBuilder = class _FromBuilder {
  constructor(table2, whereClause) {
    this.table = table2;
    this.whereClause = whereClause;
  }
  [QueryBrand] = true;
  where(predicate) {
    const newCondition = predicate(this.table.cols);
    const nextWhere = this.whereClause ? this.whereClause.and(newCondition) : newCondition;
    return new _FromBuilder(this.table, nextWhere);
  }
  rightSemijoin(right, on) {
    const sourceQuery = new _FromBuilder(right);
    const joinCondition = on(
      this.table.indexedCols,
      right.indexedCols
    );
    return new SemijoinImpl(sourceQuery, this, joinCondition);
  }
  leftSemijoin(right, on) {
    const filterQuery = new _FromBuilder(right);
    const joinCondition = on(
      this.table.indexedCols,
      right.indexedCols
    );
    return new SemijoinImpl(this, filterQuery, joinCondition);
  }
  toSql() {
    return renderSelectSqlWithJoins(this.table, this.whereClause);
  }
  build() {
    return this;
  }
};
var TableRefImpl = class {
  [QueryBrand] = true;
  type = "table";
  sourceName;
  accessorName;
  cols;
  indexedCols;
  tableDef;
  // Delegate UntypedTableDef properties from tableDef so this can be used as a table def.
  get columns() {
    return this.tableDef.columns;
  }
  get indexes() {
    return this.tableDef.indexes;
  }
  get rowType() {
    return this.tableDef.rowType;
  }
  get constraints() {
    return this.tableDef.constraints;
  }
  constructor(tableDef) {
    this.sourceName = tableDef.sourceName;
    this.accessorName = tableDef.accessorName;
    this.cols = createRowExpr(tableDef);
    this.indexedCols = this.cols;
    this.tableDef = tableDef;
    Object.freeze(this);
  }
  asFrom() {
    return new FromBuilder(this);
  }
  rightSemijoin(other, on) {
    return this.asFrom().rightSemijoin(other, on);
  }
  leftSemijoin(other, on) {
    return this.asFrom().leftSemijoin(other, on);
  }
  build() {
    return this.asFrom().build();
  }
  toSql() {
    return this.asFrom().toSql();
  }
  where(predicate) {
    return this.asFrom().where(predicate);
  }
};
function createTableRefFromDef(tableDef) {
  return new TableRefImpl(tableDef);
}
function makeQueryBuilder(schema2) {
  const qb = /* @__PURE__ */ Object.create(null);
  for (const table2 of Object.values(schema2.tables)) {
    const ref = createTableRefFromDef(
      table2
    );
    qb[table2.accessorName] = ref;
  }
  return Object.freeze(qb);
}
function createRowExpr(tableDef) {
  const row = {};
  for (const columnName of Object.keys(tableDef.columns)) {
    const columnBuilder = tableDef.columns[columnName];
    const column = new ColumnExpression(
      tableDef.sourceName,
      columnName,
      columnBuilder.typeBuilder.algebraicType
    );
    row[columnName] = Object.freeze(column);
  }
  return Object.freeze(row);
}
function renderSelectSqlWithJoins(table2, where, extraClauses = []) {
  const quotedTable = quoteIdentifier(table2.sourceName);
  const sql = `SELECT * FROM ${quotedTable}`;
  const clauses = [];
  if (where) clauses.push(booleanExprToSql(where));
  clauses.push(...extraClauses);
  if (clauses.length === 0) return sql;
  const whereSql = clauses.length === 1 ? clauses[0] : clauses.map(wrapInParens).join(" AND ");
  return `${sql} WHERE ${whereSql}`;
}
var ColumnExpression = class {
  type = "column";
  column;
  table;
  // phantom: actual runtime value is undefined
  tsValueType;
  spacetimeType;
  constructor(table2, column, spacetimeType) {
    this.table = table2;
    this.column = column;
    this.spacetimeType = spacetimeType;
  }
  eq(x) {
    return new BooleanExpr({
      type: "eq",
      left: this,
      right: normalizeValue(x)
    });
  }
  ne(x) {
    return new BooleanExpr({
      type: "ne",
      left: this,
      right: normalizeValue(x)
    });
  }
  lt(x) {
    return new BooleanExpr({
      type: "lt",
      left: this,
      right: normalizeValue(x)
    });
  }
  lte(x) {
    return new BooleanExpr({
      type: "lte",
      left: this,
      right: normalizeValue(x)
    });
  }
  gt(x) {
    return new BooleanExpr({
      type: "gt",
      left: this,
      right: normalizeValue(x)
    });
  }
  gte(x) {
    return new BooleanExpr({
      type: "gte",
      left: this,
      right: normalizeValue(x)
    });
  }
};
function literal(value) {
  return { type: "literal", value };
}
function normalizeValue(val) {
  if (val.type === "literal")
    return val;
  if (typeof val === "object" && val != null && "type" in val && val.type === "column") {
    return val;
  }
  return literal(val);
}
var BooleanExpr = class _BooleanExpr {
  constructor(data) {
    this.data = data;
  }
  and(other) {
    return new _BooleanExpr({ type: "and", clauses: [this.data, other.data] });
  }
  or(other) {
    return new _BooleanExpr({ type: "or", clauses: [this.data, other.data] });
  }
  not() {
    return new _BooleanExpr({ type: "not", clause: this.data });
  }
};
function not(clause) {
  return new BooleanExpr({ type: "not", clause: clause.data });
}
function and(...clauses) {
  return new BooleanExpr({
    type: "and",
    clauses: clauses.map((c) => c.data)
  });
}
function or(...clauses) {
  return new BooleanExpr({
    type: "or",
    clauses: clauses.map((c) => c.data)
  });
}
function booleanExprToSql(expr, tableAlias) {
  const data = expr instanceof BooleanExpr ? expr.data : expr;
  switch (data.type) {
    case "eq":
      return `${valueExprToSql(data.left)} = ${valueExprToSql(data.right)}`;
    case "ne":
      return `${valueExprToSql(data.left)} <> ${valueExprToSql(data.right)}`;
    case "gt":
      return `${valueExprToSql(data.left)} > ${valueExprToSql(data.right)}`;
    case "gte":
      return `${valueExprToSql(data.left)} >= ${valueExprToSql(data.right)}`;
    case "lt":
      return `${valueExprToSql(data.left)} < ${valueExprToSql(data.right)}`;
    case "lte":
      return `${valueExprToSql(data.left)} <= ${valueExprToSql(data.right)}`;
    case "and":
      return data.clauses.map((c) => booleanExprToSql(c)).map(wrapInParens).join(" AND ");
    case "or":
      return data.clauses.map((c) => booleanExprToSql(c)).map(wrapInParens).join(" OR ");
    case "not":
      return `NOT ${wrapInParens(booleanExprToSql(data.clause))}`;
  }
}
function wrapInParens(sql) {
  return `(${sql})`;
}
function valueExprToSql(expr, tableAlias) {
  if (isLiteralExpr(expr)) {
    return literalValueToSql(expr.value);
  }
  const table2 = expr.table;
  return `${quoteIdentifier(table2)}.${quoteIdentifier(expr.column)}`;
}
function literalValueToSql(value) {
  if (value === null || value === void 0) {
    return "NULL";
  }
  if (value instanceof Identity || value instanceof ConnectionId) {
    return `0x${value.toHexString()}`;
  }
  if (value instanceof Timestamp) {
    return `'${value.toISOString()}'`;
  }
  switch (typeof value) {
    case "number":
    case "bigint":
      return String(value);
    case "boolean":
      return value ? "TRUE" : "FALSE";
    case "string":
      return `'${value.replace(/'/g, "''")}'`;
    default:
      return `'${JSON.stringify(value).replace(/'/g, "''")}'`;
  }
}
function quoteIdentifier(name) {
  return `"${name.replace(/"/g, '""')}"`;
}
function isLiteralExpr(expr) {
  return expr.type === "literal";
}
function evaluateBooleanExpr(expr, row) {
  return evaluateData(expr.data, row);
}
function evaluateData(data, row) {
  switch (data.type) {
    case "eq":
      return resolveValue(data.left, row) === resolveValue(data.right, row);
    case "ne":
      return resolveValue(data.left, row) !== resolveValue(data.right, row);
    case "gt":
      return resolveValue(data.left, row) > resolveValue(data.right, row);
    case "gte":
      return resolveValue(data.left, row) >= resolveValue(data.right, row);
    case "lt":
      return resolveValue(data.left, row) < resolveValue(data.right, row);
    case "lte":
      return resolveValue(data.left, row) <= resolveValue(data.right, row);
    case "and":
      return data.clauses.every((c) => evaluateData(c, row));
    case "or":
      return data.clauses.some((c) => evaluateData(c, row));
    case "not":
      return !evaluateData(data.clause, row);
  }
}
function resolveValue(expr, row) {
  if (isLiteralExpr(expr)) {
    return toComparableValue(expr.value);
  }
  return toComparableValue(row[expr.column]);
}
function isHexSerializableLike(value) {
  return !!value && typeof value === "object" && typeof value.toHexString === "function";
}
function isTimestampLike(value) {
  if (!value || typeof value !== "object") return false;
  if (value instanceof Timestamp) return true;
  const micros = value["__timestamp_micros_since_unix_epoch__"];
  return typeof micros === "bigint";
}
function toComparableValue(value) {
  if (isHexSerializableLike(value)) {
    return value.toHexString();
  }
  if (isTimestampLike(value)) {
    return value.__timestamp_micros_since_unix_epoch__;
  }
  return value;
}
function getQueryTableName(query) {
  if (query.table) return query.table.name;
  if (query.name) return query.name;
  if (query.sourceQuery) return query.sourceQuery.table.name;
  throw new Error("Cannot extract table name from query");
}
function getQueryAccessorName(query) {
  if (query.table) return query.table.accessorName;
  if (query.accessorName) return query.accessorName;
  if (query.sourceQuery) return query.sourceQuery.table.accessorName;
  throw new Error("Cannot extract accessor name from query");
}
function getQueryWhereClause(query) {
  if (query.whereClause) return query.whereClause;
  return void 0;
}

// src/server/views.ts
function makeViewExport(ctx, opts, params, ret, fn) {
  const viewExport = (
    // @ts-expect-error typescript incorrectly says Function#bind requires an argument.
    fn.bind()
  );
  viewExport[exportContext] = ctx;
  viewExport[registerExport] = (ctx2, exportName) => {
    registerView(ctx2, opts, exportName, false, params, ret, fn);
  };
  return viewExport;
}
function makeAnonViewExport(ctx, opts, params, ret, fn) {
  const viewExport = (
    // @ts-expect-error typescript incorrectly says Function#bind requires an argument.
    fn.bind()
  );
  viewExport[exportContext] = ctx;
  viewExport[registerExport] = (ctx2, exportName) => {
    registerView(ctx2, opts, exportName, true, params, ret, fn);
  };
  return viewExport;
}
function registerView(ctx, opts, exportName, anon, params, ret, fn) {
  const paramsBuilder = new RowBuilder(params, toPascalCase(exportName));
  let returnType = ctx.registerTypesRecursively(ret).algebraicType;
  const { typespace } = ctx;
  const { value: paramType } = ctx.resolveType(
    ctx.registerTypesRecursively(paramsBuilder)
  );
  ctx.moduleDef.views.push({
    sourceName: exportName,
    index: (anon ? ctx.anonViews : ctx.views).length,
    isPublic: opts.public,
    isAnonymous: anon,
    params: paramType,
    returnType
  });
  if (opts.name != null) {
    ctx.moduleDef.explicitNames.entries.push({
      tag: "Function",
      value: {
        sourceName: exportName,
        canonicalName: opts.name
      }
    });
  }
  if (returnType.tag == "Sum") {
    const originalFn = fn;
    fn = ((ctx2, args) => {
      const ret2 = originalFn(ctx2, args);
      return ret2 == null ? [] : [ret2];
    });
    returnType = AlgebraicType.Array(
      returnType.value.variants[0].algebraicType
    );
  }
  (anon ? ctx.anonViews : ctx.views).push({
    fn,
    deserializeParams: ProductType.makeDeserializer(paramType, typespace),
    serializeReturn: AlgebraicType.makeSerializer(returnType, typespace),
    returnTypeBaseSize: bsatnBaseSize(typespace, returnType)
  });
}

// src/lib/errors.ts
var SenderError = class extends Error {
  constructor(message) {
    super(message);
  }
  get name() {
    return "SenderError";
  }
};

// src/server/errors.ts
var SpacetimeHostError = class extends Error {
  constructor(message) {
    super(message);
  }
  get name() {
    return "SpacetimeHostError";
  }
};
var errorData = {
  /**
   * A generic error class for unknown error codes.
   */
  HostCallFailure: 1,
  /**
   * Error indicating that an ABI call was made outside of a transaction.
   */
  NotInTransaction: 2,
  /**
   * Error indicating that BSATN decoding failed.
   * This typically means that the data could not be decoded to the expected type.
   */
  BsatnDecodeError: 3,
  /**
   * Error indicating that a specified table does not exist.
   */
  NoSuchTable: 4,
  /**
   * Error indicating that a specified index does not exist.
   */
  NoSuchIndex: 5,
  /**
   * Error indicating that a specified row iterator is not valid.
   */
  NoSuchIter: 6,
  /**
   * Error indicating that a specified console timer does not exist.
   */
  NoSuchConsoleTimer: 7,
  /**
   * Error indicating that a specified bytes source or sink is not valid.
   */
  NoSuchBytes: 8,
  /**
   * Error indicating that a provided sink has no more space left.
   */
  NoSpace: 9,
  /**
   * Error indicating that there is no more space in the database.
   */
  BufferTooSmall: 11,
  /**
   * Error indicating that a value with a given unique identifier already exists.
   */
  UniqueAlreadyExists: 12,
  /**
   * Error indicating that the specified delay in scheduling a row was too long.
   */
  ScheduleAtDelayTooLong: 13,
  /**
   * Error indicating that an index was not unique when it was expected to be.
   */
  IndexNotUnique: 14,
  /**
   * Error indicating that an index was not unique when it was expected to be.
   */
  NoSuchRow: 15,
  /**
   * Error indicating that an auto-increment sequence has overflowed.
   */
  AutoIncOverflow: 16,
  WouldBlockTransaction: 17,
  TransactionNotAnonymous: 18,
  TransactionIsReadOnly: 19,
  TransactionIsMut: 20,
  HttpError: 21
};
function mapEntries(x, f) {
  return Object.fromEntries(
    Object.entries(x).map(([k, v]) => [k, f(k, v)])
  );
}
var errnoToClass = /* @__PURE__ */ new Map();
var errors = Object.freeze(
  mapEntries(errorData, (name, code) => {
    const cls = Object.defineProperty(
      class extends SpacetimeHostError {
        get name() {
          return name;
        }
      },
      "name",
      { value: name, writable: false }
    );
    errnoToClass.set(code, cls);
    return cls;
  })
);
function getErrorConstructor(code) {
  return errnoToClass.get(code) ?? SpacetimeHostError;
}

// ../../node_modules/.pnpm/pure-rand@7.0.1/node_modules/pure-rand/lib/esm/distribution/UnsafeUniformBigIntDistribution.js
var SBigInt = typeof BigInt !== "undefined" ? BigInt : void 0;
var One = typeof BigInt !== "undefined" ? BigInt(1) : void 0;
var ThirtyTwo = typeof BigInt !== "undefined" ? BigInt(32) : void 0;
var NumValues = typeof BigInt !== "undefined" ? BigInt(4294967296) : void 0;
function unsafeUniformBigIntDistribution(from, to, rng) {
  var diff = to - from + One;
  var FinalNumValues = NumValues;
  var NumIterations = 1;
  while (FinalNumValues < diff) {
    FinalNumValues <<= ThirtyTwo;
    ++NumIterations;
  }
  var value = generateNext(NumIterations, rng);
  if (value < diff) {
    return value + from;
  }
  if (value + diff < FinalNumValues) {
    return value % diff + from;
  }
  var MaxAcceptedRandom = FinalNumValues - FinalNumValues % diff;
  while (value >= MaxAcceptedRandom) {
    value = generateNext(NumIterations, rng);
  }
  return value % diff + from;
}
function generateNext(NumIterations, rng) {
  var value = SBigInt(rng.unsafeNext() + 2147483648);
  for (var num = 1; num < NumIterations; ++num) {
    var out = rng.unsafeNext();
    value = (value << ThirtyTwo) + SBigInt(out + 2147483648);
  }
  return value;
}

// ../../node_modules/.pnpm/pure-rand@7.0.1/node_modules/pure-rand/lib/esm/distribution/internals/UnsafeUniformIntDistributionInternal.js
function unsafeUniformIntDistributionInternal(rangeSize, rng) {
  var MaxAllowed = rangeSize > 2 ? ~~(4294967296 / rangeSize) * rangeSize : 4294967296;
  var deltaV = rng.unsafeNext() + 2147483648;
  while (deltaV >= MaxAllowed) {
    deltaV = rng.unsafeNext() + 2147483648;
  }
  return deltaV % rangeSize;
}

// ../../node_modules/.pnpm/pure-rand@7.0.1/node_modules/pure-rand/lib/esm/distribution/internals/ArrayInt64.js
function fromNumberToArrayInt64(out, n) {
  if (n < 0) {
    var posN = -n;
    out.sign = -1;
    out.data[0] = ~~(posN / 4294967296);
    out.data[1] = posN >>> 0;
  } else {
    out.sign = 1;
    out.data[0] = ~~(n / 4294967296);
    out.data[1] = n >>> 0;
  }
  return out;
}
function substractArrayInt64(out, arrayIntA, arrayIntB) {
  var lowA = arrayIntA.data[1];
  var highA = arrayIntA.data[0];
  var signA = arrayIntA.sign;
  var lowB = arrayIntB.data[1];
  var highB = arrayIntB.data[0];
  var signB = arrayIntB.sign;
  out.sign = 1;
  if (signA === 1 && signB === -1) {
    var low_1 = lowA + lowB;
    var high = highA + highB + (low_1 > 4294967295 ? 1 : 0);
    out.data[0] = high >>> 0;
    out.data[1] = low_1 >>> 0;
    return out;
  }
  var lowFirst = lowA;
  var highFirst = highA;
  var lowSecond = lowB;
  var highSecond = highB;
  if (signA === -1) {
    lowFirst = lowB;
    highFirst = highB;
    lowSecond = lowA;
    highSecond = highA;
  }
  var reminderLow = 0;
  var low = lowFirst - lowSecond;
  if (low < 0) {
    reminderLow = 1;
    low = low >>> 0;
  }
  out.data[0] = highFirst - highSecond - reminderLow;
  out.data[1] = low;
  return out;
}

// ../../node_modules/.pnpm/pure-rand@7.0.1/node_modules/pure-rand/lib/esm/distribution/internals/UnsafeUniformArrayIntDistributionInternal.js
function unsafeUniformArrayIntDistributionInternal(out, rangeSize, rng) {
  var rangeLength = rangeSize.length;
  while (true) {
    for (var index = 0; index !== rangeLength; ++index) {
      var indexRangeSize = index === 0 ? rangeSize[0] + 1 : 4294967296;
      var g = unsafeUniformIntDistributionInternal(indexRangeSize, rng);
      out[index] = g;
    }
    for (var index = 0; index !== rangeLength; ++index) {
      var current = out[index];
      var currentInRange = rangeSize[index];
      if (current < currentInRange) {
        return out;
      } else if (current > currentInRange) {
        break;
      }
    }
  }
}

// ../../node_modules/.pnpm/pure-rand@7.0.1/node_modules/pure-rand/lib/esm/distribution/UnsafeUniformIntDistribution.js
var safeNumberMaxSafeInteger = Number.MAX_SAFE_INTEGER;
var sharedA = { sign: 1, data: [0, 0] };
var sharedB = { sign: 1, data: [0, 0] };
var sharedC = { sign: 1, data: [0, 0] };
var sharedData = [0, 0];
function uniformLargeIntInternal(from, to, rangeSize, rng) {
  var rangeSizeArrayIntValue = rangeSize <= safeNumberMaxSafeInteger ? fromNumberToArrayInt64(sharedC, rangeSize) : substractArrayInt64(sharedC, fromNumberToArrayInt64(sharedA, to), fromNumberToArrayInt64(sharedB, from));
  if (rangeSizeArrayIntValue.data[1] === 4294967295) {
    rangeSizeArrayIntValue.data[0] += 1;
    rangeSizeArrayIntValue.data[1] = 0;
  } else {
    rangeSizeArrayIntValue.data[1] += 1;
  }
  unsafeUniformArrayIntDistributionInternal(sharedData, rangeSizeArrayIntValue.data, rng);
  return sharedData[0] * 4294967296 + sharedData[1] + from;
}
function unsafeUniformIntDistribution(from, to, rng) {
  var rangeSize = to - from;
  if (rangeSize <= 4294967295) {
    var g = unsafeUniformIntDistributionInternal(rangeSize + 1, rng);
    return g + from;
  }
  return uniformLargeIntInternal(from, to, rangeSize, rng);
}

// ../../node_modules/.pnpm/pure-rand@7.0.1/node_modules/pure-rand/lib/esm/generator/XoroShiro.js
var XoroShiro128Plus = (function() {
  function XoroShiro128Plus2(s01, s00, s11, s10) {
    this.s01 = s01;
    this.s00 = s00;
    this.s11 = s11;
    this.s10 = s10;
  }
  XoroShiro128Plus2.prototype.clone = function() {
    return new XoroShiro128Plus2(this.s01, this.s00, this.s11, this.s10);
  };
  XoroShiro128Plus2.prototype.next = function() {
    var nextRng = new XoroShiro128Plus2(this.s01, this.s00, this.s11, this.s10);
    var out = nextRng.unsafeNext();
    return [out, nextRng];
  };
  XoroShiro128Plus2.prototype.unsafeNext = function() {
    var out = this.s00 + this.s10 | 0;
    var a0 = this.s10 ^ this.s00;
    var a1 = this.s11 ^ this.s01;
    var s00 = this.s00;
    var s01 = this.s01;
    this.s00 = s00 << 24 ^ s01 >>> 8 ^ a0 ^ a0 << 16;
    this.s01 = s01 << 24 ^ s00 >>> 8 ^ a1 ^ (a1 << 16 | a0 >>> 16);
    this.s10 = a1 << 5 ^ a0 >>> 27;
    this.s11 = a0 << 5 ^ a1 >>> 27;
    return out;
  };
  XoroShiro128Plus2.prototype.jump = function() {
    var nextRng = new XoroShiro128Plus2(this.s01, this.s00, this.s11, this.s10);
    nextRng.unsafeJump();
    return nextRng;
  };
  XoroShiro128Plus2.prototype.unsafeJump = function() {
    var ns01 = 0;
    var ns00 = 0;
    var ns11 = 0;
    var ns10 = 0;
    var jump = [3639956645, 3750757012, 1261568508, 386426335];
    for (var i = 0; i !== 4; ++i) {
      for (var mask = 1; mask; mask <<= 1) {
        if (jump[i] & mask) {
          ns01 ^= this.s01;
          ns00 ^= this.s00;
          ns11 ^= this.s11;
          ns10 ^= this.s10;
        }
        this.unsafeNext();
      }
    }
    this.s01 = ns01;
    this.s00 = ns00;
    this.s11 = ns11;
    this.s10 = ns10;
  };
  XoroShiro128Plus2.prototype.getState = function() {
    return [this.s01, this.s00, this.s11, this.s10];
  };
  return XoroShiro128Plus2;
})();
function fromState(state) {
  var valid = state.length === 4;
  if (!valid) {
    throw new Error("The state must have been produced by a xoroshiro128plus RandomGenerator");
  }
  return new XoroShiro128Plus(state[0], state[1], state[2], state[3]);
}
var xoroshiro128plus = Object.assign(function(seed) {
  return new XoroShiro128Plus(-1, ~seed, seed | 0, 0);
}, { fromState });

// src/server/rng.ts
var { asUintN } = BigInt;
function pcg32(state) {
  const MUL = 6364136223846793005n;
  const INC = 11634580027462260723n;
  state = asUintN(64, state * MUL + INC);
  const xorshifted = Number(asUintN(32, (state >> 18n ^ state) >> 27n));
  const rot = Number(asUintN(32, state >> 59n));
  return xorshifted >> rot | xorshifted << 32 - rot;
}
function generateFloat64(rng) {
  const g1 = unsafeUniformIntDistribution(0, (1 << 26) - 1, rng);
  const g2 = unsafeUniformIntDistribution(0, (1 << 27) - 1, rng);
  const value = (g1 * Math.pow(2, 27) + g2) * Math.pow(2, -53);
  return value;
}
function makeRandom(seed) {
  const rng = xoroshiro128plus(pcg32(seed.microsSinceUnixEpoch));
  const random = () => generateFloat64(rng);
  random.fill = (array) => {
    const elem = array.at(0);
    if (typeof elem === "bigint") {
      const upper = (1n << BigInt(array.BYTES_PER_ELEMENT * 8)) - 1n;
      for (let i = 0; i < array.length; i++) {
        array[i] = unsafeUniformBigIntDistribution(0n, upper, rng);
      }
    } else if (typeof elem === "number") {
      const upper = (1 << array.BYTES_PER_ELEMENT * 8) - 1;
      for (let i = 0; i < array.length; i++) {
        array[i] = unsafeUniformIntDistribution(0, upper, rng);
      }
    }
    return array;
  };
  random.uint32 = () => rng.unsafeNext();
  random.integerInRange = (min, max) => unsafeUniformIntDistribution(min, max, rng);
  random.bigintInRange = (min, max) => unsafeUniformBigIntDistribution(min, max, rng);
  return random;
}

// src/server/runtime.ts
var { freeze } = Object;
var sys = _syscalls2_0;
function parseJsonObject(json) {
  let value;
  try {
    value = JSON.parse(json);
  } catch {
    throw new Error("Invalid JSON: failed to parse string");
  }
  if (value === null || typeof value !== "object" || Array.isArray(value)) {
    throw new Error("Expected a JSON object at the top level");
  }
  return value;
}
var JwtClaimsImpl = class {
  /**
   * Creates a new JwtClaims instance.
   * @param rawPayload The JWT payload as a raw JSON string.
   * @param identity The identity for this JWT. We are only taking this because we don't have a blake3 implementation (which we need to compute it).
   */
  constructor(rawPayload, identity) {
    this.rawPayload = rawPayload;
    this.fullPayload = parseJsonObject(rawPayload);
    this._identity = identity;
  }
  fullPayload;
  _identity;
  get identity() {
    return this._identity;
  }
  get subject() {
    return this.fullPayload["sub"];
  }
  get issuer() {
    return this.fullPayload["iss"];
  }
  get audience() {
    const aud = this.fullPayload["aud"];
    if (aud == null) {
      return [];
    }
    return typeof aud === "string" ? [aud] : aud;
  }
};
var AuthCtxImpl = class _AuthCtxImpl {
  isInternal;
  // Source of the JWT payload string, if there is one.
  _jwtSource;
  // Whether we have initialized the JWT claims.
  _initializedJWT = false;
  _jwtClaims;
  _senderIdentity;
  constructor(opts) {
    this.isInternal = opts.isInternal;
    this._jwtSource = opts.jwtSource;
    this._senderIdentity = opts.senderIdentity;
  }
  _initializeJWT() {
    if (this._initializedJWT) return;
    this._initializedJWT = true;
    const token = this._jwtSource();
    if (!token) {
      this._jwtClaims = null;
    } else {
      this._jwtClaims = new JwtClaimsImpl(token, this._senderIdentity);
    }
    Object.freeze(this);
  }
  /** Lazily compute whether a JWT exists and is parseable. */
  get hasJWT() {
    this._initializeJWT();
    return this._jwtClaims !== null;
  }
  /** Lazily parse the JwtClaims only when accessed. */
  get jwt() {
    this._initializeJWT();
    return this._jwtClaims;
  }
  /** Create a context representing internal (non-user) requests. */
  static internal() {
    return new _AuthCtxImpl({
      isInternal: true,
      jwtSource: () => null,
      senderIdentity: Identity.zero()
    });
  }
  /** If there is a connection id, look up the JWT payload from the system tables. */
  static fromSystemTables(connectionId, sender) {
    if (connectionId === null) {
      return new _AuthCtxImpl({
        isInternal: false,
        jwtSource: () => null,
        senderIdentity: sender
      });
    }
    return new _AuthCtxImpl({
      isInternal: false,
      jwtSource: () => {
        const payloadBuf = sys.get_jwt_payload(connectionId.__connection_id__);
        if (payloadBuf.length === 0) return null;
        const payloadStr = new TextDecoder().decode(payloadBuf);
        return payloadStr;
      },
      senderIdentity: sender
    });
  }
};
var ReducerCtxImpl = class ReducerCtx {
  #identity;
  #senderAuth;
  #uuidCounter;
  #random;
  sender;
  timestamp;
  connectionId;
  db;
  constructor(sender, timestamp, connectionId, dbView) {
    Object.seal(this);
    this.sender = sender;
    this.timestamp = timestamp;
    this.connectionId = connectionId;
    this.db = dbView;
  }
  /** Reset the `ReducerCtx` to be used for a new transaction */
  static reset(me, sender, timestamp, connectionId) {
    me.sender = sender;
    me.timestamp = timestamp;
    me.connectionId = connectionId;
    me.#uuidCounter = void 0;
    me.#senderAuth = void 0;
  }
  get identity() {
    return this.#identity ??= new Identity(sys.identity());
  }
  get senderAuth() {
    return this.#senderAuth ??= AuthCtxImpl.fromSystemTables(
      this.connectionId,
      this.sender
    );
  }
  get random() {
    return this.#random ??= makeRandom(this.timestamp);
  }
  /**
   * Create a new random {@link Uuid} `v4` using this `ReducerCtx`'s RNG.
   */
  newUuidV4() {
    const bytes = this.random.fill(new Uint8Array(16));
    return Uuid.fromRandomBytesV4(bytes);
  }
  /**
   * Create a new sortable {@link Uuid} `v7` using this `ReducerCtx`'s RNG, counter,
   * and timestamp.
   */
  newUuidV7() {
    const bytes = this.random.fill(new Uint8Array(4));
    const counter = this.#uuidCounter ??= { value: 0 };
    return Uuid.fromCounterV7(counter, this.timestamp, bytes);
  }
};
var callUserFunction = function __spacetimedb_end_short_backtrace(fn, ...args) {
  return fn(...args);
};
var makeHooks = (schema2) => new ModuleHooksImpl(schema2);
var ModuleHooksImpl = class {
  #schema;
  #dbView_;
  #reducerArgsDeserializers;
  /** Cache the `ReducerCtx` object to avoid allocating anew for ever reducer call. */
  #reducerCtx_;
  constructor(schema2) {
    this.#schema = schema2;
    this.#reducerArgsDeserializers = schema2.moduleDef.reducers.map(
      ({ params }) => ProductType.makeDeserializer(params, schema2.typespace)
    );
  }
  get #dbView() {
    return this.#dbView_ ??= freeze(
      Object.fromEntries(
        Object.values(this.#schema.schemaType.tables).map((table2) => [
          table2.accessorName,
          makeTableView(this.#schema.typespace, table2.tableDef)
        ])
      )
    );
  }
  get #reducerCtx() {
    return this.#reducerCtx_ ??= new ReducerCtxImpl(
      Identity.zero(),
      Timestamp.UNIX_EPOCH,
      null,
      this.#dbView
    );
  }
  __describe_module__() {
    const writer = new BinaryWriter(128);
    RawModuleDef.serialize(
      writer,
      RawModuleDef.V10(this.#schema.rawModuleDefV10())
    );
    return writer.getBuffer();
  }
  __get_error_constructor__(code) {
    return getErrorConstructor(code);
  }
  get __sender_error_class__() {
    return SenderError;
  }
  __call_reducer__(reducerId, sender, connId, timestamp, argsBuf) {
    const moduleCtx = this.#schema;
    const deserializeArgs = this.#reducerArgsDeserializers[reducerId];
    BINARY_READER.reset(argsBuf);
    const args = deserializeArgs(BINARY_READER);
    const senderIdentity = new Identity(sender);
    const ctx = this.#reducerCtx;
    ReducerCtxImpl.reset(
      ctx,
      senderIdentity,
      new Timestamp(timestamp),
      ConnectionId.nullIfZero(new ConnectionId(connId))
    );
    callUserFunction(moduleCtx.reducers[reducerId], ctx, args);
  }
  __call_view__(id, sender, argsBuf) {
    const moduleCtx = this.#schema;
    const { fn, deserializeParams, serializeReturn, returnTypeBaseSize } = moduleCtx.views[id];
    const ctx = freeze({
      sender: new Identity(sender),
      // this is the non-readonly DbView, but the typing for the user will be
      // the readonly one, and if they do call mutating functions it will fail
      // at runtime
      db: this.#dbView,
      from: makeQueryBuilder(moduleCtx.schemaType)
    });
    const args = deserializeParams(new BinaryReader(argsBuf));
    const ret = callUserFunction(fn, ctx, args);
    const retBuf = new BinaryWriter(returnTypeBaseSize);
    if (isRowTypedQuery(ret)) {
      const query = toSql(ret);
      ViewResultHeader.serialize(retBuf, ViewResultHeader.RawSql(query));
    } else {
      ViewResultHeader.serialize(retBuf, ViewResultHeader.RowData);
      serializeReturn(retBuf, ret);
    }
    return { data: retBuf.getBuffer() };
  }
  __call_view_anon__(id, argsBuf) {
    const moduleCtx = this.#schema;
    const { fn, deserializeParams, serializeReturn, returnTypeBaseSize } = moduleCtx.anonViews[id];
    const ctx = freeze({
      // this is the non-readonly DbView, but the typing for the user will be
      // the readonly one, and if they do call mutating functions it will fail
      // at runtime
      db: this.#dbView,
      from: makeQueryBuilder(moduleCtx.schemaType)
    });
    const args = deserializeParams(new BinaryReader(argsBuf));
    const ret = callUserFunction(fn, ctx, args);
    const retBuf = new BinaryWriter(returnTypeBaseSize);
    if (isRowTypedQuery(ret)) {
      const query = toSql(ret);
      ViewResultHeader.serialize(retBuf, ViewResultHeader.RawSql(query));
    } else {
      ViewResultHeader.serialize(retBuf, ViewResultHeader.RowData);
      serializeReturn(retBuf, ret);
    }
    return { data: retBuf.getBuffer() };
  }
  __call_procedure__(id, sender, connection_id, timestamp, args) {
    return callProcedure(
      this.#schema,
      id,
      new Identity(sender),
      ConnectionId.nullIfZero(new ConnectionId(connection_id)),
      new Timestamp(timestamp),
      args,
      () => this.#dbView
    );
  }
};
var BINARY_WRITER = new BinaryWriter(0);
var BINARY_READER = new BinaryReader(new Uint8Array());
function makeTableView(typespace, table2) {
  const table_id = sys.table_id_from_name(table2.sourceName);
  const rowType = typespace.types[table2.productTypeRef];
  if (rowType.tag !== "Product") {
    throw "impossible";
  }
  const serializeRow = AlgebraicType.makeSerializer(rowType, typespace);
  const deserializeRow = AlgebraicType.makeDeserializer(rowType, typespace);
  const sequences = table2.sequences.map((seq) => {
    const col = rowType.value.elements[seq.column];
    const colType = col.algebraicType;
    let sequenceTrigger;
    switch (colType.tag) {
      case "U8":
      case "I8":
      case "U16":
      case "I16":
      case "U32":
      case "I32":
        sequenceTrigger = 0;
        break;
      case "U64":
      case "I64":
      case "U128":
      case "I128":
      case "U256":
      case "I256":
        sequenceTrigger = 0n;
        break;
      default:
        throw new TypeError("invalid sequence type");
    }
    return {
      colName: col.name,
      sequenceTrigger,
      deserialize: AlgebraicType.makeDeserializer(colType, typespace)
    };
  });
  const hasAutoIncrement = sequences.length > 0;
  const iter = () => tableIterator(sys.datastore_table_scan_bsatn(table_id), deserializeRow);
  const integrateGeneratedColumns = hasAutoIncrement ? (row, ret_buf) => {
    BINARY_READER.reset(ret_buf);
    for (const { colName, deserialize, sequenceTrigger } of sequences) {
      if (row[colName] === sequenceTrigger) {
        row[colName] = deserialize(BINARY_READER);
      }
    }
  } : null;
  const tableMethods = {
    count: () => sys.datastore_table_row_count(table_id),
    iter,
    [Symbol.iterator]: () => iter(),
    insert: (row) => {
      const buf = LEAF_BUF;
      BINARY_WRITER.reset(buf);
      serializeRow(BINARY_WRITER, row);
      sys.datastore_insert_bsatn(table_id, buf.buffer, BINARY_WRITER.offset);
      const ret = { ...row };
      integrateGeneratedColumns?.(ret, buf.view);
      return ret;
    },
    delete: (row) => {
      const buf = LEAF_BUF;
      BINARY_WRITER.reset(buf);
      BINARY_WRITER.writeU32(1);
      serializeRow(BINARY_WRITER, row);
      const count = sys.datastore_delete_all_by_eq_bsatn(
        table_id,
        buf.buffer,
        BINARY_WRITER.offset
      );
      return count > 0;
    }
  };
  const tableView = Object.assign(
    /* @__PURE__ */ Object.create(null),
    tableMethods
  );
  for (const indexDef of table2.indexes) {
    const index_id = sys.index_id_from_name(indexDef.sourceName);
    let column_ids;
    let isHashIndex = false;
    switch (indexDef.algorithm.tag) {
      case "Hash":
        isHashIndex = true;
        column_ids = indexDef.algorithm.value;
        break;
      case "BTree":
        column_ids = indexDef.algorithm.value;
        break;
      case "Direct":
        column_ids = [indexDef.algorithm.value];
        break;
    }
    const numColumns = column_ids.length;
    const columnSet = new Set(column_ids);
    const isUnique = table2.constraints.filter((x) => x.data.tag === "Unique").some((x) => columnSet.isSubsetOf(new Set(x.data.value.columns)));
    const isPrimaryKey = isUnique && column_ids.length === table2.primaryKey.length && column_ids.every((id, i) => table2.primaryKey[i] === id);
    const indexSerializers = column_ids.map(
      (id) => AlgebraicType.makeSerializer(
        rowType.value.elements[id].algebraicType,
        typespace
      )
    );
    const serializePoint = (buffer, colVal) => {
      BINARY_WRITER.reset(buffer);
      for (let i = 0; i < numColumns; i++) {
        indexSerializers[i](BINARY_WRITER, colVal[i]);
      }
      return BINARY_WRITER.offset;
    };
    const serializeSingleElement = numColumns === 1 ? indexSerializers[0] : null;
    const serializeSinglePoint = serializeSingleElement && ((buffer, colVal) => {
      BINARY_WRITER.reset(buffer);
      serializeSingleElement(BINARY_WRITER, colVal);
      return BINARY_WRITER.offset;
    });
    let index;
    if (isUnique && serializeSinglePoint) {
      const base = {
        find: (colVal) => {
          const buf = LEAF_BUF;
          const point_len = serializeSinglePoint(buf, colVal);
          const iter_id = sys.datastore_index_scan_point_bsatn(
            index_id,
            buf.buffer,
            point_len
          );
          return tableIterateOne(iter_id, deserializeRow);
        },
        delete: (colVal) => {
          const buf = LEAF_BUF;
          const point_len = serializeSinglePoint(buf, colVal);
          const num = sys.datastore_delete_by_index_scan_point_bsatn(
            index_id,
            buf.buffer,
            point_len
          );
          return num > 0;
        }
      };
      if (isPrimaryKey) {
        base.update = (row) => {
          const buf = LEAF_BUF;
          BINARY_WRITER.reset(buf);
          serializeRow(BINARY_WRITER, row);
          sys.datastore_update_bsatn(
            table_id,
            index_id,
            buf.buffer,
            BINARY_WRITER.offset
          );
          integrateGeneratedColumns?.(row, buf.view);
          return row;
        };
      }
      index = base;
    } else if (isUnique) {
      const base = {
        find: (colVal) => {
          if (colVal.length !== numColumns) {
            throw new TypeError("wrong number of elements");
          }
          const buf = LEAF_BUF;
          const point_len = serializePoint(buf, colVal);
          const iter_id = sys.datastore_index_scan_point_bsatn(
            index_id,
            buf.buffer,
            point_len
          );
          return tableIterateOne(iter_id, deserializeRow);
        },
        delete: (colVal) => {
          if (colVal.length !== numColumns)
            throw new TypeError("wrong number of elements");
          const buf = LEAF_BUF;
          const point_len = serializePoint(buf, colVal);
          const num = sys.datastore_delete_by_index_scan_point_bsatn(
            index_id,
            buf.buffer,
            point_len
          );
          return num > 0;
        }
      };
      if (isPrimaryKey) {
        base.update = (row) => {
          const buf = LEAF_BUF;
          BINARY_WRITER.reset(buf);
          serializeRow(BINARY_WRITER, row);
          sys.datastore_update_bsatn(
            table_id,
            index_id,
            buf.buffer,
            BINARY_WRITER.offset
          );
          integrateGeneratedColumns?.(row, buf.view);
          return row;
        };
      }
      index = base;
    } else if (serializeSinglePoint) {
      const rawIndex = {
        filter: (range) => {
          const buf = LEAF_BUF;
          const point_len = serializeSinglePoint(buf, range);
          const iter_id = sys.datastore_index_scan_point_bsatn(
            index_id,
            buf.buffer,
            point_len
          );
          return tableIterator(iter_id, deserializeRow);
        },
        delete: (range) => {
          const buf = LEAF_BUF;
          const point_len = serializeSinglePoint(buf, range);
          return sys.datastore_delete_by_index_scan_point_bsatn(
            index_id,
            buf.buffer,
            point_len
          );
        }
      };
      if (isHashIndex) {
        index = rawIndex;
      } else {
        index = rawIndex;
      }
    } else if (isHashIndex) {
      index = {
        filter: (range) => {
          const buf = LEAF_BUF;
          const point_len = serializePoint(buf, range);
          const iter_id = sys.datastore_index_scan_point_bsatn(
            index_id,
            buf.buffer,
            point_len
          );
          return tableIterator(iter_id, deserializeRow);
        },
        delete: (range) => {
          const buf = LEAF_BUF;
          const point_len = serializePoint(buf, range);
          return sys.datastore_delete_by_index_scan_point_bsatn(
            index_id,
            buf.buffer,
            point_len
          );
        }
      };
    } else {
      const serializeRange = (buffer, range) => {
        if (range.length > numColumns) throw new TypeError("too many elements");
        BINARY_WRITER.reset(buffer);
        const writer = BINARY_WRITER;
        const prefix_elems = range.length - 1;
        for (let i = 0; i < prefix_elems; i++) {
          indexSerializers[i](writer, range[i]);
        }
        const rstartOffset = writer.offset;
        const term = range[range.length - 1];
        const serializeTerm = indexSerializers[range.length - 1];
        if (term instanceof Range) {
          const writeBound = (bound) => {
            const tags = { included: 0, excluded: 1, unbounded: 2 };
            writer.writeU8(tags[bound.tag]);
            if (bound.tag !== "unbounded") serializeTerm(writer, bound.value);
          };
          writeBound(term.from);
          const rstartLen = writer.offset - rstartOffset;
          writeBound(term.to);
          const rendLen = writer.offset - rstartLen;
          return [rstartOffset, prefix_elems, rstartLen, rendLen];
        } else {
          writer.writeU8(0);
          serializeTerm(writer, term);
          const rstartLen = writer.offset;
          const rendLen = 0;
          return [rstartOffset, prefix_elems, rstartLen, rendLen];
        }
      };
      index = {
        filter: (range) => {
          if (range.length === numColumns) {
            const buf = LEAF_BUF;
            const point_len = serializePoint(buf, range);
            const iter_id = sys.datastore_index_scan_point_bsatn(
              index_id,
              buf.buffer,
              point_len
            );
            return tableIterator(iter_id, deserializeRow);
          } else {
            const buf = LEAF_BUF;
            const args = serializeRange(buf, range);
            const iter_id = sys.datastore_index_scan_range_bsatn(
              index_id,
              buf.buffer,
              ...args
            );
            return tableIterator(iter_id, deserializeRow);
          }
        },
        delete: (range) => {
          if (range.length === numColumns) {
            const buf = LEAF_BUF;
            const point_len = serializePoint(buf, range);
            return sys.datastore_delete_by_index_scan_point_bsatn(
              index_id,
              buf.buffer,
              point_len
            );
          } else {
            const buf = LEAF_BUF;
            const args = serializeRange(buf, range);
            return sys.datastore_delete_by_index_scan_range_bsatn(
              index_id,
              buf.buffer,
              ...args
            );
          }
        }
      };
    }
    if (Object.hasOwn(tableView, indexDef.accessorName)) {
      freeze(Object.assign(tableView[indexDef.accessorName], index));
    } else {
      tableView[indexDef.accessorName] = freeze(index);
    }
  }
  return freeze(tableView);
}
function* tableIterator(id, deserialize) {
  using iter = new IteratorHandle(id);
  const iterBuf = takeBuf();
  try {
    let amt;
    while (amt = iter.advance(iterBuf)) {
      const reader = new BinaryReader(iterBuf.view);
      while (reader.offset < amt) {
        yield deserialize(reader);
      }
    }
  } finally {
    returnBuf(iterBuf);
  }
}
function tableIterateOne(id, deserialize) {
  const buf = LEAF_BUF;
  const ret = advanceIterRaw(id, buf);
  if (ret !== 0) {
    BINARY_READER.reset(buf.view);
    return deserialize(BINARY_READER);
  }
  return null;
}
function advanceIterRaw(id, buf) {
  while (true) {
    try {
      return 0 | sys.row_iter_bsatn_advance(id, buf.buffer);
    } catch (e) {
      if (e && typeof e === "object" && hasOwn(e, "__buffer_too_small__")) {
        buf.grow(e.__buffer_too_small__);
        continue;
      }
      throw e;
    }
  }
}
var DEFAULT_BUFFER_CAPACITY = 32 * 1024 * 2;
var ITER_BUFS = [
  new ResizableBuffer(DEFAULT_BUFFER_CAPACITY)
];
var ITER_BUF_COUNT = 1;
function takeBuf() {
  return ITER_BUF_COUNT ? ITER_BUFS[--ITER_BUF_COUNT] : new ResizableBuffer(DEFAULT_BUFFER_CAPACITY);
}
function returnBuf(buf) {
  ITER_BUFS[ITER_BUF_COUNT++] = buf;
}
var LEAF_BUF = new ResizableBuffer(DEFAULT_BUFFER_CAPACITY);
var IteratorHandle = class _IteratorHandle {
  #id;
  static #finalizationRegistry = new FinalizationRegistry(
    sys.row_iter_bsatn_close
  );
  constructor(id) {
    this.#id = id;
    _IteratorHandle.#finalizationRegistry.register(this, id, this);
  }
  /** Unregister this object with the finalization registry and return the id */
  #detach() {
    const id = this.#id;
    this.#id = -1;
    _IteratorHandle.#finalizationRegistry.unregister(this);
    return id;
  }
  /** Call `row_iter_bsatn_advance`, returning 0 if this iterator has been exhausted. */
  advance(buf) {
    if (this.#id === -1) return 0;
    const ret = advanceIterRaw(this.#id, buf);
    if (ret <= 0) this.#detach();
    return ret < 0 ? -ret : ret;
  }
  [Symbol.dispose]() {
    if (this.#id >= 0) {
      const id = this.#detach();
      sys.row_iter_bsatn_close(id);
    }
  }
};

// src/server/http_internal.ts
var { freeze: freeze2 } = Object;
var textEncoder = new TextEncoder();
var textDecoder = new TextDecoder(
  "utf-8"
  /* { fatal: true } */
);
var makeResponse = Symbol("makeResponse");
var SyncResponse = class _SyncResponse {
  #body;
  #inner;
  constructor(body, init) {
    if (body == null) {
      this.#body = null;
    } else if (typeof body === "string") {
      this.#body = body;
    } else {
      this.#body = new Uint8Array(body).buffer;
    }
    this.#inner = {
      headers: new Headers(init?.headers),
      status: init?.status ?? 200,
      statusText: init?.statusText ?? "",
      type: "default",
      url: null,
      aborted: false
    };
  }
  static [makeResponse](body, inner) {
    const me = new _SyncResponse(body);
    me.#inner = inner;
    return me;
  }
  get headers() {
    return this.#inner.headers;
  }
  get status() {
    return this.#inner.status;
  }
  get statusText() {
    return this.#inner.statusText;
  }
  get ok() {
    return 200 <= this.#inner.status && this.#inner.status <= 299;
  }
  get url() {
    return this.#inner.url ?? "";
  }
  get type() {
    return this.#inner.type;
  }
  arrayBuffer() {
    return this.bytes().buffer;
  }
  bytes() {
    if (this.#body == null) {
      return new Uint8Array();
    } else if (typeof this.#body === "string") {
      return textEncoder.encode(this.#body);
    } else {
      return new Uint8Array(this.#body);
    }
  }
  json() {
    return JSON.parse(this.text());
  }
  text() {
    if (this.#body == null) {
      return "";
    } else if (typeof this.#body === "string") {
      return this.#body;
    } else {
      return textDecoder.decode(this.#body);
    }
  }
};
var requestBaseSize = bsatnBaseSize({ types: [] }, HttpRequest.algebraicType);
var methods = /* @__PURE__ */ new Map([
  ["GET", { tag: "Get" }],
  ["HEAD", { tag: "Head" }],
  ["POST", { tag: "Post" }],
  ["PUT", { tag: "Put" }],
  ["DELETE", { tag: "Delete" }],
  ["CONNECT", { tag: "Connect" }],
  ["OPTIONS", { tag: "Options" }],
  ["TRACE", { tag: "Trace" }],
  ["PATCH", { tag: "Patch" }]
]);
function fetch(url, init = {}) {
  const method = methods.get(init.method?.toUpperCase() ?? "GET") ?? {
    tag: "Extension",
    value: init.method
  };
  const headers = {
    // anys because the typings are wonky - see comment in SyncResponse.constructor
    entries: headersToList(new Headers(init.headers)).flatMap(([k, v]) => Array.isArray(v) ? v.map((v2) => [k, v2]) : [[k, v]]).map(([name, value]) => ({ name, value: textEncoder.encode(value) }))
  };
  const uri = "" + url;
  const request = freeze2({
    method,
    headers,
    timeout: init.timeout,
    uri,
    version: { tag: "Http11" }
  });
  const requestBuf = new BinaryWriter(requestBaseSize);
  HttpRequest.serialize(requestBuf, request);
  const body = init.body == null ? new Uint8Array() : typeof init.body === "string" ? init.body : new Uint8Array(init.body);
  const [responseBuf, responseBody] = sys.procedure_http_request(
    requestBuf.getBuffer(),
    body
  );
  const response = HttpResponse.deserialize(new BinaryReader(responseBuf));
  return SyncResponse[makeResponse](responseBody, {
    type: "basic",
    url: uri,
    status: response.code,
    statusText: (0, import_statuses.default)(response.code),
    headers: new Headers(),
    aborted: false
  });
}
freeze2(fetch);
var httpClient = freeze2({ fetch });

// src/server/procedures.ts
function makeProcedureExport(ctx, opts, params, ret, fn) {
  const name = opts?.name;
  const procedureExport = (...args) => fn(...args);
  procedureExport[exportContext] = ctx;
  procedureExport[registerExport] = (ctx2, exportName) => {
    registerProcedure(ctx2, name ?? exportName, params, ret, fn);
    ctx2.functionExports.set(
      procedureExport,
      name ?? exportName
    );
  };
  return procedureExport;
}
var TransactionCtxImpl = class TransactionCtx extends ReducerCtxImpl {
};
function registerProcedure(ctx, exportName, params, ret, fn, opts) {
  ctx.defineFunction(exportName);
  const paramsType = {
    elements: Object.entries(params).map(([n, c]) => ({
      name: n,
      algebraicType: ctx.registerTypesRecursively(
        "typeBuilder" in c ? c.typeBuilder : c
      ).algebraicType
    }))
  };
  const returnType = ctx.registerTypesRecursively(ret).algebraicType;
  ctx.moduleDef.procedures.push({
    sourceName: exportName,
    params: paramsType,
    returnType,
    visibility: FunctionVisibility.ClientCallable
  });
  const { typespace } = ctx;
  ctx.procedures.push({
    fn,
    deserializeArgs: ProductType.makeDeserializer(paramsType, typespace),
    serializeReturn: AlgebraicType.makeSerializer(returnType, typespace),
    returnTypeBaseSize: bsatnBaseSize(typespace, returnType)
  });
}
function callProcedure(moduleCtx, id, sender, connectionId, timestamp, argsBuf, dbView) {
  const { fn, deserializeArgs, serializeReturn, returnTypeBaseSize } = moduleCtx.procedures[id];
  const args = deserializeArgs(new BinaryReader(argsBuf));
  const ctx = new ProcedureCtxImpl(
    sender,
    timestamp,
    connectionId,
    dbView
  );
  const ret = callUserFunction(fn, ctx, args);
  const retBuf = new BinaryWriter(returnTypeBaseSize);
  serializeReturn(retBuf, ret);
  return retBuf.getBuffer();
}
var ProcedureCtxImpl = class ProcedureCtx {
  constructor(sender, timestamp, connectionId, dbView) {
    this.sender = sender;
    this.timestamp = timestamp;
    this.connectionId = connectionId;
    this.#dbView = dbView;
  }
  #identity;
  #uuidCounter;
  #random;
  #dbView;
  get identity() {
    return this.#identity ??= new Identity(sys.identity());
  }
  get random() {
    return this.#random ??= makeRandom(this.timestamp);
  }
  get http() {
    return httpClient;
  }
  withTx(body) {
    const run = () => {
      const timestamp = sys.procedure_start_mut_tx();
      try {
        const ctx = new TransactionCtxImpl(
          this.sender,
          new Timestamp(timestamp),
          this.connectionId,
          this.#dbView()
        );
        return body(ctx);
      } catch (e) {
        sys.procedure_abort_mut_tx();
        throw e;
      }
    };
    let res = run();
    try {
      sys.procedure_commit_mut_tx();
      return res;
    } catch {
    }
    console.warn("committing anonymous transaction failed");
    res = run();
    try {
      sys.procedure_commit_mut_tx();
      return res;
    } catch (e) {
      throw new Error("transaction retry failed again", { cause: e });
    }
  }
  newUuidV4() {
    const bytes = this.random.fill(new Uint8Array(16));
    return Uuid.fromRandomBytesV4(bytes);
  }
  newUuidV7() {
    const bytes = this.random.fill(new Uint8Array(4));
    const counter = this.#uuidCounter ??= { value: 0 };
    return Uuid.fromCounterV7(counter, this.timestamp, bytes);
  }
};

// src/server/reducers.ts
function makeReducerExport(ctx, opts, params, fn, lifecycle) {
  const reducerExport = (...args) => fn(...args);
  reducerExport[exportContext] = ctx;
  reducerExport[registerExport] = (ctx2, exportName) => {
    registerReducer(ctx2, exportName, params, fn, opts, lifecycle);
    ctx2.functionExports.set(
      reducerExport,
      exportName
    );
  };
  return reducerExport;
}
function registerReducer(ctx, exportName, params, fn, opts, lifecycle) {
  ctx.defineFunction(exportName);
  if (!(params instanceof RowBuilder)) {
    params = new RowBuilder(params);
  }
  if (params.typeName === void 0) {
    params.typeName = toPascalCase(exportName);
  }
  const ref = ctx.registerTypesRecursively(params);
  const paramsType = ctx.resolveType(ref).value;
  const isLifecycle = lifecycle != null;
  ctx.moduleDef.reducers.push({
    sourceName: exportName,
    params: paramsType,
    //ModuleDef validation code is responsible to mark private reducers
    visibility: FunctionVisibility.ClientCallable,
    //Hardcoded for now - reducers do not return values yet
    okReturnType: AlgebraicType.Product({ elements: [] }),
    errReturnType: AlgebraicType.String
  });
  if (opts?.name != null) {
    ctx.moduleDef.explicitNames.entries.push({
      tag: "Function",
      value: {
        sourceName: exportName,
        canonicalName: opts.name
      }
    });
  }
  if (isLifecycle) {
    ctx.moduleDef.lifeCycleReducers.push({
      lifecycleSpec: lifecycle,
      functionName: exportName
    });
  }
  if (!fn.name) {
    Object.defineProperty(fn, "name", { value: exportName, writable: false });
  }
  ctx.reducers.push(fn);
}

// src/server/schema.ts
var SchemaInner = class extends ModuleContext {
  schemaType;
  existingFunctions = /* @__PURE__ */ new Set();
  reducers = [];
  procedures = [];
  views = [];
  anonViews = [];
  /**
   * Maps ReducerExport objects to the name of the reducer.
   * Used for resolving the reducers of scheduled tables.
   */
  functionExports = /* @__PURE__ */ new Map();
  pendingSchedules = [];
  constructor(getSchemaType) {
    super();
    this.schemaType = getSchemaType(this);
  }
  defineFunction(name) {
    if (this.existingFunctions.has(name)) {
      throw new TypeError(
        `There is already a reducer or procedure with the name '${name}'`
      );
    }
    this.existingFunctions.add(name);
  }
  resolveSchedules() {
    for (const { reducer, scheduleAtCol, tableName } of this.pendingSchedules) {
      const functionName = this.functionExports.get(reducer());
      if (functionName === void 0) {
        const msg = `Table ${tableName} defines a schedule, but it seems like the associated function was not exported.`;
        throw new TypeError(msg);
      }
      this.moduleDef.schedules.push({
        sourceName: void 0,
        tableName,
        scheduleAtCol,
        functionName
      });
    }
  }
};
var Schema = class {
  #ctx;
  constructor(ctx) {
    this.#ctx = ctx;
  }
  [moduleHooks](exports) {
    const registeredSchema = this.#ctx;
    for (const [name, moduleExport] of Object.entries(exports)) {
      if (name === "default") continue;
      if (!isModuleExport(moduleExport)) {
        throw new TypeError(
          "exporting something that is not a spacetime export"
        );
      }
      checkExportContext(moduleExport, registeredSchema);
      moduleExport[registerExport](registeredSchema, name);
    }
    registeredSchema.resolveSchedules();
    return makeHooks(registeredSchema);
  }
  get schemaType() {
    return this.#ctx.schemaType;
  }
  get moduleDef() {
    return this.#ctx.moduleDef;
  }
  get typespace() {
    return this.#ctx.typespace;
  }
  reducer(...args) {
    let opts, params = {}, fn;
    switch (args.length) {
      case 1:
        [fn] = args;
        break;
      case 2: {
        let arg1;
        [arg1, fn] = args;
        if (typeof arg1.name === "string") opts = arg1;
        else params = arg1;
        break;
      }
      case 3:
        [opts, params, fn] = args;
        break;
    }
    return makeReducerExport(this.#ctx, opts, params, fn);
  }
  init(...args) {
    let opts, fn;
    switch (args.length) {
      case 1:
        [fn] = args;
        break;
      case 2:
        [opts, fn] = args;
        break;
    }
    return makeReducerExport(this.#ctx, opts, {}, fn, Lifecycle.Init);
  }
  clientConnected(...args) {
    let opts, fn;
    switch (args.length) {
      case 1:
        [fn] = args;
        break;
      case 2:
        [opts, fn] = args;
        break;
    }
    return makeReducerExport(this.#ctx, opts, {}, fn, Lifecycle.OnConnect);
  }
  clientDisconnected(...args) {
    let opts, fn;
    switch (args.length) {
      case 1:
        [fn] = args;
        break;
      case 2:
        [opts, fn] = args;
        break;
    }
    return makeReducerExport(this.#ctx, opts, {}, fn, Lifecycle.OnDisconnect);
  }
  view(opts, ret, fn) {
    return makeViewExport(this.#ctx, opts, {}, ret, fn);
  }
  // TODO: re-enable once parameterized views are supported in SQL
  // view<Ret extends ViewReturnTypeBuilder>(
  //   opts: ViewOpts,
  //   ret: Ret,
  //   fn: ViewFn<S, {}, Ret>
  // ): void;
  // view<Params extends ParamsObj, Ret extends ViewReturnTypeBuilder>(
  //   opts: ViewOpts,
  //   params: Params,
  //   ret: Ret,
  //   fn: ViewFn<S, {}, Ret>
  // ): void;
  // view<Params extends ParamsObj, Ret extends ViewReturnTypeBuilder>(
  //   opts: ViewOpts,
  //   paramsOrRet: Ret | Params,
  //   retOrFn: ViewFn<S, {}, Ret> | Ret,
  //   maybeFn?: ViewFn<S, Params, Ret>
  // ): void {
  //   if (typeof retOrFn === 'function') {
  //     defineView(name, false, {}, paramsOrRet as Ret, retOrFn);
  //   } else {
  //     defineView(name, false, paramsOrRet as Params, retOrFn, maybeFn!);
  //   }
  // }
  anonymousView(opts, ret, fn) {
    return makeAnonViewExport(this.#ctx, opts, {}, ret, fn);
  }
  procedure(...args) {
    let opts, params = {}, ret, fn;
    switch (args.length) {
      case 2:
        [ret, fn] = args;
        break;
      case 3: {
        let arg1;
        [arg1, ret, fn] = args;
        if (typeof arg1.name === "string") opts = arg1;
        else params = arg1;
        break;
      }
      case 4:
        [opts, params, ret, fn] = args;
        break;
    }
    return makeProcedureExport(this.#ctx, opts, params, ret, fn);
  }
  /**
   * Bundle multiple reducers, procedures, etc into one value to export.
   * The name they will be exported with is their corresponding key in the `exports` argument.
   */
  exportGroup(exports) {
    return {
      [exportContext]: this.#ctx,
      [registerExport](ctx, _exportName) {
        for (const [exportName, moduleExport] of Object.entries(exports)) {
          checkExportContext(moduleExport, ctx);
          moduleExport[registerExport](ctx, exportName);
        }
      }
    };
  }
  clientVisibilityFilter = {
    sql: (filter) => ({
      [exportContext]: this.#ctx,
      [registerExport](ctx, _exportName) {
        ctx.moduleDef.rowLevelSecurity.push({ sql: filter });
      }
    })
  };
};
var registerExport = Symbol("SpacetimeDB.registerExport");
var exportContext = Symbol("SpacetimeDB.exportContext");
function isModuleExport(x) {
  return (typeof x === "function" || typeof x === "object") && x !== null && registerExport in x;
}
function checkExportContext(exp, schema2) {
  if (exp[exportContext] != null && exp[exportContext] !== schema2) {
    throw new TypeError("multiple schemas are not supported");
  }
}
function schema(tables, moduleSettings) {
  const ctx = new SchemaInner((ctx2) => {
    if (moduleSettings?.CASE_CONVERSION_POLICY != null) {
      ctx2.setCaseConversionPolicy(moduleSettings.CASE_CONVERSION_POLICY);
    }
    const tableSchemas = {};
    for (const [accName, table2] of Object.entries(tables)) {
      const tableDef = table2.tableDef(ctx2, accName);
      tableSchemas[accName] = tableToSchema(accName, table2, tableDef);
      ctx2.moduleDef.tables.push(tableDef);
      if (table2.schedule) {
        ctx2.pendingSchedules.push({
          ...table2.schedule,
          tableName: tableDef.sourceName
        });
      }
      if (table2.tableName) {
        ctx2.moduleDef.explicitNames.entries.push({
          tag: "Table",
          value: {
            sourceName: accName,
            canonicalName: table2.tableName
          }
        });
      }
    }
    return { tables: tableSchemas };
  });
  return new Schema(ctx);
}

// src/server/console.ts
var import_object_inspect = __toESM(require_object_inspect());
var fmtLog = (...data) => data.map((x) => typeof x === "string" ? x : (0, import_object_inspect.default)(x)).join(" ");
var console_level_error = 0;
var console_level_warn = 1;
var console_level_info = 2;
var console_level_debug = 3;
var console_level_trace = 4;
var timerMap = /* @__PURE__ */ new Map();
var console2 = {
  // @ts-expect-error we want a blank prototype, but typescript complains
  __proto__: {},
  [Symbol.toStringTag]: "console",
  assert: (condition = false, ...data) => {
    if (!condition) {
      sys.console_log(console_level_error, fmtLog(...data));
    }
  },
  clear: () => {
  },
  debug: (...data) => {
    sys.console_log(console_level_debug, fmtLog(...data));
  },
  error: (...data) => {
    sys.console_log(console_level_error, fmtLog(...data));
  },
  info: (...data) => {
    sys.console_log(console_level_info, fmtLog(...data));
  },
  log: (...data) => {
    sys.console_log(console_level_info, fmtLog(...data));
  },
  table: (tabularData, _properties) => {
    sys.console_log(console_level_info, fmtLog(tabularData));
  },
  trace: (...data) => {
    sys.console_log(console_level_trace, fmtLog(...data));
  },
  warn: (...data) => {
    sys.console_log(console_level_warn, fmtLog(...data));
  },
  dir: (_item, _options) => {
  },
  dirxml: (..._data) => {
  },
  // Counting
  count: (_label = "default") => {
  },
  countReset: (_label = "default") => {
  },
  // Grouping
  group: (..._data) => {
  },
  groupCollapsed: (..._data) => {
  },
  groupEnd: () => {
  },
  // Timing
  time: (label = "default") => {
    if (timerMap.has(label)) {
      sys.console_log(console_level_warn, `Timer '${label}' already exists.`);
      return;
    }
    timerMap.set(label, sys.console_timer_start(label));
  },
  timeLog: (label = "default", ...data) => {
    sys.console_log(console_level_info, fmtLog(label, ...data));
  },
  timeEnd: (label = "default") => {
    const spanId = timerMap.get(label);
    if (spanId === void 0) {
      sys.console_log(console_level_warn, `Timer '${label}' does not exist.`);
      return;
    }
    sys.console_timer_end(spanId);
    timerMap.delete(label);
  },
  // Additional console methods to satisfy the Console interface
  timeStamp: () => {
  },
  profile: () => {
  },
  profileEnd: () => {
  }
};

// src/server/polyfills.ts
globalThis.console = console2;
/*! Bundled license information:

statuses/index.js:
  (*!
   * statuses
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2016 Douglas Christopher Wilson
   * MIT Licensed
   *)
*/

export { ArrayBuilder, ArrayColumnBuilder, BoolBuilder, BoolColumnBuilder, BooleanExpr, ByteArrayBuilder, ByteArrayColumnBuilder, CaseConversionPolicy, ColumnBuilder, ColumnExpression, ConnectionIdBuilder, ConnectionIdColumnBuilder, F32Builder, F32ColumnBuilder, F64Builder, F64ColumnBuilder, I128Builder, I128ColumnBuilder, I16Builder, I16ColumnBuilder, I256Builder, I256ColumnBuilder, I32Builder, I32ColumnBuilder, I64Builder, I64ColumnBuilder, I8Builder, I8ColumnBuilder, IdentityBuilder, IdentityColumnBuilder, OptionBuilder, OptionColumnBuilder, ProductBuilder, ProductColumnBuilder, RefBuilder, ResultBuilder, ResultColumnBuilder, RowBuilder, ScheduleAtBuilder, ScheduleAtColumnBuilder, SenderError, SimpleSumBuilder, SimpleSumColumnBuilder, SpacetimeHostError, StringBuilder, StringColumnBuilder, SumBuilder, SumColumnBuilder, TimeDurationBuilder, TimeDurationColumnBuilder, TimestampBuilder, TimestampColumnBuilder, TypeBuilder, U128Builder, U128ColumnBuilder, U16Builder, U16ColumnBuilder, U256Builder, U256ColumnBuilder, U32Builder, U32ColumnBuilder, U64Builder, U64ColumnBuilder, U8Builder, U8ColumnBuilder, UuidBuilder, UuidColumnBuilder, and, createTableRefFromDef, errors, evaluateBooleanExpr, getQueryAccessorName, getQueryTableName, getQueryWhereClause, isRowTypedQuery, isTypedQuery, literal, makeQueryBuilder, not, or, schema, t, table, toCamelCase, toComparableValue, toSql };
//# sourceMappingURL=index.mjs.map
//# sourceMappingURL=index.mjs.map